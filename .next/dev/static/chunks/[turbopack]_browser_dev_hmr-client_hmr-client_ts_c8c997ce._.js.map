{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["turbopack:///[turbopack]/browser/dev/hmr-client/hmr-client.ts"],"sourcesContent":["/// <reference path=\"../../../shared/runtime-types.d.ts\" />\n/// <reference path=\"../../runtime/base/dev-globals.d.ts\" />\n/// <reference path=\"../../runtime/base/dev-protocol.d.ts\" />\n/// <reference path=\"../../runtime/base/dev-extensions.ts\" />\n\ntype SendMessage = (msg: any) => void\nexport type WebSocketMessage =\n  | {\n      type: 'turbopack-connected'\n    }\n  | {\n      type: 'turbopack-message'\n      data: Record<string, any>\n    }\n\nexport type ClientOptions = {\n  addMessageListener: (cb: (msg: WebSocketMessage) => void) => void\n  sendMessage: SendMessage\n  onUpdateError: (err: unknown) => void\n}\n\nexport function connect({\n  addMessageListener,\n  sendMessage,\n  onUpdateError = console.error,\n}: ClientOptions) {\n  addMessageListener((msg) => {\n    switch (msg.type) {\n      case 'turbopack-connected':\n        handleSocketConnected(sendMessage)\n        break\n      default:\n        try {\n          if (Array.isArray(msg.data)) {\n            for (let i = 0; i < msg.data.length; i++) {\n              handleSocketMessage(msg.data[i] as ServerMessage)\n            }\n          } else {\n            handleSocketMessage(msg.data as ServerMessage)\n          }\n          applyAggregatedUpdates()\n        } catch (e: unknown) {\n          console.warn(\n            '[Fast Refresh] performing full reload\\n\\n' +\n              \"Fast Refresh will perform a full reload when you edit a file that's imported by modules outside of the React rendering tree.\\n\" +\n              'You might have a file which exports a React component but also exports a value that is imported by a non-React component file.\\n' +\n              'Consider migrating the non-React component export to a separate file and importing it into both files.\\n\\n' +\n              'It is also possible the parent component of the component you edited is a class component, which disables Fast Refresh.\\n' +\n              'Fast Refresh requires at least one parent function component in your React tree.'\n          )\n          onUpdateError(e)\n          location.reload()\n        }\n        break\n    }\n  })\n\n  const queued = globalThis.TURBOPACK_CHUNK_UPDATE_LISTENERS\n  if (queued != null && !Array.isArray(queued)) {\n    throw new Error('A separate HMR handler was already registered')\n  }\n  globalThis.TURBOPACK_CHUNK_UPDATE_LISTENERS = {\n    push: ([chunkPath, callback]: [ChunkListPath, UpdateCallback]) => {\n      subscribeToChunkUpdate(chunkPath, sendMessage, callback)\n    },\n  }\n\n  if (Array.isArray(queued)) {\n    for (const [chunkPath, callback] of queued) {\n      subscribeToChunkUpdate(chunkPath, sendMessage, callback)\n    }\n  }\n}\n\ntype UpdateCallbackSet = {\n  callbacks: Set<UpdateCallback>\n  unsubscribe: () => void\n}\n\nconst updateCallbackSets: Map<ResourceKey, UpdateCallbackSet> = new Map()\n\nfunction sendJSON(sendMessage: SendMessage, message: ClientMessage) {\n  sendMessage(JSON.stringify(message))\n}\n\ntype ResourceKey = string\n\nfunction resourceKey(resource: ResourceIdentifier): ResourceKey {\n  return JSON.stringify({\n    path: resource.path,\n    headers: resource.headers || null,\n  })\n}\n\nfunction subscribeToUpdates(\n  sendMessage: SendMessage,\n  resource: ResourceIdentifier\n): () => void {\n  sendJSON(sendMessage, {\n    type: 'turbopack-subscribe',\n    ...resource,\n  })\n\n  return () => {\n    sendJSON(sendMessage, {\n      type: 'turbopack-unsubscribe',\n      ...resource,\n    })\n  }\n}\n\nfunction handleSocketConnected(sendMessage: SendMessage) {\n  for (const key of updateCallbackSets.keys()) {\n    subscribeToUpdates(sendMessage, JSON.parse(key))\n  }\n}\n\n// we aggregate all pending updates until the issues are resolved\nconst chunkListsWithPendingUpdates: Map<ResourceKey, PartialServerMessage> =\n  new Map()\n\nfunction aggregateUpdates(msg: PartialServerMessage) {\n  const key = resourceKey(msg.resource)\n  let aggregated = chunkListsWithPendingUpdates.get(key)\n\n  if (aggregated) {\n    aggregated.instruction = mergeChunkListUpdates(\n      aggregated.instruction,\n      msg.instruction\n    )\n  } else {\n    chunkListsWithPendingUpdates.set(key, msg)\n  }\n}\n\nfunction applyAggregatedUpdates() {\n  if (chunkListsWithPendingUpdates.size === 0) return\n  hooks.beforeRefresh()\n  for (const msg of chunkListsWithPendingUpdates.values()) {\n    triggerUpdate(msg)\n  }\n  chunkListsWithPendingUpdates.clear()\n  finalizeUpdate()\n}\n\nfunction mergeChunkListUpdates(\n  updateA: ChunkListUpdate,\n  updateB: ChunkListUpdate\n): ChunkListUpdate {\n  let chunks\n  if (updateA.chunks != null) {\n    if (updateB.chunks == null) {\n      chunks = updateA.chunks\n    } else {\n      chunks = mergeChunkListChunks(updateA.chunks, updateB.chunks)\n    }\n  } else if (updateB.chunks != null) {\n    chunks = updateB.chunks\n  }\n\n  let merged\n  if (updateA.merged != null) {\n    if (updateB.merged == null) {\n      merged = updateA.merged\n    } else {\n      // Since `merged` is an array of updates, we need to merge them all into\n      // one, consistent update.\n      // Since there can only be `EcmascriptMergeUpdates` in the array, there is\n      // no need to key on the `type` field.\n      let update = updateA.merged[0]\n      for (let i = 1; i < updateA.merged.length; i++) {\n        update = mergeChunkListEcmascriptMergedUpdates(\n          update,\n          updateA.merged[i]\n        )\n      }\n\n      for (let i = 0; i < updateB.merged.length; i++) {\n        update = mergeChunkListEcmascriptMergedUpdates(\n          update,\n          updateB.merged[i]\n        )\n      }\n\n      merged = [update]\n    }\n  } else if (updateB.merged != null) {\n    merged = updateB.merged\n  }\n\n  return {\n    type: 'ChunkListUpdate',\n    chunks,\n    merged,\n  }\n}\n\nfunction mergeChunkListChunks(\n  chunksA: Record<ChunkPath, ChunkUpdate>,\n  chunksB: Record<ChunkPath, ChunkUpdate>\n): Record<ChunkPath, ChunkUpdate> {\n  const chunks: Record<ChunkPath, ChunkUpdate> = {}\n\n  for (const [chunkPath, chunkUpdateA] of Object.entries(chunksA) as Array<\n    [ChunkPath, ChunkUpdate]\n  >) {\n    const chunkUpdateB = chunksB[chunkPath]\n    if (chunkUpdateB != null) {\n      const mergedUpdate = mergeChunkUpdates(chunkUpdateA, chunkUpdateB)\n      if (mergedUpdate != null) {\n        chunks[chunkPath] = mergedUpdate\n      }\n    } else {\n      chunks[chunkPath] = chunkUpdateA\n    }\n  }\n\n  for (const [chunkPath, chunkUpdateB] of Object.entries(chunksB) as Array<\n    [ChunkPath, ChunkUpdate]\n  >) {\n    if (chunks[chunkPath] == null) {\n      chunks[chunkPath] = chunkUpdateB\n    }\n  }\n\n  return chunks\n}\n\nfunction mergeChunkUpdates(\n  updateA: ChunkUpdate,\n  updateB: ChunkUpdate\n): ChunkUpdate | undefined {\n  if (\n    (updateA.type === 'added' && updateB.type === 'deleted') ||\n    (updateA.type === 'deleted' && updateB.type === 'added')\n  ) {\n    return undefined\n  }\n\n  if (updateA.type === 'partial') {\n    invariant(updateA.instruction, 'Partial updates are unsupported')\n  }\n\n  if (updateB.type === 'partial') {\n    invariant(updateB.instruction, 'Partial updates are unsupported')\n  }\n\n  return undefined\n}\n\nfunction mergeChunkListEcmascriptMergedUpdates(\n  mergedA: EcmascriptMergedUpdate,\n  mergedB: EcmascriptMergedUpdate\n): EcmascriptMergedUpdate {\n  const entries = mergeEcmascriptChunkEntries(mergedA.entries, mergedB.entries)\n  const chunks = mergeEcmascriptChunksUpdates(mergedA.chunks, mergedB.chunks)\n\n  return {\n    type: 'EcmascriptMergedUpdate',\n    entries,\n    chunks,\n  }\n}\n\nfunction mergeEcmascriptChunkEntries(\n  entriesA: Record<ModuleId, EcmascriptModuleEntry> | undefined,\n  entriesB: Record<ModuleId, EcmascriptModuleEntry> | undefined\n): Record<ModuleId, EcmascriptModuleEntry> {\n  return { ...entriesA, ...entriesB }\n}\n\nfunction mergeEcmascriptChunksUpdates(\n  chunksA: Record<ChunkPath, EcmascriptMergedChunkUpdate> | undefined,\n  chunksB: Record<ChunkPath, EcmascriptMergedChunkUpdate> | undefined\n): Record<ChunkPath, EcmascriptMergedChunkUpdate> | undefined {\n  if (chunksA == null) {\n    return chunksB\n  }\n\n  if (chunksB == null) {\n    return chunksA\n  }\n\n  const chunks: Record<ChunkPath, EcmascriptMergedChunkUpdate> = {}\n\n  for (const [chunkPath, chunkUpdateA] of Object.entries(chunksA) as Array<\n    [ChunkPath, EcmascriptMergedChunkUpdate]\n  >) {\n    const chunkUpdateB = chunksB[chunkPath]\n    if (chunkUpdateB != null) {\n      const mergedUpdate = mergeEcmascriptChunkUpdates(\n        chunkUpdateA,\n        chunkUpdateB\n      )\n      if (mergedUpdate != null) {\n        chunks[chunkPath] = mergedUpdate\n      }\n    } else {\n      chunks[chunkPath] = chunkUpdateA\n    }\n  }\n\n  for (const [chunkPath, chunkUpdateB] of Object.entries(chunksB) as Array<\n    [ChunkPath, EcmascriptMergedChunkUpdate]\n  >) {\n    if (chunks[chunkPath] == null) {\n      chunks[chunkPath] = chunkUpdateB\n    }\n  }\n\n  if (Object.keys(chunks).length === 0) {\n    return undefined\n  }\n\n  return chunks\n}\n\nfunction mergeEcmascriptChunkUpdates(\n  updateA: EcmascriptMergedChunkUpdate,\n  updateB: EcmascriptMergedChunkUpdate\n): EcmascriptMergedChunkUpdate | undefined {\n  if (updateA.type === 'added' && updateB.type === 'deleted') {\n    // These two completely cancel each other out.\n    return undefined\n  }\n\n  if (updateA.type === 'deleted' && updateB.type === 'added') {\n    const added = []\n    const deleted = []\n    const deletedModules = new Set(updateA.modules ?? [])\n    const addedModules = new Set(updateB.modules ?? [])\n\n    for (const moduleId of addedModules) {\n      if (!deletedModules.has(moduleId)) {\n        added.push(moduleId)\n      }\n    }\n\n    for (const moduleId of deletedModules) {\n      if (!addedModules.has(moduleId)) {\n        deleted.push(moduleId)\n      }\n    }\n\n    if (added.length === 0 && deleted.length === 0) {\n      return undefined\n    }\n\n    return {\n      type: 'partial',\n      added,\n      deleted,\n    }\n  }\n\n  if (updateA.type === 'partial' && updateB.type === 'partial') {\n    const added = new Set([...(updateA.added ?? []), ...(updateB.added ?? [])])\n    const deleted = new Set([\n      ...(updateA.deleted ?? []),\n      ...(updateB.deleted ?? []),\n    ])\n\n    if (updateB.added != null) {\n      for (const moduleId of updateB.added) {\n        deleted.delete(moduleId)\n      }\n    }\n\n    if (updateB.deleted != null) {\n      for (const moduleId of updateB.deleted) {\n        added.delete(moduleId)\n      }\n    }\n\n    return {\n      type: 'partial',\n      added: [...added],\n      deleted: [...deleted],\n    }\n  }\n\n  if (updateA.type === 'added' && updateB.type === 'partial') {\n    const modules = new Set([\n      ...(updateA.modules ?? []),\n      ...(updateB.added ?? []),\n    ])\n\n    for (const moduleId of updateB.deleted ?? []) {\n      modules.delete(moduleId)\n    }\n\n    return {\n      type: 'added',\n      modules: [...modules],\n    }\n  }\n\n  if (updateA.type === 'partial' && updateB.type === 'deleted') {\n    // We could eagerly return `updateB` here, but this would potentially be\n    // incorrect if `updateA` has added modules.\n\n    const modules = new Set(updateB.modules ?? [])\n\n    if (updateA.added != null) {\n      for (const moduleId of updateA.added) {\n        modules.delete(moduleId)\n      }\n    }\n\n    return {\n      type: 'deleted',\n      modules: [...modules],\n    }\n  }\n\n  // Any other update combination is invalid.\n\n  return undefined\n}\n\nfunction invariant(_: never, message: string): never {\n  throw new Error(`Invariant: ${message}`)\n}\n\nconst CRITICAL = ['bug', 'error', 'fatal']\n\nfunction compareByList(list: any[], a: any, b: any) {\n  const aI = list.indexOf(a) + 1 || list.length\n  const bI = list.indexOf(b) + 1 || list.length\n  return aI - bI\n}\n\nconst chunksWithIssues: Map<ResourceKey, Issue[]> = new Map()\n\nfunction emitIssues() {\n  const issues = []\n  const deduplicationSet = new Set()\n\n  for (const [_, chunkIssues] of chunksWithIssues) {\n    for (const chunkIssue of chunkIssues) {\n      if (deduplicationSet.has(chunkIssue.formatted)) continue\n\n      issues.push(chunkIssue)\n      deduplicationSet.add(chunkIssue.formatted)\n    }\n  }\n\n  sortIssues(issues)\n\n  hooks.issues(issues)\n}\n\nfunction handleIssues(msg: ServerMessage): boolean {\n  const key = resourceKey(msg.resource)\n  let hasCriticalIssues = false\n\n  for (const issue of msg.issues) {\n    if (CRITICAL.includes(issue.severity)) {\n      hasCriticalIssues = true\n    }\n  }\n\n  if (msg.issues.length > 0) {\n    chunksWithIssues.set(key, msg.issues)\n  } else if (chunksWithIssues.has(key)) {\n    chunksWithIssues.delete(key)\n  }\n\n  emitIssues()\n\n  return hasCriticalIssues\n}\n\nconst SEVERITY_ORDER = ['bug', 'fatal', 'error', 'warning', 'info', 'log']\nconst CATEGORY_ORDER = [\n  'parse',\n  'resolve',\n  'code generation',\n  'rendering',\n  'typescript',\n  'other',\n]\n\nfunction sortIssues(issues: Issue[]) {\n  issues.sort((a, b) => {\n    const first = compareByList(SEVERITY_ORDER, a.severity, b.severity)\n    if (first !== 0) return first\n    return compareByList(CATEGORY_ORDER, a.category, b.category)\n  })\n}\n\nconst hooks = {\n  beforeRefresh: () => {},\n  refresh: () => {},\n  buildOk: () => {},\n  issues: (_issues: Issue[]) => {},\n}\n\nexport function setHooks(newHooks: typeof hooks) {\n  Object.assign(hooks, newHooks)\n}\n\nfunction handleSocketMessage(msg: ServerMessage) {\n  sortIssues(msg.issues)\n\n  handleIssues(msg)\n\n  switch (msg.type) {\n    case 'issues':\n      // issues are already handled\n      break\n    case 'partial':\n      // aggregate updates\n      aggregateUpdates(msg)\n      break\n    default:\n      // run single update\n      const runHooks = chunkListsWithPendingUpdates.size === 0\n      if (runHooks) hooks.beforeRefresh()\n      triggerUpdate(msg)\n      if (runHooks) finalizeUpdate()\n      break\n  }\n}\n\nfunction finalizeUpdate() {\n  hooks.refresh()\n  hooks.buildOk()\n\n  // This is used by the Next.js integration test suite to notify it when HMR\n  // updates have been completed.\n  // TODO: Only run this in test environments (gate by `process.env.__NEXT_TEST_MODE`)\n  if (globalThis.__NEXT_HMR_CB) {\n    globalThis.__NEXT_HMR_CB()\n    globalThis.__NEXT_HMR_CB = null\n  }\n}\n\nfunction subscribeToChunkUpdate(\n  chunkListPath: ChunkListPath,\n  sendMessage: SendMessage,\n  callback: UpdateCallback\n): () => void {\n  return subscribeToUpdate(\n    {\n      path: chunkListPath,\n    },\n    sendMessage,\n    callback\n  )\n}\n\nexport function subscribeToUpdate(\n  resource: ResourceIdentifier,\n  sendMessage: SendMessage,\n  callback: UpdateCallback\n) {\n  const key = resourceKey(resource)\n  let callbackSet: UpdateCallbackSet\n  const existingCallbackSet = updateCallbackSets.get(key)\n  if (!existingCallbackSet) {\n    callbackSet = {\n      callbacks: new Set([callback]),\n      unsubscribe: subscribeToUpdates(sendMessage, resource),\n    }\n    updateCallbackSets.set(key, callbackSet)\n  } else {\n    existingCallbackSet.callbacks.add(callback)\n    callbackSet = existingCallbackSet\n  }\n\n  return () => {\n    callbackSet.callbacks.delete(callback)\n\n    if (callbackSet.callbacks.size === 0) {\n      callbackSet.unsubscribe()\n      updateCallbackSets.delete(key)\n    }\n  }\n}\n\nfunction triggerUpdate(msg: ServerMessage) {\n  const key = resourceKey(msg.resource)\n  const callbackSet = updateCallbackSets.get(key)\n  if (!callbackSet) {\n    return\n  }\n\n  for (const callback of callbackSet.callbacks) {\n    callback(msg)\n  }\n\n  if (msg.type === 'notFound') {\n    // This indicates that the resource which we subscribed to either does not exist or\n    // has been deleted. In either case, we should clear all update callbacks, so if a\n    // new subscription is created for the same resource, it will send a new \"subscribe\"\n    // message to the server.\n    // No need to send an \"unsubscribe\" message to the server, it will have already\n    // dropped the update stream before sending the \"notFound\" message.\n    updateCallbackSets.delete(key)\n  }\n}\n"],"names":["connect","addMessageListener","sendMessage","onUpdateError","console","error","msg","type","handleSocketConnected","Array","isArray","data","i","length","handleSocketMessage","applyAggregatedUpdates","e","warn","location","reload","queued","globalThis","TURBOPACK_CHUNK_UPDATE_LISTENERS","Error","push","chunkPath","callback","subscribeToChunkUpdate","updateCallbackSets","Map","sendJSON","message","JSON","stringify","resourceKey","resource","path","headers","subscribeToUpdates","key","keys","parse","chunkListsWithPendingUpdates","aggregateUpdates","aggregated","get","instruction","mergeChunkListUpdates","set","size","hooks","beforeRefresh","values","triggerUpdate","clear","finalizeUpdate","updateA","updateB","chunks","mergeChunkListChunks","merged","update","mergeChunkListEcmascriptMergedUpdates","chunksA","chunksB","chunkUpdateA","Object","entries","chunkUpdateB","mergedUpdate","mergeChunkUpdates","undefined","invariant","mergedA","mergedB","mergeEcmascriptChunkEntries","mergeEcmascriptChunksUpdates","entriesA","entriesB","mergeEcmascriptChunkUpdates","added","deleted","deletedModules","Set","modules","addedModules","moduleId","has","delete","_","CRITICAL","compareByList","list","a","b","aI","indexOf","bI","chunksWithIssues","emitIssues","issues","deduplicationSet","chunkIssues","chunkIssue","formatted","add","sortIssues","handleIssues","hasCriticalIssues","issue","includes","severity","SEVERITY_ORDER","CATEGORY_ORDER","sort","first","category","refresh","buildOk","_issues","setHooks","newHooks","assign","runHooks","__NEXT_HMR_CB","chunkListPath","subscribeToUpdate","callbackSet","existingCallbackSet","callbacks","unsubscribe"],"mappings":"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","ignoreList":[0]}}]
}