{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 14, "column": 0}, "map": {"version":3,"sources":["turbopack:///[turbopack]/shared/runtime-utils.ts"],"sourcesContent":["/**\n * This file contains runtime types and functions that are shared between all\n * TurboPack ECMAScript runtimes.\n *\n * It will be prepended to the runtime code of each runtime.\n */\n\n/* eslint-disable @typescript-eslint/no-unused-vars */\n\n/// <reference path=\"./runtime-types.d.ts\" />\n\ntype EsmNamespaceObject = Record<string, any>\n\n// @ts-ignore Defined in `dev-base.ts`\ndeclare function getOrInstantiateModuleFromParent<M>(\n  id: ModuleId,\n  sourceModule: M\n): M\n\nconst REEXPORTED_OBJECTS = new WeakMap<Module, ReexportedObjects>()\n\n/**\n * Constructs the `__turbopack_context__` object for a module.\n */\nfunction Context(\n  this: TurbopackBaseContext<Module>,\n  module: Module,\n  exports: Exports\n) {\n  this.m = module\n  // We need to store this here instead of accessing it from the module object to:\n  // 1. Make it available to factories directly, since we rewrite `this` to\n  //    `__turbopack_context__.e` in CJS modules.\n  // 2. Support async modules which rewrite `module.exports` to a promise, so we\n  //    can still access the original exports object from functions like\n  //    `esmExport`\n  // Ideally we could find a new approach for async modules and drop this property altogether.\n  this.e = exports\n}\nconst contextPrototype = Context.prototype as TurbopackBaseContext<Module>\n\ntype ModuleContextMap = Record<ModuleId, ModuleContextEntry>\n\ninterface ModuleContextEntry {\n  id: () => ModuleId\n  module: () => any\n}\n\ninterface ModuleContext {\n  // require call\n  (moduleId: string): Exports | EsmNamespaceObject\n\n  // async import call\n  import(moduleId: string): Promise<Exports | EsmNamespaceObject>\n\n  keys(): ModuleId[]\n\n  resolve(moduleId: string): ModuleId\n}\n\ntype GetOrInstantiateModuleFromParent<M extends Module> = (\n  moduleId: M['id'],\n  parentModule: M\n) => M\n\ndeclare function getOrInstantiateRuntimeModule(\n  chunkPath: ChunkPath,\n  moduleId: ModuleId\n): Module\n\nconst hasOwnProperty = Object.prototype.hasOwnProperty\nconst toStringTag = typeof Symbol !== 'undefined' && Symbol.toStringTag\n\nfunction defineProp(\n  obj: any,\n  name: PropertyKey,\n  options: PropertyDescriptor & ThisType<any>\n) {\n  if (!hasOwnProperty.call(obj, name)) Object.defineProperty(obj, name, options)\n}\n\nfunction getOverwrittenModule(\n  moduleCache: ModuleCache<Module>,\n  id: ModuleId\n): Module {\n  let module = moduleCache[id]\n  if (!module) {\n    // This is invoked when a module is merged into another module, thus it wasn't invoked via\n    // instantiateModule and the cache entry wasn't created yet.\n    module = createModuleObject(id)\n    moduleCache[id] = module\n  }\n  return module\n}\n\n/**\n * Creates the module object. Only done here to ensure all module objects have the same shape.\n */\nfunction createModuleObject(id: ModuleId): Module {\n  return {\n    exports: {},\n    error: undefined,\n    id,\n    namespaceObject: undefined,\n  }\n}\n\ntype BindingTag = 0\nconst BindingTag_Value = 0 as BindingTag\n\n// an arbitrary sequence of bindings as\n// - a prop name\n// - BindingTag_Value, a value to be bound directly, or\n// - 1 or 2 functions to bind as getters and sdetters\ntype EsmBindings = Array<\n  string | BindingTag | (() => unknown) | ((v: unknown) => void) | unknown\n>\n\n/**\n * Adds the getters to the exports object.\n */\nfunction esm(exports: Exports, bindings: EsmBindings) {\n  defineProp(exports, '__esModule', { value: true })\n  if (toStringTag) defineProp(exports, toStringTag, { value: 'Module' })\n  let i = 0\n  while (i < bindings.length) {\n    const propName = bindings[i++] as string\n    const tagOrFunction = bindings[i++]\n    if (typeof tagOrFunction === 'number') {\n      if (tagOrFunction === BindingTag_Value) {\n        defineProp(exports, propName, {\n          value: bindings[i++],\n          enumerable: true,\n          writable: false,\n        })\n      } else {\n        throw new Error(`unexpected tag: ${tagOrFunction}`)\n      }\n    } else {\n      const getterFn = tagOrFunction as () => unknown\n      if (typeof bindings[i] === 'function') {\n        const setterFn = bindings[i++] as (v: unknown) => void\n        defineProp(exports, propName, {\n          get: getterFn,\n          set: setterFn,\n          enumerable: true,\n        })\n      } else {\n        defineProp(exports, propName, {\n          get: getterFn,\n          enumerable: true,\n        })\n      }\n    }\n  }\n  Object.seal(exports)\n}\n\n/**\n * Makes the module an ESM with exports\n */\nfunction esmExport(\n  this: TurbopackBaseContext<Module>,\n  bindings: EsmBindings,\n  id: ModuleId | undefined\n) {\n  let module: Module\n  let exports: Module['exports']\n  if (id != null) {\n    module = getOverwrittenModule(this.c, id)\n    exports = module.exports\n  } else {\n    module = this.m\n    exports = this.e\n  }\n  module.namespaceObject = exports\n  esm(exports, bindings)\n}\ncontextPrototype.s = esmExport\n\ntype ReexportedObjects = Record<PropertyKey, unknown>[]\nfunction ensureDynamicExports(\n  module: Module,\n  exports: Exports\n): ReexportedObjects {\n  let reexportedObjects: ReexportedObjects | undefined =\n    REEXPORTED_OBJECTS.get(module)\n\n  if (!reexportedObjects) {\n    REEXPORTED_OBJECTS.set(module, (reexportedObjects = []))\n    module.exports = module.namespaceObject = new Proxy(exports, {\n      get(target, prop) {\n        if (\n          hasOwnProperty.call(target, prop) ||\n          prop === 'default' ||\n          prop === '__esModule'\n        ) {\n          return Reflect.get(target, prop)\n        }\n        for (const obj of reexportedObjects!) {\n          const value = Reflect.get(obj, prop)\n          if (value !== undefined) return value\n        }\n        return undefined\n      },\n      ownKeys(target) {\n        const keys = Reflect.ownKeys(target)\n        for (const obj of reexportedObjects!) {\n          for (const key of Reflect.ownKeys(obj)) {\n            if (key !== 'default' && !keys.includes(key)) keys.push(key)\n          }\n        }\n        return keys\n      },\n    })\n  }\n  return reexportedObjects\n}\n\n/**\n * Dynamically exports properties from an object\n */\nfunction dynamicExport(\n  this: TurbopackBaseContext<Module>,\n  object: Record<string, any>,\n  id: ModuleId | undefined\n) {\n  let module: Module\n  let exports: Exports\n  if (id != null) {\n    module = getOverwrittenModule(this.c, id)\n    exports = module.exports\n  } else {\n    module = this.m\n    exports = this.e\n  }\n  const reexportedObjects = ensureDynamicExports(module, exports)\n\n  if (typeof object === 'object' && object !== null) {\n    reexportedObjects.push(object)\n  }\n}\ncontextPrototype.j = dynamicExport\n\nfunction exportValue(\n  this: TurbopackBaseContext<Module>,\n  value: any,\n  id: ModuleId | undefined\n) {\n  let module: Module\n  if (id != null) {\n    module = getOverwrittenModule(this.c, id)\n  } else {\n    module = this.m\n  }\n  module.exports = value\n}\ncontextPrototype.v = exportValue\n\nfunction exportNamespace(\n  this: TurbopackBaseContext<Module>,\n  namespace: any,\n  id: ModuleId | undefined\n) {\n  let module: Module\n  if (id != null) {\n    module = getOverwrittenModule(this.c, id)\n  } else {\n    module = this.m\n  }\n  module.exports = module.namespaceObject = namespace\n}\ncontextPrototype.n = exportNamespace\n\nfunction createGetter(obj: Record<string | symbol, any>, key: string | symbol) {\n  return () => obj[key]\n}\n\n/**\n * @returns prototype of the object\n */\nconst getProto: (obj: any) => any = Object.getPrototypeOf\n  ? (obj) => Object.getPrototypeOf(obj)\n  : (obj) => obj.__proto__\n\n/** Prototypes that are not expanded for exports */\nconst LEAF_PROTOTYPES = [null, getProto({}), getProto([]), getProto(getProto)]\n\n/**\n * @param raw\n * @param ns\n * @param allowExportDefault\n *   * `false`: will have the raw module as default export\n *   * `true`: will have the default property as default export\n */\nfunction interopEsm(\n  raw: Exports,\n  ns: EsmNamespaceObject,\n  allowExportDefault?: boolean\n) {\n  const bindings: EsmBindings = []\n  let defaultLocation = -1\n  for (\n    let current = raw;\n    (typeof current === 'object' || typeof current === 'function') &&\n    !LEAF_PROTOTYPES.includes(current);\n    current = getProto(current)\n  ) {\n    for (const key of Object.getOwnPropertyNames(current)) {\n      bindings.push(key, createGetter(raw, key))\n      if (defaultLocation === -1 && key === 'default') {\n        defaultLocation = bindings.length - 1\n      }\n    }\n  }\n\n  // this is not really correct\n  // we should set the `default` getter if the imported module is a `.cjs file`\n  if (!(allowExportDefault && defaultLocation >= 0)) {\n    // Replace the binding with one for the namespace itself in order to preserve iteration order.\n    if (defaultLocation >= 0) {\n      // Replace the getter with the value\n      bindings.splice(defaultLocation, 1, BindingTag_Value, raw)\n    } else {\n      bindings.push('default', BindingTag_Value, raw)\n    }\n  }\n\n  esm(ns, bindings)\n  return ns\n}\n\nfunction createNS(raw: Module['exports']): EsmNamespaceObject {\n  if (typeof raw === 'function') {\n    return function (this: any, ...args: any[]) {\n      return raw.apply(this, args)\n    }\n  } else {\n    return Object.create(null)\n  }\n}\n\nfunction esmImport(\n  this: TurbopackBaseContext<Module>,\n  id: ModuleId\n): Exclude<Module['namespaceObject'], undefined> {\n  const module = getOrInstantiateModuleFromParent(id, this.m)\n\n  // any ES module has to have `module.namespaceObject` defined.\n  if (module.namespaceObject) return module.namespaceObject\n\n  // only ESM can be an async module, so we don't need to worry about exports being a promise here.\n  const raw = module.exports\n  return (module.namespaceObject = interopEsm(\n    raw,\n    createNS(raw),\n    raw && (raw as any).__esModule\n  ))\n}\ncontextPrototype.i = esmImport\n\nfunction asyncLoader(\n  this: TurbopackBaseContext<Module>,\n  moduleId: ModuleId\n): Promise<Exports> {\n  const loader = this.r(moduleId) as (\n    importFunction: EsmImport\n  ) => Promise<Exports>\n  return loader(esmImport.bind(this))\n}\ncontextPrototype.A = asyncLoader\n\n// Add a simple runtime require so that environments without one can still pass\n// `typeof require` CommonJS checks so that exports are correctly registered.\nconst runtimeRequire =\n  // @ts-ignore\n  typeof require === 'function'\n    ? // @ts-ignore\n      require\n    : function require() {\n        throw new Error('Unexpected use of runtime require')\n      }\ncontextPrototype.t = runtimeRequire\n\nfunction commonJsRequire(\n  this: TurbopackBaseContext<Module>,\n  id: ModuleId\n): Exports {\n  return getOrInstantiateModuleFromParent(id, this.m).exports\n}\ncontextPrototype.r = commonJsRequire\n\n/**\n * Remove fragments and query parameters since they are never part of the context map keys\n *\n * This matches how we parse patterns at resolving time.  Arguably we should only do this for\n * strings passed to `import` but the resolve does it for `import` and `require` and so we do\n * here as well.\n */\nfunction parseRequest(request: string): string {\n  // Per the URI spec fragments can contain `?` characters, so we should trim it off first\n  // https://datatracker.ietf.org/doc/html/rfc3986#section-3.5\n  const hashIndex = request.indexOf('#')\n  if (hashIndex !== -1) {\n    request = request.substring(0, hashIndex)\n  }\n\n  const queryIndex = request.indexOf('?')\n  if (queryIndex !== -1) {\n    request = request.substring(0, queryIndex)\n  }\n\n  return request\n}\n/**\n * `require.context` and require/import expression runtime.\n */\nfunction moduleContext(map: ModuleContextMap): ModuleContext {\n  function moduleContext(id: string): Exports {\n    id = parseRequest(id)\n    if (hasOwnProperty.call(map, id)) {\n      return map[id].module()\n    }\n\n    const e = new Error(`Cannot find module '${id}'`)\n    ;(e as any).code = 'MODULE_NOT_FOUND'\n    throw e\n  }\n\n  moduleContext.keys = (): string[] => {\n    return Object.keys(map)\n  }\n\n  moduleContext.resolve = (id: string): ModuleId => {\n    id = parseRequest(id)\n    if (hasOwnProperty.call(map, id)) {\n      return map[id].id()\n    }\n\n    const e = new Error(`Cannot find module '${id}'`)\n    ;(e as any).code = 'MODULE_NOT_FOUND'\n    throw e\n  }\n\n  moduleContext.import = async (id: string) => {\n    return await (moduleContext(id) as Promise<Exports>)\n  }\n\n  return moduleContext\n}\ncontextPrototype.f = moduleContext\n\n/**\n * Returns the path of a chunk defined by its data.\n */\nfunction getChunkPath(chunkData: ChunkData): ChunkPath {\n  return typeof chunkData === 'string' ? chunkData : chunkData.path\n}\n\nfunction isPromise<T = any>(maybePromise: any): maybePromise is Promise<T> {\n  return (\n    maybePromise != null &&\n    typeof maybePromise === 'object' &&\n    'then' in maybePromise &&\n    typeof maybePromise.then === 'function'\n  )\n}\n\nfunction isAsyncModuleExt<T extends {}>(obj: T): obj is AsyncModuleExt & T {\n  return turbopackQueues in obj\n}\n\nfunction createPromise<T>() {\n  let resolve: (value: T | PromiseLike<T>) => void\n  let reject: (reason?: any) => void\n\n  const promise = new Promise<T>((res, rej) => {\n    reject = rej\n    resolve = res\n  })\n\n  return {\n    promise,\n    resolve: resolve!,\n    reject: reject!,\n  }\n}\n\n// Load the CompressedmoduleFactories of a chunk into the `moduleFactories` Map.\n// The CompressedModuleFactories format is\n// - 1 or more module ids\n// - a module factory function\n// So walking this is a little complex but the flat structure is also fast to\n// traverse, we can use `typeof` operators to distinguish the two cases.\nfunction installCompressedModuleFactories(\n  chunkModules: CompressedModuleFactories,\n  offset: number,\n  moduleFactories: ModuleFactories,\n  newModuleId?: (id: ModuleId) => void\n) {\n  let i = offset\n  while (i < chunkModules.length) {\n    let moduleId = chunkModules[i] as ModuleId\n    let end = i + 1\n    // Find our factory function\n    while (\n      end < chunkModules.length &&\n      typeof chunkModules[end] !== 'function'\n    ) {\n      end++\n    }\n    if (end === chunkModules.length) {\n      throw new Error('malformed chunk format, expected a factory function')\n    }\n    // Each chunk item has a 'primary id' and optional additional ids. If the primary id is already\n    // present we know all the additional ids are also present, so we don't need to check.\n    if (!moduleFactories.has(moduleId)) {\n      const moduleFactoryFn = chunkModules[end] as Function\n      applyModuleFactoryName(moduleFactoryFn)\n      newModuleId?.(moduleId)\n      for (; i < end; i++) {\n        moduleId = chunkModules[i] as ModuleId\n        moduleFactories.set(moduleId, moduleFactoryFn)\n      }\n    }\n    i = end + 1 // end is pointing at the last factory advance to the next id or the end of the array.\n  }\n}\n\n// everything below is adapted from webpack\n// https://github.com/webpack/webpack/blob/6be4065ade1e252c1d8dcba4af0f43e32af1bdc1/lib/runtime/AsyncModuleRuntimeModule.js#L13\n\nconst turbopackQueues = Symbol('turbopack queues')\nconst turbopackExports = Symbol('turbopack exports')\nconst turbopackError = Symbol('turbopack error')\n\nconst enum QueueStatus {\n  Unknown = -1,\n  Unresolved = 0,\n  Resolved = 1,\n}\n\ntype AsyncQueueFn = (() => void) & { queueCount: number }\ntype AsyncQueue = AsyncQueueFn[] & {\n  status: QueueStatus\n}\n\nfunction resolveQueue(queue?: AsyncQueue) {\n  if (queue && queue.status !== QueueStatus.Resolved) {\n    queue.status = QueueStatus.Resolved\n    queue.forEach((fn) => fn.queueCount--)\n    queue.forEach((fn) => (fn.queueCount-- ? fn.queueCount++ : fn()))\n  }\n}\n\ntype Dep = Exports | AsyncModulePromise | Promise<Exports>\n\ntype AsyncModuleExt = {\n  [turbopackQueues]: (fn: (queue: AsyncQueue) => void) => void\n  [turbopackExports]: Exports\n  [turbopackError]?: any\n}\n\ntype AsyncModulePromise<T = Exports> = Promise<T> & AsyncModuleExt\n\nfunction wrapDeps(deps: Dep[]): AsyncModuleExt[] {\n  return deps.map((dep): AsyncModuleExt => {\n    if (dep !== null && typeof dep === 'object') {\n      if (isAsyncModuleExt(dep)) return dep\n      if (isPromise(dep)) {\n        const queue: AsyncQueue = Object.assign([], {\n          status: QueueStatus.Unresolved,\n        })\n\n        const obj: AsyncModuleExt = {\n          [turbopackExports]: {},\n          [turbopackQueues]: (fn: (queue: AsyncQueue) => void) => fn(queue),\n        }\n\n        dep.then(\n          (res) => {\n            obj[turbopackExports] = res\n            resolveQueue(queue)\n          },\n          (err) => {\n            obj[turbopackError] = err\n            resolveQueue(queue)\n          }\n        )\n\n        return obj\n      }\n    }\n\n    return {\n      [turbopackExports]: dep,\n      [turbopackQueues]: () => {},\n    }\n  })\n}\n\nfunction asyncModule(\n  this: TurbopackBaseContext<Module>,\n  body: (\n    handleAsyncDependencies: (\n      deps: Dep[]\n    ) => Exports[] | Promise<() => Exports[]>,\n    asyncResult: (err?: any) => void\n  ) => void,\n  hasAwait: boolean\n) {\n  const module = this.m\n  const queue: AsyncQueue | undefined = hasAwait\n    ? Object.assign([], { status: QueueStatus.Unknown })\n    : undefined\n\n  const depQueues: Set<AsyncQueue> = new Set()\n\n  const { resolve, reject, promise: rawPromise } = createPromise<Exports>()\n\n  const promise: AsyncModulePromise = Object.assign(rawPromise, {\n    [turbopackExports]: module.exports,\n    [turbopackQueues]: (fn) => {\n      queue && fn(queue)\n      depQueues.forEach(fn)\n      promise['catch'](() => {})\n    },\n  } satisfies AsyncModuleExt)\n\n  const attributes: PropertyDescriptor = {\n    get(): any {\n      return promise\n    },\n    set(v: any) {\n      // Calling `esmExport` leads to this.\n      if (v !== promise) {\n        promise[turbopackExports] = v\n      }\n    },\n  }\n\n  Object.defineProperty(module, 'exports', attributes)\n  Object.defineProperty(module, 'namespaceObject', attributes)\n\n  function handleAsyncDependencies(deps: Dep[]) {\n    const currentDeps = wrapDeps(deps)\n\n    const getResult = () =>\n      currentDeps.map((d) => {\n        if (d[turbopackError]) throw d[turbopackError]\n        return d[turbopackExports]\n      })\n\n    const { promise, resolve } = createPromise<() => Exports[]>()\n\n    const fn: AsyncQueueFn = Object.assign(() => resolve(getResult), {\n      queueCount: 0,\n    })\n\n    function fnQueue(q: AsyncQueue) {\n      if (q !== queue && !depQueues.has(q)) {\n        depQueues.add(q)\n        if (q && q.status === QueueStatus.Unresolved) {\n          fn.queueCount++\n          q.push(fn)\n        }\n      }\n    }\n\n    currentDeps.map((dep) => dep[turbopackQueues](fnQueue))\n\n    return fn.queueCount ? promise : getResult()\n  }\n\n  function asyncResult(err?: any) {\n    if (err) {\n      reject((promise[turbopackError] = err))\n    } else {\n      resolve(promise[turbopackExports])\n    }\n\n    resolveQueue(queue)\n  }\n\n  body(handleAsyncDependencies, asyncResult)\n\n  if (queue && queue.status === QueueStatus.Unknown) {\n    queue.status = QueueStatus.Unresolved\n  }\n}\ncontextPrototype.a = asyncModule\n\n/**\n * A pseudo \"fake\" URL object to resolve to its relative path.\n *\n * When UrlRewriteBehavior is set to relative, calls to the `new URL()` will construct url without base using this\n * runtime function to generate context-agnostic urls between different rendering context, i.e ssr / client to avoid\n * hydration mismatch.\n *\n * This is based on webpack's existing implementation:\n * https://github.com/webpack/webpack/blob/87660921808566ef3b8796f8df61bd79fc026108/lib/runtime/RelativeUrlRuntimeModule.js\n */\nconst relativeURL = function relativeURL(this: any, inputUrl: string) {\n  const realUrl = new URL(inputUrl, 'x:/')\n  const values: Record<string, any> = {}\n  for (const key in realUrl) values[key] = (realUrl as any)[key]\n  values.href = inputUrl\n  values.pathname = inputUrl.replace(/[?#].*/, '')\n  values.origin = values.protocol = ''\n  values.toString = values.toJSON = (..._args: Array<any>) => inputUrl\n  for (const key in values)\n    Object.defineProperty(this, key, {\n      enumerable: true,\n      configurable: true,\n      value: values[key],\n    })\n}\nrelativeURL.prototype = URL.prototype\ncontextPrototype.U = relativeURL\n\n/**\n * Utility function to ensure all variants of an enum are handled.\n */\nfunction invariant(never: never, computeMessage: (arg: any) => string): never {\n  throw new Error(`Invariant: ${computeMessage(never)}`)\n}\n\n/**\n * A stub function to make `require` available but non-functional in ESM.\n */\nfunction requireStub(_moduleId: ModuleId): never {\n  throw new Error('dynamic usage of require is not supported')\n}\ncontextPrototype.z = requireStub\n\n// Make `globalThis` available to the module in a way that cannot be shadowed by a local variable.\ncontextPrototype.g = globalThis\n\ntype ContextConstructor<M> = {\n  new (module: Module, exports: Exports): TurbopackBaseContext<M>\n}\n\nfunction applyModuleFactoryName(factory: Function) {\n  // Give the module factory a nice name to improve stack traces.\n  Object.defineProperty(factory, 'name', {\n    value: 'module evaluation',\n  })\n}\n"],"names":["REEXPORTED_OBJECTS","WeakMap","Context","module","exports","m","e","contextPrototype","prototype","hasOwnProperty","Object","toStringTag","Symbol","defineProp","obj","name","options","call","defineProperty","getOverwrittenModule","moduleCache","id","createModuleObject","error","undefined","namespaceObject","BindingTag_Value","esm","bindings","value","i","length","propName","tagOrFunction","enumerable","writable","Error","getterFn","setterFn","get","set","seal","esmExport","c","s","ensureDynamicExports","reexportedObjects","Proxy","target","prop","Reflect","ownKeys","keys","key","includes","push","dynamicExport","object","j","exportValue","v","exportNamespace","namespace","n","createGetter","getProto","getPrototypeOf","__proto__","LEAF_PROTOTYPES","interopEsm","raw","ns","allowExportDefault","defaultLocation","current","getOwnPropertyNames","splice","createNS","args","apply","create","esmImport","getOrInstantiateModuleFromParent","__esModule","asyncLoader","moduleId","loader","r","bind","A","runtimeRequire","require","require1","t","commonJsRequire","parseRequest","request","hashIndex","indexOf","substring","queryIndex","moduleContext","map","code","resolve","import","f","getChunkPath","chunkData","path","isPromise","maybePromise","then","isAsyncModuleExt","turbopackQueues","createPromise","reject","promise","Promise","res","rej","installCompressedModuleFactories","chunkModules","offset","moduleFactories","newModuleId","end","has","moduleFactoryFn","applyModuleFactoryName","turbopackExports","turbopackError","resolveQueue","queue","status","forEach","fn","queueCount","wrapDeps","deps","dep","assign","err","asyncModule","body","hasAwait","depQueues","Set","rawPromise","attributes","handleAsyncDependencies","currentDeps","getResult","d","fnQueue","q","add","asyncResult","a","relativeURL","inputUrl","realUrl","URL","values","href","pathname","replace","origin","protocol","toString","toJSON","_args","configurable","U","invariant","never","computeMessage","requireStub","_moduleId","z","g","globalThis","factory"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 515, "column": 0}, "map": {"version":3,"sources":["turbopack:///[turbopack]/browser/runtime/base/runtime-base.ts"],"sourcesContent":["/**\n * This file contains runtime types and functions that are shared between all\n * Turbopack *browser* ECMAScript runtimes.\n *\n * It will be appended to the runtime code of each runtime right after the\n * shared runtime utils.\n */\n\n/* eslint-disable @typescript-eslint/no-unused-vars */\n\n/// <reference path=\"../base/globals.d.ts\" />\n/// <reference path=\"../../../shared/runtime-utils.ts\" />\n\n// Used in WebWorkers to tell the runtime about the chunk suffix\ndeclare var TURBOPACK_ASSET_SUFFIX: string\n// Used in WebWorkers to tell the runtime about the current chunk url since it\n// can't be detected via `document.currentScript`. Note it's stored in reversed\n// order to use `push` and `pop`\ndeclare var TURBOPACK_NEXT_CHUNK_URLS: ChunkUrl[] | undefined\n\n// Injected by rust code\ndeclare var CHUNK_BASE_PATH: string\ndeclare var ASSET_SUFFIX: string\ndeclare var WORKER_FORWARDED_GLOBALS: string[]\n\ninterface TurbopackBrowserBaseContext<M> extends TurbopackBaseContext<M> {\n  R: ResolvePathFromModule\n}\n\nconst browserContextPrototype =\n  Context.prototype as TurbopackBrowserBaseContext<unknown>\n\n// Provided by build or dev base\ndeclare function instantiateModule(\n  id: ModuleId,\n  sourceType: SourceType,\n  sourceData: SourceData\n): Module\n\ntype RuntimeParams = {\n  otherChunks: ChunkData[]\n  runtimeModuleIds: ModuleId[]\n}\n\ntype ChunkRegistrationChunk =\n  | ChunkPath\n  | { getAttribute: (name: string) => string | null }\n  | undefined\n\ntype ChunkRegistration = [\n  chunkPath: ChunkRegistrationChunk,\n  ...([RuntimeParams] | CompressedModuleFactories),\n]\n\ntype ChunkList = {\n  script: ChunkRegistrationChunk\n  chunks: ChunkData[]\n  source: 'entry' | 'dynamic'\n}\n\nenum SourceType {\n  /**\n   * The module was instantiated because it was included in an evaluated chunk's\n   * runtime.\n   * SourceData is a ChunkPath.\n   */\n  Runtime = 0,\n  /**\n   * The module was instantiated because a parent module imported it.\n   * SourceData is a ModuleId.\n   */\n  Parent = 1,\n  /**\n   * The module was instantiated because it was included in a chunk's hot module\n   * update.\n   * SourceData is an array of ModuleIds or undefined.\n   */\n  Update = 2,\n}\n\ntype SourceData = ChunkPath | ModuleId | ModuleId[] | undefined\ninterface RuntimeBackend {\n  registerChunk: (\n    chunkPath: ChunkPath | ChunkScript,\n    params?: RuntimeParams\n  ) => void\n  /**\n   * Returns the same Promise for the same chunk URL.\n   */\n  loadChunkCached: (sourceType: SourceType, chunkUrl: ChunkUrl) => Promise<void>\n  loadWebAssembly: (\n    sourceType: SourceType,\n    sourceData: SourceData,\n    wasmChunkPath: ChunkPath,\n    edgeModule: () => WebAssembly.Module,\n    importsObj: WebAssembly.Imports\n  ) => Promise<Exports>\n  loadWebAssemblyModule: (\n    sourceType: SourceType,\n    sourceData: SourceData,\n    wasmChunkPath: ChunkPath,\n    edgeModule: () => WebAssembly.Module\n  ) => Promise<WebAssembly.Module>\n}\n\ninterface DevRuntimeBackend {\n  reloadChunk?: (chunkUrl: ChunkUrl) => Promise<void>\n  unloadChunk?: (chunkUrl: ChunkUrl) => void\n  restart: () => void\n}\n\nconst moduleFactories: ModuleFactories = new Map()\ncontextPrototype.M = moduleFactories\n\nconst availableModules: Map<ModuleId, Promise<any> | true> = new Map()\n\nconst availableModuleChunks: Map<ChunkPath, Promise<any> | true> = new Map()\n\nfunction factoryNotAvailableMessage(\n  moduleId: ModuleId,\n  sourceType: SourceType,\n  sourceData: SourceData\n): string {\n  let instantiationReason\n  switch (sourceType) {\n    case SourceType.Runtime:\n      instantiationReason = `as a runtime entry of chunk ${sourceData}`\n      break\n    case SourceType.Parent:\n      instantiationReason = `because it was required from module ${sourceData}`\n      break\n    case SourceType.Update:\n      instantiationReason = 'because of an HMR update'\n      break\n    default:\n      invariant(\n        sourceType,\n        (sourceType) => `Unknown source type: ${sourceType}`\n      )\n  }\n  return `Module ${moduleId} was instantiated ${instantiationReason}, but the module factory is not available.`\n}\n\nfunction loadChunk(\n  this: TurbopackBrowserBaseContext<Module>,\n  chunkData: ChunkData\n): Promise<void> {\n  return loadChunkInternal(SourceType.Parent, this.m.id, chunkData)\n}\nbrowserContextPrototype.l = loadChunk\n\nfunction loadInitialChunk(chunkPath: ChunkPath, chunkData: ChunkData) {\n  return loadChunkInternal(SourceType.Runtime, chunkPath, chunkData)\n}\n\nasync function loadChunkInternal(\n  sourceType: SourceType,\n  sourceData: SourceData,\n  chunkData: ChunkData\n): Promise<void> {\n  if (typeof chunkData === 'string') {\n    return loadChunkPath(sourceType, sourceData, chunkData)\n  }\n\n  const includedList = chunkData.included || []\n  const modulesPromises = includedList.map((included) => {\n    if (moduleFactories.has(included)) return true\n    return availableModules.get(included)\n  })\n  if (modulesPromises.length > 0 && modulesPromises.every((p) => p)) {\n    // When all included items are already loaded or loading, we can skip loading ourselves\n    await Promise.all(modulesPromises)\n    return\n  }\n\n  const includedModuleChunksList = chunkData.moduleChunks || []\n  const moduleChunksPromises = includedModuleChunksList\n    .map((included) => {\n      // TODO(alexkirsz) Do we need this check?\n      // if (moduleFactories[included]) return true;\n      return availableModuleChunks.get(included)\n    })\n    .filter((p) => p)\n\n  let promise: Promise<unknown>\n  if (moduleChunksPromises.length > 0) {\n    // Some module chunks are already loaded or loading.\n\n    if (moduleChunksPromises.length === includedModuleChunksList.length) {\n      // When all included module chunks are already loaded or loading, we can skip loading ourselves\n      await Promise.all(moduleChunksPromises)\n      return\n    }\n\n    const moduleChunksToLoad: Set<ChunkPath> = new Set()\n    for (const moduleChunk of includedModuleChunksList) {\n      if (!availableModuleChunks.has(moduleChunk)) {\n        moduleChunksToLoad.add(moduleChunk)\n      }\n    }\n\n    for (const moduleChunkToLoad of moduleChunksToLoad) {\n      const promise = loadChunkPath(sourceType, sourceData, moduleChunkToLoad)\n\n      availableModuleChunks.set(moduleChunkToLoad, promise)\n\n      moduleChunksPromises.push(promise)\n    }\n\n    promise = Promise.all(moduleChunksPromises)\n  } else {\n    promise = loadChunkPath(sourceType, sourceData, chunkData.path)\n\n    // Mark all included module chunks as loading if they are not already loaded or loading.\n    for (const includedModuleChunk of includedModuleChunksList) {\n      if (!availableModuleChunks.has(includedModuleChunk)) {\n        availableModuleChunks.set(includedModuleChunk, promise)\n      }\n    }\n  }\n\n  for (const included of includedList) {\n    if (!availableModules.has(included)) {\n      // It might be better to race old and new promises, but it's rare that the new promise will be faster than a request started earlier.\n      // In production it's even more rare, because the chunk optimization tries to deduplicate modules anyway.\n      availableModules.set(included, promise)\n    }\n  }\n\n  await promise\n}\n\nconst loadedChunk = Promise.resolve(undefined)\nconst instrumentedBackendLoadChunks = new WeakMap<\n  Promise<any>,\n  Promise<any> | typeof loadedChunk\n>()\n// Do not make this async. React relies on referential equality of the returned Promise.\nfunction loadChunkByUrl(\n  this: TurbopackBrowserBaseContext<Module>,\n  chunkUrl: ChunkUrl\n) {\n  return loadChunkByUrlInternal(SourceType.Parent, this.m.id, chunkUrl)\n}\nbrowserContextPrototype.L = loadChunkByUrl\n\n// Do not make this async. React relies on referential equality of the returned Promise.\nfunction loadChunkByUrlInternal(\n  sourceType: SourceType,\n  sourceData: SourceData,\n  chunkUrl: ChunkUrl\n): Promise<any> {\n  const thenable = BACKEND.loadChunkCached(sourceType, chunkUrl)\n  let entry = instrumentedBackendLoadChunks.get(thenable)\n  if (entry === undefined) {\n    const resolve = instrumentedBackendLoadChunks.set.bind(\n      instrumentedBackendLoadChunks,\n      thenable,\n      loadedChunk\n    )\n    entry = thenable.then(resolve).catch((cause) => {\n      let loadReason: string\n      switch (sourceType) {\n        case SourceType.Runtime:\n          loadReason = `as a runtime dependency of chunk ${sourceData}`\n          break\n        case SourceType.Parent:\n          loadReason = `from module ${sourceData}`\n          break\n        case SourceType.Update:\n          loadReason = 'from an HMR update'\n          break\n        default:\n          invariant(\n            sourceType,\n            (sourceType) => `Unknown source type: ${sourceType}`\n          )\n      }\n      let error = new Error(\n        `Failed to load chunk ${chunkUrl} ${loadReason}${\n          cause ? `: ${cause}` : ''\n        }`,\n        cause ? { cause } : undefined\n      )\n      error.name = 'ChunkLoadError'\n      throw error\n    })\n    instrumentedBackendLoadChunks.set(thenable, entry)\n  }\n\n  return entry\n}\n\n// Do not make this async. React relies on referential equality of the returned Promise.\nfunction loadChunkPath(\n  sourceType: SourceType,\n  sourceData: SourceData,\n  chunkPath: ChunkPath\n): Promise<void> {\n  const url = getChunkRelativeUrl(chunkPath)\n  return loadChunkByUrlInternal(sourceType, sourceData, url)\n}\n\n/**\n * Returns an absolute url to an asset.\n */\nfunction resolvePathFromModule(\n  this: TurbopackBaseContext<Module>,\n  moduleId: string\n): string {\n  const exported = this.r(moduleId)\n  return exported?.default ?? exported\n}\nbrowserContextPrototype.R = resolvePathFromModule\n\n/**\n * no-op for browser\n * @param modulePath\n */\nfunction resolveAbsolutePath(modulePath?: string): string {\n  return `/ROOT/${modulePath ?? ''}`\n}\nbrowserContextPrototype.P = resolveAbsolutePath\n\n/**\n * Exports a URL with the static suffix appended.\n */\nfunction exportUrl(\n  this: TurbopackBrowserBaseContext<Module>,\n  url: string,\n  id: ModuleId | undefined\n) {\n  exportValue.call(this, `${url}${ASSET_SUFFIX}`, id)\n}\nbrowserContextPrototype.q = exportUrl\n\n/**\n * Returns a URL for the worker.\n * The entrypoint is a pre-compiled worker runtime file. The params configure\n * which module chunks to load and which module to run as the entry point.\n *\n * The params are a JSON array of the following structure:\n * `[TURBOPACK_NEXT_CHUNK_URLS, ASSET_SUFFIX, ...WORKER_FORWARDED_GLOBALS values]`\n *\n * @param entrypoint URL path to the worker entrypoint chunk\n * @param moduleChunks list of module chunk paths to load\n * @param shared whether this is a SharedWorker (uses querystring for URL identity)\n */\nfunction getWorkerURL(\n  entrypoint: ChunkPath,\n  moduleChunks: ChunkPath[],\n  shared: boolean\n): URL {\n  const chunkUrls = moduleChunks\n    .map((chunk) => getChunkRelativeUrl(chunk))\n    .reverse()\n  const params: unknown[] = [chunkUrls, ASSET_SUFFIX]\n  for (const globalName of WORKER_FORWARDED_GLOBALS) {\n    params.push((globalThis as Record<string, unknown>)[globalName])\n  }\n\n  const url = new URL(getChunkRelativeUrl(entrypoint), location.origin)\n  const paramsJson = JSON.stringify(params)\n  if (shared) {\n    url.searchParams.set('params', paramsJson)\n  } else {\n    url.hash = '#params=' + encodeURIComponent(paramsJson)\n  }\n  return url\n}\nbrowserContextPrototype.b = getWorkerURL\n\n/**\n * Instantiates a runtime module.\n */\nfunction instantiateRuntimeModule(\n  moduleId: ModuleId,\n  chunkPath: ChunkPath\n): Module {\n  return instantiateModule(moduleId, SourceType.Runtime, chunkPath)\n}\n/**\n * Returns the URL relative to the origin where a chunk can be fetched from.\n */\nfunction getChunkRelativeUrl(chunkPath: ChunkPath | ChunkListPath): ChunkUrl {\n  return `${CHUNK_BASE_PATH}${chunkPath\n    .split('/')\n    .map((p) => encodeURIComponent(p))\n    .join('/')}${ASSET_SUFFIX}` as ChunkUrl\n}\n\n/**\n * Return the ChunkPath from a ChunkScript.\n */\nfunction getPathFromScript(chunkScript: ChunkPath | ChunkScript): ChunkPath\nfunction getPathFromScript(\n  chunkScript: ChunkListPath | ChunkListScript\n): ChunkListPath\nfunction getPathFromScript(\n  chunkScript: ChunkPath | ChunkListPath | ChunkScript | ChunkListScript\n): ChunkPath | ChunkListPath {\n  if (typeof chunkScript === 'string') {\n    return chunkScript as ChunkPath | ChunkListPath\n  }\n  const chunkUrl = chunkScript.src!\n  const src = decodeURIComponent(chunkUrl.replace(/[?#].*$/, ''))\n  const path = src.startsWith(CHUNK_BASE_PATH)\n    ? src.slice(CHUNK_BASE_PATH.length)\n    : src\n  return path as ChunkPath | ChunkListPath\n}\n\n/**\n * Return the ChunkUrl from a ChunkScript.\n */\nfunction getUrlFromScript(chunk: ChunkPath | ChunkScript): ChunkUrl {\n  if (typeof chunk === 'string') {\n    return getChunkRelativeUrl(chunk)\n  } else {\n    // This is already exactly what we want\n    return chunk.src! as ChunkUrl\n  }\n}\n\n/**\n * Determine the chunk to register. Note that this function has side-effects!\n */\nfunction getChunkFromRegistration(\n  chunk: ChunkRegistrationChunk\n): ChunkPath | CurrentScript {\n  if (typeof chunk === 'string') {\n    return chunk\n  } else if (!chunk) {\n    if (typeof TURBOPACK_NEXT_CHUNK_URLS !== 'undefined') {\n      return { src: TURBOPACK_NEXT_CHUNK_URLS.pop()! } as CurrentScript\n    } else {\n      throw new Error('chunk path empty but not in a worker')\n    }\n  } else {\n    return { src: chunk.getAttribute('src')! } as CurrentScript\n  }\n}\n\nconst regexJsUrl = /\\.js(?:\\?[^#]*)?(?:#.*)?$/\n/**\n * Checks if a given path/URL ends with .js, optionally followed by ?query or #fragment.\n */\nfunction isJs(chunkUrlOrPath: ChunkUrl | ChunkPath): boolean {\n  return regexJsUrl.test(chunkUrlOrPath)\n}\n\nconst regexCssUrl = /\\.css(?:\\?[^#]*)?(?:#.*)?$/\n/**\n * Checks if a given path/URL ends with .css, optionally followed by ?query or #fragment.\n */\nfunction isCss(chunkUrl: ChunkUrl): boolean {\n  return regexCssUrl.test(chunkUrl)\n}\n\nfunction loadWebAssembly(\n  this: TurbopackBaseContext<Module>,\n  chunkPath: ChunkPath,\n  edgeModule: () => WebAssembly.Module,\n  importsObj: WebAssembly.Imports\n): Promise<Exports> {\n  return BACKEND.loadWebAssembly(\n    SourceType.Parent,\n    this.m.id,\n    chunkPath,\n    edgeModule,\n    importsObj\n  )\n}\ncontextPrototype.w = loadWebAssembly\n\nfunction loadWebAssemblyModule(\n  this: TurbopackBaseContext<Module>,\n  chunkPath: ChunkPath,\n  edgeModule: () => WebAssembly.Module\n): Promise<WebAssembly.Module> {\n  return BACKEND.loadWebAssemblyModule(\n    SourceType.Parent,\n    this.m.id,\n    chunkPath,\n    edgeModule\n  )\n}\ncontextPrototype.u = loadWebAssemblyModule\n"],"names":["browserContextPrototype","Context","prototype","SourceType","moduleFactories","Map","contextPrototype","M","availableModules","availableModuleChunks","factoryNotAvailableMessage","moduleId","sourceType","sourceData","instantiationReason","invariant","loadChunk","chunkData","loadChunkInternal","m","id","l","loadInitialChunk","chunkPath","loadChunkPath","includedList","included","modulesPromises","map","has","get","length","every","p","Promise","all","includedModuleChunksList","moduleChunks","moduleChunksPromises","filter","promise","moduleChunksToLoad","Set","moduleChunk","add","moduleChunkToLoad","set","push","path","includedModuleChunk","loadedChunk","resolve","undefined","instrumentedBackendLoadChunks","WeakMap","loadChunkByUrl","chunkUrl","loadChunkByUrlInternal","L","thenable","BACKEND","loadChunkCached","entry","bind","then","catch","cause","loadReason","error","Error","name","url","getChunkRelativeUrl","resolvePathFromModule","exported","r","default","R","resolveAbsolutePath","modulePath","P","exportUrl","exportValue","call","ASSET_SUFFIX","q","getWorkerURL","entrypoint","shared","chunkUrls","chunk","reverse","params","globalName","WORKER_FORWARDED_GLOBALS","globalThis","URL","location","origin","paramsJson","JSON","stringify","searchParams","hash","encodeURIComponent","b","instantiateRuntimeModule","instantiateModule","CHUNK_BASE_PATH","split","join","getPathFromScript","chunkScript","src","decodeURIComponent","replace","startsWith","slice","getUrlFromScript","getChunkFromRegistration","TURBOPACK_NEXT_CHUNK_URLS","pop","getAttribute","regexJsUrl","isJs","chunkUrlOrPath","test","regexCssUrl","isCss","loadWebAssembly","edgeModule","importsObj","w","loadWebAssemblyModule","u"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 789, "column": 0}, "map": {"version":3,"sources":["turbopack:///[turbopack]/browser/runtime/base/dev-base.ts"],"sourcesContent":["/// <reference path=\"./dev-globals.d.ts\" />\n/// <reference path=\"./dev-protocol.d.ts\" />\n/// <reference path=\"./dev-extensions.ts\" />\n\ninterface TurbopackDevContext extends TurbopackBrowserBaseContext<HotModule> {\n  k: RefreshContext\n}\n\nconst devContextPrototype = Context.prototype as TurbopackDevContext\n\n/**\n * This file contains runtime types and functions that are shared between all\n * Turbopack *development* ECMAScript runtimes.\n *\n * It will be appended to the runtime code of each runtime right after the\n * shared runtime utils.\n */\n\n/* eslint-disable @typescript-eslint/no-unused-vars */\n\nconst devModuleCache: ModuleCache<HotModule> = Object.create(null)\ndevContextPrototype.c = devModuleCache\n\n// This file must not use `import` and `export` statements. Otherwise, it\n// becomes impossible to augment interfaces declared in `<reference>`d files\n// (e.g. `Module`). Hence, the need for `import()` here.\ntype RefreshRuntimeGlobals =\n  import('@next/react-refresh-utils/dist/runtime').RefreshRuntimeGlobals\n\ndeclare var $RefreshHelpers$: RefreshRuntimeGlobals['$RefreshHelpers$']\ndeclare var $RefreshReg$: RefreshRuntimeGlobals['$RefreshReg$']\ndeclare var $RefreshSig$: RefreshRuntimeGlobals['$RefreshSig$']\ndeclare var $RefreshInterceptModuleExecution$: RefreshRuntimeGlobals['$RefreshInterceptModuleExecution$']\n\ntype RefreshContext = {\n  register: RefreshRuntimeGlobals['$RefreshReg$']\n  signature: RefreshRuntimeGlobals['$RefreshSig$']\n  registerExports: typeof registerExportsAndSetupBoundaryForReactRefresh\n}\n\ntype RefreshHelpers = RefreshRuntimeGlobals['$RefreshHelpers$']\n\ntype ModuleFactory = (\n  this: Module['exports'],\n  context: TurbopackDevContext\n) => unknown\n\ninterface DevRuntimeBackend {\n  reloadChunk?: (chunkUrl: ChunkUrl) => Promise<void>\n  unloadChunk?: (chunkUrl: ChunkUrl) => void\n  restart: () => void\n}\n\nclass UpdateApplyError extends Error {\n  name = 'UpdateApplyError'\n\n  dependencyChain: ModuleId[]\n\n  constructor(message: string, dependencyChain: ModuleId[]) {\n    super(message)\n    this.dependencyChain = dependencyChain\n  }\n}\n\n/**\n * Module IDs that are instantiated as part of the runtime of a chunk.\n */\nconst runtimeModules: Set<ModuleId> = new Set()\n\n/**\n * Map from module ID to the chunks that contain this module.\n *\n * In HMR, we need to keep track of which modules are contained in which so\n * chunks. This is so we don't eagerly dispose of a module when it is removed\n * from chunk A, but still exists in chunk B.\n */\nconst moduleChunksMap: Map<ModuleId, Set<ChunkPath>> = new Map()\n/**\n * Map from a chunk path to all modules it contains.\n */\nconst chunkModulesMap: Map<ChunkPath, Set<ModuleId>> = new Map()\n/**\n * Chunk lists that contain a runtime. When these chunk lists receive an update\n * that can't be reconciled with the current state of the page, we need to\n * reload the runtime entirely.\n */\nconst runtimeChunkLists: Set<ChunkListPath> = new Set()\n/**\n * Map from a chunk list to the chunk paths it contains.\n */\nconst chunkListChunksMap: Map<ChunkListPath, Set<ChunkPath>> = new Map()\n/**\n * Map from a chunk path to the chunk lists it belongs to.\n */\nconst chunkChunkListsMap: Map<ChunkPath, Set<ChunkListPath>> = new Map()\n\n/**\n * Maps module IDs to persisted data between executions of their hot module\n * implementation (`hot.data`).\n */\nconst moduleHotData: Map<ModuleId, HotData> = new Map()\n/**\n * Maps module instances to their hot module state.\n */\nconst moduleHotState: Map<Module, HotState> = new Map()\n/**\n * Modules that call `module.hot.invalidate()` (while being updated).\n */\nconst queuedInvalidatedModules: Set<ModuleId> = new Set()\n\n/**\n * Gets or instantiates a runtime module.\n */\n// @ts-ignore\nfunction getOrInstantiateRuntimeModule(\n  chunkPath: ChunkPath,\n  moduleId: ModuleId\n): Module {\n  const module = devModuleCache[moduleId]\n  if (module) {\n    if (module.error) {\n      throw module.error\n    }\n    return module\n  }\n\n  // @ts-ignore\n  return instantiateModule(moduleId, SourceType.Runtime, chunkPath)\n}\n\n/**\n * Retrieves a module from the cache, or instantiate it if it is not cached.\n */\n// @ts-ignore Defined in `runtime-utils.ts`\nconst getOrInstantiateModuleFromParent: GetOrInstantiateModuleFromParent<\n  HotModule\n> = (id, sourceModule) => {\n  if (!sourceModule.hot.active) {\n    console.warn(\n      `Unexpected import of module ${id} from module ${sourceModule.id}, which was deleted by an HMR update`\n    )\n  }\n\n  const module = devModuleCache[id]\n\n  if (sourceModule.children.indexOf(id) === -1) {\n    sourceModule.children.push(id)\n  }\n\n  if (module) {\n    if (module.error) {\n      throw module.error\n    }\n\n    if (module.parents.indexOf(sourceModule.id) === -1) {\n      module.parents.push(sourceModule.id)\n    }\n\n    return module\n  }\n\n  return instantiateModule(id, SourceType.Parent, sourceModule.id)\n}\n\nfunction DevContext(\n  this: TurbopackDevContext,\n  module: HotModule,\n  exports: Exports,\n  refresh: RefreshContext\n) {\n  Context.call(this, module, exports)\n  this.k = refresh\n}\nDevContext.prototype = Context.prototype\n\ntype DevContextConstructor = {\n  new (\n    module: HotModule,\n    exports: Exports,\n    refresh: RefreshContext\n  ): TurbopackDevContext\n}\n\nfunction instantiateModule(\n  moduleId: ModuleId,\n  sourceType: SourceType,\n  sourceData: SourceData\n): Module {\n  // We are in development, this is always a string.\n  let id = moduleId as string\n\n  const moduleFactory = moduleFactories.get(id)\n  if (typeof moduleFactory !== 'function') {\n    // This can happen if modules incorrectly handle HMR disposes/updates,\n    // e.g. when they keep a `setTimeout` around which still executes old code\n    // and contains e.g. a `require(\"something\")` call.\n    throw new Error(\n      factoryNotAvailableMessage(id, sourceType, sourceData) +\n        ' It might have been deleted in an HMR update.'\n    )\n  }\n\n  const hotData = moduleHotData.get(id)!\n  const { hot, hotState } = createModuleHot(id, hotData)\n\n  let parents: ModuleId[]\n  switch (sourceType) {\n    case SourceType.Runtime:\n      runtimeModules.add(id)\n      parents = []\n      break\n    case SourceType.Parent:\n      // No need to add this module as a child of the parent module here, this\n      // has already been taken care of in `getOrInstantiateModuleFromParent`.\n      parents = [sourceData as ModuleId]\n      break\n    case SourceType.Update:\n      parents = (sourceData as ModuleId[]) || []\n      break\n    default:\n      invariant(\n        sourceType,\n        (sourceType) => `Unknown source type: ${sourceType}`\n      )\n  }\n\n  const module: HotModule = createModuleObject(id) as HotModule\n  const exports = module.exports\n  module.parents = parents\n  module.children = []\n  module.hot = hot\n\n  devModuleCache[id] = module\n  moduleHotState.set(module, hotState)\n\n  // NOTE(alexkirsz) This can fail when the module encounters a runtime error.\n  try {\n    runModuleExecutionHooks(module, (refresh) => {\n      const context = new (DevContext as any as DevContextConstructor)(\n        module,\n        exports,\n        refresh\n      )\n      moduleFactory(context, module, exports)\n    })\n  } catch (error) {\n    module.error = error as any\n    throw error\n  }\n\n  if (module.namespaceObject && module.exports !== module.namespaceObject) {\n    // in case of a circular dependency: cjs1 -> esm2 -> cjs1\n    interopEsm(module.exports, module.namespaceObject)\n  }\n\n  return module\n}\n\nconst DUMMY_REFRESH_CONTEXT = {\n  register: (_type: unknown, _id: unknown) => {},\n  signature: () => (_type: unknown) => {},\n  registerExports: (_module: unknown, _helpers: unknown) => {},\n}\n\n/**\n * NOTE(alexkirsz) Webpack has a \"module execution\" interception hook that\n * Next.js' React Refresh runtime hooks into to add module context to the\n * refresh registry.\n */\nfunction runModuleExecutionHooks(\n  module: HotModule,\n  executeModule: (ctx: RefreshContext) => void\n) {\n  if (typeof globalThis.$RefreshInterceptModuleExecution$ === 'function') {\n    const cleanupReactRefreshIntercept =\n      globalThis.$RefreshInterceptModuleExecution$(module.id)\n    try {\n      executeModule({\n        register: globalThis.$RefreshReg$,\n        signature: globalThis.$RefreshSig$,\n        registerExports: registerExportsAndSetupBoundaryForReactRefresh,\n      })\n    } finally {\n      // Always cleanup the intercept, even if module execution failed.\n      cleanupReactRefreshIntercept()\n    }\n  } else {\n    // If the react refresh hooks are not installed we need to bind dummy functions.\n    // This is expected when running in a Web Worker.  It is also common in some of\n    // our test environments.\n    executeModule(DUMMY_REFRESH_CONTEXT)\n  }\n}\n\n/**\n * This is adapted from https://github.com/vercel/next.js/blob/3466862d9dc9c8bb3131712134d38757b918d1c0/packages/react-refresh-utils/internal/ReactRefreshModule.runtime.ts\n */\nfunction registerExportsAndSetupBoundaryForReactRefresh(\n  module: HotModule,\n  helpers: RefreshHelpers\n) {\n  const currentExports = module.exports\n  const prevExports = module.hot.data.prevExports ?? null\n\n  helpers.registerExportsForReactRefresh(currentExports, module.id)\n\n  // A module can be accepted automatically based on its exports, e.g. when\n  // it is a Refresh Boundary.\n  if (helpers.isReactRefreshBoundary(currentExports)) {\n    // Save the previous exports on update, so we can compare the boundary\n    // signatures.\n    module.hot.dispose((data) => {\n      data.prevExports = currentExports\n    })\n    // Unconditionally accept an update to this module, we'll check if it's\n    // still a Refresh Boundary later.\n    module.hot.accept()\n\n    // This field is set when the previous version of this module was a\n    // Refresh Boundary, letting us know we need to check for invalidation or\n    // enqueue an update.\n    if (prevExports !== null) {\n      // A boundary can become ineligible if its exports are incompatible\n      // with the previous exports.\n      //\n      // For example, if you add/remove/change exports, we'll want to\n      // re-execute the importing modules, and force those components to\n      // re-render. Similarly, if you convert a class component to a\n      // function, we want to invalidate the boundary.\n      if (\n        helpers.shouldInvalidateReactRefreshBoundary(\n          helpers.getRefreshBoundarySignature(prevExports),\n          helpers.getRefreshBoundarySignature(currentExports)\n        )\n      ) {\n        module.hot.invalidate()\n      } else {\n        helpers.scheduleUpdate()\n      }\n    }\n  } else {\n    // Since we just executed the code for the module, it's possible that the\n    // new exports made it ineligible for being a boundary.\n    // We only care about the case when we were _previously_ a boundary,\n    // because we already accepted this update (accidental side effect).\n    const isNoLongerABoundary = prevExports !== null\n    if (isNoLongerABoundary) {\n      module.hot.invalidate()\n    }\n  }\n}\n\nfunction formatDependencyChain(dependencyChain: ModuleId[]): string {\n  return `Dependency chain: ${dependencyChain.join(' -> ')}`\n}\n\nfunction computeOutdatedModules(\n  added: Map<ModuleId, EcmascriptModuleEntry | undefined>,\n  modified: Map<ModuleId, EcmascriptModuleEntry>\n): {\n  outdatedModules: Set<ModuleId>\n  newModuleFactories: Map<ModuleId, ModuleFactory>\n} {\n  const newModuleFactories = new Map<ModuleId, ModuleFactory>()\n\n  for (const [moduleId, entry] of added) {\n    if (entry != null) {\n      newModuleFactories.set(moduleId, _eval(entry))\n    }\n  }\n\n  const outdatedModules = computedInvalidatedModules(modified.keys())\n\n  for (const [moduleId, entry] of modified) {\n    newModuleFactories.set(moduleId, _eval(entry))\n  }\n\n  return { outdatedModules, newModuleFactories }\n}\n\nfunction computedInvalidatedModules(\n  invalidated: Iterable<ModuleId>\n): Set<ModuleId> {\n  const outdatedModules = new Set<ModuleId>()\n\n  for (const moduleId of invalidated) {\n    const effect = getAffectedModuleEffects(moduleId)\n\n    switch (effect.type) {\n      case 'unaccepted':\n        throw new UpdateApplyError(\n          `cannot apply update: unaccepted module. ${formatDependencyChain(\n            effect.dependencyChain\n          )}.`,\n          effect.dependencyChain\n        )\n      case 'self-declined':\n        throw new UpdateApplyError(\n          `cannot apply update: self-declined module. ${formatDependencyChain(\n            effect.dependencyChain\n          )}.`,\n          effect.dependencyChain\n        )\n      case 'accepted':\n        for (const outdatedModuleId of effect.outdatedModules) {\n          outdatedModules.add(outdatedModuleId)\n        }\n        break\n      // TODO(alexkirsz) Dependencies: handle dependencies effects.\n      default:\n        invariant(effect, (effect) => `Unknown effect type: ${effect?.type}`)\n    }\n  }\n\n  return outdatedModules\n}\n\nfunction computeOutdatedSelfAcceptedModules(\n  outdatedModules: Iterable<ModuleId>\n): { moduleId: ModuleId; errorHandler: true | Function }[] {\n  const outdatedSelfAcceptedModules: {\n    moduleId: ModuleId\n    errorHandler: true | Function\n  }[] = []\n  for (const moduleId of outdatedModules) {\n    const module = devModuleCache[moduleId]\n    const hotState = moduleHotState.get(module)!\n    if (module && hotState.selfAccepted && !hotState.selfInvalidated) {\n      outdatedSelfAcceptedModules.push({\n        moduleId,\n        errorHandler: hotState.selfAccepted,\n      })\n    }\n  }\n  return outdatedSelfAcceptedModules\n}\n\n/**\n * Adds, deletes, and moves modules between chunks. This must happen before the\n * dispose phase as it needs to know which modules were removed from all chunks,\n * which we can only compute *after* taking care of added and moved modules.\n */\nfunction updateChunksPhase(\n  chunksAddedModules: Map<ChunkPath, Set<ModuleId>>,\n  chunksDeletedModules: Map<ChunkPath, Set<ModuleId>>\n): { disposedModules: Set<ModuleId> } {\n  for (const [chunkPath, addedModuleIds] of chunksAddedModules) {\n    for (const moduleId of addedModuleIds) {\n      addModuleToChunk(moduleId, chunkPath)\n    }\n  }\n\n  const disposedModules: Set<ModuleId> = new Set()\n  for (const [chunkPath, addedModuleIds] of chunksDeletedModules) {\n    for (const moduleId of addedModuleIds) {\n      if (removeModuleFromChunk(moduleId, chunkPath)) {\n        disposedModules.add(moduleId)\n      }\n    }\n  }\n\n  return { disposedModules }\n}\n\nfunction disposePhase(\n  outdatedModules: Iterable<ModuleId>,\n  disposedModules: Iterable<ModuleId>\n): { outdatedModuleParents: Map<ModuleId, Array<ModuleId>> } {\n  for (const moduleId of outdatedModules) {\n    disposeModule(moduleId, 'replace')\n  }\n\n  for (const moduleId of disposedModules) {\n    disposeModule(moduleId, 'clear')\n  }\n\n  // Removing modules from the module cache is a separate step.\n  // We also want to keep track of previous parents of the outdated modules.\n  const outdatedModuleParents = new Map()\n  for (const moduleId of outdatedModules) {\n    const oldModule = devModuleCache[moduleId]\n    outdatedModuleParents.set(moduleId, oldModule?.parents)\n    delete devModuleCache[moduleId]\n  }\n\n  // TODO(alexkirsz) Dependencies: remove outdated dependency from module\n  // children.\n\n  return { outdatedModuleParents }\n}\n\n/**\n * Disposes of an instance of a module.\n *\n * Returns the persistent hot data that should be kept for the next module\n * instance.\n *\n * NOTE: mode = \"replace\" will not remove modules from the devModuleCache\n * This must be done in a separate step afterwards.\n * This is important because all modules need to be disposed to update the\n * parent/child relationships before they are actually removed from the devModuleCache.\n * If this was done in this method, the following disposeModule calls won't find\n * the module from the module id in the cache.\n */\nfunction disposeModule(moduleId: ModuleId, mode: 'clear' | 'replace') {\n  const module = devModuleCache[moduleId]\n  if (!module) {\n    return\n  }\n\n  const hotState = moduleHotState.get(module)!\n  const data = {}\n\n  // Run the `hot.dispose` handler, if any, passing in the persistent\n  // `hot.data` object.\n  for (const disposeHandler of hotState.disposeHandlers) {\n    disposeHandler(data)\n  }\n\n  // This used to warn in `getOrInstantiateModuleFromParent` when a disposed\n  // module is still importing other modules.\n  module.hot.active = false\n\n  moduleHotState.delete(module)\n\n  // TODO(alexkirsz) Dependencies: delete the module from outdated deps.\n\n  // Remove the disposed module from its children's parent list.\n  // It will be added back once the module re-instantiates and imports its\n  // children again.\n  for (const childId of module.children) {\n    const child = devModuleCache[childId]\n    if (!child) {\n      continue\n    }\n\n    const idx = child.parents.indexOf(module.id)\n    if (idx >= 0) {\n      child.parents.splice(idx, 1)\n    }\n  }\n\n  switch (mode) {\n    case 'clear':\n      delete devModuleCache[module.id]\n      moduleHotData.delete(module.id)\n      break\n    case 'replace':\n      moduleHotData.set(module.id, data)\n      break\n    default:\n      invariant(mode, (mode) => `invalid mode: ${mode}`)\n  }\n}\n\nfunction applyPhase(\n  outdatedSelfAcceptedModules: {\n    moduleId: ModuleId\n    errorHandler: true | Function\n  }[],\n  newModuleFactories: Map<ModuleId, ModuleFactory>,\n  outdatedModuleParents: Map<ModuleId, Array<ModuleId>>,\n  reportError: (err: any) => void\n) {\n  // Update module factories.\n  for (const [moduleId, factory] of newModuleFactories.entries()) {\n    applyModuleFactoryName(factory)\n    moduleFactories.set(moduleId, factory)\n  }\n\n  // TODO(alexkirsz) Run new runtime entries here.\n\n  // TODO(alexkirsz) Dependencies: call accept handlers for outdated deps.\n\n  // Re-instantiate all outdated self-accepted modules.\n  for (const { moduleId, errorHandler } of outdatedSelfAcceptedModules) {\n    try {\n      instantiateModule(\n        moduleId,\n        SourceType.Update,\n        outdatedModuleParents.get(moduleId)\n      )\n    } catch (err) {\n      if (typeof errorHandler === 'function') {\n        try {\n          errorHandler(err, { moduleId, module: devModuleCache[moduleId] })\n        } catch (err2) {\n          reportError(err2)\n          reportError(err)\n        }\n      } else {\n        reportError(err)\n      }\n    }\n  }\n}\n\nfunction applyUpdate(update: PartialUpdate) {\n  switch (update.type) {\n    case 'ChunkListUpdate':\n      applyChunkListUpdate(update)\n      break\n    default:\n      invariant(update, (update) => `Unknown update type: ${update.type}`)\n  }\n}\n\nfunction applyChunkListUpdate(update: ChunkListUpdate) {\n  if (update.merged != null) {\n    for (const merged of update.merged) {\n      switch (merged.type) {\n        case 'EcmascriptMergedUpdate':\n          applyEcmascriptMergedUpdate(merged)\n          break\n        default:\n          invariant(merged, (merged) => `Unknown merged type: ${merged.type}`)\n      }\n    }\n  }\n\n  if (update.chunks != null) {\n    for (const [chunkPath, chunkUpdate] of Object.entries(\n      update.chunks\n    ) as Array<[ChunkPath, ChunkUpdate]>) {\n      const chunkUrl = getChunkRelativeUrl(chunkPath)\n\n      switch (chunkUpdate.type) {\n        case 'added':\n          BACKEND.loadChunkCached(SourceType.Update, chunkUrl)\n          break\n        case 'total':\n          DEV_BACKEND.reloadChunk?.(chunkUrl)\n          break\n        case 'deleted':\n          DEV_BACKEND.unloadChunk?.(chunkUrl)\n          break\n        case 'partial':\n          invariant(\n            chunkUpdate.instruction,\n            (instruction) =>\n              `Unknown partial instruction: ${JSON.stringify(instruction)}.`\n          )\n          break\n        default:\n          invariant(\n            chunkUpdate,\n            (chunkUpdate) => `Unknown chunk update type: ${chunkUpdate.type}`\n          )\n      }\n    }\n  }\n}\n\nfunction applyEcmascriptMergedUpdate(update: EcmascriptMergedUpdate) {\n  const { entries = {}, chunks = {} } = update\n  const { added, modified, chunksAdded, chunksDeleted } = computeChangedModules(\n    entries,\n    chunks\n  )\n  const { outdatedModules, newModuleFactories } = computeOutdatedModules(\n    added,\n    modified\n  )\n  const { disposedModules } = updateChunksPhase(chunksAdded, chunksDeleted)\n\n  applyInternal(outdatedModules, disposedModules, newModuleFactories)\n}\n\nfunction applyInvalidatedModules(outdatedModules: Set<ModuleId>) {\n  if (queuedInvalidatedModules.size > 0) {\n    computedInvalidatedModules(queuedInvalidatedModules).forEach((moduleId) => {\n      outdatedModules.add(moduleId)\n    })\n\n    queuedInvalidatedModules.clear()\n  }\n\n  return outdatedModules\n}\n\nfunction applyInternal(\n  outdatedModules: Set<ModuleId>,\n  disposedModules: Iterable<ModuleId>,\n  newModuleFactories: Map<ModuleId, ModuleFactory>\n) {\n  outdatedModules = applyInvalidatedModules(outdatedModules)\n\n  const outdatedSelfAcceptedModules =\n    computeOutdatedSelfAcceptedModules(outdatedModules)\n\n  const { outdatedModuleParents } = disposePhase(\n    outdatedModules,\n    disposedModules\n  )\n\n  // we want to continue on error and only throw the error after we tried applying all updates\n  let error: any\n\n  function reportError(err: any) {\n    if (!error) error = err\n  }\n\n  applyPhase(\n    outdatedSelfAcceptedModules,\n    newModuleFactories,\n    outdatedModuleParents,\n    reportError\n  )\n\n  if (error) {\n    throw error\n  }\n\n  if (queuedInvalidatedModules.size > 0) {\n    applyInternal(new Set(), [], new Map())\n  }\n}\n\nfunction computeChangedModules(\n  entries: Record<ModuleId, EcmascriptModuleEntry>,\n  updates: Record<ChunkPath, EcmascriptMergedChunkUpdate>\n): {\n  added: Map<ModuleId, EcmascriptModuleEntry | undefined>\n  modified: Map<ModuleId, EcmascriptModuleEntry>\n  deleted: Set<ModuleId>\n  chunksAdded: Map<ChunkPath, Set<ModuleId>>\n  chunksDeleted: Map<ChunkPath, Set<ModuleId>>\n} {\n  const chunksAdded = new Map()\n  const chunksDeleted = new Map()\n  const added: Map<ModuleId, EcmascriptModuleEntry> = new Map()\n  const modified = new Map()\n  const deleted: Set<ModuleId> = new Set()\n\n  for (const [chunkPath, mergedChunkUpdate] of Object.entries(updates) as Array<\n    [ChunkPath, EcmascriptMergedChunkUpdate]\n  >) {\n    switch (mergedChunkUpdate.type) {\n      case 'added': {\n        const updateAdded = new Set(mergedChunkUpdate.modules)\n        for (const moduleId of updateAdded) {\n          added.set(moduleId, entries[moduleId])\n        }\n        chunksAdded.set(chunkPath, updateAdded)\n        break\n      }\n      case 'deleted': {\n        // We could also use `mergedChunkUpdate.modules` here.\n        const updateDeleted = new Set(chunkModulesMap.get(chunkPath))\n        for (const moduleId of updateDeleted) {\n          deleted.add(moduleId)\n        }\n        chunksDeleted.set(chunkPath, updateDeleted)\n        break\n      }\n      case 'partial': {\n        const updateAdded = new Set(mergedChunkUpdate.added)\n        const updateDeleted = new Set(mergedChunkUpdate.deleted)\n        for (const moduleId of updateAdded) {\n          added.set(moduleId, entries[moduleId])\n        }\n        for (const moduleId of updateDeleted) {\n          deleted.add(moduleId)\n        }\n        chunksAdded.set(chunkPath, updateAdded)\n        chunksDeleted.set(chunkPath, updateDeleted)\n        break\n      }\n      default:\n        invariant(\n          mergedChunkUpdate,\n          (mergedChunkUpdate) =>\n            `Unknown merged chunk update type: ${mergedChunkUpdate.type}`\n        )\n    }\n  }\n\n  // If a module was added from one chunk and deleted from another in the same update,\n  // consider it to be modified, as it means the module was moved from one chunk to another\n  // AND has new code in a single update.\n  for (const moduleId of added.keys()) {\n    if (deleted.has(moduleId)) {\n      added.delete(moduleId)\n      deleted.delete(moduleId)\n    }\n  }\n\n  for (const [moduleId, entry] of Object.entries(entries)) {\n    // Modules that haven't been added to any chunk but have new code are considered\n    // to be modified.\n    // This needs to be under the previous loop, as we need it to get rid of modules\n    // that were added and deleted in the same update.\n    if (!added.has(moduleId)) {\n      modified.set(moduleId, entry)\n    }\n  }\n\n  return { added, deleted, modified, chunksAdded, chunksDeleted }\n}\n\ntype ModuleEffect =\n  | {\n      type: 'unaccepted'\n      dependencyChain: ModuleId[]\n    }\n  | {\n      type: 'self-declined'\n      dependencyChain: ModuleId[]\n      moduleId: ModuleId\n    }\n  | {\n      type: 'accepted'\n      moduleId: ModuleId\n      outdatedModules: Set<ModuleId>\n    }\n\nfunction getAffectedModuleEffects(moduleId: ModuleId): ModuleEffect {\n  const outdatedModules: Set<ModuleId> = new Set()\n\n  type QueueItem = { moduleId?: ModuleId; dependencyChain: ModuleId[] }\n\n  const queue: QueueItem[] = [\n    {\n      moduleId,\n      dependencyChain: [],\n    },\n  ]\n\n  let nextItem\n  while ((nextItem = queue.shift())) {\n    const { moduleId, dependencyChain } = nextItem\n\n    if (moduleId != null) {\n      if (outdatedModules.has(moduleId)) {\n        // Avoid infinite loops caused by cycles between modules in the dependency chain.\n        continue\n      }\n\n      outdatedModules.add(moduleId)\n    }\n\n    // We've arrived at the runtime of the chunk, which means that nothing\n    // else above can accept this update.\n    if (moduleId === undefined) {\n      return {\n        type: 'unaccepted',\n        dependencyChain,\n      }\n    }\n\n    const module = devModuleCache[moduleId]\n    const hotState = moduleHotState.get(module)!\n\n    if (\n      // The module is not in the cache. Since this is a \"modified\" update,\n      // it means that the module was never instantiated before.\n      !module || // The module accepted itself without invalidating globalThis.\n      // TODO is that right?\n      (hotState.selfAccepted && !hotState.selfInvalidated)\n    ) {\n      continue\n    }\n\n    if (hotState.selfDeclined) {\n      return {\n        type: 'self-declined',\n        dependencyChain,\n        moduleId,\n      }\n    }\n\n    if (runtimeModules.has(moduleId)) {\n      queue.push({\n        moduleId: undefined,\n        dependencyChain: [...dependencyChain, moduleId],\n      })\n      continue\n    }\n\n    for (const parentId of module.parents) {\n      const parent = devModuleCache[parentId]\n\n      if (!parent) {\n        // TODO(alexkirsz) Is this even possible?\n        continue\n      }\n\n      // TODO(alexkirsz) Dependencies: check accepted and declined\n      // dependencies here.\n\n      queue.push({\n        moduleId: parentId,\n        dependencyChain: [...dependencyChain, moduleId],\n      })\n    }\n  }\n\n  return {\n    type: 'accepted',\n    moduleId,\n    outdatedModules,\n  }\n}\n\nfunction handleApply(chunkListPath: ChunkListPath, update: ServerMessage) {\n  switch (update.type) {\n    case 'partial': {\n      // This indicates that the update is can be applied to the current state of the application.\n      applyUpdate(update.instruction)\n      break\n    }\n    case 'restart': {\n      // This indicates that there is no way to apply the update to the\n      // current state of the application, and that the application must be\n      // restarted.\n      DEV_BACKEND.restart()\n      break\n    }\n    case 'notFound': {\n      // This indicates that the chunk list no longer exists: either the dynamic import which created it was removed,\n      // or the page itself was deleted.\n      // If it is a dynamic import, we simply discard all modules that the chunk has exclusive access to.\n      // If it is a runtime chunk list, we restart the application.\n      if (runtimeChunkLists.has(chunkListPath)) {\n        DEV_BACKEND.restart()\n      } else {\n        disposeChunkList(chunkListPath)\n      }\n      break\n    }\n    default:\n      throw new Error(`Unknown update type: ${update.type}`)\n  }\n}\n\nfunction createModuleHot(\n  moduleId: ModuleId,\n  hotData: HotData\n): { hot: Hot; hotState: HotState } {\n  const hotState: HotState = {\n    selfAccepted: false,\n    selfDeclined: false,\n    selfInvalidated: false,\n    disposeHandlers: [],\n  }\n\n  const hot: Hot = {\n    // TODO(alexkirsz) This is not defined in the HMR API. It was used to\n    // decide whether to warn whenever an HMR-disposed module required other\n    // modules. We might want to remove it.\n    active: true,\n\n    data: hotData ?? {},\n\n    // TODO(alexkirsz) Support full (dep, callback, errorHandler) form.\n    accept: (\n      modules?: string | string[] | AcceptErrorHandler,\n      _callback?: AcceptCallback,\n      _errorHandler?: AcceptErrorHandler\n    ) => {\n      if (modules === undefined) {\n        hotState.selfAccepted = true\n      } else if (typeof modules === 'function') {\n        hotState.selfAccepted = modules\n      } else {\n        throw new Error('unsupported `accept` signature')\n      }\n    },\n\n    decline: (dep) => {\n      if (dep === undefined) {\n        hotState.selfDeclined = true\n      } else {\n        throw new Error('unsupported `decline` signature')\n      }\n    },\n\n    dispose: (callback) => {\n      hotState.disposeHandlers.push(callback)\n    },\n\n    addDisposeHandler: (callback) => {\n      hotState.disposeHandlers.push(callback)\n    },\n\n    removeDisposeHandler: (callback) => {\n      const idx = hotState.disposeHandlers.indexOf(callback)\n      if (idx >= 0) {\n        hotState.disposeHandlers.splice(idx, 1)\n      }\n    },\n\n    invalidate: () => {\n      hotState.selfInvalidated = true\n      queuedInvalidatedModules.add(moduleId)\n    },\n\n    // NOTE(alexkirsz) This is part of the management API, which we don't\n    // implement, but the Next.js React Refresh runtime uses this to decide\n    // whether to schedule an update.\n    status: () => 'idle',\n\n    // NOTE(alexkirsz) Since we always return \"idle\" for now, these are no-ops.\n    addStatusHandler: (_handler) => {},\n    removeStatusHandler: (_handler) => {},\n\n    // NOTE(jridgewell) Check returns the list of updated modules, but we don't\n    // want the webpack code paths to ever update (the turbopack paths handle\n    // this already).\n    check: () => Promise.resolve(null),\n  }\n\n  return { hot, hotState }\n}\n\n/**\n * Removes a module from a chunk.\n * Returns `true` if there are no remaining chunks including this module.\n */\nfunction removeModuleFromChunk(\n  moduleId: ModuleId,\n  chunkPath: ChunkPath\n): boolean {\n  const moduleChunks = moduleChunksMap.get(moduleId)!\n  moduleChunks.delete(chunkPath)\n\n  const chunkModules = chunkModulesMap.get(chunkPath)!\n  chunkModules.delete(moduleId)\n\n  const noRemainingModules = chunkModules.size === 0\n  if (noRemainingModules) {\n    chunkModulesMap.delete(chunkPath)\n  }\n\n  const noRemainingChunks = moduleChunks.size === 0\n  if (noRemainingChunks) {\n    moduleChunksMap.delete(moduleId)\n  }\n\n  return noRemainingChunks\n}\n\n/**\n * Disposes of a chunk list and its corresponding exclusive chunks.\n */\nfunction disposeChunkList(chunkListPath: ChunkListPath): boolean {\n  const chunkPaths = chunkListChunksMap.get(chunkListPath)\n  if (chunkPaths == null) {\n    return false\n  }\n  chunkListChunksMap.delete(chunkListPath)\n\n  for (const chunkPath of chunkPaths) {\n    const chunkChunkLists = chunkChunkListsMap.get(chunkPath)!\n    chunkChunkLists.delete(chunkListPath)\n\n    if (chunkChunkLists.size === 0) {\n      chunkChunkListsMap.delete(chunkPath)\n      disposeChunk(chunkPath)\n    }\n  }\n\n  // We must also dispose of the chunk list's chunk itself to ensure it may\n  // be reloaded properly in the future.\n  const chunkListUrl = getChunkRelativeUrl(chunkListPath)\n\n  DEV_BACKEND.unloadChunk?.(chunkListUrl)\n\n  return true\n}\n\n/**\n * Disposes of a chunk and its corresponding exclusive modules.\n *\n * @returns Whether the chunk was disposed of.\n */\nfunction disposeChunk(chunkPath: ChunkPath): boolean {\n  const chunkUrl = getChunkRelativeUrl(chunkPath)\n  // This should happen whether the chunk has any modules in it or not.\n  // For instance, CSS chunks have no modules in them, but they still need to be unloaded.\n  DEV_BACKEND.unloadChunk?.(chunkUrl)\n\n  const chunkModules = chunkModulesMap.get(chunkPath)\n  if (chunkModules == null) {\n    return false\n  }\n  chunkModules.delete(chunkPath)\n\n  for (const moduleId of chunkModules) {\n    const moduleChunks = moduleChunksMap.get(moduleId)!\n    moduleChunks.delete(chunkPath)\n\n    const noRemainingChunks = moduleChunks.size === 0\n    if (noRemainingChunks) {\n      moduleChunksMap.delete(moduleId)\n      disposeModule(moduleId, 'clear')\n      availableModules.delete(moduleId)\n    }\n  }\n\n  return true\n}\n\n/**\n * Adds a module to a chunk.\n */\nfunction addModuleToChunk(moduleId: ModuleId, chunkPath: ChunkPath) {\n  let moduleChunks = moduleChunksMap.get(moduleId)\n  if (!moduleChunks) {\n    moduleChunks = new Set([chunkPath])\n    moduleChunksMap.set(moduleId, moduleChunks)\n  } else {\n    moduleChunks.add(chunkPath)\n  }\n\n  let chunkModules = chunkModulesMap.get(chunkPath)\n  if (!chunkModules) {\n    chunkModules = new Set([moduleId])\n    chunkModulesMap.set(chunkPath, chunkModules)\n  } else {\n    chunkModules.add(moduleId)\n  }\n}\n\n/**\n * Marks a chunk list as a runtime chunk list. There can be more than one\n * runtime chunk list. For instance, integration tests can have multiple chunk\n * groups loaded at runtime, each with its own chunk list.\n */\nfunction markChunkListAsRuntime(chunkListPath: ChunkListPath) {\n  runtimeChunkLists.add(chunkListPath)\n}\n\nfunction registerChunk(registration: ChunkRegistration) {\n  const chunk = getChunkFromRegistration(registration[0]) as\n    | ChunkPath\n    | ChunkScript\n  let runtimeParams: RuntimeParams | undefined\n  // When bootstrapping we are passed a single runtimeParams object so we can distinguish purely based on length\n  if (registration.length === 2) {\n    runtimeParams = registration[1] as RuntimeParams\n  } else {\n    let chunkPath = getPathFromScript(chunk)\n    runtimeParams = undefined\n    installCompressedModuleFactories(\n      registration as CompressedModuleFactories,\n      /* offset= */ 1,\n      moduleFactories,\n      (id: ModuleId) => addModuleToChunk(id, chunkPath)\n    )\n  }\n  return BACKEND.registerChunk(chunk, runtimeParams)\n}\n\n/**\n * Subscribes to chunk list updates from the update server and applies them.\n */\nfunction registerChunkList(chunkList: ChunkList) {\n  const chunkListScript = getChunkFromRegistration(chunkList.script) as\n    | ChunkListPath\n    | ChunkListScript\n  const chunkListPath = getPathFromScript(chunkListScript)\n  // The \"chunk\" is also registered to finish the loading in the backend\n  BACKEND.registerChunk(chunkListPath as string as ChunkPath)\n  globalThis.TURBOPACK_CHUNK_UPDATE_LISTENERS!.push([\n    chunkListPath,\n    handleApply.bind(null, chunkListPath),\n  ])\n\n  // Adding chunks to chunk lists and vice versa.\n  const chunkPaths = new Set(chunkList.chunks.map(getChunkPath))\n  chunkListChunksMap.set(chunkListPath, chunkPaths)\n  for (const chunkPath of chunkPaths) {\n    let chunkChunkLists = chunkChunkListsMap.get(chunkPath)\n    if (!chunkChunkLists) {\n      chunkChunkLists = new Set([chunkListPath])\n      chunkChunkListsMap.set(chunkPath, chunkChunkLists)\n    } else {\n      chunkChunkLists.add(chunkListPath)\n    }\n  }\n\n  if (chunkList.source === 'entry') {\n    markChunkListAsRuntime(chunkListPath)\n  }\n}\n\nglobalThis.TURBOPACK_CHUNK_UPDATE_LISTENERS ??= []\n"],"names":["devContextPrototype","Context","prototype","devModuleCache","Object","create","c","UpdateApplyError","Error","name","dependencyChain","message","runtimeModules","Set","moduleChunksMap","Map","chunkModulesMap","runtimeChunkLists","chunkListChunksMap","chunkChunkListsMap","moduleHotData","moduleHotState","queuedInvalidatedModules","getOrInstantiateRuntimeModule","chunkPath","moduleId","module","error","instantiateModule","SourceType","Runtime","getOrInstantiateModuleFromParent","id","sourceModule","hot","active","console","warn","children","indexOf","push","parents","Parent","DevContext","exports","refresh","call","k","sourceType","sourceData","moduleFactory","moduleFactories","get","factoryNotAvailableMessage","hotData","hotState","createModuleHot","add","Update","invariant","createModuleObject","set","runModuleExecutionHooks","context","namespaceObject","interopEsm","DUMMY_REFRESH_CONTEXT","register","_type","_id","signature","registerExports","_module","_helpers","executeModule","globalThis","$RefreshInterceptModuleExecution$","cleanupReactRefreshIntercept","$RefreshReg$","$RefreshSig$","registerExportsAndSetupBoundaryForReactRefresh","helpers","currentExports","prevExports","data","registerExportsForReactRefresh","isReactRefreshBoundary","dispose","accept","shouldInvalidateReactRefreshBoundary","getRefreshBoundarySignature","invalidate","scheduleUpdate","isNoLongerABoundary","formatDependencyChain","join","computeOutdatedModules","added","modified","newModuleFactories","entry","_eval","outdatedModules","computedInvalidatedModules","keys","invalidated","effect","getAffectedModuleEffects","type","outdatedModuleId","computeOutdatedSelfAcceptedModules","outdatedSelfAcceptedModules","selfAccepted","selfInvalidated","errorHandler","updateChunksPhase","chunksAddedModules","chunksDeletedModules","addedModuleIds","addModuleToChunk","disposedModules","removeModuleFromChunk","disposePhase","disposeModule","outdatedModuleParents","oldModule","mode","disposeHandler","disposeHandlers","delete","childId","child","idx","splice","applyPhase","reportError","factory","entries","applyModuleFactoryName","err","err2","applyUpdate","update","applyChunkListUpdate","merged","applyEcmascriptMergedUpdate","chunks","chunkUpdate","chunkUrl","getChunkRelativeUrl","BACKEND","loadChunkCached","DEV_BACKEND","reloadChunk","unloadChunk","instruction","JSON","stringify","chunksAdded","chunksDeleted","computeChangedModules","applyInternal","applyInvalidatedModules","size","forEach","clear","updates","deleted","mergedChunkUpdate","updateAdded","modules","updateDeleted","has","queue","nextItem","shift","undefined","selfDeclined","parentId","parent","handleApply","chunkListPath","restart","disposeChunkList","_callback","_errorHandler","decline","dep","callback","addDisposeHandler","removeDisposeHandler","status","addStatusHandler","_handler","removeStatusHandler","check","Promise","resolve","moduleChunks","chunkModules","noRemainingModules","noRemainingChunks","chunkPaths","chunkChunkLists","disposeChunk","chunkListUrl","availableModules","markChunkListAsRuntime","registerChunk","registration","chunk","getChunkFromRegistration","runtimeParams","length","getPathFromScript","installCompressedModuleFactories","registerChunkList","chunkList","chunkListScript","script","TURBOPACK_CHUNK_UPDATE_LISTENERS","bind","map","getChunkPath","source"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 1644, "column": 0}, "map": {"version":3,"sources":["turbopack:///[turbopack]/browser/runtime/dom/runtime-backend-dom.ts"],"sourcesContent":["/**\n * This file contains the runtime code specific to the Turbopack ECMAScript DOM runtime.\n *\n * It will be appended to the base runtime code.\n */\n\n/* eslint-disable @typescript-eslint/no-unused-vars */\n\n/// <reference path=\"../../../browser/runtime/base/runtime-base.ts\" />\n/// <reference path=\"../../../shared/runtime-types.d.ts\" />\n\nfunction getAssetSuffixFromScriptSrc() {\n  // TURBOPACK_ASSET_SUFFIX is set in web workers\n  return (\n    (self.TURBOPACK_ASSET_SUFFIX ??\n      document?.currentScript\n        ?.getAttribute?.('src')\n        ?.replace(/^(.*(?=\\?)|^.*$)/, '')) ||\n    ''\n  )\n}\n\ntype ChunkResolver = {\n  resolved: boolean\n  loadingStarted: boolean\n  resolve: () => void\n  reject: (error?: Error) => void\n  promise: Promise<any>\n}\n\nlet BACKEND: RuntimeBackend\n\n/**\n * Maps chunk paths to the corresponding resolver.\n */\nconst chunkResolvers: Map<ChunkUrl, ChunkResolver> = new Map()\n\n;(() => {\n  BACKEND = {\n    async registerChunk(chunk, params) {\n      let chunkPath = getPathFromScript(chunk)\n      let chunkUrl = getUrlFromScript(chunk)\n\n      const resolver = getOrCreateResolver(chunkUrl)\n      resolver.resolve()\n\n      if (params == null) {\n        return\n      }\n\n      for (const otherChunkData of params.otherChunks) {\n        const otherChunkPath = getChunkPath(otherChunkData)\n        const otherChunkUrl = getChunkRelativeUrl(otherChunkPath)\n\n        // Chunk might have started loading, so we want to avoid triggering another load.\n        getOrCreateResolver(otherChunkUrl)\n      }\n\n      // This waits for chunks to be loaded, but also marks included items as available.\n      await Promise.all(\n        params.otherChunks.map((otherChunkData) =>\n          loadInitialChunk(chunkPath, otherChunkData)\n        )\n      )\n\n      if (params.runtimeModuleIds.length > 0) {\n        for (const moduleId of params.runtimeModuleIds) {\n          getOrInstantiateRuntimeModule(chunkPath, moduleId)\n        }\n      }\n    },\n\n    /**\n     * Loads the given chunk, and returns a promise that resolves once the chunk\n     * has been loaded.\n     */\n    loadChunkCached(sourceType: SourceType, chunkUrl: ChunkUrl) {\n      return doLoadChunk(sourceType, chunkUrl)\n    },\n\n    async loadWebAssembly(\n      _sourceType: SourceType,\n      _sourceData: SourceData,\n      wasmChunkPath: ChunkPath,\n      _edgeModule: () => WebAssembly.Module,\n      importsObj: WebAssembly.Imports\n    ): Promise<Exports> {\n      const req = fetchWebAssembly(wasmChunkPath)\n\n      const { instance } = await WebAssembly.instantiateStreaming(\n        req,\n        importsObj\n      )\n\n      return instance.exports\n    },\n\n    async loadWebAssemblyModule(\n      _sourceType: SourceType,\n      _sourceData: SourceData,\n      wasmChunkPath: ChunkPath,\n      _edgeModule: () => WebAssembly.Module\n    ): Promise<WebAssembly.Module> {\n      const req = fetchWebAssembly(wasmChunkPath)\n\n      return await WebAssembly.compileStreaming(req)\n    },\n  }\n\n  function getOrCreateResolver(chunkUrl: ChunkUrl): ChunkResolver {\n    let resolver = chunkResolvers.get(chunkUrl)\n    if (!resolver) {\n      let resolve: () => void\n      let reject: (error?: Error) => void\n      const promise = new Promise<void>((innerResolve, innerReject) => {\n        resolve = innerResolve\n        reject = innerReject\n      })\n      resolver = {\n        resolved: false,\n        loadingStarted: false,\n        promise,\n        resolve: () => {\n          resolver!.resolved = true\n          resolve()\n        },\n        reject: reject!,\n      }\n      chunkResolvers.set(chunkUrl, resolver)\n    }\n    return resolver\n  }\n\n  /**\n   * Loads the given chunk, and returns a promise that resolves once the chunk\n   * has been loaded.\n   */\n  function doLoadChunk(sourceType: SourceType, chunkUrl: ChunkUrl) {\n    const resolver = getOrCreateResolver(chunkUrl)\n    if (resolver.loadingStarted) {\n      return resolver.promise\n    }\n\n    if (sourceType === SourceType.Runtime) {\n      // We don't need to load chunks references from runtime code, as they're already\n      // present in the DOM.\n      resolver.loadingStarted = true\n\n      if (isCss(chunkUrl)) {\n        // CSS chunks do not register themselves, and as such must be marked as\n        // loaded instantly.\n        resolver.resolve()\n      }\n\n      // We need to wait for JS chunks to register themselves within `registerChunk`\n      // before we can start instantiating runtime modules, hence the absence of\n      // `resolver.resolve()` in this branch.\n\n      return resolver.promise\n    }\n\n    if (typeof importScripts === 'function') {\n      // We're in a web worker\n      if (isCss(chunkUrl)) {\n        // ignore\n      } else if (isJs(chunkUrl)) {\n        self.TURBOPACK_NEXT_CHUNK_URLS!.push(chunkUrl)\n        importScripts(chunkUrl)\n      } else {\n        throw new Error(\n          `can't infer type of chunk from URL ${chunkUrl} in worker`\n        )\n      }\n    } else {\n      // TODO(PACK-2140): remove this once all filenames are guaranteed to be escaped.\n      const decodedChunkUrl = decodeURI(chunkUrl)\n\n      if (isCss(chunkUrl)) {\n        const previousLinks = document.querySelectorAll(\n          `link[rel=stylesheet][href=\"${chunkUrl}\"],link[rel=stylesheet][href^=\"${chunkUrl}?\"],link[rel=stylesheet][href=\"${decodedChunkUrl}\"],link[rel=stylesheet][href^=\"${decodedChunkUrl}?\"]`\n        )\n        if (previousLinks.length > 0) {\n          // CSS chunks do not register themselves, and as such must be marked as\n          // loaded instantly.\n          resolver.resolve()\n        } else {\n          const link = document.createElement('link')\n          link.rel = 'stylesheet'\n          link.href = chunkUrl\n          link.onerror = () => {\n            resolver.reject()\n          }\n          link.onload = () => {\n            // CSS chunks do not register themselves, and as such must be marked as\n            // loaded instantly.\n            resolver.resolve()\n          }\n          // Append to the `head` for webpack compatibility.\n          document.head.appendChild(link)\n        }\n      } else if (isJs(chunkUrl)) {\n        const previousScripts = document.querySelectorAll(\n          `script[src=\"${chunkUrl}\"],script[src^=\"${chunkUrl}?\"],script[src=\"${decodedChunkUrl}\"],script[src^=\"${decodedChunkUrl}?\"]`\n        )\n        if (previousScripts.length > 0) {\n          // There is this edge where the script already failed loading, but we\n          // can't detect that. The Promise will never resolve in this case.\n          for (const script of Array.from(previousScripts)) {\n            script.addEventListener('error', () => {\n              resolver.reject()\n            })\n          }\n        } else {\n          const script = document.createElement('script')\n          script.src = chunkUrl\n          // We'll only mark the chunk as loaded once the script has been executed,\n          // which happens in `registerChunk`. Hence the absence of `resolve()` in\n          // this branch.\n          script.onerror = () => {\n            resolver.reject()\n          }\n          // Append to the `head` for webpack compatibility.\n          document.head.appendChild(script)\n        }\n      } else {\n        throw new Error(`can't infer type of chunk from URL ${chunkUrl}`)\n      }\n    }\n\n    resolver.loadingStarted = true\n    return resolver.promise\n  }\n\n  function fetchWebAssembly(wasmChunkPath: ChunkPath) {\n    return fetch(getChunkRelativeUrl(wasmChunkPath))\n  }\n})()\n"],"names":["getAssetSuffixFromScriptSrc","self","TURBOPACK_ASSET_SUFFIX","document","currentScript","getAttribute","replace","BACKEND","chunkResolvers","Map","registerChunk","chunk","params","chunkPath","getPathFromScript","chunkUrl","getUrlFromScript","resolver","getOrCreateResolver","resolve","otherChunkData","otherChunks","otherChunkPath","getChunkPath","otherChunkUrl","getChunkRelativeUrl","Promise","all","map","loadInitialChunk","runtimeModuleIds","length","moduleId","getOrInstantiateRuntimeModule","loadChunkCached","sourceType","doLoadChunk","loadWebAssembly","_sourceType","_sourceData","wasmChunkPath","_edgeModule","importsObj","req","fetchWebAssembly","instance","WebAssembly","instantiateStreaming","exports","loadWebAssemblyModule","compileStreaming","get","reject","promise","innerResolve","innerReject","resolved","loadingStarted","set","SourceType","Runtime","isCss","importScripts","isJs","TURBOPACK_NEXT_CHUNK_URLS","push","Error","decodedChunkUrl","decodeURI","previousLinks","querySelectorAll","link","createElement","rel","href","onerror","onload","head","appendChild","previousScripts","script","Array","from","addEventListener","src","fetch"],"mappings":"AAAA;;;;CAIC,GAED,oDAAoD,GAEpD,sEAAsE;AACtE,2DAA2D;AAE3D,SAASA;IACP,+CAA+C;IAC/C,OACE,CAACC,KAAKC,sBAAsB,IAC1BC,UAAUC,eACNC,eAAe,QACfC,QAAQ,oBAAoB,GAAG,KACrC;AAEJ;AAUA,IAAIC;AAEJ;;CAEC,GACD,MAAMC,iBAA+C,IAAIC;AAExD,CAAC;IACAF,UAAU;QACR,MAAMG,eAAcC,KAAK,EAAEC,MAAM;YAC/B,IAAIC,YAAYC,kBAAkBH;YAClC,IAAII,WAAWC,iBAAiBL;YAEhC,MAAMM,WAAWC,oBAAoBH;YACrCE,SAASE,OAAO;YAEhB,IAAIP,UAAU,MAAM;gBAClB;YACF;YAEA,KAAK,MAAMQ,kBAAkBR,OAAOS,WAAW,CAAE;gBAC/C,MAAMC,iBAAiBC,aAAaH;gBACpC,MAAMI,gBAAgBC,oBAAoBH;gBAE1C,iFAAiF;gBACjFJ,oBAAoBM;YACtB;YAEA,kFAAkF;YAClF,MAAME,QAAQC,GAAG,CACff,OAAOS,WAAW,CAACO,GAAG,CAAC,CAACR,iBACtBS,iBAAiBhB,WAAWO;YAIhC,IAAIR,OAAOkB,gBAAgB,CAACC,MAAM,GAAG,GAAG;gBACtC,KAAK,MAAMC,YAAYpB,OAAOkB,gBAAgB,CAAE;oBAC9CG,8BAA8BpB,WAAWmB;gBAC3C;YACF;QACF;QAEA;;;KAGC,GACDE,iBAAgBC,UAAsB,EAAEpB,QAAkB;YACxD,OAAOqB,YAAYD,YAAYpB;QACjC;QAEA,MAAMsB,iBACJC,WAAuB,EACvBC,WAAuB,EACvBC,aAAwB,EACxBC,WAAqC,EACrCC,UAA+B;YAE/B,MAAMC,MAAMC,iBAAiBJ;YAE7B,MAAM,EAAEK,QAAQ,EAAE,GAAG,MAAMC,YAAYC,oBAAoB,CACzDJ,KACAD;YAGF,OAAOG,SAASG,OAAO;QACzB;QAEA,MAAMC,uBACJX,WAAuB,EACvBC,WAAuB,EACvBC,aAAwB,EACxBC,WAAqC;YAErC,MAAME,MAAMC,iBAAiBJ;YAE7B,OAAO,MAAMM,YAAYI,gBAAgB,CAACP;QAC5C;IACF;IAEA,SAASzB,oBAAoBH,QAAkB;QAC7C,IAAIE,WAAWT,eAAe2C,GAAG,CAACpC;QAClC,IAAI,CAACE,UAAU;YACb,IAAIE;YACJ,IAAIiC;YACJ,MAAMC,UAAU,IAAI3B,QAAc,CAAC4B,cAAcC;gBAC/CpC,UAAUmC;gBACVF,SAASG;YACX;YACAtC,WAAW;gBACTuC,UAAU;gBACVC,gBAAgB;gBAChBJ;gBACAlC,SAAS;oBACPF,SAAUuC,QAAQ,GAAG;oBACrBrC;gBACF;gBACAiC,QAAQA;YACV;YACA5C,eAAekD,GAAG,CAAC3C,UAAUE;QAC/B;QACA,OAAOA;IACT;IAEA;;;GAGC,GACD,SAASmB,YAAYD,UAAsB,EAAEpB,QAAkB;QAC7D,MAAME,WAAWC,oBAAoBH;QACrC,IAAIE,SAASwC,cAAc,EAAE;YAC3B,OAAOxC,SAASoC,OAAO;QACzB;QAEA,IAAIlB,eAAewB,WAAWC,OAAO,EAAE;YACrC,gFAAgF;YAChF,sBAAsB;YACtB3C,SAASwC,cAAc,GAAG;YAE1B,IAAII,MAAM9C,WAAW;gBACnB,uEAAuE;gBACvE,oBAAoB;gBACpBE,SAASE,OAAO;YAClB;YAEA,8EAA8E;YAC9E,0EAA0E;YAC1E,uCAAuC;YAEvC,OAAOF,SAASoC,OAAO;QACzB;QAEA,IAAI,OAAOS,kBAAkB,YAAY;YACvC,wBAAwB;YACxB,IAAID,MAAM9C,WAAW;YACnB,SAAS;YACX,OAAO,IAAIgD,KAAKhD,WAAW;gBACzBd,KAAK+D,yBAAyB,CAAEC,IAAI,CAAClD;gBACrC+C,cAAc/C;YAChB,OAAO;gBACL,MAAM,IAAImD,MACR,CAAC,mCAAmC,EAAEnD,SAAS,UAAU,CAAC;YAE9D;QACF,OAAO;YACL,gFAAgF;YAChF,MAAMoD,kBAAkBC,UAAUrD;YAElC,IAAI8C,MAAM9C,WAAW;gBACnB,MAAMsD,gBAAgBlE,SAASmE,gBAAgB,CAC7C,CAAC,2BAA2B,EAAEvD,SAAS,+BAA+B,EAAEA,SAAS,+BAA+B,EAAEoD,gBAAgB,+BAA+B,EAAEA,gBAAgB,GAAG,CAAC;gBAEzL,IAAIE,cAActC,MAAM,GAAG,GAAG;oBAC5B,uEAAuE;oBACvE,oBAAoB;oBACpBd,SAASE,OAAO;gBAClB,OAAO;oBACL,MAAMoD,OAAOpE,SAASqE,aAAa,CAAC;oBACpCD,KAAKE,GAAG,GAAG;oBACXF,KAAKG,IAAI,GAAG3D;oBACZwD,KAAKI,OAAO,GAAG;wBACb1D,SAASmC,MAAM;oBACjB;oBACAmB,KAAKK,MAAM,GAAG;wBACZ,uEAAuE;wBACvE,oBAAoB;wBACpB3D,SAASE,OAAO;oBAClB;oBACA,kDAAkD;oBAClDhB,SAAS0E,IAAI,CAACC,WAAW,CAACP;gBAC5B;YACF,OAAO,IAAIR,KAAKhD,WAAW;gBACzB,MAAMgE,kBAAkB5E,SAASmE,gBAAgB,CAC/C,CAAC,YAAY,EAAEvD,SAAS,gBAAgB,EAAEA,SAAS,gBAAgB,EAAEoD,gBAAgB,gBAAgB,EAAEA,gBAAgB,GAAG,CAAC;gBAE7H,IAAIY,gBAAgBhD,MAAM,GAAG,GAAG;oBAC9B,qEAAqE;oBACrE,kEAAkE;oBAClE,KAAK,MAAMiD,UAAUC,MAAMC,IAAI,CAACH,iBAAkB;wBAChDC,OAAOG,gBAAgB,CAAC,SAAS;4BAC/BlE,SAASmC,MAAM;wBACjB;oBACF;gBACF,OAAO;oBACL,MAAM4B,SAAS7E,SAASqE,aAAa,CAAC;oBACtCQ,OAAOI,GAAG,GAAGrE;oBACb,yEAAyE;oBACzE,wEAAwE;oBACxE,eAAe;oBACfiE,OAAOL,OAAO,GAAG;wBACf1D,SAASmC,MAAM;oBACjB;oBACA,kDAAkD;oBAClDjD,SAAS0E,IAAI,CAACC,WAAW,CAACE;gBAC5B;YACF,OAAO;gBACL,MAAM,IAAId,MAAM,CAAC,mCAAmC,EAAEnD,UAAU;YAClE;QACF;QAEAE,SAASwC,cAAc,GAAG;QAC1B,OAAOxC,SAASoC,OAAO;IACzB;IAEA,SAAST,iBAAiBJ,aAAwB;QAChD,OAAO6C,MAAM5D,oBAAoBe;IACnC;AACF,CAAC","ignoreList":[0]}},
    {"offset": {"line": 1810, "column": 0}, "map": {"version":3,"sources":["turbopack:///[turbopack]/browser/runtime/dom/dev-backend-dom.ts"],"sourcesContent":["/**\n * This file contains the runtime code specific to the Turbopack development\n * ECMAScript DOM runtime.\n *\n * It will be appended to the base development runtime code.\n */\n\n/* eslint-disable @typescript-eslint/no-unused-vars */\n\n/// <reference path=\"../base/runtime-base.ts\" />\n/// <reference path=\"../base/dev-base.ts\" />\n/// <reference path=\"./runtime-backend-dom.ts\" />\n/// <reference path=\"../../../shared/require-type.d.ts\" />\n\nlet DEV_BACKEND: DevRuntimeBackend\n;(() => {\n  DEV_BACKEND = {\n    unloadChunk(chunkUrl) {\n      deleteResolver(chunkUrl)\n\n      // TODO(PACK-2140): remove this once all filenames are guaranteed to be escaped.\n      const decodedChunkUrl = decodeURI(chunkUrl)\n\n      if (isCss(chunkUrl)) {\n        const links = document.querySelectorAll(\n          `link[href=\"${chunkUrl}\"],link[href^=\"${chunkUrl}?\"],link[href=\"${decodedChunkUrl}\"],link[href^=\"${decodedChunkUrl}?\"]`\n        )\n        for (const link of Array.from(links)) {\n          link.remove()\n        }\n      } else if (isJs(chunkUrl)) {\n        // Unloading a JS chunk would have no effect, as it lives in the JS\n        // runtime once evaluated.\n        // However, we still want to remove the script tag from the DOM to keep\n        // the HTML somewhat consistent from the user's perspective.\n        const scripts = document.querySelectorAll(\n          `script[src=\"${chunkUrl}\"],script[src^=\"${chunkUrl}?\"],script[src=\"${decodedChunkUrl}\"],script[src^=\"${decodedChunkUrl}?\"]`\n        )\n        for (const script of Array.from(scripts)) {\n          script.remove()\n        }\n      } else {\n        throw new Error(`can't infer type of chunk from URL ${chunkUrl}`)\n      }\n    },\n\n    reloadChunk(chunkUrl) {\n      return new Promise<void>((resolve, reject) => {\n        if (!isCss(chunkUrl)) {\n          reject(new Error('The DOM backend can only reload CSS chunks'))\n          return\n        }\n\n        const decodedChunkUrl = decodeURI(chunkUrl)\n        const previousLinks = document.querySelectorAll(\n          `link[rel=stylesheet][href=\"${chunkUrl}\"],link[rel=stylesheet][href^=\"${chunkUrl}?\"],link[rel=stylesheet][href=\"${decodedChunkUrl}\"],link[rel=stylesheet][href^=\"${decodedChunkUrl}?\"]`\n        )\n\n        if (previousLinks.length === 0) {\n          reject(new Error(`No link element found for chunk ${chunkUrl}`))\n          return\n        }\n\n        const link = document.createElement('link')\n        link.rel = 'stylesheet'\n\n        if (navigator.userAgent.includes('Firefox')) {\n          // Firefox won't reload CSS files that were previously loaded on the current page,\n          // we need to add a query param to make sure CSS is actually reloaded from the server.\n          //\n          // I believe this is this issue: https://bugzilla.mozilla.org/show_bug.cgi?id=1037506\n          //\n          // Safari has a similar issue, but only if you have a `<link rel=preload ... />` tag\n          // pointing to the same URL as the stylesheet: https://bugs.webkit.org/show_bug.cgi?id=187726\n          link.href = `${chunkUrl}?ts=${Date.now()}`\n        } else {\n          link.href = chunkUrl\n        }\n\n        link.onerror = () => {\n          reject()\n        }\n        link.onload = () => {\n          // First load the new CSS, then remove the old ones. This prevents visible\n          // flickering that would happen in-between removing the previous CSS and\n          // loading the new one.\n          for (const previousLink of Array.from(previousLinks))\n            previousLink.remove()\n\n          // CSS chunks do not register themselves, and as such must be marked as\n          // loaded instantly.\n          resolve()\n        }\n\n        // Make sure to insert the new CSS right after the previous one, so that\n        // its precedence is higher.\n        previousLinks[0].parentElement!.insertBefore(\n          link,\n          previousLinks[0].nextSibling\n        )\n      })\n    },\n\n    restart: () => self.location.reload(),\n  }\n\n  function deleteResolver(chunkUrl: ChunkUrl) {\n    chunkResolvers.delete(chunkUrl)\n  }\n})()\n\nfunction _eval({ code, url, map }: EcmascriptModuleEntry): ModuleFactory {\n  code += `\\n\\n//# sourceURL=${encodeURI(\n    location.origin + CHUNK_BASE_PATH + url + ASSET_SUFFIX\n  )}`\n  if (map) {\n    code += `\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,${btoa(\n      // btoa doesn't handle nonlatin characters, so escape them as \\x sequences\n      // See https://stackoverflow.com/a/26603875\n      unescape(encodeURIComponent(map))\n    )}`\n  }\n\n  // eslint-disable-next-line no-eval\n  return eval(code)\n}\n"],"names":["DEV_BACKEND","unloadChunk","chunkUrl","deleteResolver","decodedChunkUrl","decodeURI","isCss","links","document","querySelectorAll","link","Array","from","remove","isJs","scripts","script","Error","reloadChunk","Promise","resolve","reject","previousLinks","length","createElement","rel","navigator","userAgent","includes","href","Date","now","onerror","onload","previousLink","parentElement","insertBefore","nextSibling","restart","self","location","reload","chunkResolvers","delete","_eval","code","url","map","encodeURI","origin","CHUNK_BASE_PATH","ASSET_SUFFIX","btoa","unescape","encodeURIComponent","eval"],"mappings":"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","ignoreList":[0]}}]
}