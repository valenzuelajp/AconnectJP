{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///D:/AconnectJP/node_modules/next/src/client/register-deployment-id-global.ts"],"sourcesContent":["import { getDeploymentId } from '../shared/lib/deployment-id'\n\nconst deploymentId = getDeploymentId()\n;(globalThis as any).NEXT_DEPLOYMENT_ID = deploymentId\n"],"names":["deploymentId","getDeploymentId","globalThis","NEXT_DEPLOYMENT_ID"],"mappings":";;;8BAAgC;AAEhC,MAAMA,eAAeC,CAAAA,GAAAA,cAAAA,eAAe;AAClCC,WAAmBC,kBAAkB,GAAGH","ignoreList":[0]}},
    {"offset": {"line": 21, "column": 0}, "map": {"version":3,"sources":["file:///D:/AconnectJP/node_modules/next/src/client/asset-prefix.ts"],"sourcesContent":["import { InvariantError } from '../shared/lib/invariant-error'\n\nexport function getAssetPrefix() {\n  const currentScript = document.currentScript\n\n  if (!(currentScript instanceof HTMLScriptElement)) {\n    throw new InvariantError(\n      `Expected document.currentScript to be a <script> element. Received ${currentScript} instead.`\n    )\n  }\n\n  const { pathname } = new URL(currentScript.src)\n  const nextIndex = pathname.indexOf('/_next/')\n\n  if (nextIndex === -1) {\n    throw new InvariantError(\n      `Expected document.currentScript src to contain '/_next/'. Received ${currentScript.src} instead.`\n    )\n  }\n\n  return pathname.slice(0, nextIndex)\n}\n"],"names":["getAssetPrefix","currentScript","document","HTMLScriptElement","InvariantError","pathname","URL","src","nextIndex","indexOf","slice"],"mappings":";;;+BAEgBA,kBAAAA;;;eAAAA;;;gCAFe;AAExB,SAASA;IACd,MAAMC,gBAAgBC,SAASD,aAAa;IAE5C,IAAI,CAAEA,CAAAA,yBAAyBE,iBAAgB,GAAI;QACjD,MAAM,OAAA,cAEL,CAFK,IAAIC,gBAAAA,cAAc,CACtB,CAAC,mEAAmE,EAAEH,cAAc,SAAS,CAAC,GAD1F,qBAAA;mBAAA;wBAAA;0BAAA;QAEN;IACF;IAEA,MAAM,EAAEI,QAAQ,EAAE,GAAG,IAAIC,IAAIL,cAAcM,GAAG;IAC9C,MAAMC,YAAYH,SAASI,OAAO,CAAC;IAEnC,IAAID,cAAc,CAAC,GAAG;QACpB,MAAM,OAAA,cAEL,CAFK,IAAIJ,gBAAAA,cAAc,CACtB,CAAC,mEAAmE,EAAEH,cAAcM,GAAG,CAAC,SAAS,CAAC,GAD9F,qBAAA;mBAAA;wBAAA;0BAAA;QAEN;IACF;IAEA,OAAOF,SAASK,KAAK,CAAC,GAAGF;AAC3B","ignoreList":[0]}},
    {"offset": {"line": 62, "column": 0}, "map": {"version":3,"sources":["file:///D:/AconnectJP/node_modules/next/src/client/set-attributes-from-props.ts"],"sourcesContent":["const DOMAttributeNames: Record<string, string> = {\n  acceptCharset: 'accept-charset',\n  className: 'class',\n  htmlFor: 'for',\n  httpEquiv: 'http-equiv',\n  noModule: 'noModule',\n}\n\nconst ignoreProps = [\n  'onLoad',\n  'onReady',\n  'dangerouslySetInnerHTML',\n  'children',\n  'onError',\n  'strategy',\n  'stylesheets',\n]\n\nfunction isBooleanScriptAttribute(\n  attr: string\n): attr is 'async' | 'defer' | 'noModule' {\n  return ['async', 'defer', 'noModule'].includes(attr)\n}\n\nexport function setAttributesFromProps(el: HTMLElement, props: object) {\n  for (const [p, value] of Object.entries(props)) {\n    if (!props.hasOwnProperty(p)) continue\n    if (ignoreProps.includes(p)) continue\n\n    // we don't render undefined props to the DOM\n    if (value === undefined) {\n      continue\n    }\n\n    const attr = DOMAttributeNames[p] || p.toLowerCase()\n\n    if (el.tagName === 'SCRIPT' && isBooleanScriptAttribute(attr)) {\n      // Correctly assign boolean script attributes\n      // https://github.com/vercel/next.js/pull/20748\n      ;(el as HTMLScriptElement)[attr] = !!value\n    } else {\n      el.setAttribute(attr, String(value))\n    }\n\n    // Remove falsy non-zero boolean attributes so they are correctly interpreted\n    // (e.g. if we set them to false, this coerces to the string \"false\", which the browser interprets as true)\n    if (\n      value === false ||\n      (el.tagName === 'SCRIPT' &&\n        isBooleanScriptAttribute(attr) &&\n        (!value || value === 'false'))\n    ) {\n      // Call setAttribute before, as we need to set and unset the attribute to override force async:\n      // https://html.spec.whatwg.org/multipage/scripting.html#script-force-async\n      el.setAttribute(attr, '')\n      el.removeAttribute(attr)\n    }\n  }\n}\n"],"names":["setAttributesFromProps","DOMAttributeNames","acceptCharset","className","htmlFor","httpEquiv","noModule","ignoreProps","isBooleanScriptAttribute","attr","includes","el","props","p","value","Object","entries","hasOwnProperty","undefined","toLowerCase","tagName","setAttribute","String","removeAttribute"],"mappings":";;;+BAwBgBA,0BAAAA;;;eAAAA;;;AAxBhB,MAAMC,oBAA4C;IAChDC,eAAe;IACfC,WAAW;IACXC,SAAS;IACTC,WAAW;IACXC,UAAU;AACZ;AAEA,MAAMC,cAAc;IAClB;IACA;IACA;IACA;IACA;IACA;IACA;CACD;AAED,SAASC,yBACPC,IAAY;IAEZ,OAAO;QAAC;QAAS;QAAS;KAAW,CAACC,QAAQ,CAACD;AACjD;AAEO,SAAST,uBAAuBW,EAAe,EAAEC,KAAa;IACnE,KAAK,MAAM,CAACC,GAAGC,MAAM,IAAIC,OAAOC,OAAO,CAACJ,OAAQ;QAC9C,IAAI,CAACA,MAAMK,cAAc,CAACJ,IAAI;QAC9B,IAAIN,YAAYG,QAAQ,CAACG,IAAI;QAE7B,6CAA6C;QAC7C,IAAIC,UAAUI,WAAW;YACvB;QACF;QAEA,MAAMT,OAAOR,iBAAiB,CAACY,EAAE,IAAIA,EAAEM,WAAW;QAElD,IAAIR,GAAGS,OAAO,KAAK,YAAYZ,yBAAyBC,OAAO;YAC7D,6CAA6C;YAC7C,+CAA+C;;YAC7CE,EAAwB,CAACF,KAAK,GAAG,CAAC,CAACK;QACvC,OAAO;YACLH,GAAGU,YAAY,CAACZ,MAAMa,OAAOR;QAC/B;QAEA,6EAA6E;QAC7E,2GAA2G;QAC3G,IACEA,UAAU,SACTH,GAAGS,OAAO,KAAK,YACdZ,yBAAyBC,SACxB,CAAA,CAACK,SAASA,UAAU,OAAM,GAC7B;YACA,+FAA+F;YAC/F,2EAA2E;YAC3EH,GAAGU,YAAY,CAACZ,MAAM;YACtBE,GAAGY,eAAe,CAACd;QACrB;IACF;AACF","ignoreList":[0]}},
    {"offset": {"line": 132, "column": 0}, "map": {"version":3,"sources":["file:///D:/AconnectJP/node_modules/next/src/client/app-bootstrap.ts"],"sourcesContent":["/**\n * Before starting the Next.js runtime and requiring any module, we need to make\n * sure the following scripts are executed in the correct order:\n * - Polyfills\n * - next/script with `beforeInteractive` strategy\n */\n\nimport { getAssetPrefix } from './asset-prefix'\nimport { setAttributesFromProps } from './set-attributes-from-props'\n\nconst version = process.env.__NEXT_VERSION\n\nwindow.next = {\n  version,\n  appDir: true,\n}\n\nfunction loadScriptsInSequence(\n  scripts: [src: string, props: { [prop: string]: any }][],\n  hydrate: () => void\n) {\n  if (!scripts || !scripts.length) {\n    return hydrate()\n  }\n\n  return scripts\n    .reduce((promise, [src, props]) => {\n      return promise.then(() => {\n        return new Promise<void>((resolve, reject) => {\n          const el = document.createElement('script')\n\n          if (props) {\n            setAttributesFromProps(el, props)\n          }\n\n          if (src) {\n            el.src = src\n            el.onload = () => resolve()\n            el.onerror = reject\n          } else if (props) {\n            el.innerHTML = props.children\n            setTimeout(resolve)\n          }\n\n          document.head.appendChild(el)\n        })\n      })\n    }, Promise.resolve())\n    .catch((err: Error) => {\n      console.error(err)\n      // Still try to hydrate even if there's an error.\n    })\n    .then(() => {\n      hydrate()\n    })\n}\n\nexport function appBootstrap(hydrate: (assetPrefix: string) => void) {\n  const assetPrefix = getAssetPrefix()\n\n  loadScriptsInSequence((self as any).__next_s, () => {\n    // If the static shell is being debugged, skip hydration if the\n    // `__nextppronly` query is present. This is only enabled when the\n    // environment variable `__NEXT_EXPERIMENTAL_STATIC_SHELL_DEBUGGING` is\n    // set to `1`. Otherwise the following is optimized out.\n    if (process.env.__NEXT_EXPERIMENTAL_STATIC_SHELL_DEBUGGING === '1') {\n      const search = new URLSearchParams(window.location.search)\n      if (\n        search.get('__nextppronly') === 'fallback' ||\n        search.get('__nextppronly') === '1'\n      ) {\n        console.warn(\n          `Skipping hydration due to __nextppronly=${search.get('__nextppronly')}`\n        )\n        return\n      }\n    }\n\n    hydrate(assetPrefix)\n  })\n}\n"],"names":["appBootstrap","version","process","env","__NEXT_VERSION","window","next","appDir","loadScriptsInSequence","scripts","hydrate","length","reduce","promise","src","props","then","Promise","resolve","reject","el","document","createElement","setAttributesFromProps","onload","onerror","innerHTML","children","setTimeout","head","appendChild","catch","err","console","error","assetPrefix","getAssetPrefix","self","__next_s","__NEXT_EXPERIMENTAL_STATIC_SHELL_DEBUGGING","search","URLSearchParams","location","get","warn"],"mappings":"AAiEQE,QAAQC,GAAG,CAACoC,0CAA0C,KAAK,KAAK;AAjExE;;;;;CAKC,GAAA;;;;+BAoDevC,gBAAAA;;;eAAAA;;;6BAlDe;wCACQ;AAEvC,MAAMC,UAAUC,QAAQC,GAAG,CAACC,cAAc;AAE1CC,OAAOC,IAAI,GAAG;IACZL;IACAM,QAAQ;AACV;AAEA,SAASC,sBACPC,OAAwD,EACxDC,OAAmB;IAEnB,IAAI,CAACD,WAAW,CAACA,QAAQE,MAAM,EAAE;QAC/B,OAAOD;IACT;IAEA,OAAOD,QACJG,MAAM,CAAC,CAACC,SAAS,CAACC,KAAKC,MAAM;QAC5B,OAAOF,QAAQG,IAAI,CAAC;YAClB,OAAO,IAAIC,QAAc,CAACC,SAASC;gBACjC,MAAMC,KAAKC,SAASC,aAAa,CAAC;gBAElC,IAAIP,OAAO;oBACTQ,CAAAA,GAAAA,wBAAAA,sBAAsB,EAACH,IAAIL;gBAC7B;gBAEA,IAAID,KAAK;oBACPM,GAAGN,GAAG,GAAGA;oBACTM,GAAGI,MAAM,GAAG,IAAMN;oBAClBE,GAAGK,OAAO,GAAGN;gBACf,OAAO,IAAIJ,OAAO;oBAChBK,GAAGM,SAAS,GAAGX,MAAMY,QAAQ;oBAC7BC,WAAWV;gBACb;gBAEAG,SAASQ,IAAI,CAACC,WAAW,CAACV;YAC5B;QACF;IACF,GAAGH,QAAQC,OAAO,IACjBa,KAAK,CAAC,CAACC;QACNC,QAAQC,KAAK,CAACF;IACd,iDAAiD;IACnD,GACChB,IAAI,CAAC;QACJN;IACF;AACJ;AAEO,SAASV,aAAaU,OAAsC;IACjE,MAAMyB,cAAcC,CAAAA,GAAAA,aAAAA,cAAc;IAElC5B,sBAAuB6B,KAAaC,QAAQ,EAAE;QAC5C,+DAA+D;QAC/D,kEAAkE;QAClE,uEAAuE;QACvE,wDAAwD;QACxD;;QAaA5B,QAAQyB;IACV;AACF","ignoreList":[0]}},
    {"offset": {"line": 207, "column": 0}, "map": {"version":3,"sources":["file:///D:/AconnectJP/node_modules/next/src/client/react-client-callbacks/report-global-error.ts"],"sourcesContent":["export const reportGlobalError =\n  typeof reportError === 'function'\n    ? // In modern browsers, reportError will dispatch an error event,\n      // emulating an uncaught JavaScript error.\n      reportError\n    : (error: unknown) => {\n        // TODO: Dispatch error event\n        globalThis.console.error(error)\n      }\n"],"names":["reportGlobalError","reportError","error","globalThis","console"],"mappings":";;;+BAAaA,qBAAAA;;;eAAAA;;;AAAN,MAAMA,oBACX,OAAOC,gBAAgB,aAEnB,AACAA,cACA,CAACC,2BAFyC;IAGxC,6BAA6B;IAC7BC,WAAWC,OAAO,CAACF,KAAK,CAACA;AAC3B","ignoreList":[0]}},
    {"offset": {"line": 231, "column": 0}, "map": {"version":3,"sources":["file:///D:/AconnectJP/node_modules/next/src/client/react-client-callbacks/on-recoverable-error.ts"],"sourcesContent":["// This module can be shared between both pages router and app router\n\nimport type { HydrationOptions } from 'react-dom/client'\nimport { isBailoutToCSRError } from '../../shared/lib/lazy-dynamic/bailout-to-csr'\nimport isError from '../../lib/is-error'\nimport { reportGlobalError } from './report-global-error'\n\nconst recoverableErrors = new WeakSet<Error>()\n\nexport function isRecoverableError(error: Error): boolean {\n  return recoverableErrors.has(error)\n}\n\nexport const onRecoverableError: HydrationOptions['onRecoverableError'] = (\n  error\n) => {\n  // x-ref: https://github.com/facebook/react/pull/28736\n  let cause = isError(error) && 'cause' in error ? error.cause : error\n  // Skip certain custom errors which are not expected to be reported on client\n  if (isBailoutToCSRError(cause)) return\n\n  if (process.env.NODE_ENV !== 'production') {\n    const { decorateDevError } =\n      require('../../next-devtools/userspace/app/errors/stitched-error') as typeof import('../../next-devtools/userspace/app/errors/stitched-error')\n    const causeError = decorateDevError(cause)\n    recoverableErrors.add(causeError)\n    cause = causeError\n  }\n\n  reportGlobalError(cause)\n}\n"],"names":["isRecoverableError","onRecoverableError","recoverableErrors","WeakSet","error","has","cause","isError","isBailoutToCSRError","process","env","NODE_ENV","decorateDevError","require","causeError","add","reportGlobalError"],"mappings":"AAqBMS,QAAQC,GAAG,CAACC,QAAQ,KAAK;AArB/B,qEAAqE;;;;;;;;;;;;;;;;IASrDX,kBAAkB,EAAA;eAAlBA;;IAIHC,kBAAkB,EAAA;eAAlBA;;;;8BAVuB;kEAChB;mCACc;AAElC,MAAMC,oBAAoB,IAAIC;AAEvB,SAASH,mBAAmBI,KAAY;IAC7C,OAAOF,kBAAkBG,GAAG,CAACD;AAC/B;AAEO,MAAMH,qBAA6D,CACxEG;IAEA,sDAAsD;IACtD,IAAIE,QAAQC,CAAAA,GAAAA,SAAAA,OAAO,EAACH,UAAU,WAAWA,QAAQA,MAAME,KAAK,GAAGF;IAC/D,6EAA6E;IAC7E,IAAII,CAAAA,GAAAA,cAAAA,mBAAmB,EAACF,QAAQ;IAEhC,wCAA2C;QACzC,MAAM,EAAEM,gBAAgB,EAAE,GACxBC,QAAQ;QACV,MAAMC,aAAaF,iBAAiBN;QACpCJ,kBAAkBa,GAAG,CAACD;QACtBR,QAAQQ;IACV;IAEAE,CAAAA,GAAAA,mBAAAA,iBAAiB,EAACV;AACpB","ignoreList":[0]}},
    {"offset": {"line": 287, "column": 0}, "map": {"version":3,"sources":["file:///D:/AconnectJP/node_modules/next/src/client/components/http-access-fallback/http-access-fallback.ts"],"sourcesContent":["export const HTTPAccessErrorStatus = {\n  NOT_FOUND: 404,\n  FORBIDDEN: 403,\n  UNAUTHORIZED: 401,\n}\n\nconst ALLOWED_CODES = new Set(Object.values(HTTPAccessErrorStatus))\n\nexport const HTTP_ERROR_FALLBACK_ERROR_CODE = 'NEXT_HTTP_ERROR_FALLBACK'\n\nexport type HTTPAccessFallbackError = Error & {\n  digest: `${typeof HTTP_ERROR_FALLBACK_ERROR_CODE};${string}`\n}\n\n/**\n * Checks an error to determine if it's an error generated by\n * the HTTP navigation APIs `notFound()`, `forbidden()` or `unauthorized()`.\n *\n * @param error the error that may reference a HTTP access error\n * @returns true if the error is a HTTP access error\n */\nexport function isHTTPAccessFallbackError(\n  error: unknown\n): error is HTTPAccessFallbackError {\n  if (\n    typeof error !== 'object' ||\n    error === null ||\n    !('digest' in error) ||\n    typeof error.digest !== 'string'\n  ) {\n    return false\n  }\n  const [prefix, httpStatus] = error.digest.split(';')\n\n  return (\n    prefix === HTTP_ERROR_FALLBACK_ERROR_CODE &&\n    ALLOWED_CODES.has(Number(httpStatus))\n  )\n}\n\nexport function getAccessFallbackHTTPStatus(\n  error: HTTPAccessFallbackError\n): number {\n  const httpStatus = error.digest.split(';')[1]\n  return Number(httpStatus)\n}\n\nexport function getAccessFallbackErrorTypeByStatus(\n  status: number\n): 'not-found' | 'forbidden' | 'unauthorized' | undefined {\n  switch (status) {\n    case 401:\n      return 'unauthorized'\n    case 403:\n      return 'forbidden'\n    case 404:\n      return 'not-found'\n    default:\n      return\n  }\n}\n"],"names":["HTTPAccessErrorStatus","HTTP_ERROR_FALLBACK_ERROR_CODE","getAccessFallbackErrorTypeByStatus","getAccessFallbackHTTPStatus","isHTTPAccessFallbackError","NOT_FOUND","FORBIDDEN","UNAUTHORIZED","ALLOWED_CODES","Set","Object","values","error","digest","prefix","httpStatus","split","has","Number","status"],"mappings":";;;;;;;;;;;;;;;;;IAAaA,qBAAqB,EAAA;eAArBA;;IAQAC,8BAA8B,EAAA;eAA9BA;;IAuCGC,kCAAkC,EAAA;eAAlCA;;IAPAC,2BAA2B,EAAA;eAA3BA;;IAnBAC,yBAAyB,EAAA;eAAzBA;;;AArBT,MAAMJ,wBAAwB;IACnCK,WAAW;IACXC,WAAW;IACXC,cAAc;AAChB;AAEA,MAAMC,gBAAgB,IAAIC,IAAIC,OAAOC,MAAM,CAACX;AAErC,MAAMC,iCAAiC;AAavC,SAASG,0BACdQ,KAAc;IAEd,IACE,OAAOA,UAAU,YACjBA,UAAU,QACV,CAAE,CAAA,YAAYA,KAAI,KAClB,OAAOA,MAAMC,MAAM,KAAK,UACxB;QACA,OAAO;IACT;IACA,MAAM,CAACC,QAAQC,WAAW,GAAGH,MAAMC,MAAM,CAACG,KAAK,CAAC;IAEhD,OACEF,WAAWb,kCACXO,cAAcS,GAAG,CAACC,OAAOH;AAE7B;AAEO,SAASZ,4BACdS,KAA8B;IAE9B,MAAMG,aAAaH,MAAMC,MAAM,CAACG,KAAK,CAAC,IAAI,CAAC,EAAE;IAC7C,OAAOE,OAAOH;AAChB;AAEO,SAASb,mCACdiB,MAAc;IAEd,OAAQA;QACN,KAAK;YACH,OAAO;QACT,KAAK;YACH,OAAO;QACT,KAAK;YACH,OAAO;QACT;YACE;IACJ;AACF","ignoreList":[0]}},
    {"offset": {"line": 361, "column": 0}, "map": {"version":3,"sources":["file:///D:/AconnectJP/node_modules/next/src/client/components/redirect-status-code.ts"],"sourcesContent":["export enum RedirectStatusCode {\n  SeeOther = 303,\n  TemporaryRedirect = 307,\n  PermanentRedirect = 308,\n}\n"],"names":["RedirectStatusCode"],"mappings":";;;+BAAYA,sBAAAA;;;eAAAA;;;AAAL,IAAKA,qBAAAA,WAAAA,GAAAA,SAAAA,kBAAAA;;;;WAAAA","ignoreList":[0]}},
    {"offset": {"line": 387, "column": 0}, "map": {"version":3,"sources":["file:///D:/AconnectJP/node_modules/next/src/client/components/redirect-error.ts"],"sourcesContent":["import { RedirectStatusCode } from './redirect-status-code'\n\nexport const REDIRECT_ERROR_CODE = 'NEXT_REDIRECT'\n\nexport type RedirectType = 'push' | 'replace'\n\nexport type RedirectError = Error & {\n  digest: `${typeof REDIRECT_ERROR_CODE};${RedirectType};${string};${RedirectStatusCode};`\n}\n\n/**\n * Checks an error to determine if it's an error generated by the\n * `redirect(url)` helper.\n *\n * @param error the error that may reference a redirect error\n * @returns true if the error is a redirect error\n */\nexport function isRedirectError(error: unknown): error is RedirectError {\n  if (\n    typeof error !== 'object' ||\n    error === null ||\n    !('digest' in error) ||\n    typeof error.digest !== 'string'\n  ) {\n    return false\n  }\n\n  const digest = error.digest.split(';')\n  const [errorCode, type] = digest\n  const destination = digest.slice(2, -2).join(';')\n  const status = digest.at(-2)\n\n  const statusCode = Number(status)\n\n  return (\n    errorCode === REDIRECT_ERROR_CODE &&\n    (type === 'replace' || type === 'push') &&\n    typeof destination === 'string' &&\n    !isNaN(statusCode) &&\n    statusCode in RedirectStatusCode\n  )\n}\n"],"names":["REDIRECT_ERROR_CODE","isRedirectError","error","digest","split","errorCode","type","destination","slice","join","status","at","statusCode","Number","isNaN","RedirectStatusCode"],"mappings":";;;;;;;;;;;;;;IAEaA,mBAAmB,EAAA;eAAnBA;;IAeGC,eAAe,EAAA;eAAfA;;;oCAjBmB;AAE5B,MAAMD,sBAAsB;AAe5B,SAASC,gBAAgBC,KAAc;IAC5C,IACE,OAAOA,UAAU,YACjBA,UAAU,QACV,CAAE,CAAA,YAAYA,KAAI,KAClB,OAAOA,MAAMC,MAAM,KAAK,UACxB;QACA,OAAO;IACT;IAEA,MAAMA,SAASD,MAAMC,MAAM,CAACC,KAAK,CAAC;IAClC,MAAM,CAACC,WAAWC,KAAK,GAAGH;IAC1B,MAAMI,cAAcJ,OAAOK,KAAK,CAAC,GAAG,CAAC,GAAGC,IAAI,CAAC;IAC7C,MAAMC,SAASP,OAAOQ,EAAE,CAAC,CAAC;IAE1B,MAAMC,aAAaC,OAAOH;IAE1B,OACEL,cAAcL,uBACbM,CAAAA,SAAS,aAAaA,SAAS,MAAK,KACrC,OAAOC,gBAAgB,YACvB,CAACO,MAAMF,eACPA,cAAcG,oBAAAA,kBAAkB;AAEpC","ignoreList":[0]}},
    {"offset": {"line": 432, "column": 0}, "map": {"version":3,"sources":["file:///D:/AconnectJP/node_modules/next/src/client/components/is-next-router-error.ts"],"sourcesContent":["import {\n  isHTTPAccessFallbackError,\n  type HTTPAccessFallbackError,\n} from './http-access-fallback/http-access-fallback'\nimport { isRedirectError, type RedirectError } from './redirect-error'\n\n/**\n * Returns true if the error is a navigation signal error. These errors are\n * thrown by user code to perform navigation operations and interrupt the React\n * render.\n */\nexport function isNextRouterError(\n  error: unknown\n): error is RedirectError | HTTPAccessFallbackError {\n  return isRedirectError(error) || isHTTPAccessFallbackError(error)\n}\n"],"names":["isNextRouterError","error","isRedirectError","isHTTPAccessFallbackError"],"mappings":";;;+BAWgBA,qBAAAA;;;eAAAA;;;oCART;+BAC6C;AAO7C,SAASA,kBACdC,KAAc;IAEd,OAAOC,CAAAA,GAAAA,eAAAA,eAAe,EAACD,UAAUE,CAAAA,GAAAA,oBAAAA,yBAAyB,EAACF;AAC7D","ignoreList":[0]}},
    {"offset": {"line": 457, "column": 0}, "map": {"version":3,"sources":["file:///D:/AconnectJP/node_modules/next/src/client/lib/console.ts"],"sourcesContent":["import isError from '../../lib/is-error'\n\nfunction formatObject(arg: unknown, depth: number) {\n  switch (typeof arg) {\n    case 'object':\n      if (arg === null) {\n        return 'null'\n      } else if (Array.isArray(arg)) {\n        let result = '['\n        if (depth < 1) {\n          for (let i = 0; i < arg.length; i++) {\n            if (result !== '[') {\n              result += ','\n            }\n            if (Object.prototype.hasOwnProperty.call(arg, i)) {\n              result += formatObject(arg[i], depth + 1)\n            }\n          }\n        } else {\n          result += arg.length > 0 ? '...' : ''\n        }\n        result += ']'\n        return result\n      } else if (arg instanceof Error) {\n        return arg + ''\n      } else {\n        const keys = Object.keys(arg)\n        let result = '{'\n        if (depth < 1) {\n          for (let i = 0; i < keys.length; i++) {\n            const key = keys[i]\n            const desc = Object.getOwnPropertyDescriptor(arg, 'key')\n            if (desc && !desc.get && !desc.set) {\n              const jsonKey = JSON.stringify(key)\n              if (jsonKey !== '\"' + key + '\"') {\n                result += jsonKey + ': '\n              } else {\n                result += key + ': '\n              }\n              result += formatObject(desc.value, depth + 1)\n            }\n          }\n        } else {\n          result += keys.length > 0 ? '...' : ''\n        }\n        result += '}'\n        return result\n      }\n    case 'string':\n      return JSON.stringify(arg)\n    case 'number':\n    case 'bigint':\n    case 'boolean':\n    case 'symbol':\n    case 'undefined':\n    case 'function':\n    default:\n      return String(arg)\n  }\n}\n\nexport function formatConsoleArgs(args: unknown[]): string {\n  let message: string\n  let idx: number\n  if (typeof args[0] === 'string') {\n    message = args[0]\n    idx = 1\n  } else {\n    message = ''\n    idx = 0\n  }\n  let result = ''\n  let startQuote = false\n  for (let i = 0; i < message.length; ++i) {\n    const char = message[i]\n    if (char !== '%' || i === message.length - 1 || idx >= args.length) {\n      result += char\n      continue\n    }\n\n    const code = message[++i]\n    switch (code) {\n      case 'c': {\n        // TODO: We should colorize with HTML instead of turning into a string.\n        // Ignore for now.\n        result = startQuote ? `${result}]` : `[${result}`\n        startQuote = !startQuote\n        idx++\n        break\n      }\n      case 'O':\n      case 'o': {\n        result += formatObject(args[idx++], 0)\n        break\n      }\n      case 'd':\n      case 'i': {\n        result += parseInt(args[idx++] as any, 10)\n        break\n      }\n      case 'f': {\n        result += parseFloat(args[idx++] as any)\n        break\n      }\n      case 's': {\n        result += String(args[idx++])\n        break\n      }\n      default:\n        result += '%' + code\n    }\n  }\n\n  for (; idx < args.length; idx++) {\n    result += (idx > 0 ? ' ' : '') + formatObject(args[idx], 0)\n  }\n\n  return result\n}\n\nexport function parseConsoleArgs(args: unknown[]): {\n  environmentName: string | null\n  error: Error | null\n} {\n  // See\n  // https://github.com/facebook/react/blob/65a56d0e99261481c721334a3ec4561d173594cd/packages/react-devtools-shared/src/backend/flight/renderer.js#L88-L93\n  //\n  // Logs replayed from the server look like this:\n  // [\n  //   \"%c%s%c%o\\n\\n%s\\n\\n%s\\n\",\n  //   \"background: #e6e6e6; ...\",\n  //   \" Server \", // can also be e.g. \" Prerender \"\n  //   \"\",\n  //   Error,\n  //   \"The above error occurred in the <Page> component.\",\n  //   ...\n  // ]\n  if (\n    args.length > 3 &&\n    typeof args[0] === 'string' &&\n    args[0].startsWith('%c%s%c') &&\n    typeof args[1] === 'string' &&\n    typeof args[2] === 'string' &&\n    typeof args[3] === 'string'\n  ) {\n    const environmentName = args[2]\n    const maybeError = args[4]\n\n    return {\n      environmentName: environmentName.trim(),\n      error: isError(maybeError) ? maybeError : null,\n    }\n  }\n\n  return {\n    environmentName: null,\n    error: null,\n  }\n}\n"],"names":["formatConsoleArgs","parseConsoleArgs","formatObject","arg","depth","Array","isArray","result","i","length","Object","prototype","hasOwnProperty","call","Error","keys","key","desc","getOwnPropertyDescriptor","get","set","jsonKey","JSON","stringify","value","String","args","message","idx","startQuote","char","code","parseInt","parseFloat","startsWith","environmentName","maybeError","trim","error","isError"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 636, "column": 0}, "map": {"version":3,"sources":["file:///D:/AconnectJP/node_modules/next/src/client/app-globals.ts"],"sourcesContent":["// imports polyfill from `@next/polyfill-module` after build.\nimport '../build/polyfills/polyfill-module'\n\n// Only setup devtools in development\nif (process.env.NODE_ENV !== 'production') {\n  require('../next-devtools/userspace/app/app-dev-overlay-setup') as typeof import('../next-devtools/userspace/app/app-dev-overlay-setup')\n}\n"],"names":["process","env","NODE_ENV","require"],"mappings":"AAIIA,QAAQC,GAAG,CAACC,QAAQ,KAAK;AAJ7B,6DAA6D;;;;;;AAG7D,qCAAqC;AACrC,wCAA2C;;AAE3C","ignoreList":[0]}},
    {"offset": {"line": 658, "column": 0}, "map": {"version":3,"sources":["file:///D:/AconnectJP/node_modules/next/src/client/components/readonly-url-search-params.ts"],"sourcesContent":["/**\n * ReadonlyURLSearchParams implementation shared between client and server.\n * This file is intentionally not marked as 'use client' or 'use server'\n * so it can be imported by both environments.\n */\n\n/** @internal */\nclass ReadonlyURLSearchParamsError extends Error {\n  constructor() {\n    super(\n      'Method unavailable on `ReadonlyURLSearchParams`. Read more: https://nextjs.org/docs/app/api-reference/functions/use-search-params#updating-searchparams'\n    )\n  }\n}\n\n/**\n * A read-only version of URLSearchParams that throws errors when mutation methods are called.\n * This ensures that the URLSearchParams returned by useSearchParams() cannot be mutated.\n */\nexport class ReadonlyURLSearchParams extends URLSearchParams {\n  /** @deprecated Method unavailable on `ReadonlyURLSearchParams`. Read more: https://nextjs.org/docs/app/api-reference/functions/use-search-params#updating-searchparams */\n  append() {\n    throw new ReadonlyURLSearchParamsError()\n  }\n  /** @deprecated Method unavailable on `ReadonlyURLSearchParams`. Read more: https://nextjs.org/docs/app/api-reference/functions/use-search-params#updating-searchparams */\n  delete() {\n    throw new ReadonlyURLSearchParamsError()\n  }\n  /** @deprecated Method unavailable on `ReadonlyURLSearchParams`. Read more: https://nextjs.org/docs/app/api-reference/functions/use-search-params#updating-searchparams */\n  set() {\n    throw new ReadonlyURLSearchParamsError()\n  }\n  /** @deprecated Method unavailable on `ReadonlyURLSearchParams`. Read more: https://nextjs.org/docs/app/api-reference/functions/use-search-params#updating-searchparams */\n  sort() {\n    throw new ReadonlyURLSearchParamsError()\n  }\n}\n"],"names":["ReadonlyURLSearchParams","ReadonlyURLSearchParamsError","Error","constructor","URLSearchParams","append","delete","set","sort"],"mappings":"AAAA;;;;CAIC,GAED,cAAc;;;+BAaDA,2BAAAA;;;eAAAA;;;AAZb,MAAMC,qCAAqCC;IACzCC,aAAc;QACZ,KAAK,CACH;IAEJ;AACF;AAMO,MAAMH,gCAAgCI;IAC3C,wKAAwK,GACxKC,SAAS;QACP,MAAM,IAAIJ;IACZ;IACA,wKAAwK,GACxKK,SAAS;QACP,MAAM,IAAIL;IACZ;IACA,wKAAwK,GACxKM,MAAM;QACJ,MAAM,IAAIN;IACZ;IACA,wKAAwK,GACxKO,OAAO;QACL,MAAM,IAAIP;IACZ;AACF","ignoreList":[0]}},
    {"offset": {"line": 701, "column": 0}, "map": {"version":3,"sources":["file:///D:/AconnectJP/node_modules/next/src/client/components/app-router-headers.ts"],"sourcesContent":["export const RSC_HEADER = 'rsc' as const\nexport const ACTION_HEADER = 'next-action' as const\n// TODO: Instead of sending the full router state, we only need to send the\n// segment path. Saves bytes. Then we could also use this field for segment\n// prefetches, which also need to specify a particular segment.\nexport const NEXT_ROUTER_STATE_TREE_HEADER = 'next-router-state-tree' as const\nexport const NEXT_ROUTER_PREFETCH_HEADER = 'next-router-prefetch' as const\n// This contains the path to the segment being prefetched.\n// TODO: If we change next-router-state-tree to be a segment path, we can use\n// that instead. Then next-router-prefetch and next-router-segment-prefetch can\n// be merged into a single enum.\nexport const NEXT_ROUTER_SEGMENT_PREFETCH_HEADER =\n  'next-router-segment-prefetch' as const\nexport const NEXT_HMR_REFRESH_HEADER = 'next-hmr-refresh' as const\nexport const NEXT_HMR_REFRESH_HASH_COOKIE = '__next_hmr_refresh_hash__' as const\nexport const NEXT_URL = 'next-url' as const\nexport const RSC_CONTENT_TYPE_HEADER = 'text/x-component' as const\n\nexport const FLIGHT_HEADERS = [\n  RSC_HEADER,\n  NEXT_ROUTER_STATE_TREE_HEADER,\n  NEXT_ROUTER_PREFETCH_HEADER,\n  NEXT_HMR_REFRESH_HEADER,\n  NEXT_ROUTER_SEGMENT_PREFETCH_HEADER,\n] as const\n\nexport const NEXT_RSC_UNION_QUERY = '_rsc' as const\n\nexport const NEXT_ROUTER_STALE_TIME_HEADER = 'x-nextjs-stale-time' as const\nexport const NEXT_DID_POSTPONE_HEADER = 'x-nextjs-postponed' as const\nexport const NEXT_REWRITTEN_PATH_HEADER = 'x-nextjs-rewritten-path' as const\nexport const NEXT_REWRITTEN_QUERY_HEADER = 'x-nextjs-rewritten-query' as const\nexport const NEXT_IS_PRERENDER_HEADER = 'x-nextjs-prerender' as const\nexport const NEXT_ACTION_NOT_FOUND_HEADER = 'x-nextjs-action-not-found' as const\nexport const NEXT_REQUEST_ID_HEADER = 'x-nextjs-request-id' as const\nexport const NEXT_HTML_REQUEST_ID_HEADER = 'x-nextjs-html-request-id' as const\n\n// TODO: Should this include nextjs in the name, like the others?\nexport const NEXT_ACTION_REVALIDATED_HEADER = 'x-action-revalidated' as const\n"],"names":["ACTION_HEADER","FLIGHT_HEADERS","NEXT_ACTION_NOT_FOUND_HEADER","NEXT_ACTION_REVALIDATED_HEADER","NEXT_DID_POSTPONE_HEADER","NEXT_HMR_REFRESH_HASH_COOKIE","NEXT_HMR_REFRESH_HEADER","NEXT_HTML_REQUEST_ID_HEADER","NEXT_IS_PRERENDER_HEADER","NEXT_REQUEST_ID_HEADER","NEXT_REWRITTEN_PATH_HEADER","NEXT_REWRITTEN_QUERY_HEADER","NEXT_ROUTER_PREFETCH_HEADER","NEXT_ROUTER_SEGMENT_PREFETCH_HEADER","NEXT_ROUTER_STALE_TIME_HEADER","NEXT_ROUTER_STATE_TREE_HEADER","NEXT_RSC_UNION_QUERY","NEXT_URL","RSC_CONTENT_TYPE_HEADER","RSC_HEADER"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;IACaA,aAAa,EAAA;eAAbA;;IAiBAC,cAAc,EAAA;eAAdA;;IAeAC,4BAA4B,EAAA;eAA5BA;;IAKAC,8BAA8B,EAAA;eAA9BA;;IATAC,wBAAwB,EAAA;eAAxBA;;IAfAC,4BAA4B,EAAA;eAA5BA;;IADAC,uBAAuB,EAAA;eAAvBA;;IAsBAC,2BAA2B,EAAA;eAA3BA;;IAHAC,wBAAwB,EAAA;eAAxBA;;IAEAC,sBAAsB,EAAA;eAAtBA;;IAJAC,0BAA0B,EAAA;eAA1BA;;IACAC,2BAA2B,EAAA;eAA3BA;;IAzBAC,2BAA2B,EAAA;eAA3BA;;IAKAC,mCAAmC,EAAA;eAAnCA;;IAiBAC,6BAA6B,EAAA;eAA7BA;;IAvBAC,6BAA6B,EAAA;eAA7BA;;IAqBAC,oBAAoB,EAAA;eAApBA;;IAXAC,QAAQ,EAAA;eAARA;;IACAC,uBAAuB,EAAA;eAAvBA;;IAhBAC,UAAU,EAAA;eAAVA;;;AAAN,MAAMA,aAAa;AACnB,MAAMnB,gBAAgB;AAItB,MAAMe,gCAAgC;AACtC,MAAMH,8BAA8B;AAKpC,MAAMC,sCACX;AACK,MAAMP,0BAA0B;AAChC,MAAMD,+BAA+B;AACrC,MAAMY,WAAW;AACjB,MAAMC,0BAA0B;AAEhC,MAAMjB,iBAAiB;IAC5BkB;IACAJ;IACAH;IACAN;IACAO;CACD;AAEM,MAAMG,uBAAuB;AAE7B,MAAMF,gCAAgC;AACtC,MAAMV,2BAA2B;AACjC,MAAMM,6BAA6B;AACnC,MAAMC,8BAA8B;AACpC,MAAMH,2BAA2B;AACjC,MAAMN,+BAA+B;AACrC,MAAMO,yBAAyB;AAC/B,MAAMF,8BAA8B;AAGpC,MAAMJ,iCAAiC","ignoreList":[0]}},
    {"offset": {"line": 831, "column": 0}, "map": {"version":3,"sources":["file:///D:/AconnectJP/node_modules/next/src/client/components/navigation-untracked.ts"],"sourcesContent":["import { useContext } from 'react'\nimport { PathnameContext } from '../../shared/lib/hooks-client-context.shared-runtime'\n\n/**\n * This checks to see if the current render has any unknown route parameters that\n * would cause the pathname to be dynamic. It's used to trigger a different\n * render path in the error boundary.\n *\n * @returns true if there are any unknown route parameters, false otherwise\n */\nfunction hasFallbackRouteParams(): boolean {\n  if (typeof window === 'undefined') {\n    // AsyncLocalStorage should not be included in the client bundle.\n    const { workUnitAsyncStorage } =\n      require('../../server/app-render/work-unit-async-storage.external') as typeof import('../../server/app-render/work-unit-async-storage.external')\n\n    const workUnitStore = workUnitAsyncStorage.getStore()\n    if (!workUnitStore) return false\n\n    switch (workUnitStore.type) {\n      case 'prerender':\n      case 'prerender-client':\n      case 'prerender-ppr':\n        const fallbackParams = workUnitStore.fallbackRouteParams\n        return fallbackParams ? fallbackParams.size > 0 : false\n      case 'prerender-legacy':\n      case 'request':\n      case 'prerender-runtime':\n      case 'cache':\n      case 'private-cache':\n      case 'unstable-cache':\n        break\n      default:\n        workUnitStore satisfies never\n    }\n\n    return false\n  }\n\n  return false\n}\n\n/**\n * This returns a `null` value if there are any unknown route parameters, and\n * otherwise returns the pathname from the context. This is an alternative to\n * `usePathname` that is used in the error boundary to avoid rendering the\n * error boundary when there are unknown route parameters. This doesn't throw\n * when accessed with unknown route parameters.\n *\n * @returns\n *\n * @internal\n */\nexport function useUntrackedPathname(): string | null {\n  // If there are any unknown route parameters we would typically throw\n  // an error, but this internal method allows us to return a null value instead\n  // for components that do not propagate the pathname to the static shell (like\n  // the error boundary).\n  if (hasFallbackRouteParams()) {\n    return null\n  }\n\n  // This shouldn't cause any issues related to conditional rendering because\n  // the environment will be consistent for the render.\n  // eslint-disable-next-line react-hooks/rules-of-hooks\n  return useContext(PathnameContext)\n}\n"],"names":["useUntrackedPathname","hasFallbackRouteParams","window","workUnitAsyncStorage","require","workUnitStore","getStore","type","fallbackParams","fallbackRouteParams","size","useContext","PathnameContext"],"mappings":";;;+BAqDgBA,wBAAAA;;;eAAAA;;;uBArDW;iDACK;AAEhC;;;;;;CAMC,GACD,SAASC;IACP,IAAI,OAAOC,WAAW,aAAa;QACjC,iEAAiE;QACjE,MAAM,EAAEC,oBAAoB,EAAE,GAC5BC,QAAQ;QAEV,MAAMC,gBAAgBF,qBAAqBG,QAAQ;QACnD,IAAI,CAACD,eAAe,OAAO;QAE3B,OAAQA,cAAcE,IAAI;YACxB,KAAK;YACL,KAAK;YACL,KAAK;gBACH,MAAMC,iBAAiBH,cAAcI,mBAAmB;gBACxD,OAAOD,iBAAiBA,eAAeE,IAAI,GAAG,IAAI;YACpD,KAAK;YACL,KAAK;YACL,KAAK;YACL,KAAK;YACL,KAAK;YACL,KAAK;gBACH;YACF;gBACEL;QACJ;QAEA,OAAO;IACT;IAEA,OAAO;AACT;AAaO,SAASL;IACd,qEAAqE;IACrE,8EAA8E;IAC9E,8EAA8E;IAC9E,uBAAuB;IACvB,IAAIC,0BAA0B;QAC5B,OAAO;IACT;IAEA,2EAA2E;IAC3E,qDAAqD;IACrD,sDAAsD;IACtD,OAAOU,CAAAA,GAAAA,OAAAA,UAAU,EAACC,iCAAAA,eAAe;AACnC","ignoreList":[0]}},
    {"offset": {"line": 898, "column": 0}, "map": {"version":3,"sources":["file:///D:/AconnectJP/node_modules/next/src/client/components/router-reducer/create-href-from-url.ts"],"sourcesContent":["export function createHrefFromUrl(\n  url: Pick<URL, 'pathname' | 'search' | 'hash'>,\n  includeHash: boolean = true\n): string {\n  return url.pathname + url.search + (includeHash ? url.hash : '')\n}\n"],"names":["createHrefFromUrl","url","includeHash","pathname","search","hash"],"mappings":";;;+BAAgBA,qBAAAA;;;eAAAA;;;AAAT,SAASA,kBACdC,GAA8C,EAC9CC,cAAuB,IAAI;IAE3B,OAAOD,IAAIE,QAAQ,GAAGF,IAAIG,MAAM,GAAIF,CAAAA,cAAcD,IAAII,IAAI,GAAG,EAAC;AAChE","ignoreList":[0]}},
    {"offset": {"line": 921, "column": 0}, "map": {"version":3,"sources":["file:///D:/AconnectJP/node_modules/next/src/client/components/nav-failure-handler.ts"],"sourcesContent":["import { useEffect } from 'react'\nimport { createHrefFromUrl } from './router-reducer/create-href-from-url'\n\nexport function handleHardNavError(error: unknown): boolean {\n  if (\n    error &&\n    typeof window !== 'undefined' &&\n    window.next.__pendingUrl &&\n    createHrefFromUrl(new URL(window.location.href)) !==\n      createHrefFromUrl(window.next.__pendingUrl)\n  ) {\n    console.error(\n      `Error occurred during navigation, falling back to hard navigation`,\n      error\n    )\n    window.location.href = window.next.__pendingUrl.toString()\n    return true\n  }\n  return false\n}\n\nexport function useNavFailureHandler() {\n  if (process.env.__NEXT_APP_NAV_FAIL_HANDLING) {\n    // this if is only for DCE of the feature flag not conditional\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    useEffect(() => {\n      const uncaughtExceptionHandler = (\n        evt: ErrorEvent | PromiseRejectionEvent\n      ) => {\n        const error = 'reason' in evt ? evt.reason : evt.error\n        // if we have an unhandled exception/rejection during\n        // a navigation we fall back to a hard navigation to\n        // attempt recovering to a good state\n        handleHardNavError(error)\n      }\n      window.addEventListener('unhandledrejection', uncaughtExceptionHandler)\n      window.addEventListener('error', uncaughtExceptionHandler)\n      return () => {\n        window.removeEventListener('error', uncaughtExceptionHandler)\n        window.removeEventListener(\n          'unhandledrejection',\n          uncaughtExceptionHandler\n        )\n      }\n    }, [])\n  }\n}\n"],"names":["handleHardNavError","useNavFailureHandler","error","window","next","__pendingUrl","createHrefFromUrl","URL","location","href","console","toString","process","env","__NEXT_APP_NAV_FAIL_HANDLING","useEffect","uncaughtExceptionHandler","evt","reason","addEventListener","removeEventListener"],"mappings":"AAsBMY,QAAQC,GAAG,CAACC,4BAA4B,EAAE;;;;;;;;;;;;;;;;IAnBhCd,kBAAkB,EAAA;eAAlBA;;IAkBAC,oBAAoB,EAAA;eAApBA;;;uBArBU;mCACQ;AAE3B,SAASD,mBAAmBE,KAAc;IAC/C,IACEA,SACA,OAAOC,WAAW,eAClBA,OAAOC,IAAI,CAACC,YAAY,IACxBC,CAAAA,GAAAA,mBAAAA,iBAAiB,EAAC,IAAIC,IAAIJ,OAAOK,QAAQ,CAACC,IAAI,OAC5CH,CAAAA,GAAAA,mBAAAA,iBAAiB,EAACH,OAAOC,IAAI,CAACC,YAAY,GAC5C;QACAK,QAAQR,KAAK,CACX,CAAC,iEAAiE,CAAC,EACnEA;QAEFC,OAAOK,QAAQ,CAACC,IAAI,GAAGN,OAAOC,IAAI,CAACC,YAAY,CAACM,QAAQ;QACxD,OAAO;IACT;IACA,OAAO;AACT;AAEO,SAASV;IACd;;AAwBF","ignoreList":[0]}},
    {"offset": {"line": 969, "column": 0}, "map": {"version":3,"sources":["file:///D:/AconnectJP/node_modules/next/src/client/components/handle-isr-error.tsx"],"sourcesContent":["const workAsyncStorage =\n  typeof window === 'undefined'\n    ? (\n        require('../../server/app-render/work-async-storage.external') as typeof import('../../server/app-render/work-async-storage.external')\n      ).workAsyncStorage\n    : undefined\n\n// if we are revalidating we want to re-throw the error so the\n// function crashes so we can maintain our previous cache\n// instead of caching the error page\nexport function HandleISRError({ error }: { error: any }) {\n  if (workAsyncStorage) {\n    const store = workAsyncStorage.getStore()\n    if (store?.isStaticGeneration) {\n      if (error) {\n        console.error(error)\n      }\n      throw error\n    }\n  }\n\n  return null\n}\n"],"names":["HandleISRError","workAsyncStorage","window","require","undefined","error","store","getStore","isStaticGeneration","console"],"mappings":";;;+BAUgBA,kBAAAA;;;eAAAA;;;AAVhB,MAAMC,mBACJ,OAAOC,WAAW,cAEZC,QAAQ,+HACRF,gBAAgB,GAClBG;AAKC,SAASJ,eAAe,EAAEK,KAAK,EAAkB;IACtD,IAAIJ,kBAAkB;QACpB,MAAMK,QAAQL,iBAAiBM,QAAQ;QACvC,IAAID,OAAOE,oBAAoB;YAC7B,IAAIH,OAAO;gBACTI,QAAQJ,KAAK,CAACA;YAChB;YACA,MAAMA;QACR;IACF;IAEA,OAAO;AACT","ignoreList":[0]}},
    {"offset": {"line": 1002, "column": 0}, "map": {"version":3,"sources":["file:///D:/AconnectJP/node_modules/next/src/client/components/error-boundary.tsx"],"sourcesContent":["'use client'\n\nimport React, { type JSX } from 'react'\nimport { useUntrackedPathname } from './navigation-untracked'\nimport { isNextRouterError } from './is-next-router-error'\nimport { handleHardNavError } from './nav-failure-handler'\nimport { HandleISRError } from './handle-isr-error'\nimport { isBot } from '../../shared/lib/router/utils/is-bot'\n\nconst isBotUserAgent =\n  typeof window !== 'undefined' && isBot(window.navigator.userAgent)\n\nexport type ErrorComponent = React.ComponentType<{\n  error: Error\n  // global-error, there's no `reset` function;\n  // regular error boundary, there's a `reset` function.\n  reset?: () => void\n}>\n\nexport interface ErrorBoundaryProps {\n  children?: React.ReactNode\n  errorComponent: ErrorComponent | undefined\n  errorStyles?: React.ReactNode | undefined\n  errorScripts?: React.ReactNode | undefined\n}\n\ninterface ErrorBoundaryHandlerProps extends ErrorBoundaryProps {\n  pathname: string | null\n  errorComponent: ErrorComponent\n}\n\ninterface ErrorBoundaryHandlerState {\n  error: Error | null\n  previousPathname: string | null\n}\n\nexport class ErrorBoundaryHandler extends React.Component<\n  ErrorBoundaryHandlerProps,\n  ErrorBoundaryHandlerState\n> {\n  constructor(props: ErrorBoundaryHandlerProps) {\n    super(props)\n    this.state = { error: null, previousPathname: this.props.pathname }\n  }\n\n  static getDerivedStateFromError(error: Error) {\n    if (isNextRouterError(error)) {\n      // Re-throw if an expected internal Next.js router error occurs\n      // this means it should be handled by a different boundary (such as a NotFound boundary in a parent segment)\n      throw error\n    }\n\n    return { error }\n  }\n\n  static getDerivedStateFromProps(\n    props: ErrorBoundaryHandlerProps,\n    state: ErrorBoundaryHandlerState\n  ): ErrorBoundaryHandlerState | null {\n    const { error } = state\n\n    // if we encounter an error while\n    // a navigation is pending we shouldn't render\n    // the error boundary and instead should fallback\n    // to a hard navigation to attempt recovering\n    if (process.env.__NEXT_APP_NAV_FAIL_HANDLING) {\n      if (error && handleHardNavError(error)) {\n        // clear error so we don't render anything\n        return {\n          error: null,\n          previousPathname: props.pathname,\n        }\n      }\n    }\n\n    /**\n     * Handles reset of the error boundary when a navigation happens.\n     * Ensures the error boundary does not stay enabled when navigating to a new page.\n     * Approach of setState in render is safe as it checks the previous pathname and then overrides\n     * it as outlined in https://react.dev/reference/react/useState#storing-information-from-previous-renders\n     */\n    if (props.pathname !== state.previousPathname && state.error) {\n      return {\n        error: null,\n        previousPathname: props.pathname,\n      }\n    }\n    return {\n      error: state.error,\n      previousPathname: props.pathname,\n    }\n  }\n\n  reset = () => {\n    this.setState({ error: null })\n  }\n\n  // Explicit type is needed to avoid the generated `.d.ts` having a wide return type that could be specific to the `@types/react` version.\n  render(): React.ReactNode {\n    //When it's bot request, segment level error boundary will keep rendering the children,\n    // the final error will be caught by the root error boundary and determine wether need to apply graceful degrade.\n    if (this.state.error && !isBotUserAgent) {\n      return (\n        <>\n          <HandleISRError error={this.state.error} />\n          {this.props.errorStyles}\n          {this.props.errorScripts}\n          <this.props.errorComponent\n            error={this.state.error}\n            reset={this.reset}\n          />\n        </>\n      )\n    }\n\n    return this.props.children\n  }\n}\n\n/**\n * Handles errors through `getDerivedStateFromError`.\n * Renders the provided error component and provides a way to `reset` the error boundary state.\n */\n\n/**\n * Renders error boundary with the provided \"errorComponent\" property as the fallback.\n * If no \"errorComponent\" property is provided it renders the children without an error boundary.\n */\nexport function ErrorBoundary({\n  errorComponent,\n  errorStyles,\n  errorScripts,\n  children,\n}: ErrorBoundaryProps & {\n  children: React.ReactNode\n}): JSX.Element {\n  // When we're rendering the missing params shell, this will return null. This\n  // is because we won't be rendering any not found boundaries or error\n  // boundaries for the missing params shell. When this runs on the client\n  // (where these errors can occur), we will get the correct pathname.\n  const pathname = useUntrackedPathname()\n  if (errorComponent) {\n    return (\n      <ErrorBoundaryHandler\n        pathname={pathname}\n        errorComponent={errorComponent}\n        errorStyles={errorStyles}\n        errorScripts={errorScripts}\n      >\n        {children}\n      </ErrorBoundaryHandler>\n    )\n  }\n\n  return <>{children}</>\n}\n"],"names":["ErrorBoundary","ErrorBoundaryHandler","isBotUserAgent","window","isBot","navigator","userAgent","React","Component","constructor","props","reset","setState","error","state","previousPathname","pathname","getDerivedStateFromError","isNextRouterError","getDerivedStateFromProps","process","env","__NEXT_APP_NAV_FAIL_HANDLING","handleHardNavError","render","HandleISRError","errorStyles","errorScripts","this","errorComponent","children","useUntrackedPathname"],"mappings":"AAiEQoB,QAAQC,GAAG,CAACC,4BAA4B,EAAE;AAjElD;;;;;;;;;;;;;;;;IAgIgBtB,aAAa,EAAA;eAAbA;;IA5FHC,oBAAoB,EAAA;eAApBA;;;;;gEAlCmB;qCACK;mCACH;mCACC;gCACJ;uBACT;AAEtB,MAAMC,iBACJ,OAAOC,WAAW,eAAeC,CAAAA,GAAAA,OAAAA,KAAK,EAACD,OAAOE,SAAS,CAACC,SAAS;AA0B5D,MAAML,6BAA6BM,OAAAA,OAAK,CAACC,SAAS;IAIvDC,YAAYC,KAAgC,CAAE;QAC5C,KAAK,CAACA,QAAAA,IAAAA,CAoDRC,KAAAA,GAAQ;YACN,IAAI,CAACC,QAAQ,CAAC;gBAAEC,OAAO;YAAK;QAC9B;QArDE,IAAI,CAACC,KAAK,GAAG;YAAED,OAAO;YAAME,kBAAkB,IAAI,CAACL,KAAK,CAACM,QAAQ;QAAC;IACpE;IAEA,OAAOC,yBAAyBJ,KAAY,EAAE;QAC5C,IAAIK,CAAAA,GAAAA,mBAAAA,iBAAiB,EAACL,QAAQ;YAC5B,+DAA+D;YAC/D,4GAA4G;YAC5G,MAAMA;QACR;QAEA,OAAO;YAAEA;QAAM;IACjB;IAEA,OAAOM,yBACLT,KAAgC,EAChCI,KAAgC,EACE;QAClC,MAAM,EAAED,KAAK,EAAE,GAAGC;QAElB,iCAAiC;QACjC,8CAA8C;QAC9C,iDAAiD;QACjD,6CAA6C;QAC7C;;QAUA;;;;;KAKC,GACD,IAAIJ,MAAMM,QAAQ,KAAKF,MAAMC,gBAAgB,IAAID,MAAMD,KAAK,EAAE;YAC5D,OAAO;gBACLA,OAAO;gBACPE,kBAAkBL,MAAMM,QAAQ;YAClC;QACF;QACA,OAAO;YACLH,OAAOC,MAAMD,KAAK;YAClBE,kBAAkBL,MAAMM,QAAQ;QAClC;IACF;IAMA,yIAAyI;IACzIQ,SAA0B;QACxB,uFAAuF;QACvF,iHAAiH;QACjH,IAAI,IAAI,CAACV,KAAK,CAACD,KAAK,IAAI,CAACX,gBAAgB;YACvC,OAAA,WAAA,GACE,CAAA,GAAA,YAAA,IAAA,EAAA,YAAA,QAAA,EAAA;;kCACE,CAAA,GAAA,YAAA,GAAA,EAACuB,gBAAAA,cAAc,EAAA;wBAACZ,OAAO,IAAI,CAACC,KAAK,CAACD,KAAK;;oBACtC,IAAI,CAACH,KAAK,CAACgB,WAAW;oBACtB,IAAI,CAAChB,KAAK,CAACiB,YAAY;kCACxB,CAAA,GAAA,YAAA,GAAA,EAACC,IAAI,CAAClB,KAAK,CAACmB,cAAc,EAAA;wBACxBhB,OAAO,IAAI,CAACC,KAAK,CAACD,KAAK;wBACvBF,OAAO,IAAI,CAACA,KAAK;;;;QAIzB;QAEA,OAAO,IAAI,CAACD,KAAK,CAACoB,QAAQ;IAC5B;AACF;AAWO,SAAS9B,cAAc,EAC5B6B,cAAc,EACdH,WAAW,EACXC,YAAY,EACZG,QAAQ,EAGT;IACC,6EAA6E;IAC7E,qEAAqE;IACrE,wEAAwE;IACxE,oEAAoE;IACpE,MAAMd,WAAWe,CAAAA,GAAAA,qBAAAA,oBAAoB;IACrC,IAAIF,gBAAgB;QAClB,OAAA,WAAA,GACE,CAAA,GAAA,YAAA,GAAA,EAAC5B,sBAAAA;YACCe,UAAUA;YACVa,gBAAgBA;YAChBH,aAAaA;YACbC,cAAcA;sBAEbG;;IAGP;IAEA,OAAA,WAAA,GAAO,CAAA,GAAA,YAAA,GAAA,EAAA,YAAA,QAAA,EAAA;kBAAGA;;AACZ","ignoreList":[0]}},
    {"offset": {"line": 1133, "column": 0}, "map": {"version":3,"sources":["file:///D:/AconnectJP/node_modules/next/src/client/components/builtin/error-styles.tsx"],"sourcesContent":["import React from 'react'\n\nexport const errorStyles = {\n  container: {\n    fontFamily:\n      'system-ui,\"Segoe UI\",Roboto,Helvetica,Arial,sans-serif,\"Apple Color Emoji\",\"Segoe UI Emoji\"',\n    height: '100vh',\n    display: 'flex',\n    alignItems: 'center',\n    justifyContent: 'center',\n  },\n  card: {\n    maxWidth: '420px',\n    padding: '32px 28px',\n    textAlign: 'left' as const,\n  },\n  icon: {\n    marginBottom: '16px',\n  },\n  title: {\n    fontSize: '17px',\n    fontWeight: 600,\n    letterSpacing: '-0.01em',\n    margin: '0 0 8px 0',\n    color: 'var(--next-error-title)',\n  },\n  message: {\n    fontSize: '14px',\n    fontWeight: 400,\n    lineHeight: 1.6,\n    margin: '0 0 6px 0',\n    color: 'var(--next-error-message)',\n  },\n  messageHint: {\n    fontSize: '13px',\n    fontWeight: 400,\n    lineHeight: 1.5,\n    margin: '0 0 20px 0',\n    color: 'var(--next-error-hint)',\n  },\n  buttonGroup: {\n    display: 'flex',\n    gap: '12px',\n    alignItems: 'center',\n  },\n  button: {\n    padding: '10px 20px',\n    fontSize: '14px',\n    fontWeight: 500,\n    letterSpacing: '0.01em',\n    borderRadius: '6px',\n    cursor: 'pointer',\n    color: 'var(--next-error-btn-text)',\n    background: 'var(--next-error-btn-bg)',\n    border: 'var(--next-error-btn-border)',\n  },\n  buttonSecondary: {\n    padding: '10px 20px',\n    fontSize: '14px',\n    fontWeight: 500,\n    letterSpacing: '0.01em',\n    borderRadius: '6px',\n    cursor: 'pointer',\n    color: 'var(--next-error-btn-secondary-text)',\n    background: 'transparent',\n    border: 'none',\n  },\n  digestContainer: {\n    marginTop: '20px',\n    paddingTop: '16px',\n    borderTop: 'var(--next-error-digest-border)',\n  },\n  digest: {\n    fontSize: '12px',\n    fontWeight: 400,\n    margin: '0',\n    color: 'var(--next-error-digest)',\n  },\n  digestCode: {\n    fontFamily:\n      'ui-monospace,SFMono-Regular,\"SF Mono\",Menlo,Consolas,monospace',\n    fontSize: '11px',\n    color: 'var(--next-error-digest-code)',\n    userSelect: 'all' as const,\n  },\n} as const\n\nexport const errorThemeCss = `\n:root {\n  --next-error-bg: #fff;\n  --next-error-text: #171717;\n  --next-error-title: #171717;\n  --next-error-message: #666;\n  --next-error-hint: #888;\n  --next-error-digest: #999;\n  --next-error-digest-code: #888;\n  --next-error-digest-border: 1px solid rgba(0,0,0,0.06);\n  --next-error-btn-text: #171717;\n  --next-error-btn-bg: #fff;\n  --next-error-btn-border: 1px solid #e5e5e5;\n  --next-error-btn-secondary-text: #666;\n  --next-error-icon-ring: #fecaca;\n  --next-error-icon-fill: #fef2f2;\n}\n@media (prefers-color-scheme: dark) {\n  :root {\n    --next-error-bg: #0a0a0a;\n    --next-error-text: #ededed;\n    --next-error-title: #ededed;\n    --next-error-message: #a0a0a0;\n    --next-error-hint: #707070;\n    --next-error-digest: #606060;\n    --next-error-digest-code: #707070;\n    --next-error-digest-border: 1px solid rgba(255,255,255,0.08);\n    --next-error-btn-text: #ededed;\n    --next-error-btn-bg: #1a1a1a;\n    --next-error-btn-border: 1px solid #333;\n    --next-error-btn-secondary-text: #a0a0a0;\n    --next-error-icon-ring: #5c2121;\n    --next-error-icon-fill: #2a1618;\n  }\n}\nbody { margin: 0; color: var(--next-error-text); background: var(--next-error-bg); }\n`.replace(/\\n\\s*/g, '')\n\nexport function ErrorIcon() {\n  return (\n    <svg\n      width=\"40\"\n      height=\"40\"\n      viewBox=\"0 0 40 40\"\n      fill=\"none\"\n      style={errorStyles.icon}\n    >\n      <circle\n        cx=\"20\"\n        cy=\"20\"\n        r=\"19\"\n        stroke=\"var(--next-error-icon-ring)\"\n        strokeWidth=\"2\"\n      />\n      <circle cx=\"20\" cy=\"20\" r=\"16\" fill=\"var(--next-error-icon-fill)\" />\n      <path\n        d=\"M20 12v9\"\n        stroke=\"#dc2626\"\n        strokeWidth=\"2.5\"\n        strokeLinecap=\"round\"\n      />\n      <circle cx=\"20\" cy=\"27\" r=\"1.5\" fill=\"#dc2626\" />\n    </svg>\n  )\n}\n"],"names":["ErrorIcon","errorStyles","errorThemeCss","container","fontFamily","height","display","alignItems","justifyContent","card","maxWidth","padding","textAlign","icon","marginBottom","title","fontSize","fontWeight","letterSpacing","margin","color","message","lineHeight","messageHint","buttonGroup","gap","button","borderRadius","cursor","background","border","buttonSecondary","digestContainer","marginTop","paddingTop","borderTop","digest","digestCode","userSelect","replace","svg","width","viewBox","fill","style","circle","cx","cy","r","stroke","strokeWidth","path","d","strokeLinecap"],"mappings":";;;;;;;;;;;;;;;IA6HgBA,SAAS,EAAA;eAATA;;IA3HHC,WAAW,EAAA;eAAXA;;IAqFAC,aAAa,EAAA;eAAbA;;;;;gEAvFK;AAEX,MAAMD,cAAc;IACzBE,WAAW;QACTC,YACE;QACFC,QAAQ;QACRC,SAAS;QACTC,YAAY;QACZC,gBAAgB;IAClB;IACAC,MAAM;QACJC,UAAU;QACVC,SAAS;QACTC,WAAW;IACb;IACAC,MAAM;QACJC,cAAc;IAChB;IACAC,OAAO;QACLC,UAAU;QACVC,YAAY;QACZC,eAAe;QACfC,QAAQ;QACRC,OAAO;IACT;IACAC,SAAS;QACPL,UAAU;QACVC,YAAY;QACZK,YAAY;QACZH,QAAQ;QACRC,OAAO;IACT;IACAG,aAAa;QACXP,UAAU;QACVC,YAAY;QACZK,YAAY;QACZH,QAAQ;QACRC,OAAO;IACT;IACAI,aAAa;QACXlB,SAAS;QACTmB,KAAK;QACLlB,YAAY;IACd;IACAmB,QAAQ;QACNf,SAAS;QACTK,UAAU;QACVC,YAAY;QACZC,eAAe;QACfS,cAAc;QACdC,QAAQ;QACRR,OAAO;QACPS,YAAY;QACZC,QAAQ;IACV;IACAC,iBAAiB;QACfpB,SAAS;QACTK,UAAU;QACVC,YAAY;QACZC,eAAe;QACfS,cAAc;QACdC,QAAQ;QACRR,OAAO;QACPS,YAAY;QACZC,QAAQ;IACV;IACAE,iBAAiB;QACfC,WAAW;QACXC,YAAY;QACZC,WAAW;IACb;IACAC,QAAQ;QACNpB,UAAU;QACVC,YAAY;QACZE,QAAQ;QACRC,OAAO;IACT;IACAiB,YAAY;QACVjC,YACE;QACFY,UAAU;QACVI,OAAO;QACPkB,YAAY;IACd;AACF;AAEO,MAAMpC,gBAAgB,CAAC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAoC9B,CAAC,CAACqC,OAAO,CAAC,UAAU;AAEb,SAASvC;IACd,OAAA,WAAA,GACE,CAAA,GAAA,YAAA,IAAA,EAACwC,OAAAA;QACCC,OAAM;QACNpC,QAAO;QACPqC,SAAQ;QACRC,MAAK;QACLC,OAAO3C,YAAYY,IAAI;;0BAEvB,CAAA,GAAA,YAAA,GAAA,EAACgC,UAAAA;gBACCC,IAAG;gBACHC,IAAG;gBACHC,GAAE;gBACFC,QAAO;gBACPC,aAAY;;0BAEd,CAAA,GAAA,YAAA,GAAA,EAACL,UAAAA;gBAAOC,IAAG;gBAAKC,IAAG;gBAAKC,GAAE;gBAAKL,MAAK;;0BACpC,CAAA,GAAA,YAAA,GAAA,EAACQ,QAAAA;gBACCC,GAAE;gBACFH,QAAO;gBACPC,aAAY;gBACZG,eAAc;;0BAEhB,CAAA,GAAA,YAAA,GAAA,EAACR,UAAAA;gBAAOC,IAAG;gBAAKC,IAAG;gBAAKC,GAAE;gBAAML,MAAK;;;;AAG3C","ignoreList":[0]}},
    {"offset": {"line": 1327, "column": 0}, "map": {"version":3,"sources":["file:///D:/AconnectJP/node_modules/next/src/client/components/builtin/global-error.tsx"],"sourcesContent":["'use client'\n\nimport { HandleISRError } from '../handle-isr-error'\nimport { errorStyles, errorThemeCss, ErrorIcon } from './error-styles'\n\nexport type GlobalErrorComponent = React.ComponentType<{\n  error: any\n}>\n\nfunction DefaultGlobalError({ error }: { error: any }) {\n  const digest: string | undefined = error?.digest\n  const isServerError = !!digest\n\n  // Server error: \"This page failed to load\"\n  // Client error: \"This page crashed\"\n  const title = isServerError ? 'This page failed to load' : 'This page crashed'\n  const message = isServerError\n    ? 'Something went wrong while loading this page.'\n    : 'An error occurred while running this page.'\n  const hint = isServerError\n    ? 'If this keeps happening, it may be a server issue.'\n    : null\n\n  return (\n    <html id=\"__next_error__\">\n      <head>\n        <style dangerouslySetInnerHTML={{ __html: errorThemeCss }} />\n      </head>\n      <body>\n        <HandleISRError error={error} />\n        <div style={errorStyles.container}>\n          <div style={errorStyles.card}>\n            <ErrorIcon />\n            <h1 style={errorStyles.title}>{title}</h1>\n            <p style={errorStyles.message}>{message}</p>\n            {hint && <p style={errorStyles.messageHint}>{hint}</p>}\n            {!isServerError && (\n              <p style={errorStyles.messageHint}>\n                Reloading usually fixes this.\n              </p>\n            )}\n            <div style={errorStyles.buttonGroup}>\n              <form>\n                <button type=\"submit\" style={errorStyles.button}>\n                  Reload page\n                </button>\n              </form>\n              {!isServerError && (\n                <button\n                  type=\"button\"\n                  style={errorStyles.buttonSecondary}\n                  onClick={() => {\n                    if (window.history.length > 1) {\n                      window.history.back()\n                    } else {\n                      window.location.href = '/'\n                    }\n                  }}\n                >\n                  Go back\n                </button>\n              )}\n            </div>\n            {digest && (\n              <div style={errorStyles.digestContainer}>\n                <p style={errorStyles.digest}>\n                  Error reference:{' '}\n                  <code style={errorStyles.digestCode}>{digest}</code>\n                </p>\n              </div>\n            )}\n          </div>\n        </div>\n      </body>\n    </html>\n  )\n}\n\n// Exported so that the import signature in the loaders can be identical to user\n// supplied custom global error signatures.\nexport default DefaultGlobalError\n"],"names":["DefaultGlobalError","error","digest","isServerError","title","message","hint","html","id","head","style","dangerouslySetInnerHTML","__html","errorThemeCss","body","HandleISRError","div","errorStyles","container","card","ErrorIcon","h1","p","messageHint","buttonGroup","form","button","type","buttonSecondary","onClick","window","history","length","back","location","href","digestContainer","code","digestCode"],"mappings":";;;+BA+EA,AADA,2CAC2C,qCADqC;AAEhF,WAAA;;;eAAA;;;;gCA9E+B;6BACuB;AAMtD,SAASA,mBAAmB,EAAEC,KAAK,EAAkB;IACnD,MAAMC,SAA6BD,OAAOC;IAC1C,MAAMC,gBAAgB,CAAC,CAACD;IAExB,2CAA2C;IAC3C,oCAAoC;IACpC,MAAME,QAAQD,gBAAgB,6BAA6B;IAC3D,MAAME,UAAUF,gBACZ,kDACA;IACJ,MAAMG,OAAOH,gBACT,uDACA;IAEJ,OAAA,WAAA,GACE,CAAA,GAAA,YAAA,IAAA,EAACI,QAAAA;QAAKC,IAAG;;0BACP,CAAA,GAAA,YAAA,GAAA,EAACC,QAAAA;0BACC,WAAA,GAAA,CAAA,GAAA,YAAA,GAAA,EAACC,SAAAA;oBAAMC,yBAAyB;wBAAEC,QAAQC,aAAAA,aAAa;oBAAC;;;0BAE1D,CAAA,GAAA,YAAA,IAAA,EAACC,QAAAA;;kCACC,CAAA,GAAA,YAAA,GAAA,EAACC,gBAAAA,cAAc,EAAA;wBAACd,OAAOA;;kCACvB,CAAA,GAAA,YAAA,GAAA,EAACe,OAAAA;wBAAIN,OAAOO,aAAAA,WAAW,CAACC,SAAS;kCAC/B,WAAA,GAAA,CAAA,GAAA,YAAA,IAAA,EAACF,OAAAA;4BAAIN,OAAOO,aAAAA,WAAW,CAACE,IAAI;;8CAC1B,CAAA,GAAA,YAAA,GAAA,EAACC,aAAAA,SAAS,EAAA,CAAA;8CACV,CAAA,GAAA,YAAA,GAAA,EAACC,MAAAA;oCAAGX,OAAOO,aAAAA,WAAW,CAACb,KAAK;8CAAGA;;8CAC/B,CAAA,GAAA,YAAA,GAAA,EAACkB,KAAAA;oCAAEZ,OAAOO,aAAAA,WAAW,CAACZ,OAAO;8CAAGA;;gCAC/BC,QAAAA,WAAAA,GAAQ,CAAA,GAAA,YAAA,GAAA,EAACgB,KAAAA;oCAAEZ,OAAOO,aAAAA,WAAW,CAACM,WAAW;8CAAGjB;;gCAC5C,CAACH,iBAAAA,WAAAA,GACA,CAAA,GAAA,YAAA,GAAA,EAACmB,KAAAA;oCAAEZ,OAAOO,aAAAA,WAAW,CAACM,WAAW;8CAAE;;8CAIrC,CAAA,GAAA,YAAA,IAAA,EAACP,OAAAA;oCAAIN,OAAOO,aAAAA,WAAW,CAACO,WAAW;;sDACjC,CAAA,GAAA,YAAA,GAAA,EAACC,QAAAA;sDACC,WAAA,GAAA,CAAA,GAAA,YAAA,GAAA,EAACC,UAAAA;gDAAOC,MAAK;gDAASjB,OAAOO,aAAAA,WAAW,CAACS,MAAM;0DAAE;;;wCAIlD,CAACvB,iBAAAA,WAAAA,GACA,CAAA,GAAA,YAAA,GAAA,EAACuB,UAAAA;4CACCC,MAAK;4CACLjB,OAAOO,aAAAA,WAAW,CAACW,eAAe;4CAClCC,SAAS;gDACP,IAAIC,OAAOC,OAAO,CAACC,MAAM,GAAG,GAAG;oDAC7BF,OAAOC,OAAO,CAACE,IAAI;gDACrB,OAAO;oDACLH,OAAOI,QAAQ,CAACC,IAAI,GAAG;gDACzB;4CACF;sDACD;;;;gCAKJjC,UAAAA,WAAAA,GACC,CAAA,GAAA,YAAA,GAAA,EAACc,OAAAA;oCAAIN,OAAOO,aAAAA,WAAW,CAACmB,eAAe;8CACrC,WAAA,GAAA,CAAA,GAAA,YAAA,IAAA,EAACd,KAAAA;wCAAEZ,OAAOO,aAAAA,WAAW,CAACf,MAAM;;4CAAE;4CACX;0DACjB,CAAA,GAAA,YAAA,GAAA,EAACmC,QAAAA;gDAAK3B,OAAOO,aAAAA,WAAW,CAACqB,UAAU;0DAAGpC;;;;;;;;;;;;AASxD;MAIA,WAAeF","ignoreList":[0]}},
    {"offset": {"line": 1443, "column": 0}, "map": {"version":3,"sources":["file:///D:/AconnectJP/node_modules/next/src/client/dev/runtime-error-handler.ts"],"sourcesContent":["export const RuntimeErrorHandler = {\n  hadRuntimeError: false,\n}\n"],"names":["RuntimeErrorHandler","hadRuntimeError"],"mappings":";;;+BAAaA,uBAAAA;;;eAAAA;;;AAAN,MAAMA,sBAAsB;IACjCC,iBAAiB;AACnB","ignoreList":[0]}},
    {"offset": {"line": 1466, "column": 0}, "map": {"version":3,"sources":["file:///D:/AconnectJP/node_modules/next/src/client/components/not-found.ts"],"sourcesContent":["import {\n  HTTP_ERROR_FALLBACK_ERROR_CODE,\n  type HTTPAccessFallbackError,\n} from './http-access-fallback/http-access-fallback'\n\n/**\n * This function allows you to render the [not-found.js file](https://nextjs.org/docs/app/api-reference/file-conventions/not-found)\n * within a route segment as well as inject a tag.\n *\n * `notFound()` can be used in\n * [Server Components](https://nextjs.org/docs/app/building-your-application/rendering/server-components),\n * [Route Handlers](https://nextjs.org/docs/app/building-your-application/routing/route-handlers), and\n * [Server Actions](https://nextjs.org/docs/app/building-your-application/data-fetching/server-actions-and-mutations).\n *\n * - In a Server Component, this will insert a `<meta name=\"robots\" content=\"noindex\" />` meta tag and set the status code to 404.\n * - In a Route Handler or Server Action, it will serve a 404 to the caller.\n *\n * Read more: [Next.js Docs: `notFound`](https://nextjs.org/docs/app/api-reference/functions/not-found)\n */\n\nconst DIGEST = `${HTTP_ERROR_FALLBACK_ERROR_CODE};404`\n\nexport function notFound(): never {\n  const error = new Error(DIGEST) as HTTPAccessFallbackError\n  ;(error as HTTPAccessFallbackError).digest = DIGEST\n\n  throw error\n}\n"],"names":["notFound","DIGEST","HTTP_ERROR_FALLBACK_ERROR_CODE","error","Error","digest"],"mappings":";;;+BAsBgBA,YAAAA;;;eAAAA;;;oCAnBT;AAEP;;;;;;;;;;;;;CAaC,GAED,MAAMC,SAAS,GAAGC,oBAAAA,8BAA8B,CAAC,IAAI,CAAC;AAE/C,SAASF;IACd,MAAMG,QAAQ,OAAA,cAAiB,CAAjB,IAAIC,MAAMH,SAAV,qBAAA;eAAA;oBAAA;sBAAA;IAAgB;IAC5BE,MAAkCE,MAAM,GAAGJ;IAE7C,MAAME;AACR","ignoreList":[0]}},
    {"offset": {"line": 1510, "column": 0}, "map": {"version":3,"sources":["file:///D:/AconnectJP/node_modules/next/src/client/react-client-callbacks/error-boundary-callbacks.ts"],"sourcesContent":["// This file is only used in app router due to the specific error state handling.\n\nimport type { ErrorInfo } from 'react'\nimport { isNextRouterError } from '../components/is-next-router-error'\nimport { isBailoutToCSRError } from '../../shared/lib/lazy-dynamic/bailout-to-csr'\nimport { reportGlobalError } from './report-global-error'\nimport { ErrorBoundaryHandler } from '../components/error-boundary'\nimport DefaultErrorBoundary from '../components/builtin/global-error'\n\nconst devToolErrorMod: typeof import('../../next-devtools/userspace/app/errors') =\n  process.env.NODE_ENV !== 'production'\n    ? (require('../../next-devtools/userspace/app/errors') as typeof import('../../next-devtools/userspace/app/errors'))\n    : {\n        decorateDevError: (error: unknown) => error as Error,\n        handleClientError: () => {},\n        originConsoleError: console.error.bind(console),\n      }\n\nexport function onCaughtError(\n  thrownValue: unknown,\n  errorInfo: ErrorInfo & { errorBoundary?: React.Component }\n) {\n  const errorBoundaryComponent = errorInfo.errorBoundary?.constructor\n\n  let isImplicitErrorBoundary\n\n  if (process.env.NODE_ENV !== 'production') {\n    const { AppDevOverlayErrorBoundary } =\n      require('../../next-devtools/userspace/app/app-dev-overlay-error-boundary') as typeof import('../../next-devtools/userspace/app/app-dev-overlay-error-boundary')\n\n    isImplicitErrorBoundary =\n      errorBoundaryComponent === AppDevOverlayErrorBoundary\n  }\n\n  isImplicitErrorBoundary =\n    isImplicitErrorBoundary ||\n    (errorBoundaryComponent === ErrorBoundaryHandler &&\n      (errorInfo.errorBoundary! as InstanceType<typeof ErrorBoundaryHandler>)\n        .props.errorComponent === DefaultErrorBoundary)\n\n  // Skip the segment explorer triggered error\n  if (process.env.NODE_ENV !== 'production') {\n    const { SEGMENT_EXPLORER_SIMULATED_ERROR_MESSAGE } =\n      require('../../next-devtools/userspace/app/segment-explorer-node') as typeof import('../../next-devtools/userspace/app/segment-explorer-node')\n    if (\n      thrownValue instanceof Error &&\n      thrownValue.message === SEGMENT_EXPLORER_SIMULATED_ERROR_MESSAGE\n    ) {\n      return\n    }\n  }\n\n  if (isImplicitErrorBoundary) {\n    // We don't consider errors caught unless they're caught by an explicit error\n    // boundary. The built-in ones are considered implicit.\n    // This mimics how the same app would behave without Next.js.\n    return onUncaughtError(thrownValue)\n  }\n\n  // Skip certain custom errors which are not expected to be reported on client\n  if (isBailoutToCSRError(thrownValue) || isNextRouterError(thrownValue)) return\n\n  if (process.env.NODE_ENV !== 'production') {\n    const errorBoundaryName =\n      // read react component displayName\n      (errorBoundaryComponent as any)?.displayName ||\n      errorBoundaryComponent?.name ||\n      'Unknown'\n\n    const componentThatErroredFrame = errorInfo?.componentStack?.split('\\n')[1]\n\n    // Match chrome or safari stack trace\n    const matches =\n      // regex to match the function name in the stack trace\n      // example 1: at Page (http://localhost:3000/_next/static/chunks/pages/index.js?ts=1631600000000:2:1)\n      // example 2: Page@http://localhost:3000/_next/static/chunks/pages/index.js?ts=1631600000000:2:1\n      componentThatErroredFrame?.match(/\\s+at (\\w+)\\s+|(\\w+)@/) ?? []\n    const componentThatErroredName = matches[1] || matches[2] || 'Unknown'\n\n    // Create error location with errored component and error boundary, to match the behavior of default React onCaughtError handler.\n    const errorBoundaryMessage = `It was handled by the <${errorBoundaryName}> error boundary.`\n    const componentErrorMessage = componentThatErroredName\n      ? `The above error occurred in the <${componentThatErroredName}> component.`\n      : `The above error occurred in one of your components.`\n\n    const errorLocation = `${componentErrorMessage} ${errorBoundaryMessage}`\n    const error = devToolErrorMod.decorateDevError(thrownValue)\n\n    // Log and report the error with location but without modifying the error stack\n    devToolErrorMod.originConsoleError('%o\\n\\n%s', thrownValue, errorLocation)\n\n    devToolErrorMod.handleClientError(error)\n  } else {\n    devToolErrorMod.originConsoleError(thrownValue)\n  }\n}\n\nexport function onUncaughtError(thrownValue: unknown) {\n  // Skip certain custom errors which are not expected to be reported on client\n  if (isBailoutToCSRError(thrownValue) || isNextRouterError(thrownValue)) return\n\n  if (process.env.NODE_ENV !== 'production') {\n    const error = devToolErrorMod.decorateDevError(thrownValue)\n\n    // TODO: Add an adendum to the overlay telling people about custom error boundaries.\n    reportGlobalError(error)\n  } else {\n    reportGlobalError(thrownValue)\n  }\n}\n"],"names":["onCaughtError","onUncaughtError","devToolErrorMod","process","env","NODE_ENV","require","decorateDevError","error","handleClientError","originConsoleError","console","bind","thrownValue","errorInfo","errorBoundaryComponent","errorBoundary","constructor","isImplicitErrorBoundary","AppDevOverlayErrorBoundary","ErrorBoundaryHandler","props","errorComponent","DefaultErrorBoundary","SEGMENT_EXPLORER_SIMULATED_ERROR_MESSAGE","Error","message","isBailoutToCSRError","isNextRouterError","errorBoundaryName","displayName","name","componentThatErroredFrame","componentStack","split","matches","match","componentThatErroredName","errorBoundaryMessage","componentErrorMessage","errorLocation","reportGlobalError"],"mappings":"AAUEG,QAAQC,GAAG,CAACC,QAAQ,KAAK,eACpBC,QAAQ;AAXf,iFAAiF;;;;;;;;;;;;;;;;IAkBjEN,aAAa,EAAA;eAAbA;;IA+EAC,eAAe,EAAA;eAAfA;;;;mCA9FkB;8BACE;mCACF;+BACG;sEACJ;AAEjC,MAAMC,6LAGA;AAMC,SAASF,cACda,WAAoB,EACpBC,SAA0D;IAE1D,MAAMC,yBAAyBD,UAAUE,aAAa,EAAEC;IAExD,IAAIC;IAEJ,IAAIf,QAAQC,GAAG,CAACC,QAAQ,KAAK,WAAc;QACzC,MAAM,EAAEc,0BAA0B,EAAE,GAClCb,QAAQ;QAEVY,0BACEH,2BAA2BI;IAC/B;IAEAD,0BACEA,2BACCH,2BAA2BK,eAAAA,oBAAoB,IAC7CN,UAAUE,aAAa,CACrBK,KAAK,CAACC,cAAc,KAAKC,aAAAA,OAAoB;IAEpD,4CAA4C;IAC5C,IAAIpB,QAAQC,GAAG,CAACC,QAAQ,KAAK,WAAc;QACzC,MAAM,EAAEmB,wCAAwC,EAAE,GAChDlB,QAAQ;QACV,IACEO,uBAAuBY,SACvBZ,YAAYa,OAAO,KAAKF,0CACxB;YACA;QACF;IACF;IAEA,IAAIN,yBAAyB;QAC3B,6EAA6E;QAC7E,uDAAuD;QACvD,6DAA6D;QAC7D,OAAOjB,gBAAgBY;IACzB;IAEA,6EAA6E;IAC7E,IAAIc,CAAAA,GAAAA,cAAAA,mBAAmB,EAACd,gBAAgBe,CAAAA,GAAAA,mBAAAA,iBAAiB,EAACf,cAAc;IAExE,IAAIV,QAAQC,GAAG,CAACC,QAAQ,KAAK,WAAc;QACzC,MAAMwB,oBAEJ,AADA,AACCd,wBAAgCe,WADE,IAEnCf,wBAAwBgB,QACxB;QAEF,MAAMC,4BAA4BlB,WAAWmB,gBAAgBC,MAAM,KAAK,CAAC,EAAE;QAE3E,qCAAqC;QACrC,MAAMC,UACJ,AACA,sDADsD,+CAC+C;QACrG,gGAAgG;QAChGH,2BAA2BI,MAAM,4BAA4B,EAAE;QACjE,MAAMC,2BAA2BF,OAAO,CAAC,EAAE,IAAIA,OAAO,CAAC,EAAE,IAAI;QAE7D,iIAAiI;QACjI,MAAMG,uBAAuB,CAAC,uBAAuB,EAAET,kBAAkB,iBAAiB,CAAC;QAC3F,MAAMU,wBAAwBF,uCAC1B,CAAC,iCAAiC,EAAEA,yBAAyB,YAAY,CAAC,GAC1E,CAAC,mDAAmD,CAAC;QAEzD,MAAMG,gBAAgB,GAAGD,sBAAsB,CAAC,EAAED,sBAAsB;QACxE,MAAM9B,QAAQN,gBAAgBK,gBAAgB,CAACM;QAE/C,+EAA+E;QAC/EX,gBAAgBQ,kBAAkB,CAAC,YAAYG,aAAa2B;QAE5DtC,gBAAgBO,iBAAiB,CAACD;IACpC,OAAO;;AAGT;AAEO,SAASP,gBAAgBY,WAAoB;IAClD,6EAA6E;IAC7E,IAAIc,CAAAA,GAAAA,cAAAA,mBAAmB,EAACd,gBAAgBe,CAAAA,GAAAA,mBAAAA,iBAAiB,EAACf,cAAc;IAExE,IAAIV,QAAQC,GAAG,CAACC,QAAQ,KAAK,WAAc;QACzC,MAAMG,QAAQN,gBAAgBK,gBAAgB,CAACM;QAE/C,oFAAoF;QACpF4B,CAAAA,GAAAA,mBAAAA,iBAAiB,EAACjC;IACpB,OAAO;;AAGT","ignoreList":[0]}},
    {"offset": {"line": 1604, "column": 0}, "map": {"version":3,"sources":["file:///D:/AconnectJP/node_modules/next/src/client/components/router-reducer/router-reducer-types.ts"],"sourcesContent":["import type { CacheNode } from '../../../shared/lib/app-router-types'\nimport type {\n  FlightRouterState,\n  FlightSegmentPath,\n} from '../../../shared/lib/app-router-types'\nimport type { NavigationSeed } from '../segment-cache/navigation'\nimport type { FetchServerResponseResult } from './fetch-server-response'\n\nexport const ACTION_REFRESH = 'refresh'\nexport const ACTION_NAVIGATE = 'navigate'\nexport const ACTION_RESTORE = 'restore'\nexport const ACTION_SERVER_PATCH = 'server-patch'\nexport const ACTION_HMR_REFRESH = 'hmr-refresh'\nexport const ACTION_SERVER_ACTION = 'server-action'\n\nexport type RouterChangeByServerResponse = ({\n  navigatedAt,\n  previousTree,\n  serverResponse,\n}: {\n  navigatedAt: number\n  previousTree: FlightRouterState\n  serverResponse: FetchServerResponseResult\n}) => void\n\n/**\n * Refresh triggers a refresh of the full page data.\n * - fetches the Flight data and fills rsc at the root of the cache.\n * - The router state is updated at the root.\n */\nexport interface RefreshAction {\n  type: typeof ACTION_REFRESH\n}\n\nexport interface HmrRefreshAction {\n  type: typeof ACTION_HMR_REFRESH\n}\n\nexport type ServerActionDispatcher = (\n  args: Omit<\n    ServerActionAction,\n    'type' | 'mutable' | 'navigate' | 'changeByServerResponse' | 'cache'\n  >\n) => void\n\nexport interface ServerActionAction {\n  type: typeof ACTION_SERVER_ACTION\n  actionId: string\n  actionArgs: any[]\n  resolve: (value: any) => void\n  reject: (reason?: any) => void\n  didRevalidate?: boolean\n}\n\n/**\n * Navigate triggers a navigation to the provided url. It supports two types: `push` and `replace`.\n *\n * `navigateType`:\n * - `push` - pushes a new history entry in the browser history\n * - `replace` - replaces the current history entry in the browser history\n *\n * Navigate has multiple cache heuristics:\n * - page was prefetched\n *  - Apply router state tree from prefetch\n *  - Apply Flight data from prefetch to the cache\n *  - If Flight data is a string, it's a redirect and the state is updated to trigger a redirect\n *  - Check if hard navigation is needed\n *    - Hard navigation happens when a dynamic parameter below the common layout changed\n *    - When hard navigation is needed the cache is invalidated below the flightSegmentPath\n *    - The missing cache nodes of the page will be fetched in layout-router and trigger the SERVER_PATCH action\n *  - If hard navigation is not needed\n *    - The cache is reused\n *    - If any cache nodes are missing they'll be fetched in layout-router and trigger the SERVER_PATCH action\n * - page was not prefetched\n *  - The navigate was called from `next/router` (`router.push()` / `router.replace()`) / `next/link` without prefetched data available (e.g. the prefetch didn't come back from the server before clicking the link)\n *    - Flight data is fetched in the reducer (suspends the reducer)\n *    - Router state tree is created based on Flight data\n *    - Cache is filled based on the Flight data\n *\n * Above steps explain 3 cases:\n * - `soft` - Reuses the existing cache and fetches missing nodes in layout-router.\n * - `hard` - Creates a new cache where cache nodes are removed below the common layout and fetches missing nodes in layout-router.\n * - `optimistic` (explicit no prefetch) - Creates a new cache and kicks off the data fetch in the reducer. The data fetch is awaited in the layout-router.\n */\nexport interface NavigateAction {\n  type: typeof ACTION_NAVIGATE\n  url: URL\n  isExternalUrl: boolean\n  locationSearch: Location['search']\n  navigateType: 'push' | 'replace'\n  shouldScroll: boolean\n}\n\n/**\n * Restore applies the provided router state.\n * - Used for `popstate` (back/forward navigation) where a known router state has to be applied.\n * - Also used when syncing the router state with `pushState`/`replaceState` calls.\n * - Router state is applied as-is from the history state, if available.\n * - If the history state does not contain the router state, the existing router state is used.\n * - If any cache node is missing it will be fetched in layout-router during rendering and the server-patch case.\n * - If existing cache nodes match these are used.\n */\nexport interface RestoreAction {\n  type: typeof ACTION_RESTORE\n  url: URL\n  historyState: AppHistoryState | undefined\n}\n\nexport type AppHistoryState = {\n  tree: FlightRouterState\n  renderedSearch: string\n}\n\n/**\n * Server-patch applies the provided Flight data to the cache and router tree.\n */\nexport interface ServerPatchAction {\n  type: typeof ACTION_SERVER_PATCH\n  previousTree: FlightRouterState\n  url: URL\n  nextUrl: string | null\n  seed: NavigationSeed | null\n  mpa: boolean\n}\n\n/**\n * PrefetchKind defines the type of prefetching that should be done.\n * - `auto` - if the page is dynamic, prefetch the page data partially, if static prefetch the page data fully.\n * - `full` - prefetch the page data fully.\n */\n\nexport enum PrefetchKind {\n  AUTO = 'auto',\n  FULL = 'full',\n}\n\n/**\n * Prefetch adds the provided FlightData to the prefetch cache\n * - Creates the router state tree based on the patch in FlightData\n * - Adds the FlightData to the prefetch cache\n * - In ACTION_NAVIGATE the prefetch cache is checked and the router state tree and FlightData are applied.\n */\n\nexport interface PushRef {\n  /**\n   * If the app-router should push a new history entry in app-router's useEffect()\n   */\n  pendingPush: boolean\n  /**\n   * Multi-page navigation through location.href.\n   */\n  mpaNavigation: boolean\n  /**\n   * Skip applying the router state to the browser history state.\n   */\n  preserveCustomHistoryState: boolean\n}\n\nexport type FocusAndScrollRef = {\n  /**\n   * If focus and scroll should be set in the layout-router's useEffect()\n   */\n  apply: boolean\n  /**\n   * The hash fragment that should be scrolled to.\n   */\n  hashFragment: string | null\n  /**\n   * The paths of the segments that should be focused.\n   */\n  segmentPaths: FlightSegmentPath[]\n  /**\n   * If only the URLs hash fragment changed\n   */\n  onlyHashChange: boolean\n}\n\n/**\n * Handles keeping the state of app-router.\n */\nexport type AppRouterState = {\n  /**\n   * The router state, this is written into the history state in app-router using replaceState/pushState.\n   * - Has to be serializable as it is written into the history state.\n   * - Holds which segments and parallel routes are shown on the screen.\n   */\n  tree: FlightRouterState\n  /**\n   * The cache holds React nodes for every segment that is shown on screen as well as previously shown segments.\n   * It also holds in-progress data requests.\n   */\n  cache: CacheNode\n  /**\n   * Decides if the update should create a new history entry and if the navigation has to trigger a browser navigation.\n   */\n  pushRef: PushRef\n  /**\n   * Decides if the update should apply scroll and focus management.\n   */\n  focusAndScrollRef: FocusAndScrollRef\n  /**\n   * The canonical url that is pushed/replaced.\n   * - This is the url you see in the browser.\n   */\n  canonicalUrl: string\n\n  /**\n   * The search query observed by the server during rendering. This may be\n   * different from the canonical URL's search query if the server performed\n   * a rewrite. Even though a client component won't observe this (unless it\n   * were passed from a Server component), the client router needs to know this\n   * so it can properly cache segment data; it'ss part of a page segment's\n   * cache key.\n   */\n  renderedSearch: string\n\n  /**\n   * The underlying \"url\" representing the UI state, which is used for intercepting routes.\n   */\n  nextUrl: string | null\n\n  /**\n   * The previous next-url that was used previous to a dynamic navigation.\n   */\n  previousNextUrl: string | null\n\n  debugInfo: Array<unknown> | null\n}\n\nexport type ReadonlyReducerState = Readonly<AppRouterState>\nexport type ReducerState =\n  | (Promise<AppRouterState> & { _debugInfo?: Array<unknown> })\n  | AppRouterState\nexport type ReducerActions = Readonly<\n  | RefreshAction\n  | NavigateAction\n  | RestoreAction\n  | ServerPatchAction\n  | HmrRefreshAction\n  | ServerActionAction\n>\n"],"names":["ACTION_HMR_REFRESH","ACTION_NAVIGATE","ACTION_REFRESH","ACTION_RESTORE","ACTION_SERVER_ACTION","ACTION_SERVER_PATCH","PrefetchKind"],"mappings":";;;;;;;;;;;;;;;;;;;IAYaA,kBAAkB,EAAA;eAAlBA;;IAHAC,eAAe,EAAA;eAAfA;;IADAC,cAAc,EAAA;eAAdA;;IAEAC,cAAc,EAAA;eAAdA;;IAGAC,oBAAoB,EAAA;eAApBA;;IAFAC,mBAAmB,EAAA;eAAnBA;;IAwHDC,YAAY,EAAA;eAAZA;;;AA3HL,MAAMJ,iBAAiB;AACvB,MAAMD,kBAAkB;AACxB,MAAME,iBAAiB;AACvB,MAAME,sBAAsB;AAC5B,MAAML,qBAAqB;AAC3B,MAAMI,uBAAuB;AAsH7B,IAAKE,eAAAA,WAAAA,GAAAA,SAAAA,YAAAA;;;WAAAA","ignoreList":[0]}},
    {"offset": {"line": 1667, "column": 0}, "map": {"version":3,"sources":["file:///D:/AconnectJP/node_modules/next/src/client/components/use-action-queue.ts"],"sourcesContent":["import type { Dispatch } from 'react'\nimport React, { use, useMemo, useOptimistic } from 'react'\nimport { isThenable } from '../../shared/lib/is-thenable'\nimport type { AppRouterActionQueue } from './app-router-instance'\nimport type {\n  AppRouterState,\n  ReducerActions,\n  ReducerState,\n} from './router-reducer/router-reducer-types'\n\n// The app router state lives outside of React, so we can import the dispatch\n// method directly wherever we need it, rather than passing it around via props\n// or context.\nlet dispatch: Dispatch<ReducerActions> | null = null\n\nexport function dispatchAppRouterAction(action: ReducerActions) {\n  if (dispatch === null) {\n    throw new Error(\n      'Internal Next.js error: Router action dispatched before initialization.'\n    )\n  }\n  dispatch(action)\n}\n\n// Optimistic state setter for experimental_gesturePush. Only should be used\n// during a gesture transition.\nlet setGestureRouterState: ((state: ReducerState) => void) | null = null\n\nexport function dispatchGestureState(state: ReducerState) {\n  if (setGestureRouterState === null) {\n    throw new Error(\n      'Internal Next.js error: Router action dispatched before initialization.'\n    )\n  }\n  setGestureRouterState(state)\n}\n\nconst __DEV__ = process.env.NODE_ENV !== 'production'\nconst promisesWithDebugInfo: WeakMap<\n  Promise<AppRouterState>,\n  Promise<AppRouterState> & { _debugInfo?: Array<unknown> }\n> = __DEV__ ? new WeakMap() : (null as any)\n\nexport function useActionQueue(\n  actionQueue: AppRouterActionQueue\n): AppRouterState {\n  const [canonicalState, setState] = React.useState<ReducerState>(\n    actionQueue.state\n  )\n\n  // Wrap the canonical state in useOptimistic to support\n  // experimental_gesturePush. During a gesture transition, this returns a fork\n  // of the router state that represents the eventual target if/when the gesture\n  // completes. Otherwise it returns the canonical state.\n  const [state, setGesture] = useOptimistic(canonicalState)\n  setGestureRouterState = setGesture\n\n  // Because of a known issue that requires to decode Flight streams inside the\n  // render phase, we have to be a bit clever and assign the dispatch method to\n  // a module-level variable upon initialization. The useState hook in this\n  // module only exists to synchronize state that lives outside of React.\n  // Ideally, what we'd do instead is pass the state as a prop to root.render;\n  // this is conceptually how we're modeling the app router state, despite the\n  // weird implementation details.\n  if (process.env.NODE_ENV !== 'production') {\n    const { useAppDevRenderingIndicator } =\n      require('../../next-devtools/userspace/use-app-dev-rendering-indicator') as typeof import('../../next-devtools/userspace/use-app-dev-rendering-indicator')\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    const appDevRenderingIndicator = useAppDevRenderingIndicator()\n\n    dispatch = (action: ReducerActions) => {\n      appDevRenderingIndicator(() => {\n        actionQueue.dispatch(action, setState)\n      })\n    }\n  } else {\n    dispatch = (action: ReducerActions) =>\n      actionQueue.dispatch(action, setState)\n  }\n\n  // When navigating to a non-prefetched route, then App Router state will be\n  // blocked until the server responds. We need to transfer the `_debugInfo`\n  // from the underlying Flight response onto the top-level promise that is\n  // passed to React (via `use`) so that the latency is accurately represented\n  // in the React DevTools.\n  const stateWithDebugInfo = useMemo(() => {\n    if (!__DEV__) {\n      return state\n    }\n\n    if (isThenable(state)) {\n      // useMemo can't be used to cache a Promise since the memoized value is thrown\n      // away when we suspend. So we use a WeakMap to cache the Promise with debug info.\n      let promiseWithDebugInfo = promisesWithDebugInfo.get(state)\n      if (promiseWithDebugInfo === undefined) {\n        const debugInfo: Array<unknown> = []\n        promiseWithDebugInfo = Promise.resolve(state).then((asyncState) => {\n          if (asyncState.debugInfo !== null) {\n            debugInfo.push(...asyncState.debugInfo)\n          }\n          return asyncState\n        }) as Promise<AppRouterState> & { _debugInfo?: Array<unknown> }\n        promiseWithDebugInfo._debugInfo = debugInfo\n\n        promisesWithDebugInfo.set(state, promiseWithDebugInfo)\n      }\n\n      return promiseWithDebugInfo\n    }\n    return state\n  }, [state])\n\n  return isThenable(stateWithDebugInfo)\n    ? use(stateWithDebugInfo)\n    : stateWithDebugInfo\n}\n"],"names":["dispatchAppRouterAction","dispatchGestureState","useActionQueue","dispatch","action","Error","setGestureRouterState","state","__DEV__","process","env","NODE_ENV","promisesWithDebugInfo","WeakMap","actionQueue","canonicalState","setState","React","useState","setGesture","useOptimistic","useAppDevRenderingIndicator","require","appDevRenderingIndicator","stateWithDebugInfo","useMemo","isThenable","promiseWithDebugInfo","get","undefined","debugInfo","Promise","resolve","then","asyncState","push","_debugInfo","set","use"],"mappings":"AAqCgBS,QAAQC,GAAG,CAACC,QAAQ;;;;;;;;;;;;;;;;;IAtBpBX,uBAAuB,EAAA;eAAvBA;;IAaAC,oBAAoB,EAAA;eAApBA;;IAeAC,cAAc,EAAA;eAAdA;;;;iEA1CmC;4BACxB;AAQ3B,6EAA6E;AAC7E,+EAA+E;AAC/E,cAAc;AACd,IAAIC,WAA4C;AAEzC,SAASH,wBAAwBI,MAAsB;IAC5D,IAAID,aAAa,MAAM;QACrB,MAAM,OAAA,cAEL,CAFK,IAAIE,MACR,4EADI,qBAAA;mBAAA;wBAAA;0BAAA;QAEN;IACF;IACAF,SAASC;AACX;AAEA,4EAA4E;AAC5E,+BAA+B;AAC/B,IAAIE,wBAAgE;AAE7D,SAASL,qBAAqBM,KAAmB;IACtD,IAAID,0BAA0B,MAAM;QAClC,MAAM,OAAA,cAEL,CAFK,IAAID,MACR,4EADI,qBAAA;mBAAA;wBAAA;0BAAA;QAEN;IACF;IACAC,sBAAsBC;AACxB;AAEA,MAAMC,8DAAmC;AACzC,MAAMI,wBAGFJ,uCAAU,IAAIK,YAAa;AAExB,SAASX,eACdY,WAAiC;IAEjC,MAAM,CAACC,gBAAgBC,SAAS,GAAGC,OAAAA,OAAK,CAACC,QAAQ,CAC/CJ,YAAYP,KAAK;IAGnB,uDAAuD;IACvD,6EAA6E;IAC7E,8EAA8E;IAC9E,uDAAuD;IACvD,MAAM,CAACA,OAAOY,WAAW,GAAGC,CAAAA,GAAAA,OAAAA,aAAa,EAACL;IAC1CT,wBAAwBa;IAExB,6EAA6E;IAC7E,6EAA6E;IAC7E,yEAAyE;IACzE,uEAAuE;IACvE,4EAA4E;IAC5E,4EAA4E;IAC5E,gCAAgC;IAChC,IAAIV,QAAQC,GAAG,CAACC,QAAQ,KAAK,WAAc;QACzC,MAAM,EAAEU,2BAA2B,EAAE,GACnCC,QAAQ;QACV,sDAAsD;QACtD,MAAMC,2BAA2BF;QAEjClB,WAAW,CAACC;YACVmB,yBAAyB;gBACvBT,YAAYX,QAAQ,CAACC,QAAQY;YAC/B;QACF;IACF,OAAO;;IAKP,2EAA2E;IAC3E,0EAA0E;IAC1E,yEAAyE;IACzE,4EAA4E;IAC5E,yBAAyB;IACzB,MAAMQ,qBAAqBC,CAAAA,GAAAA,OAAAA,OAAO,EAAC;QACjC,IAAI,CAACjB,SAAS;;QAId,IAAIkB,CAAAA,GAAAA,YAAAA,UAAU,EAACnB,QAAQ;YACrB,8EAA8E;YAC9E,kFAAkF;YAClF,IAAIoB,uBAAuBf,sBAAsBgB,GAAG,CAACrB;YACrD,IAAIoB,yBAAyBE,WAAW;gBACtC,MAAMC,YAA4B,EAAE;gBACpCH,uBAAuBI,QAAQC,OAAO,CAACzB,OAAO0B,IAAI,CAAC,CAACC;oBAClD,IAAIA,WAAWJ,SAAS,KAAK,MAAM;wBACjCA,UAAUK,IAAI,IAAID,WAAWJ,SAAS;oBACxC;oBACA,OAAOI;gBACT;gBACAP,qBAAqBS,UAAU,GAAGN;gBAElClB,sBAAsByB,GAAG,CAAC9B,OAAOoB;YACnC;YAEA,OAAOA;QACT;QACA,OAAOpB;IACT,GAAG;QAACA;KAAM;IAEV,OAAOmB,CAAAA,GAAAA,YAAAA,UAAU,EAACF,sBACdc,CAAAA,GAAAA,OAAAA,GAAG,EAACd,sBACJA;AACN","ignoreList":[0]}},
    {"offset": {"line": 1794, "column": 0}, "map": {"version":3,"sources":["file:///D:/AconnectJP/node_modules/next/src/client/app-call-server.ts"],"sourcesContent":["import { startTransition } from 'react'\nimport { ACTION_SERVER_ACTION } from './components/router-reducer/router-reducer-types'\nimport { dispatchAppRouterAction } from './components/use-action-queue'\n\nexport async function callServer(actionId: string, actionArgs: any[]) {\n  return new Promise((resolve, reject) => {\n    startTransition(() => {\n      dispatchAppRouterAction({\n        type: ACTION_SERVER_ACTION,\n        actionId,\n        actionArgs,\n        resolve,\n        reject,\n      })\n    })\n  })\n}\n"],"names":["callServer","actionId","actionArgs","Promise","resolve","reject","startTransition","dispatchAppRouterAction","type","ACTION_SERVER_ACTION"],"mappings":";;;+BAIsBA,cAAAA;;;eAAAA;;;uBAJU;oCACK;gCACG;AAEjC,eAAeA,WAAWC,QAAgB,EAAEC,UAAiB;IAClE,OAAO,IAAIC,QAAQ,CAACC,SAASC;QAC3BC,CAAAA,GAAAA,OAAAA,eAAe,EAAC;YACdC,CAAAA,GAAAA,gBAAAA,uBAAuB,EAAC;gBACtBC,MAAMC,oBAAAA,oBAAoB;gBAC1BR;gBACAC;gBACAE;gBACAC;YACF;QACF;IACF;AACF","ignoreList":[0]}},
    {"offset": {"line": 1830, "column": 0}, "map": {"version":3,"sources":["file:///D:/AconnectJP/node_modules/next/src/client/app-find-source-map-url.ts"],"sourcesContent":["const basePath = process.env.__NEXT_ROUTER_BASEPATH || ''\nconst pathname = `${basePath}/__nextjs_source-map`\n\nexport const findSourceMapURL =\n  process.env.NODE_ENV === 'development'\n    ? function findSourceMapURL(filename: string): string | null {\n        if (filename === '') {\n          return null\n        }\n\n        if (\n          filename.startsWith(document.location.origin) &&\n          filename.includes('/_next/static')\n        ) {\n          // This is a request for a client chunk. This can only happen when\n          // using Turbopack. In this case, since we control how those source\n          // maps are generated, we can safely assume that the sourceMappingURL\n          // is relative to the filename, with an added `.map` extension. The\n          // browser can just request this file, and it gets served through the\n          // normal dev server, without the need to route this through\n          // the `/__nextjs_source-map` dev middleware.\n          return `${filename}.map`\n        }\n\n        const url = new URL(pathname, document.location.origin)\n        url.searchParams.set('filename', filename)\n\n        return url.href\n      }\n    : undefined\n"],"names":["findSourceMapURL","basePath","process","env","__NEXT_ROUTER_BASEPATH","pathname","NODE_ENV","filename","startsWith","document","location","origin","includes","url","URL","searchParams","set","href","undefined"],"mappings":"AAAiBE,QAAQC,GAAG,CAACC,sBAAsB;;;;;+BAGtCJ,oBAAAA;;;eAAAA;;;AAHb,MAAMC,mDAAiD;AACvD,MAAMI,WAAW,GAAGJ,SAAS,oBAAoB,CAAC;AAE3C,MAAMD,mBACXE,QAAQC,GAAG,CAACG,QAAQ,KAAK,cACrB,SAASN,iBAAiBO,QAAgB;IACxC,IAAIA,aAAa,IAAI;QACnB,OAAO;IACT;IAEA,IACEA,SAASC,UAAU,CAACC,SAASC,QAAQ,CAACC,MAAM,KAC5CJ,SAASK,QAAQ,CAAC,kBAClB;QACA,kEAAkE;QAClE,mEAAmE;QACnE,qEAAqE;QACrE,mEAAmE;QACnE,qEAAqE;QACrE,4DAA4D;QAC5D,6CAA6C;QAC7C,OAAO,GAAGL,SAAS,IAAI,CAAC;IAC1B;IAEA,MAAMM,MAAM,IAAIC,IAAIT,UAAUI,SAASC,QAAQ,CAACC,MAAM;IACtDE,IAAIE,YAAY,CAACC,GAAG,CAAC,YAAYT;IAEjC,OAAOM,IAAII,IAAI;AACjB,IACAC","ignoreList":[0]}},
    {"offset": {"line": 1872, "column": 0}, "map": {"version":3,"sources":["file:///D:/AconnectJP/node_modules/next/src/client/route-params.ts"],"sourcesContent":["import type { DynamicParamTypesShort } from '../shared/lib/app-router-types'\nimport {\n  addSearchParamsIfPageSegment,\n  DEFAULT_SEGMENT_KEY,\n  PAGE_SEGMENT_KEY,\n} from '../shared/lib/segment'\nimport { ROOT_SEGMENT_REQUEST_KEY } from '../shared/lib/segment-cache/segment-value-encoding'\nimport {\n  NEXT_REWRITTEN_PATH_HEADER,\n  NEXT_REWRITTEN_QUERY_HEADER,\n  NEXT_RSC_UNION_QUERY,\n} from './components/app-router-headers'\nimport type {\n  NormalizedPathname,\n  NormalizedSearch,\n} from './components/segment-cache/cache-key'\nimport type { RSCResponse } from './components/router-reducer/fetch-server-response'\nimport type { ParsedUrlQuery } from 'querystring'\n\nexport type RouteParamValue = string | Array<string> | null\n\nexport function getRenderedSearch(\n  response: RSCResponse<unknown> | Response\n): NormalizedSearch {\n  // If the server performed a rewrite, the search params used to render the\n  // page will be different from the params in the request URL. In this case,\n  // the response will include a header that gives the rewritten search query.\n  const rewrittenQuery = response.headers.get(NEXT_REWRITTEN_QUERY_HEADER)\n  if (rewrittenQuery !== null) {\n    return (\n      rewrittenQuery === '' ? '' : '?' + rewrittenQuery\n    ) as NormalizedSearch\n  }\n  // If the header is not present, there was no rewrite, so we use the search\n  // query of the response URL.\n  return urlToUrlWithoutFlightMarker(new URL(response.url))\n    .search as NormalizedSearch\n}\n\nexport function getRenderedPathname(\n  response: RSCResponse<unknown> | Response\n): NormalizedPathname {\n  // If the server performed a rewrite, the pathname used to render the\n  // page will be different from the pathname in the request URL. In this case,\n  // the response will include a header that gives the rewritten pathname.\n  const rewrittenPath = response.headers.get(NEXT_REWRITTEN_PATH_HEADER)\n  return (rewrittenPath ??\n    urlToUrlWithoutFlightMarker(new URL(response.url))\n      .pathname) as NormalizedPathname\n}\n\nexport function parseDynamicParamFromURLPart(\n  paramType: DynamicParamTypesShort,\n  pathnameParts: Array<string>,\n  partIndex: number\n): RouteParamValue {\n  // This needs to match the behavior in get-dynamic-param.ts.\n  switch (paramType) {\n    // Catchalls\n    case 'c': {\n      // Catchalls receive all the remaining URL parts. If there are no\n      // remaining pathname parts, return an empty array.\n      return partIndex < pathnameParts.length\n        ? pathnameParts.slice(partIndex).map((s) => encodeURIComponent(s))\n        : []\n    }\n    // Catchall intercepted\n    case 'ci(..)(..)':\n    case 'ci(.)':\n    case 'ci(..)':\n    case 'ci(...)': {\n      const prefix = paramType.length - 2\n      return partIndex < pathnameParts.length\n        ? pathnameParts.slice(partIndex).map((s, i) => {\n            if (i === 0) {\n              return encodeURIComponent(s.slice(prefix))\n            }\n\n            return encodeURIComponent(s)\n          })\n        : []\n    }\n    // Optional catchalls\n    case 'oc': {\n      // Optional catchalls receive all the remaining URL parts, unless this is\n      // the end of the pathname, in which case they return null.\n      return partIndex < pathnameParts.length\n        ? pathnameParts.slice(partIndex).map((s) => encodeURIComponent(s))\n        : null\n    }\n    // Dynamic\n    case 'd': {\n      if (partIndex >= pathnameParts.length) {\n        // The route tree expected there to be more parts in the URL than there\n        // actually are. This could happen if the x-nextjs-rewritten-path header\n        // is incorrectly set, or potentially due to bug in Next.js. TODO:\n        // Should this be a hard error? During a prefetch, we can just abort.\n        // During a client navigation, we could trigger a hard refresh. But if\n        // it happens during initial render, we don't really have any\n        // recovery options.\n        return ''\n      }\n      return encodeURIComponent(pathnameParts[partIndex])\n    }\n    // Dynamic intercepted\n    case 'di(..)(..)':\n    case 'di(.)':\n    case 'di(..)':\n    case 'di(...)': {\n      const prefix = paramType.length - 2\n      if (partIndex >= pathnameParts.length) {\n        // The route tree expected there to be more parts in the URL than there\n        // actually are. This could happen if the x-nextjs-rewritten-path header\n        // is incorrectly set, or potentially due to bug in Next.js. TODO:\n        // Should this be a hard error? During a prefetch, we can just abort.\n        // During a client navigation, we could trigger a hard refresh. But if\n        // it happens during initial render, we don't really have any\n        // recovery options.\n        return ''\n      }\n\n      return encodeURIComponent(pathnameParts[partIndex].slice(prefix))\n    }\n    default:\n      paramType satisfies never\n      return ''\n  }\n}\n\nexport function doesStaticSegmentAppearInURL(segment: string): boolean {\n  // This is not a parameterized segment; however, we need to determine\n  // whether or not this segment appears in the URL. For example, this route\n  // groups do not appear in the URL, so they should be skipped. Any other\n  // special cases must be handled here.\n  // TODO: Consider encoding this directly into the router tree instead of\n  // inferring it on the client based on the segment type. Something like\n  // a `doesAppearInURL` flag in FlightRouterState.\n  if (\n    segment === ROOT_SEGMENT_REQUEST_KEY ||\n    // For some reason, the loader tree sometimes includes extra __PAGE__\n    // \"layouts\" when part of a parallel route. But it's not a leaf node.\n    // Otherwise, we wouldn't need this special case because pages are\n    // always leaf nodes.\n    // TODO: Investigate why the loader produces these fake page segments.\n    segment.startsWith(PAGE_SEGMENT_KEY) ||\n    // Route groups.\n    (segment[0] === '(' && segment.endsWith(')')) ||\n    segment === DEFAULT_SEGMENT_KEY ||\n    segment === '/_not-found'\n  ) {\n    return false\n  } else {\n    // All other segment types appear in the URL\n    return true\n  }\n}\n\nexport function getCacheKeyForDynamicParam(\n  paramValue: RouteParamValue,\n  renderedSearch: NormalizedSearch\n): string {\n  // This needs to match the logic in get-dynamic-param.ts, until we're able to\n  // unify the various implementations so that these are always computed on\n  // the client.\n  if (typeof paramValue === 'string') {\n    // TODO: Refactor or remove this helper function to accept a string rather\n    // than the whole segment type. Also we can probably just append the\n    // search string instead of turning it into JSON.\n    const pageSegmentWithSearchParams = addSearchParamsIfPageSegment(\n      paramValue,\n      Object.fromEntries(new URLSearchParams(renderedSearch))\n    ) as string\n    return pageSegmentWithSearchParams\n  } else if (paramValue === null) {\n    return ''\n  } else {\n    return paramValue.join('/')\n  }\n}\n\nexport function urlToUrlWithoutFlightMarker(url: URL): URL {\n  const urlWithoutFlightParameters = new URL(url)\n  urlWithoutFlightParameters.searchParams.delete(NEXT_RSC_UNION_QUERY)\n  if (process.env.NODE_ENV === 'production') {\n    if (\n      process.env.__NEXT_CONFIG_OUTPUT === 'export' &&\n      urlWithoutFlightParameters.pathname.endsWith('.txt')\n    ) {\n      const { pathname } = urlWithoutFlightParameters\n      const length = pathname.endsWith('/index.txt') ? 10 : 4\n      // Slice off `/index.txt` or `.txt` from the end of the pathname\n      urlWithoutFlightParameters.pathname = pathname.slice(0, -length)\n    }\n  }\n  return urlWithoutFlightParameters\n}\n\nexport function getParamValueFromCacheKey(\n  paramCacheKey: string,\n  paramType: DynamicParamTypesShort\n) {\n  // Turn the cache key string sent by the server (as part of FlightRouterState)\n  // into a value that can be passed to `useParams` and client components.\n  const isCatchAll = paramType === 'c' || paramType === 'oc'\n  if (isCatchAll) {\n    // Catch-all param keys are a concatenation of the path segments.\n    // See equivalent logic in `getSelectedParams`.\n    // TODO: We should just pass the array directly, rather than concatenate\n    // it to a string and then split it back to an array. It needs to be an\n    // array in some places, like when passing a key React, but we can convert\n    // it at runtime in those places.\n    return paramCacheKey.split('/')\n  }\n  return paramCacheKey\n}\n\nexport function urlSearchParamsToParsedUrlQuery(\n  searchParams: URLSearchParams\n): ParsedUrlQuery {\n  // Converts a URLSearchParams object to the same type used by the server when\n  // creating search params props, i.e. the type returned by Node's\n  // \"querystring\" module.\n  const result: ParsedUrlQuery = {}\n  for (const [key, value] of searchParams.entries()) {\n    if (result[key] === undefined) {\n      result[key] = value\n    } else if (Array.isArray(result[key])) {\n      result[key].push(value)\n    } else {\n      result[key] = [result[key], value]\n    }\n  }\n  return result\n}\n"],"names":["doesStaticSegmentAppearInURL","getCacheKeyForDynamicParam","getParamValueFromCacheKey","getRenderedPathname","getRenderedSearch","parseDynamicParamFromURLPart","urlSearchParamsToParsedUrlQuery","urlToUrlWithoutFlightMarker","response","rewrittenQuery","headers","get","NEXT_REWRITTEN_QUERY_HEADER","URL","url","search","rewrittenPath","NEXT_REWRITTEN_PATH_HEADER","pathname","paramType","pathnameParts","partIndex","length","slice","map","s","encodeURIComponent","prefix","i","segment","ROOT_SEGMENT_REQUEST_KEY","startsWith","PAGE_SEGMENT_KEY","endsWith","DEFAULT_SEGMENT_KEY","paramValue","renderedSearch","pageSegmentWithSearchParams","addSearchParamsIfPageSegment","Object","fromEntries","URLSearchParams","join","urlWithoutFlightParameters","searchParams","delete","NEXT_RSC_UNION_QUERY","process","env","NODE_ENV","__NEXT_CONFIG_OUTPUT","paramCacheKey","isCatchAll","split","result","key","value","entries","undefined","Array","isArray","push"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 2100, "column": 0}, "map": {"version":3,"sources":["file:///D:/AconnectJP/node_modules/next/src/client/flight-data-helpers.ts"],"sourcesContent":["import type {\n  CacheNodeSeedData,\n  FlightData,\n  FlightDataPath,\n  FlightRouterState,\n  FlightSegmentPath,\n  Segment,\n  HeadData,\n  InitialRSCPayload,\n} from '../shared/lib/app-router-types'\nimport { PAGE_SEGMENT_KEY } from '../shared/lib/segment'\nimport type { NormalizedSearch } from './components/segment-cache/cache-key'\nimport {\n  getCacheKeyForDynamicParam,\n  parseDynamicParamFromURLPart,\n  doesStaticSegmentAppearInURL,\n  getRenderedPathname,\n  getRenderedSearch,\n} from './route-params'\nimport { createHrefFromUrl } from './components/router-reducer/create-href-from-url'\n\nexport type NormalizedFlightData = {\n  /**\n   * The full `FlightSegmentPath` inclusive of the final `Segment`\n   */\n  segmentPath: FlightSegmentPath\n  /**\n   * The `FlightSegmentPath` exclusive of the final `Segment`\n   */\n  pathToSegment: FlightSegmentPath\n  segment: Segment\n  tree: FlightRouterState\n  seedData: CacheNodeSeedData | null\n  head: HeadData\n  isHeadPartial: boolean\n  isRootRender: boolean\n}\n\n// TODO: We should only have to export `normalizeFlightData`, however because the initial flight data\n// that gets passed to `createInitialRouterState` doesn't conform to the `FlightDataPath` type (it's missing the root segment)\n// we're currently exporting it so we can use it directly. This should be fixed as part of the unification of\n// the different ways we express `FlightSegmentPath`.\nexport function getFlightDataPartsFromPath(\n  flightDataPath: FlightDataPath\n): NormalizedFlightData {\n  // Pick the last 4 items from the `FlightDataPath` to get the [tree, seedData, viewport, isHeadPartial].\n  const flightDataPathLength = 4\n  // tree, seedData, and head are *always* the last three items in the `FlightDataPath`.\n  const [tree, seedData, head, isHeadPartial] =\n    flightDataPath.slice(-flightDataPathLength)\n  // The `FlightSegmentPath` is everything except the last three items. For a root render, it won't be present.\n  const segmentPath = flightDataPath.slice(0, -flightDataPathLength)\n\n  return {\n    // TODO: Unify these two segment path helpers. We are inconsistently pushing an empty segment (\"\")\n    // to the start of the segment path in some places which makes it hard to use solely the segment path.\n    // Look for \"// TODO-APP: remove ''\" in the codebase.\n    pathToSegment: segmentPath.slice(0, -1),\n    segmentPath,\n    // if the `FlightDataPath` corresponds with the root, there'll be no segment path,\n    // in which case we default to ''.\n    segment: segmentPath[segmentPath.length - 1] ?? '',\n    tree,\n    seedData,\n    head,\n    isHeadPartial,\n    isRootRender: flightDataPath.length === flightDataPathLength,\n  }\n}\n\nexport function createInitialRSCPayloadFromFallbackPrerender(\n  response: Response,\n  fallbackInitialRSCPayload: InitialRSCPayload\n): InitialRSCPayload {\n  // This is a static fallback page. In order to hydrate the page, we need to\n  // parse the client params from the URL, but to account for the possibility\n  // that the page was rewritten, we need to check the response headers\n  // for x-nextjs-rewritten-path or x-nextjs-rewritten-query headers. Since\n  // we can't access the headers of the initial document response, the client\n  // performs a fetch request to the current location. Since it's possible that\n  // the fetch request will be dynamically rewritten to a different path than\n  // the initial document, this fetch request delivers _all_ the hydration data\n  // for the page; it was not inlined into the document, like it normally\n  // would be.\n  //\n  // TODO: Consider treating the case where fetch is rewritten to a different\n  // path from the document as a special deopt case. We should optimistically\n  // assume this won't happen, inline the data into the document, and perform\n  // a minimal request (like a HEAD or range request) to verify that the\n  // response matches. Tricky to get right because we need to account for\n  // all the different deployment environments we support, like output:\n  // \"export\" mode, where we currently don't assume that custom response\n  // headers are present.\n\n  // Patch the Flight data sent by the server with the correct params parsed\n  // from the URL + response object.\n  const renderedPathname = getRenderedPathname(response)\n  const renderedSearch = getRenderedSearch(response)\n  const canonicalUrl = createHrefFromUrl(new URL(location.href))\n  const originalFlightDataPath = fallbackInitialRSCPayload.f[0]\n  const originalFlightRouterState = originalFlightDataPath[0]\n  return {\n    b: fallbackInitialRSCPayload.b,\n    c: canonicalUrl.split('/'),\n    q: renderedSearch,\n    i: fallbackInitialRSCPayload.i,\n    f: [\n      [\n        fillInFallbackFlightRouterState(\n          originalFlightRouterState,\n          renderedPathname,\n          renderedSearch as NormalizedSearch\n        ),\n        originalFlightDataPath[1],\n        originalFlightDataPath[2],\n        originalFlightDataPath[2],\n      ],\n    ],\n    m: fallbackInitialRSCPayload.m,\n    G: fallbackInitialRSCPayload.G,\n    S: fallbackInitialRSCPayload.S,\n    h: fallbackInitialRSCPayload.h,\n  }\n}\n\nfunction fillInFallbackFlightRouterState(\n  flightRouterState: FlightRouterState,\n  renderedPathname: string,\n  renderedSearch: NormalizedSearch\n): FlightRouterState {\n  const pathnameParts = renderedPathname.split('/').filter((p) => p !== '')\n  const index = 0\n  return fillInFallbackFlightRouterStateImpl(\n    flightRouterState,\n    renderedSearch,\n    pathnameParts,\n    index\n  )\n}\n\nfunction fillInFallbackFlightRouterStateImpl(\n  flightRouterState: FlightRouterState,\n  renderedSearch: NormalizedSearch,\n  pathnameParts: Array<string>,\n  pathnamePartsIndex: number\n): FlightRouterState {\n  const originalSegment = flightRouterState[0]\n  let newSegment: Segment\n  let doesAppearInURL: boolean\n  if (typeof originalSegment === 'string') {\n    newSegment = originalSegment\n    doesAppearInURL = doesStaticSegmentAppearInURL(originalSegment)\n  } else {\n    const paramName = originalSegment[0]\n    const paramType = originalSegment[2]\n    const staticSiblings = originalSegment[3]\n    const paramValue = parseDynamicParamFromURLPart(\n      paramType,\n      pathnameParts,\n      pathnamePartsIndex\n    )\n    const cacheKey = getCacheKeyForDynamicParam(paramValue, renderedSearch)\n    newSegment = [paramName, cacheKey, paramType, staticSiblings]\n    doesAppearInURL = true\n  }\n\n  // Only increment the index if the segment appears in the URL. If it's a\n  // \"virtual\" segment, like a route group, it remains the same.\n  const childPathnamePartsIndex = doesAppearInURL\n    ? pathnamePartsIndex + 1\n    : pathnamePartsIndex\n\n  const children = flightRouterState[1]\n  const newChildren: { [key: string]: FlightRouterState } = {}\n  for (let key in children) {\n    const childFlightRouterState = children[key]\n    newChildren[key] = fillInFallbackFlightRouterStateImpl(\n      childFlightRouterState,\n      renderedSearch,\n      pathnameParts,\n      childPathnamePartsIndex\n    )\n  }\n\n  const newState: FlightRouterState = [\n    newSegment,\n    newChildren,\n    null,\n    flightRouterState[3],\n    flightRouterState[4],\n  ]\n  return newState\n}\n\nexport function getNextFlightSegmentPath(\n  flightSegmentPath: FlightSegmentPath\n): FlightSegmentPath {\n  // Since `FlightSegmentPath` is a repeated tuple of `Segment` and `ParallelRouteKey`, we slice off two items\n  // to get the next segment path.\n  return flightSegmentPath.slice(2)\n}\n\nexport function normalizeFlightData(\n  flightData: FlightData\n): NormalizedFlightData[] | string {\n  // FlightData can be a string when the server didn't respond with a proper flight response,\n  // or when a redirect happens, to signal to the client that it needs to perform an MPA navigation.\n  if (typeof flightData === 'string') {\n    return flightData\n  }\n\n  return flightData.map((flightDataPath) =>\n    getFlightDataPartsFromPath(flightDataPath)\n  )\n}\n\n/**\n * This function is used to prepare the flight router state for the request.\n * It removes markers that are not needed by the server, and are purely used\n * for stashing state on the client.\n * @param flightRouterState - The flight router state to prepare.\n * @param isHmrRefresh - Whether this is an HMR refresh request.\n * @returns The prepared flight router state.\n */\nexport function prepareFlightRouterStateForRequest(\n  flightRouterState: FlightRouterState,\n  isHmrRefresh?: boolean\n): string {\n  // HMR requests need the complete, unmodified state for proper functionality\n  if (isHmrRefresh) {\n    return encodeURIComponent(JSON.stringify(flightRouterState))\n  }\n\n  return encodeURIComponent(\n    JSON.stringify(stripClientOnlyDataFromFlightRouterState(flightRouterState))\n  )\n}\n\n/**\n * Recursively strips client-only data from FlightRouterState while preserving\n * server-needed information for proper rendering decisions.\n */\nfunction stripClientOnlyDataFromFlightRouterState(\n  flightRouterState: FlightRouterState\n): FlightRouterState {\n  const [\n    segment,\n    parallelRoutes,\n    _refreshState, // Intentionally unused - URLs are client-only\n    refreshMarker,\n    isRootLayout,\n    hasLoadingBoundary,\n  ] = flightRouterState\n\n  // Strip client-only data from the segment\n  const cleanedSegment = stripClientOnlyDataFromSegment(segment)\n\n  // Recursively process parallel routes\n  const cleanedParallelRoutes: { [key: string]: FlightRouterState } = {}\n  for (const [key, childState] of Object.entries(parallelRoutes)) {\n    cleanedParallelRoutes[key] =\n      stripClientOnlyDataFromFlightRouterState(childState)\n  }\n\n  const result: FlightRouterState = [cleanedSegment, cleanedParallelRoutes]\n  if (refreshMarker) {\n    result[2] = null // null slightly more compact than undefined\n    result[3] = refreshMarker\n  }\n\n  // Append optional fields if present\n  if (isRootLayout !== undefined) {\n    result[4] = isRootLayout\n  }\n  if (hasLoadingBoundary !== undefined) {\n    result[5] = hasLoadingBoundary\n  }\n\n  // Everything else is used only by the client and is not needed for requests.\n  return result\n}\n\n/**\n * Strips client-only data from segments:\n * - Search parameters from __PAGE__ segments\n * - staticSiblings from dynamic segment tuples (only needed for client-side\n *   prefetch reuse decisions)\n */\nfunction stripClientOnlyDataFromSegment(segment: Segment): Segment {\n  if (typeof segment === 'string') {\n    // Strip search params from __PAGE__ segments\n    if (segment.startsWith(PAGE_SEGMENT_KEY + '?')) {\n      return PAGE_SEGMENT_KEY\n    }\n    return segment\n  }\n  // Dynamic segment tuple: [paramName, paramCacheKey, paramType, staticSiblings]\n  // Strip staticSiblings (4th element) since server doesn't need it\n  const [paramName, paramCacheKey, paramType] = segment\n  return [paramName, paramCacheKey, paramType, null]\n}\n"],"names":["createInitialRSCPayloadFromFallbackPrerender","getFlightDataPartsFromPath","getNextFlightSegmentPath","normalizeFlightData","prepareFlightRouterStateForRequest","flightDataPath","flightDataPathLength","tree","seedData","head","isHeadPartial","slice","segmentPath","pathToSegment","segment","length","isRootRender","response","fallbackInitialRSCPayload","renderedPathname","getRenderedPathname","renderedSearch","getRenderedSearch","canonicalUrl","createHrefFromUrl","URL","location","href","originalFlightDataPath","f","originalFlightRouterState","b","c","split","q","i","fillInFallbackFlightRouterState","m","G","S","h","flightRouterState","pathnameParts","filter","p","index","fillInFallbackFlightRouterStateImpl","pathnamePartsIndex","originalSegment","newSegment","doesAppearInURL","doesStaticSegmentAppearInURL","paramName","paramType","staticSiblings","paramValue","parseDynamicParamFromURLPart","cacheKey","getCacheKeyForDynamicParam","childPathnamePartsIndex","children","newChildren","key","childFlightRouterState","newState","flightSegmentPath","flightData","map","isHmrRefresh","encodeURIComponent","JSON","stringify","stripClientOnlyDataFromFlightRouterState","parallelRoutes","_refreshState","refreshMarker","isRootLayout","hasLoadingBoundary","cleanedSegment","stripClientOnlyDataFromSegment","cleanedParallelRoutes","childState","Object","entries","result","undefined","startsWith","PAGE_SEGMENT_KEY","paramCacheKey"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 2334, "column": 0}, "map": {"version":3,"sources":["file:///D:/AconnectJP/node_modules/next/src/client/app-build-id.ts"],"sourcesContent":["// This gets assigned as a side-effect during app initialization. Because it\n// represents the build used to create the JS bundle, it should never change\n// after being set, so we store it in a global variable.\n//\n// When performing RSC requests, if the incoming data has a different build ID,\n// we perform an MPA navigation/refresh to load the updated build and ensure\n// that the client and server in sync.\n\n// Starts as an empty string. In practice, because setAppBuildId is called\n// during initialization before hydration starts, this will always get\n// reassigned to the actual build ID before it's ever needed by a navigation.\n// If for some reasons it didn't, due to a bug or race condition, then on\n// navigation the build comparision would fail and trigger an MPA navigation.\nlet globalBuildId: string = ''\n\nexport function setAppBuildId(buildId: string) {\n  globalBuildId = buildId\n}\n\nexport function getAppBuildId(): string {\n  return globalBuildId\n}\n"],"names":["getAppBuildId","setAppBuildId","globalBuildId","buildId"],"mappings":"AAAA,4EAA4E;AAC5E,4EAA4E;AAC5E,wDAAwD;AACxD,EAAE;AACF,+EAA+E;AAC/E,4EAA4E;AAC5E,sCAAsC;AAEtC,0EAA0E;AAC1E,sEAAsE;AACtE,6EAA6E;AAC7E,yEAAyE;AACzE,6EAA6E;;;;;;;;;;;;;;;IAO7DA,aAAa,EAAA;eAAbA;;IAJAC,aAAa,EAAA;eAAbA;;;AAFhB,IAAIC,gBAAwB;AAErB,SAASD,cAAcE,OAAe;IAC3CD,gBAAgBC;AAClB;AAEO,SAASH;IACd,OAAOE;AACT","ignoreList":[0]}},
    {"offset": {"line": 2385, "column": 0}, "map": {"version":3,"sources":["file:///D:/AconnectJP/node_modules/next/src/client/components/router-reducer/set-cache-busting-search-param.ts"],"sourcesContent":["'use client'\n\nimport { computeCacheBustingSearchParam } from '../../../shared/lib/router/utils/cache-busting-search-param'\nimport {\n  NEXT_ROUTER_PREFETCH_HEADER,\n  NEXT_ROUTER_SEGMENT_PREFETCH_HEADER,\n  NEXT_ROUTER_STATE_TREE_HEADER,\n  NEXT_URL,\n  NEXT_RSC_UNION_QUERY,\n} from '../app-router-headers'\nimport type { RequestHeaders } from './fetch-server-response'\n\n/**\n * Mutates the provided URL by adding a cache-busting search parameter for CDNs that don't\n * support custom headers. This helps avoid caching conflicts by making each request unique.\n *\n * Rather than relying on the Vary header which some CDNs ignore, we append a search param\n * to create a unique URL that forces a fresh request.\n *\n * Example:\n * URL before: https://example.com/path?query=1\n * URL after: https://example.com/path?query=1&_rsc=abc123\n *\n * Note: This function mutates the input URL directly and does not return anything.\n *\n * TODO: Since we need to use a search param anyway, we could simplify by removing the custom\n * headers approach entirely and just use search params.\n */\nexport const setCacheBustingSearchParam = (\n  url: URL,\n  headers: RequestHeaders\n): void => {\n  const uniqueCacheKey = computeCacheBustingSearchParam(\n    headers[NEXT_ROUTER_PREFETCH_HEADER],\n    headers[NEXT_ROUTER_SEGMENT_PREFETCH_HEADER],\n    headers[NEXT_ROUTER_STATE_TREE_HEADER],\n    headers[NEXT_URL]\n  )\n  setCacheBustingSearchParamWithHash(url, uniqueCacheKey)\n}\n\n/**\n * Sets a cache-busting search parameter on a URL using a provided hash value.\n *\n * This function performs the same logic as `setCacheBustingSearchParam` but accepts\n * a pre-computed hash instead of computing it from headers.\n *\n * Example:\n * URL before: https://example.com/path?query=1\n * hash: \"abc123\"\n * URL after: https://example.com/path?query=1&_rsc=abc123\n *\n * If the hash is null, we will set `_rsc` search param without a value.\n * Like this: https://example.com/path?query=1&_rsc\n *\n * Note: This function mutates the input URL directly and does not return anything.\n */\nexport const setCacheBustingSearchParamWithHash = (\n  url: URL,\n  hash: string\n): void => {\n  /**\n   * Note that we intentionally do not use `url.searchParams.set` here:\n   *\n   * const url = new URL('https://example.com/search?q=custom%20spacing');\n   * url.searchParams.set('_rsc', 'abc123');\n   * console.log(url.toString()); // Outputs: https://example.com/search?q=custom+spacing&_rsc=abc123\n   *                                                                             ^ <--- this is causing confusion\n   * This is in fact intended based on https://url.spec.whatwg.org/#interface-urlsearchparams, but\n   * we want to preserve the %20 as %20 if that's what the user passed in, hence the custom\n   * logic below.\n   */\n  const existingSearch = url.search\n  const rawQuery = existingSearch.startsWith('?')\n    ? existingSearch.slice(1)\n    : existingSearch\n\n  // Always remove any existing cache busting param and add a fresh one to ensure\n  // we have the correct value based on current request headers\n  const pairs = rawQuery\n    .split('&')\n    .filter((pair) => pair && !pair.startsWith(`${NEXT_RSC_UNION_QUERY}=`))\n\n  if (hash.length > 0) {\n    pairs.push(`${NEXT_RSC_UNION_QUERY}=${hash}`)\n  } else {\n    pairs.push(`${NEXT_RSC_UNION_QUERY}`)\n  }\n  url.search = pairs.length ? `?${pairs.join('&')}` : ''\n}\n"],"names":["setCacheBustingSearchParam","setCacheBustingSearchParamWithHash","url","headers","uniqueCacheKey","computeCacheBustingSearchParam","NEXT_ROUTER_PREFETCH_HEADER","NEXT_ROUTER_SEGMENT_PREFETCH_HEADER","NEXT_ROUTER_STATE_TREE_HEADER","NEXT_URL","hash","existingSearch","search","rawQuery","startsWith","slice","pairs","split","filter","pair","NEXT_RSC_UNION_QUERY","length","push","join"],"mappings":";;;;;;;;;;;;;;IA4BaA,0BAA0B,EAAA;eAA1BA;;IA6BAC,kCAAkC,EAAA;eAAlCA;;;yCAvDkC;kCAOxC;AAmBA,MAAMD,6BAA6B,CACxCE,KACAC;IAEA,MAAMC,iBAAiBC,CAAAA,GAAAA,yBAAAA,8BAA8B,EACnDF,OAAO,CAACG,kBAAAA,2BAA2B,CAAC,EACpCH,OAAO,CAACI,kBAAAA,mCAAmC,CAAC,EAC5CJ,OAAO,CAACK,kBAAAA,6BAA6B,CAAC,EACtCL,OAAO,CAACM,kBAAAA,QAAQ,CAAC;IAEnBR,mCAAmCC,KAAKE;AAC1C;AAkBO,MAAMH,qCAAqC,CAChDC,KACAQ;IAEA;;;;;;;;;;GAUC,GACD,MAAMC,iBAAiBT,IAAIU,MAAM;IACjC,MAAMC,WAAWF,eAAeG,UAAU,CAAC,OACvCH,eAAeI,KAAK,CAAC,KACrBJ;IAEJ,+EAA+E;IAC/E,6DAA6D;IAC7D,MAAMK,QAAQH,SACXI,KAAK,CAAC,KACNC,MAAM,CAAC,CAACC,OAASA,QAAQ,CAACA,KAAKL,UAAU,CAAC,GAAGM,kBAAAA,oBAAoB,CAAC,CAAC,CAAC;IAEvE,IAAIV,KAAKW,MAAM,GAAG,GAAG;QACnBL,MAAMM,IAAI,CAAC,GAAGF,kBAAAA,oBAAoB,CAAC,CAAC,EAAEV,MAAM;IAC9C,OAAO;QACLM,MAAMM,IAAI,CAAC,GAAGF,kBAAAA,oBAAoB,EAAE;IACtC;IACAlB,IAAIU,MAAM,GAAGI,MAAMK,MAAM,GAAG,CAAC,CAAC,EAAEL,MAAMO,IAAI,CAAC,MAAM,GAAG;AACtD","ignoreList":[0]}},
    {"offset": {"line": 2446, "column": 0}, "map": {"version":3,"sources":["file:///D:/AconnectJP/node_modules/next/src/client/components/router-reducer/fetch-server-response.ts"],"sourcesContent":["'use client'\n\n// TODO: Explicitly import from client.browser\n// eslint-disable-next-line import/no-extraneous-dependencies\nimport {\n  createFromReadableStream as createFromReadableStreamBrowser,\n  createFromFetch as createFromFetchBrowser,\n} from 'react-server-dom-webpack/client'\n\nimport type {\n  FlightRouterState,\n  NavigationFlightResponse,\n} from '../../../shared/lib/app-router-types'\n\nimport {\n  type NEXT_ROUTER_PREFETCH_HEADER,\n  type NEXT_ROUTER_SEGMENT_PREFETCH_HEADER,\n  NEXT_ROUTER_STATE_TREE_HEADER,\n  NEXT_RSC_UNION_QUERY,\n  NEXT_URL,\n  RSC_HEADER,\n  RSC_CONTENT_TYPE_HEADER,\n  NEXT_HMR_REFRESH_HEADER,\n  NEXT_DID_POSTPONE_HEADER,\n  NEXT_ROUTER_STALE_TIME_HEADER,\n  NEXT_HTML_REQUEST_ID_HEADER,\n  NEXT_REQUEST_ID_HEADER,\n} from '../app-router-headers'\nimport { callServer } from '../../app-call-server'\nimport { findSourceMapURL } from '../../app-find-source-map-url'\nimport {\n  normalizeFlightData,\n  prepareFlightRouterStateForRequest,\n  type NormalizedFlightData,\n} from '../../flight-data-helpers'\nimport { getAppBuildId } from '../../app-build-id'\nimport { setCacheBustingSearchParam } from './set-cache-busting-search-param'\nimport { urlToUrlWithoutFlightMarker } from '../../route-params'\nimport type { NormalizedSearch } from '../segment-cache/cache-key'\nimport { getDeploymentId } from '../../../shared/lib/deployment-id'\n\nconst createFromReadableStream =\n  createFromReadableStreamBrowser as (typeof import('react-server-dom-webpack/client.browser'))['createFromReadableStream']\nconst createFromFetch =\n  createFromFetchBrowser as (typeof import('react-server-dom-webpack/client.browser'))['createFromFetch']\n\nlet createDebugChannel:\n  | typeof import('../../dev/debug-channel').createDebugChannel\n  | undefined\n\nif (\n  process.env.NODE_ENV !== 'production' &&\n  process.env.__NEXT_REACT_DEBUG_CHANNEL\n) {\n  createDebugChannel = (\n    require('../../dev/debug-channel') as typeof import('../../dev/debug-channel')\n  ).createDebugChannel\n}\n\nexport interface FetchServerResponseOptions {\n  readonly flightRouterState: FlightRouterState\n  readonly nextUrl: string | null\n  readonly isHmrRefresh?: boolean\n}\n\ntype SpaFetchServerResponseResult = {\n  flightData: NormalizedFlightData[]\n  canonicalUrl: URL\n  renderedSearch: NormalizedSearch\n  couldBeIntercepted: boolean\n  prerendered: boolean\n  postponed: boolean\n  staleTime: number\n  debugInfo: Array<any> | null\n}\n\ntype MpaFetchServerResponseResult = string\n\nexport type FetchServerResponseResult =\n  | MpaFetchServerResponseResult\n  | SpaFetchServerResponseResult\n\nexport type RequestHeaders = {\n  [RSC_HEADER]?: '1'\n  [NEXT_ROUTER_STATE_TREE_HEADER]?: string\n  [NEXT_URL]?: string\n  [NEXT_ROUTER_PREFETCH_HEADER]?: '1' | '2'\n  [NEXT_ROUTER_SEGMENT_PREFETCH_HEADER]?: string\n  'x-deployment-id'?: string\n  [NEXT_HMR_REFRESH_HEADER]?: '1'\n  // A header that is only added in test mode to assert on fetch priority\n  'Next-Test-Fetch-Priority'?: RequestInit['priority']\n  [NEXT_HTML_REQUEST_ID_HEADER]?: string // dev-only\n  [NEXT_REQUEST_ID_HEADER]?: string // dev-only\n}\n\nfunction doMpaNavigation(url: string): FetchServerResponseResult {\n  return urlToUrlWithoutFlightMarker(new URL(url, location.origin)).toString()\n}\n\nlet isPageUnloading = false\n\nif (typeof window !== 'undefined') {\n  // Track when the page is unloading, e.g. due to reloading the page or\n  // performing hard navigations. This allows us to suppress error logging when\n  // the browser cancels in-flight requests during page unload.\n  window.addEventListener('pagehide', () => {\n    isPageUnloading = true\n  })\n\n  // Reset the flag on pageshow, e.g. when navigating back and the JavaScript\n  // execution context is restored by the browser.\n  window.addEventListener('pageshow', () => {\n    isPageUnloading = false\n  })\n}\n\n/**\n * Fetch the flight data for the provided url. Takes in the current router state\n * to decide what to render server-side.\n */\nexport async function fetchServerResponse(\n  url: URL,\n  options: FetchServerResponseOptions\n): Promise<FetchServerResponseResult> {\n  const { flightRouterState, nextUrl } = options\n\n  const headers: RequestHeaders = {\n    // Enable flight response\n    [RSC_HEADER]: '1',\n    // Provide the current router state\n    [NEXT_ROUTER_STATE_TREE_HEADER]: prepareFlightRouterStateForRequest(\n      flightRouterState,\n      options.isHmrRefresh\n    ),\n  }\n\n  if (process.env.NODE_ENV === 'development' && options.isHmrRefresh) {\n    headers[NEXT_HMR_REFRESH_HEADER] = '1'\n  }\n\n  if (nextUrl) {\n    headers[NEXT_URL] = nextUrl\n  }\n\n  // In static export mode, we need to modify the URL to request the .txt file,\n  // but we should preserve the original URL for the canonical URL and error handling.\n  const originalUrl = url\n\n  try {\n    if (process.env.NODE_ENV === 'production') {\n      if (process.env.__NEXT_CONFIG_OUTPUT === 'export') {\n        // In \"output: export\" mode, we can't rely on headers to distinguish\n        // between HTML and RSC requests. Instead, we append an extra prefix\n        // to the request.\n        url = new URL(url)\n        if (url.pathname.endsWith('/')) {\n          url.pathname += 'index.txt'\n        } else {\n          url.pathname += '.txt'\n        }\n      }\n    }\n\n    // Typically, during a navigation, we decode the response using Flight's\n    // `createFromFetch` API, which accepts a `fetch` promise.\n    // TODO: Remove this check once the old PPR flag is removed\n    const isLegacyPPR =\n      process.env.__NEXT_PPR && !process.env.__NEXT_CACHE_COMPONENTS\n    const shouldImmediatelyDecode = !isLegacyPPR\n    const res = await createFetch<NavigationFlightResponse>(\n      url,\n      headers,\n      'auto',\n      shouldImmediatelyDecode\n    )\n\n    const responseUrl = urlToUrlWithoutFlightMarker(new URL(res.url))\n    const canonicalUrl = res.redirected ? responseUrl : originalUrl\n\n    const contentType = res.headers.get('content-type') || ''\n    const interception = !!res.headers.get('vary')?.includes(NEXT_URL)\n    const postponed = !!res.headers.get(NEXT_DID_POSTPONE_HEADER)\n    const staleTimeHeaderSeconds = res.headers.get(\n      NEXT_ROUTER_STALE_TIME_HEADER\n    )\n    const staleTime =\n      staleTimeHeaderSeconds !== null\n        ? parseInt(staleTimeHeaderSeconds, 10) * 1000\n        : -1\n    let isFlightResponse = contentType.startsWith(RSC_CONTENT_TYPE_HEADER)\n\n    if (process.env.NODE_ENV === 'production') {\n      if (process.env.__NEXT_CONFIG_OUTPUT === 'export') {\n        if (!isFlightResponse) {\n          isFlightResponse = contentType.startsWith('text/plain')\n        }\n      }\n    }\n\n    // If fetch returns something different than flight response handle it like a mpa navigation\n    // If the fetch was not 200, we also handle it like a mpa navigation\n    if (!isFlightResponse || !res.ok || !res.body) {\n      // in case the original URL came with a hash, preserve it before redirecting to the new URL\n      if (url.hash) {\n        responseUrl.hash = url.hash\n      }\n\n      return doMpaNavigation(responseUrl.toString())\n    }\n\n    // We may navigate to a page that requires a different Webpack runtime.\n    // In prod, every page will have the same Webpack runtime.\n    // In dev, the Webpack runtime is minimal for each page.\n    // We need to ensure the Webpack runtime is updated before executing client-side JS of the new page.\n    // TODO: This needs to happen in the Flight Client.\n    // Or Webpack needs to include the runtime update in the Flight response as\n    // a blocking script.\n    if (process.env.NODE_ENV !== 'production' && !process.env.TURBOPACK) {\n      await (\n        require('../../dev/hot-reloader/app/hot-reloader-app') as typeof import('../../dev/hot-reloader/app/hot-reloader-app')\n      ).waitForWebpackRuntimeHotUpdate()\n    }\n\n    let flightResponsePromise = res.flightResponse\n    if (flightResponsePromise === null) {\n      // Typically, `createFetch` would have already started decoding the\n      // Flight response. If it hasn't, though, we need to decode it now.\n      // TODO: This should only be reachable if legacy PPR is enabled (i.e. PPR\n      // without Cache Components). Remove this branch once legacy PPR\n      // is deleted.\n      const flightStream = postponed\n        ? createUnclosingPrefetchStream(res.body)\n        : res.body\n      flightResponsePromise =\n        createFromNextReadableStream<NavigationFlightResponse>(\n          flightStream,\n          headers\n        )\n    }\n\n    const flightResponse = await flightResponsePromise\n\n    if (getAppBuildId() !== flightResponse.b) {\n      return doMpaNavigation(res.url)\n    }\n\n    const normalizedFlightData = normalizeFlightData(flightResponse.f)\n    if (typeof normalizedFlightData === 'string') {\n      return doMpaNavigation(normalizedFlightData)\n    }\n\n    return {\n      flightData: normalizedFlightData,\n      canonicalUrl: canonicalUrl,\n      // TODO: We should be able to read this from the rewrite header, not the\n      // Flight response. Theoretically they should always agree, but there are\n      // currently some cases where it's incorrect for interception routes. We\n      // can always trust the value in the response body. However, per-segment\n      // prefetch responses don't embed the value in the body; they rely on the\n      // header alone. So we need to investigate why the header is sometimes\n      // wrong for interception routes.\n      renderedSearch: flightResponse.q as NormalizedSearch,\n      couldBeIntercepted: interception,\n      prerendered: flightResponse.S,\n      postponed,\n      staleTime,\n      debugInfo: flightResponsePromise._debugInfo ?? null,\n    }\n  } catch (err) {\n    if (!isPageUnloading) {\n      console.error(\n        `Failed to fetch RSC payload for ${originalUrl}. Falling back to browser navigation.`,\n        err\n      )\n    }\n\n    // If fetch fails handle it like a mpa navigation\n    // TODO-APP: Add a test for the case where a CORS request fails, e.g. external url redirect coming from the response.\n    // See https://github.com/vercel/next.js/issues/43605#issuecomment-1451617521 for a reproduction.\n    return originalUrl.toString()\n  }\n}\n\n// This is a subset of the standard Response type. We use a custom type for\n// this so we can limit which details about the response leak into the rest of\n// the codebase. For example, there's some custom logic for manually following\n// redirects, so \"redirected\" in this type could be a composite of multiple\n// browser fetch calls; however, this fact should not leak to the caller.\nexport type RSCResponse<T> = {\n  ok: boolean\n  redirected: boolean\n  headers: Headers\n  body: ReadableStream<Uint8Array> | null\n  status: number\n  url: string\n  flightResponse: (Promise<T> & { _debugInfo?: Array<any> }) | null\n}\n\nexport async function createFetch<T>(\n  url: URL,\n  headers: RequestHeaders,\n  fetchPriority: 'auto' | 'high' | 'low' | null,\n  shouldImmediatelyDecode: boolean,\n  signal?: AbortSignal\n): Promise<RSCResponse<T>> {\n  // TODO: In output: \"export\" mode, the headers do nothing. Omit them (and the\n  // cache busting search param) from the request so they're\n  // maximally cacheable.\n\n  if (process.env.__NEXT_TEST_MODE && fetchPriority !== null) {\n    headers['Next-Test-Fetch-Priority'] = fetchPriority\n  }\n\n  const deploymentId = getDeploymentId()\n  if (deploymentId) {\n    headers['x-deployment-id'] = deploymentId\n  }\n\n  if (process.env.NODE_ENV !== 'production') {\n    if (self.__next_r) {\n      headers[NEXT_HTML_REQUEST_ID_HEADER] = self.__next_r\n    }\n\n    // Create a new request ID for the server action request. The server uses\n    // this to tag debug information sent via WebSocket to the client, which\n    // then routes those chunks to the debug channel associated with this ID.\n    headers[NEXT_REQUEST_ID_HEADER] = crypto\n      .getRandomValues(new Uint32Array(1))[0]\n      .toString(16)\n  }\n\n  const fetchOptions: RequestInit = {\n    // Backwards compat for older browsers. `same-origin` is the default in modern browsers.\n    credentials: 'same-origin',\n    headers,\n    priority: fetchPriority || undefined,\n    signal,\n  }\n  // `fetchUrl` is slightly different from `url` because we add a cache-busting\n  // search param to it. This should not leak outside of this function, so we\n  // track them separately.\n  let fetchUrl = new URL(url)\n  setCacheBustingSearchParam(fetchUrl, headers)\n  let fetchPromise = fetch(fetchUrl, fetchOptions)\n  // Immediately pass the fetch promise to the Flight client so that the debug\n  // info includes the latency from the client to the server. The internal timer\n  // in React starts as soon as `createFromFetch` is called.\n  //\n  // The only case where we don't do this is during a prefetch, because we have\n  // to do some extra processing of the response stream (see\n  // `createUnclosingPrefetchStream`). But this is fine, because a top-level\n  // prefetch response never blocks a navigation; if it hasn't already been\n  // written into the cache by the time the navigation happens, the router will\n  // go straight to a dynamic request.\n  let flightResponsePromise = shouldImmediatelyDecode\n    ? createFromNextFetch<T>(fetchPromise, headers)\n    : null\n  let browserResponse = await fetchPromise\n\n  // If the server responds with a redirect (e.g. 307), and the redirected\n  // location does not contain the cache busting search param set in the\n  // original request, the response is likely invalid  when following the\n  // redirect, the browser forwards the request headers, but since the cache\n  // busting search param is missing, the server will reject the request due to\n  // a mismatch.\n  //\n  // Ideally, we would be able to intercept the redirect response and perform it\n  // manually, instead of letting the browser automatically follow it, but this\n  // is not allowed by the fetch API.\n  //\n  // So instead, we must \"replay\" the redirect by fetching the new location\n  // again, but this time we'll append the cache busting search param to prevent\n  // a mismatch.\n  //\n  // TODO: We can optimize Next.js's built-in middleware APIs by returning a\n  // custom status code, to prevent the browser from automatically following it.\n  //\n  // This does not affect Server Action-based redirects; those are encoded\n  // differently, as part of the Flight body. It only affects redirects that\n  // occur in a middleware or a third-party proxy.\n\n  let redirected = browserResponse.redirected\n  if (process.env.__NEXT_CLIENT_VALIDATE_RSC_REQUEST_HEADERS) {\n    // This is to prevent a redirect loop. Same limit used by Chrome.\n    const MAX_REDIRECTS = 20\n    for (let n = 0; n < MAX_REDIRECTS; n++) {\n      if (!browserResponse.redirected) {\n        // The server did not perform a redirect.\n        break\n      }\n      const responseUrl = new URL(browserResponse.url, fetchUrl)\n      if (responseUrl.origin !== fetchUrl.origin) {\n        // The server redirected to an external URL. The rest of the logic below\n        // is not relevant, because it only applies to internal redirects.\n        break\n      }\n      if (\n        responseUrl.searchParams.get(NEXT_RSC_UNION_QUERY) ===\n        fetchUrl.searchParams.get(NEXT_RSC_UNION_QUERY)\n      ) {\n        // The redirected URL already includes the cache busting search param.\n        // This was probably intentional. Regardless, there's no reason to\n        // issue another request to this URL because it already has the param\n        // value that we would have added below.\n        break\n      }\n      // The RSC request was redirected. Assume the response is invalid.\n      //\n      // Append the cache busting search param to the redirected URL and\n      // fetch again.\n      // TODO: We should abort the previous request.\n      fetchUrl = new URL(responseUrl)\n      setCacheBustingSearchParam(fetchUrl, headers)\n      fetchPromise = fetch(fetchUrl, fetchOptions)\n      flightResponsePromise = shouldImmediatelyDecode\n        ? createFromNextFetch<T>(fetchPromise, headers)\n        : null\n      browserResponse = await fetchPromise\n      // We just performed a manual redirect, so this is now true.\n      redirected = true\n    }\n  }\n\n  // Remove the cache busting search param from the response URL, to prevent it\n  // from leaking outside of this function.\n  const responseUrl = new URL(browserResponse.url, fetchUrl)\n  responseUrl.searchParams.delete(NEXT_RSC_UNION_QUERY)\n\n  const rscResponse: RSCResponse<T> = {\n    url: responseUrl.href,\n\n    // This is true if any redirects occurred, either automatically by the\n    // browser, or manually by us. So it's different from\n    // `browserResponse.redirected`, which only tells us whether the browser\n    // followed a redirect, and only for the last response in the chain.\n    redirected,\n\n    // These can be copied from the last browser response we received. We\n    // intentionally only expose the subset of fields that are actually used\n    // elsewhere in the codebase.\n    ok: browserResponse.ok,\n    headers: browserResponse.headers,\n    body: browserResponse.body,\n    status: browserResponse.status,\n\n    // This is the exact promise returned by `createFromFetch`. It contains\n    // debug information that we need to transfer to any derived promises that\n    // are later rendered by React.\n    flightResponse: flightResponsePromise,\n  }\n\n  return rscResponse\n}\n\nexport function createFromNextReadableStream<T>(\n  flightStream: ReadableStream<Uint8Array>,\n  requestHeaders: RequestHeaders\n): Promise<T> {\n  return createFromReadableStream(flightStream, {\n    callServer,\n    findSourceMapURL,\n    debugChannel: createDebugChannel && createDebugChannel(requestHeaders),\n  })\n}\n\nfunction createFromNextFetch<T>(\n  promiseForResponse: Promise<Response>,\n  requestHeaders: RequestHeaders\n): Promise<T> & { _debugInfo?: Array<any> } {\n  return createFromFetch(promiseForResponse, {\n    callServer,\n    findSourceMapURL,\n    debugChannel: createDebugChannel && createDebugChannel(requestHeaders),\n  })\n}\n\nfunction createUnclosingPrefetchStream(\n  originalFlightStream: ReadableStream<Uint8Array>\n): ReadableStream<Uint8Array> {\n  // When PPR is enabled, prefetch streams may contain references that never\n  // resolve, because that's how we encode dynamic data access. In the decoded\n  // object returned by the Flight client, these are reified into hanging\n  // promises that suspend during render, which is effectively what we want.\n  // The UI resolves when it switches to the dynamic data stream\n  // (via useDeferredValue(dynamic, static)).\n  //\n  // However, the Flight implementation currently errors if the server closes\n  // the response before all the references are resolved. As a cheat to work\n  // around this, we wrap the original stream in a new stream that never closes,\n  // and therefore doesn't error.\n  const reader = originalFlightStream.getReader()\n  return new ReadableStream({\n    async pull(controller) {\n      while (true) {\n        const { done, value } = await reader.read()\n        if (!done) {\n          // Pass to the target stream and keep consuming the Flight response\n          // from the server.\n          controller.enqueue(value)\n          continue\n        }\n        // The server stream has closed. Exit, but intentionally do not close\n        // the target stream.\n        return\n      }\n    },\n  })\n}\n"],"names":["createFetch","createFromNextReadableStream","fetchServerResponse","createFromReadableStream","createFromReadableStreamBrowser","createFromFetch","createFromFetchBrowser","createDebugChannel","process","env","NODE_ENV","__NEXT_REACT_DEBUG_CHANNEL","require","doMpaNavigation","url","urlToUrlWithoutFlightMarker","URL","location","origin","toString","isPageUnloading","window","addEventListener","options","flightRouterState","nextUrl","headers","RSC_HEADER","NEXT_ROUTER_STATE_TREE_HEADER","prepareFlightRouterStateForRequest","isHmrRefresh","NEXT_HMR_REFRESH_HEADER","NEXT_URL","originalUrl","__NEXT_CONFIG_OUTPUT","pathname","endsWith","isLegacyPPR","__NEXT_PPR","__NEXT_CACHE_COMPONENTS","shouldImmediatelyDecode","res","responseUrl","canonicalUrl","redirected","contentType","get","interception","includes","postponed","NEXT_DID_POSTPONE_HEADER","staleTimeHeaderSeconds","NEXT_ROUTER_STALE_TIME_HEADER","staleTime","parseInt","isFlightResponse","startsWith","RSC_CONTENT_TYPE_HEADER","ok","body","hash","TURBOPACK","waitForWebpackRuntimeHotUpdate","flightResponsePromise","flightResponse","flightStream","createUnclosingPrefetchStream","getAppBuildId","b","normalizedFlightData","normalizeFlightData","f","flightData","renderedSearch","q","couldBeIntercepted","prerendered","S","debugInfo","_debugInfo","err","console","error","fetchPriority","signal","__NEXT_TEST_MODE","deploymentId","getDeploymentId","self","__next_r","NEXT_HTML_REQUEST_ID_HEADER","NEXT_REQUEST_ID_HEADER","crypto","getRandomValues","Uint32Array","fetchOptions","credentials","priority","undefined","fetchUrl","setCacheBustingSearchParam","fetchPromise","fetch","createFromNextFetch","browserResponse","__NEXT_CLIENT_VALIDATE_RSC_REQUEST_HEADERS","MAX_REDIRECTS","n","searchParams","NEXT_RSC_UNION_QUERY","delete","rscResponse","href","status","requestHeaders","callServer","findSourceMapURL","debugChannel","promiseForResponse","originalFlightStream","reader","getReader","ReadableStream","pull","controller","done","value","read","enqueue"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 2778, "column": 0}, "map": {"version":3,"sources":["file:///D:/AconnectJP/node_modules/next/src/client/components/match-segments.ts"],"sourcesContent":["import type { Segment } from '../../shared/lib/app-router-types'\n\nexport const matchSegment = (\n  existingSegment: Segment,\n  segment: Segment\n): boolean => {\n  // segment is either Array or string\n  if (typeof existingSegment === 'string') {\n    if (typeof segment === 'string') {\n      // Common case: segment is just a string\n      return existingSegment === segment\n    }\n    return false\n  }\n\n  if (typeof segment === 'string') {\n    return false\n  }\n  return existingSegment[0] === segment[0] && existingSegment[1] === segment[1]\n}\n"],"names":["matchSegment","existingSegment","segment"],"mappings":";;;+BAEaA,gBAAAA;;;eAAAA;;;AAAN,MAAMA,eAAe,CAC1BC,iBACAC;IAEA,oCAAoC;IACpC,IAAI,OAAOD,oBAAoB,UAAU;QACvC,IAAI,OAAOC,YAAY,UAAU;YAC/B,wCAAwC;YACxC,OAAOD,oBAAoBC;QAC7B;QACA,OAAO;IACT;IAEA,IAAI,OAAOA,YAAY,UAAU;QAC/B,OAAO;IACT;IACA,OAAOD,eAAe,CAAC,EAAE,KAAKC,OAAO,CAAC,EAAE,IAAID,eAAe,CAAC,EAAE,KAAKC,OAAO,CAAC,EAAE;AAC/E","ignoreList":[0]}},
    {"offset": {"line": 2812, "column": 0}, "map": {"version":3,"sources":["file:///D:/AconnectJP/node_modules/next/src/client/components/router-reducer/is-navigating-to-new-root-layout.ts"],"sourcesContent":["import type { FlightRouterState } from '../../../shared/lib/app-router-types'\nimport type { RouteTree } from '../segment-cache/cache'\n\nexport function isNavigatingToNewRootLayout(\n  currentTree: FlightRouterState,\n  nextTree: RouteTree\n): boolean {\n  // Compare segments\n  const currentTreeSegment = currentTree[0]\n  const nextTreeSegment = nextTree.segment\n\n  // If any segment is different before we find the root layout, the root layout has changed.\n  // E.g. /same/(group1)/layout.js -> /same/(group2)/layout.js\n  // First segment is 'same' for both, keep looking. (group1) changed to (group2) before the root layout was found, it must have changed.\n  if (Array.isArray(currentTreeSegment) && Array.isArray(nextTreeSegment)) {\n    // Compare dynamic param name and type but ignore the value, different values would not affect the current root layout\n    // /[name] - /slug1 and /slug2, both values (slug1 & slug2) still has the same layout /[name]/layout.js\n    if (\n      currentTreeSegment[0] !== nextTreeSegment[0] ||\n      currentTreeSegment[2] !== nextTreeSegment[2]\n    ) {\n      return true\n    }\n  } else if (currentTreeSegment !== nextTreeSegment) {\n    return true\n  }\n\n  // Current tree root layout found\n  if (currentTree[4]) {\n    // If the next tree doesn't have the root layout flag, it must have changed.\n    return !nextTree.isRootLayout\n  }\n  // Current tree didn't have its root layout here, must have changed.\n  if (nextTree.isRootLayout) {\n    return true\n  }\n\n  const slots = nextTree.slots\n  const currentTreeChildren = currentTree[1]\n  if (slots !== null) {\n    for (const slot in slots) {\n      const nextTreeChild = slots[slot]\n      const currentTreeChild = currentTreeChildren[slot]\n      if (\n        currentTreeChild === undefined ||\n        isNavigatingToNewRootLayout(currentTreeChild, nextTreeChild)\n      ) {\n        return true\n      }\n    }\n  }\n  return false\n}\n"],"names":["isNavigatingToNewRootLayout","currentTree","nextTree","currentTreeSegment","nextTreeSegment","segment","Array","isArray","isRootLayout","slots","currentTreeChildren","slot","nextTreeChild","currentTreeChild","undefined"],"mappings":";;;+BAGgBA,+BAAAA;;;eAAAA;;;AAAT,SAASA,4BACdC,WAA8B,EAC9BC,QAAmB;IAEnB,mBAAmB;IACnB,MAAMC,qBAAqBF,WAAW,CAAC,EAAE;IACzC,MAAMG,kBAAkBF,SAASG,OAAO;IAExC,2FAA2F;IAC3F,4DAA4D;IAC5D,uIAAuI;IACvI,IAAIC,MAAMC,OAAO,CAACJ,uBAAuBG,MAAMC,OAAO,CAACH,kBAAkB;QACvE,sHAAsH;QACtH,uGAAuG;QACvG,IACED,kBAAkB,CAAC,EAAE,KAAKC,eAAe,CAAC,EAAE,IAC5CD,kBAAkB,CAAC,EAAE,KAAKC,eAAe,CAAC,EAAE,EAC5C;YACA,OAAO;QACT;IACF,OAAO,IAAID,uBAAuBC,iBAAiB;QACjD,OAAO;IACT;IAEA,iCAAiC;IACjC,IAAIH,WAAW,CAAC,EAAE,EAAE;QAClB,4EAA4E;QAC5E,OAAO,CAACC,SAASM,YAAY;IAC/B;IACA,oEAAoE;IACpE,IAAIN,SAASM,YAAY,EAAE;QACzB,OAAO;IACT;IAEA,MAAMC,QAAQP,SAASO,KAAK;IAC5B,MAAMC,sBAAsBT,WAAW,CAAC,EAAE;IAC1C,IAAIQ,UAAU,MAAM;QAClB,IAAK,MAAME,QAAQF,MAAO;YACxB,MAAMG,gBAAgBH,KAAK,CAACE,KAAK;YACjC,MAAME,mBAAmBH,mBAAmB,CAACC,KAAK;YAClD,IACEE,qBAAqBC,aACrBd,4BAA4Ba,kBAAkBD,gBAC9C;gBACA,OAAO;YACT;QACF;IACF;IACA,OAAO;AACT","ignoreList":[0]}},
    {"offset": {"line": 2870, "column": 0}, "map": {"version":3,"sources":["file:///D:/AconnectJP/node_modules/next/src/client/components/segment-cache/types.ts"],"sourcesContent":["/**\n * Shared types and constants for the Segment Cache.\n */\n\nexport const enum NavigationResultTag {\n  MPA,\n  Success,\n  NoOp,\n  Async,\n}\n\n/**\n * The priority of the prefetch task. Higher numbers are higher priority.\n */\nexport const enum PrefetchPriority {\n  /**\n   * Assigned to the most recently hovered/touched link. Special network\n   * bandwidth is reserved for this task only. There's only ever one Intent-\n   * priority task at a time; when a new Intent task is scheduled, the previous\n   * one is bumped down to Default.\n   */\n  Intent = 2,\n  /**\n   * The default priority for prefetch tasks.\n   */\n  Default = 1,\n  /**\n   * Assigned to tasks when they spawn non-blocking background work, like\n   * revalidating a partially cached entry to see if more data is available.\n   */\n  Background = 0,\n}\n\nexport const enum FetchStrategy {\n  // Deliberately ordered so we can easily compare two segments\n  // and determine if one segment is \"more specific\" than another\n  // (i.e. if it's likely that it contains more data)\n  LoadingBoundary = 0,\n  PPR = 1,\n  PPRRuntime = 2,\n  Full = 3,\n}\n\n/**\n * A subset of fetch strategies used for prefetch tasks.\n * A prefetch task can't know if it should use `PPR` or `LoadingBoundary`\n * until we complete the initial tree prefetch request, so we use `PPR` to signal both cases\n * and adjust it based on the route when actually fetching.\n * */\nexport type PrefetchTaskFetchStrategy =\n  | FetchStrategy.PPR\n  | FetchStrategy.PPRRuntime\n  | FetchStrategy.Full\n"],"names":["FetchStrategy","NavigationResultTag","PrefetchPriority"],"mappings":"AAAA;;CAEC;;;;;;;;;;;;;;;IA+BiBA,aAAa,EAAA;eAAbA;;IA7BAC,mBAAmB,EAAA;eAAnBA;;IAUAC,gBAAgB,EAAA;eAAhBA;;;AAVX,IAAWD,sBAAAA,WAAAA,GAAAA,SAAAA,mBAAAA;;;;;WAAAA;;AAUX,IAAWC,mBAAAA,WAAAA,GAAAA,SAAAA,gBAAAA;IAChB;;;;;GAKC,GAAA,gBAAA,CAAA,gBAAA,CAAA,SAAA,GAAA,EAAA,GAAA;IAED;;GAEC,GAAA,gBAAA,CAAA,gBAAA,CAAA,UAAA,GAAA,EAAA,GAAA;IAED;;;GAGC,GAAA,gBAAA,CAAA,gBAAA,CAAA,aAAA,GAAA,EAAA,GAAA;WAfeA;;AAmBX,IAAWF,gBAAAA,WAAAA,GAAAA,SAAAA,aAAAA;IAChB,6DAA6D;IAC7D,+DAA+D;IAC/D,mDAAmD;;;;;WAHnCA","ignoreList":[0]}},
    {"offset": {"line": 2941, "column": 0}, "map": {"version":3,"sources":["file:///D:/AconnectJP/node_modules/next/src/client/components/segment-cache/lru.ts"],"sourcesContent":["import { deleteMapEntry } from './cache-map'\nimport type { UnknownMapEntry } from './cache-map'\n\n// We use an LRU for memory management. We must update this whenever we add or\n// remove a new cache entry, or when an entry changes size.\n\nlet head: UnknownMapEntry | null = null\nlet didScheduleCleanup: boolean = false\nlet lruSize: number = 0\n\n// TODO: I chose the max size somewhat arbitrarily. Consider setting this based\n// on navigator.deviceMemory, or some other heuristic. We should make this\n// customizable via the Next.js config, too.\nconst maxLruSize = 50 * 1024 * 1024 // 50 MB\n\nexport function lruPut(node: UnknownMapEntry) {\n  if (head === node) {\n    // Already at the head\n    return\n  }\n  const prev = node.prev\n  const next = node.next\n  if (next === null || prev === null) {\n    // This is an insertion\n    lruSize += node.size\n    // Whenever we add an entry, we need to check if we've exceeded the\n    // max size. We don't evict entries immediately; they're evicted later in\n    // an asynchronous task.\n    ensureCleanupIsScheduled()\n  } else {\n    // This is a move. Remove from its current position.\n    prev.next = next\n    next.prev = prev\n  }\n\n  // Move to the front of the list\n  if (head === null) {\n    // This is the first entry\n    node.prev = node\n    node.next = node\n  } else {\n    // Add to the front of the list\n    const tail = head.prev\n    node.prev = tail\n    // In practice, this is never null, but that isn't encoded in the type\n    if (tail !== null) {\n      tail.next = node\n    }\n    node.next = head\n    head.prev = node\n  }\n  head = node\n}\n\nexport function updateLruSize(node: UnknownMapEntry, newNodeSize: number) {\n  // This is a separate function from `put` so that we can resize the entry\n  // regardless of whether it's currently being tracked by the LRU.\n  const prevNodeSize = node.size\n  node.size = newNodeSize\n  if (node.next === null) {\n    // This entry is not currently being tracked by the LRU.\n    return\n  }\n  // Update the total LRU size\n  lruSize = lruSize - prevNodeSize + newNodeSize\n  ensureCleanupIsScheduled()\n}\n\nexport function deleteFromLru(deleted: UnknownMapEntry) {\n  const next = deleted.next\n  const prev = deleted.prev\n  if (next !== null && prev !== null) {\n    lruSize -= deleted.size\n\n    deleted.next = null\n    deleted.prev = null\n\n    // Remove from the list\n    if (head === deleted) {\n      // Update the head\n      if (next === head) {\n        // This was the last entry\n        head = null\n      } else {\n        head = next\n        prev.next = next\n        next.prev = prev\n      }\n    } else {\n      prev.next = next\n      next.prev = prev\n    }\n  } else {\n    // Already deleted\n  }\n}\n\nfunction ensureCleanupIsScheduled() {\n  if (didScheduleCleanup || lruSize <= maxLruSize) {\n    return\n  }\n  didScheduleCleanup = true\n  requestCleanupCallback(cleanup)\n}\n\nfunction cleanup() {\n  didScheduleCleanup = false\n\n  // Evict entries until we're at 90% capacity. We can assume this won't\n  // infinite loop because even if `maxLruSize` were 0, eventually\n  // `deleteFromLru` sets `head` to `null` when we run out entries.\n  const ninetyPercentMax = maxLruSize * 0.9\n  while (lruSize > ninetyPercentMax && head !== null) {\n    const tail = head.prev\n    // In practice, this is never null, but that isn't encoded in the type\n    if (tail !== null) {\n      // Delete the entry from the map. In turn, this will remove it from\n      // the LRU.\n      deleteMapEntry(tail)\n    }\n  }\n}\n\nconst requestCleanupCallback =\n  typeof requestIdleCallback === 'function'\n    ? requestIdleCallback\n    : (cb: () => void) => setTimeout(cb, 0)\n"],"names":["deleteFromLru","lruPut","updateLruSize","head","didScheduleCleanup","lruSize","maxLruSize","node","prev","next","size","ensureCleanupIsScheduled","tail","newNodeSize","prevNodeSize","deleted","requestCleanupCallback","cleanup","ninetyPercentMax","deleteMapEntry","requestIdleCallback","cb","setTimeout"],"mappings":";;;;;;;;;;;;;;;IAoEgBA,aAAa,EAAA;eAAbA;;IArDAC,MAAM,EAAA;eAANA;;IAuCAC,aAAa,EAAA;eAAbA;;;0BAtDe;AAG/B,8EAA8E;AAC9E,2DAA2D;AAE3D,IAAIC,OAA+B;AACnC,IAAIC,qBAA8B;AAClC,IAAIC,UAAkB;AAEtB,+EAA+E;AAC/E,0EAA0E;AAC1E,4CAA4C;AAC5C,MAAMC,aAAa,KAAK,OAAO,KAAK,QAAQ;;AAErC,SAASL,OAAOM,IAAqB;IAC1C,IAAIJ,SAASI,MAAM;QACjB,sBAAsB;QACtB;IACF;IACA,MAAMC,OAAOD,KAAKC,IAAI;IACtB,MAAMC,OAAOF,KAAKE,IAAI;IACtB,IAAIA,SAAS,QAAQD,SAAS,MAAM;QAClC,uBAAuB;QACvBH,WAAWE,KAAKG,IAAI;QACpB,mEAAmE;QACnE,yEAAyE;QACzE,wBAAwB;QACxBC;IACF,OAAO;QACL,oDAAoD;QACpDH,KAAKC,IAAI,GAAGA;QACZA,KAAKD,IAAI,GAAGA;IACd;IAEA,gCAAgC;IAChC,IAAIL,SAAS,MAAM;QACjB,0BAA0B;QAC1BI,KAAKC,IAAI,GAAGD;QACZA,KAAKE,IAAI,GAAGF;IACd,OAAO;QACL,+BAA+B;QAC/B,MAAMK,OAAOT,KAAKK,IAAI;QACtBD,KAAKC,IAAI,GAAGI;QACZ,sEAAsE;QACtE,IAAIA,SAAS,MAAM;YACjBA,KAAKH,IAAI,GAAGF;QACd;QACAA,KAAKE,IAAI,GAAGN;QACZA,KAAKK,IAAI,GAAGD;IACd;IACAJ,OAAOI;AACT;AAEO,SAASL,cAAcK,IAAqB,EAAEM,WAAmB;IACtE,yEAAyE;IACzE,iEAAiE;IACjE,MAAMC,eAAeP,KAAKG,IAAI;IAC9BH,KAAKG,IAAI,GAAGG;IACZ,IAAIN,KAAKE,IAAI,KAAK,MAAM;QACtB,wDAAwD;QACxD;IACF;IACA,4BAA4B;IAC5BJ,UAAUA,UAAUS,eAAeD;IACnCF;AACF;AAEO,SAASX,cAAce,OAAwB;IACpD,MAAMN,OAAOM,QAAQN,IAAI;IACzB,MAAMD,OAAOO,QAAQP,IAAI;IACzB,IAAIC,SAAS,QAAQD,SAAS,MAAM;QAClCH,WAAWU,QAAQL,IAAI;QAEvBK,QAAQN,IAAI,GAAG;QACfM,QAAQP,IAAI,GAAG;QAEf,uBAAuB;QACvB,IAAIL,SAASY,SAAS;YACpB,kBAAkB;YAClB,IAAIN,SAASN,MAAM;gBACjB,0BAA0B;gBAC1BA,OAAO;YACT,OAAO;gBACLA,OAAOM;gBACPD,KAAKC,IAAI,GAAGA;gBACZA,KAAKD,IAAI,GAAGA;YACd;QACF,OAAO;YACLA,KAAKC,IAAI,GAAGA;YACZA,KAAKD,IAAI,GAAGA;QACd;IACF,OAAO;IACL,kBAAkB;IACpB;AACF;AAEA,SAASG;IACP,IAAIP,sBAAsBC,WAAWC,YAAY;QAC/C;IACF;IACAF,qBAAqB;IACrBY,uBAAuBC;AACzB;AAEA,SAASA;IACPb,qBAAqB;IAErB,sEAAsE;IACtE,gEAAgE;IAChE,iEAAiE;IACjE,MAAMc,mBAAmBZ,aAAa;IACtC,MAAOD,UAAUa,oBAAoBf,SAAS,KAAM;QAClD,MAAMS,OAAOT,KAAKK,IAAI;QACtB,sEAAsE;QACtE,IAAII,SAAS,MAAM;YACjB,mEAAmE;YACnE,WAAW;YACXO,CAAAA,GAAAA,UAAAA,cAAc,EAACP;QACjB;IACF;AACF;AAEA,MAAMI,yBACJ,OAAOI,wBAAwB,aAC3BA,sBACA,CAACC,KAAmBC,WAAWD,IAAI","ignoreList":[0]}},
    {"offset": {"line": 3088, "column": 0}, "map": {"version":3,"sources":["file:///D:/AconnectJP/node_modules/next/src/client/components/segment-cache/cache-map.ts"],"sourcesContent":["import type { VaryPath } from './vary-path'\nimport { lruPut, updateLruSize, deleteFromLru } from './lru'\n\n/**\n * A specialized data type for storing multi-key cache entries.\n *\n * The basic structure is a map whose keys are tuples, called the keypath.\n * When querying the cache, keypaths are compared per-element.\n *\n * Example:\n *   set(map, ['https://localhost', 'foo/bar/baz'], 'yay');\n *   get(map, ['https://localhost', 'foo/bar/baz']) -> 'yay'\n *\n * NOTE: Array syntax is used in these examples for illustration purposes, but\n * in reality the paths are lists.\n * \n * The parts of the keypath represent the different inputs that contribute\n * to the entry value. To illustrate, if you were to use this data type to store\n * HTTP responses, the keypath would include the URL and everything listed by\n * the Vary header.\n * \n * See vary-path.ts for more details.\n *\n * The order of elements in a keypath must be consistent between lookups to\n * be considered the same, but besides that, the order of the keys is not\n * semantically meaningful.\n *\n * Keypaths may include a special kind of key called Fallback. When an entry is\n * stored with Fallback as part of its keypath, it means that the entry does not\n * vary by that key. When querying the cache, if an exact match is not found for\n * a keypath, the cache will check for a Fallback match instead. Each element of\n * the keypath may have a Fallback, so retrieval is an O(n ^ 2) operation, but\n * it's expected that keypaths are relatively short.\n *\n * Example:\n *   set(cacheMap, ['store', 'product', 1], PRODUCT_PAGE_1);\n *   set(cacheMap, ['store', 'product', Fallback], GENERIC_PRODUCT_PAGE);\n *\n *   // Exact match\n *   get(cacheMap, ['store', 'product', 1]) -> PRODUCT_PAGE_1\n *\n *   // Fallback match\n *   get(cacheMap, ['store', 'product', 2]) -> GENERIC_PRODUCT_PAGE\n *\n * Because we have the Fallback mechanism, we can impose a constraint that\n * regular JS maps do not have: a value cannot be stored at multiple keypaths\n * simultaneously. These cases should be expressed with Fallback keys instead.\n *\n * Additionally, because values only exist at a single keypath at a time, we\n * can optimize successive lookups by caching the internal map entry on the\n * value itself, using the `ref` field. This is especially useful because it\n * lets us skip the O(n ^ 2) lookup that occurs when Fallback entries\n * are present.\n *\n\n * How to decide if stuff belongs in here, or in cache.ts?\n * -------------------------------------------------------\n * \n * Anything to do with retrival, lifetimes, or eviction needs to go in this\n * module because it affects the fallback algorithm. For example, when\n * performing a lookup, if an entry is stale, it needs to be treated as\n * semantically equivalent to if the entry was not present at all.\n * \n * If there's logic that's not related to the fallback algorithm, though, we\n * should prefer to put it in cache.ts.\n */\n\n// The protocol that values must implement. In practice, the only two types that\n// we ever actually deal with in this module are RouteCacheEntry and\n// SegmentCacheEntry; this is just to keep track of the coupling so we don't\n// leak concerns between the modules unnecessarily.\nexport interface MapValue {\n  ref: UnknownMapEntry | null\n  size: number\n  staleAt: number\n  version: number\n}\n\n/**\n * Represents a node in the cache map and LRU.\n * MapEntry<V> structurally satisfies this interface for any V extends MapValue.\n *\n * The LRU can contain entries of different value types\n * (e.g., both RouteCacheEntry and SegmentCacheEntry). This interface captures\n * the common structure needed for cache map and LRU operations without\n * requiring knowledge of the specific value type.\n */\nexport interface MapEntry<V extends MapValue> {\n  // Cache map structure fields\n  parent: MapEntry<V> | null\n  key: unknown\n  map: Map<unknown, MapEntry<V>> | null\n  value: V | null\n\n  // LRU linked list fields\n  prev: MapEntry<V> | null\n  next: MapEntry<V> | null\n  size: number\n}\n\n/**\n * A looser type for MapEntry\n * This allows the LRU to work with entries of different\n * value types while still providing type safety.\n *\n * The `map` field lets Map<unknown, MapEntry<V>> be assignable to this\n * type since we're only reading from the map, not inserting into it.\n */\nexport type UnknownMapEntry = {\n  parent: UnknownMapEntry | null\n  key: unknown\n  map: Pick<Map<unknown, UnknownMapEntry>, 'get' | 'delete' | 'size'> | null\n  value: MapValue | null\n\n  prev: UnknownMapEntry | null\n  next: UnknownMapEntry | null\n  size: number\n}\n\n// The CacheMap type is just the root entry of the map.\nexport type CacheMap<V extends MapValue> = MapEntry<V>\n\nexport type FallbackType = { __brand: 'Fallback' }\nexport const Fallback = {} as FallbackType\n\n// This is a special internal key that is used for \"revalidation\" entries. It's\n// an implementation detail that shouldn't leak outside of this module.\nconst Revalidation = {}\n\nexport function createCacheMap<V extends MapValue>(): CacheMap<V> {\n  const cacheMap: MapEntry<V> = {\n    parent: null,\n    key: null,\n    value: null,\n    map: null,\n\n    // LRU-related fields\n    prev: null,\n    next: null,\n    size: 0,\n  }\n  return cacheMap\n}\n\nfunction getOrInitialize<V extends MapValue>(\n  cacheMap: CacheMap<V>,\n  keys: VaryPath,\n  isRevalidation: boolean\n): MapEntry<V> {\n  // Go through each level of keys until we find the entry that matches, or\n  // create a new entry if one doesn't exist.\n  //\n  // This function will only return entries that match the keypath _exactly_.\n  // Unlike getWithFallback, it will not access fallback entries unless it's\n  // explicitly part of the keypath.\n  let entry = cacheMap\n  let remainingKeys: VaryPath | null = keys\n  let key: unknown | null = null\n  while (true) {\n    const previousKey = key\n    if (remainingKeys !== null) {\n      key = remainingKeys.value\n      remainingKeys = remainingKeys.parent\n    } else if (isRevalidation && previousKey !== Revalidation) {\n      // During a revalidation, we append an internal \"Revalidation\" key to\n      // the end of the keypath. The \"normal\" entry is its parent.\n\n      // However, if the parent entry is currently empty, we don't need to store\n      // this as a revalidation entry. Just insert the revalidation into the\n      // normal slot.\n      if (entry.value === null) {\n        return entry\n      }\n\n      // Otheriwse, create a child entry.\n      key = Revalidation\n    } else {\n      // There are no more keys. This is the terminal entry.\n      break\n    }\n\n    let map = entry.map\n    if (map !== null) {\n      const existingEntry = map.get(key)\n      if (existingEntry !== undefined) {\n        // Found a match. Keep going.\n        entry = existingEntry\n        continue\n      }\n    } else {\n      map = new Map()\n      entry.map = map\n    }\n    // No entry exists yet at this level. Create a new one.\n    const newEntry: MapEntry<V> = {\n      parent: entry,\n      key,\n      value: null,\n      map: null,\n\n      // LRU-related fields\n      prev: null,\n      next: null,\n      size: 0,\n    }\n    map.set(key, newEntry)\n    entry = newEntry\n  }\n\n  return entry\n}\n\nexport function getFromCacheMap<V extends MapValue>(\n  now: number,\n  currentCacheVersion: number,\n  rootEntry: CacheMap<V>,\n  keys: VaryPath,\n  isRevalidation: boolean\n): V | null {\n  const entry = getEntryWithFallbackImpl(\n    now,\n    currentCacheVersion,\n    rootEntry,\n    keys,\n    isRevalidation,\n    0\n  )\n  if (entry === null || entry.value === null) {\n    return null\n  }\n  // This is an LRU access. Move the entry to the front of the list.\n  lruPut(entry)\n  return entry.value\n}\n\nexport function isValueExpired(\n  now: number,\n  currentCacheVersion: number,\n  value: MapValue\n): boolean {\n  return value.staleAt <= now || value.version < currentCacheVersion\n}\n\nfunction lazilyEvictIfNeeded<V extends MapValue>(\n  now: number,\n  currentCacheVersion: number,\n  entry: MapEntry<V>\n) {\n  // We have a matching entry, but before we can return it, we need to check if\n  // it's still fresh. Otherwise it should be treated the same as a cache miss.\n\n  if (entry.value === null) {\n    // This entry has no value, so there's nothing to evict.\n    return entry\n  }\n\n  const value = entry.value\n  if (isValueExpired(now, currentCacheVersion, value)) {\n    // The value expired. Lazily evict it from the cache, and return null. This\n    // is conceptually the same as a cache miss.\n    deleteMapEntry(entry)\n    return null\n  }\n\n  // The matched entry has not expired. Return it.\n  return entry\n}\n\nfunction getEntryWithFallbackImpl<V extends MapValue>(\n  now: number,\n  currentCacheVersion: number,\n  entry: MapEntry<V>,\n  keys: VaryPath | null,\n  isRevalidation: boolean,\n  previousKey: unknown | null\n): MapEntry<V> | null {\n  // This is similar to getExactEntry, but if an exact match is not found for\n  // a key, it will return the fallback entry instead. This is recursive at\n  // every level, e.g. an entry with keypath [a, Fallback, c, Fallback] is\n  // valid match for [a, b, c, d].\n  //\n  // It will return the most specific match available.\n  let key\n  let remainingKeys: VaryPath | null\n  if (keys !== null) {\n    key = keys.value\n    remainingKeys = keys.parent\n  } else if (isRevalidation && previousKey !== Revalidation) {\n    // During a revalidation, we append an internal \"Revalidation\" key to\n    // the end of the keypath.\n    key = Revalidation\n    remainingKeys = null\n  } else {\n    // There are no more keys. This is the terminal entry.\n\n    // TODO: When performing a lookup during a navigation, as opposed to a\n    // prefetch, we may want to skip entries that are Pending if there's also\n    // a Fulfilled fallback entry. Tricky to say, though, since if it's\n    // already pending, it's likely to stream in soon. Maybe we could do this\n    // just on slow connections and offline mode.\n\n    return lazilyEvictIfNeeded(now, currentCacheVersion, entry)\n  }\n  const map = entry.map\n  if (map !== null) {\n    const existingEntry = map.get(key)\n    if (existingEntry !== undefined) {\n      // Found an exact match for this key. Keep searching.\n      const result = getEntryWithFallbackImpl(\n        now,\n        currentCacheVersion,\n        existingEntry,\n        remainingKeys,\n        isRevalidation,\n        key\n      )\n      if (result !== null) {\n        return result\n      }\n    }\n    // No match found for this key. Check if there's a fallback.\n    const fallbackEntry = map.get(Fallback)\n    if (fallbackEntry !== undefined) {\n      // Found a fallback for this key. Keep searching.\n      return getEntryWithFallbackImpl(\n        now,\n        currentCacheVersion,\n        fallbackEntry,\n        remainingKeys,\n        isRevalidation,\n        key\n      )\n    }\n  }\n  return null\n}\n\nexport function setInCacheMap<V extends MapValue>(\n  cacheMap: CacheMap<V>,\n  keys: VaryPath,\n  value: V,\n  isRevalidation: boolean\n): void {\n  // Add a value to the map at the given keypath. If the value is already\n  // part of the map, it's removed from its previous keypath. (NOTE: This is\n  // unlike a regular JS map, but the behavior is intentional.)\n  const entry = getOrInitialize(cacheMap, keys, isRevalidation)\n  setMapEntryValue(entry, value)\n\n  // This is an LRU access. Move the entry to the front of the list.\n  lruPut(entry)\n  updateLruSize(entry, value.size)\n}\n\nfunction setMapEntryValue(entry: UnknownMapEntry, value: MapValue): void {\n  if (entry.value !== null) {\n    // There's already a value at the given keypath. Disconnect the old value\n    // from the map. We're not calling `deleteMapEntry` here because the\n    // entry itself is still in the map. We just want to overwrite its value.\n    dropRef(entry.value)\n    entry.value = null\n  }\n\n  // This value may already be in the map at a different keypath.\n  // Grab a reference before we overwrite it.\n  const oldEntry = value.ref\n\n  entry.value = value\n  value.ref = entry\n\n  updateLruSize(entry, value.size)\n\n  if (oldEntry !== null && oldEntry !== entry && oldEntry.value === value) {\n    // This value is already in the map at a different keypath in the map.\n    // Values only exist at a single keypath at a time. Remove it from the\n    // previous keypath.\n    //\n    // Note that only the internal map entry is garbage collected; we don't\n    // call `dropRef` here because it's still in the map, just\n    // at a new keypath (the one we just set, above).\n    deleteMapEntry(oldEntry)\n  }\n}\n\nexport function deleteFromCacheMap(value: MapValue): void {\n  const entry = value.ref\n  if (entry === null) {\n    // This value is not a member of any map.\n    return\n  }\n\n  dropRef(value)\n  deleteMapEntry(entry)\n}\n\nfunction dropRef(value: MapValue): void {\n  // Drop the value from the map by setting its `ref` backpointer to\n  // null. This is a separate operation from `deleteMapEntry` because when\n  // re-keying a value we need to be able to delete the old, internal map\n  // entry without garbage collecting the value itself.\n  value.ref = null\n}\n\nexport function deleteMapEntry(entry: UnknownMapEntry): void {\n  // Delete the entry from the cache.\n  entry.value = null\n\n  deleteFromLru(entry)\n\n  // Check if we can garbage collect the entry.\n  const map = entry.map\n  if (map === null) {\n    // Since this entry has no value, and also no child entries, we can\n    // garbage collect it. Remove it from its parent, and keep garbage\n    // collecting the parents until we reach a non-empty entry.\n    let parent = entry.parent\n    let key = entry.key\n    while (parent !== null) {\n      const parentMap = parent.map\n      if (parentMap !== null) {\n        parentMap.delete(key)\n        if (parentMap.size === 0) {\n          // We just removed the last entry in the parent map.\n          parent.map = null\n          if (parent.value === null) {\n            // The parent node has no child entries, nor does it have a value\n            // on itself. It can be garbage collected. Keep going.\n            key = parent.key\n            parent = parent.parent\n            continue\n          }\n        }\n      }\n      // The parent is not empty. Stop garbage collecting.\n      break\n    }\n  } else {\n    // Check if there's a revalidating entry. If so, promote it to a\n    // \"normal\" entry, since the normal one was just deleted.\n    const revalidatingEntry = map.get(Revalidation)\n    if (revalidatingEntry !== undefined && revalidatingEntry.value !== null) {\n      setMapEntryValue(entry, revalidatingEntry.value)\n    }\n  }\n}\n\nexport function setSizeInCacheMap<V extends MapValue>(\n  value: V,\n  size: number\n): void {\n  const entry = value.ref\n  if (entry === null) {\n    // This value is not a member of any map.\n    return\n  }\n  // Except during initialization (when the size is set to 0), this is the only\n  // place the `size` field should be updated, to ensure it's in sync with the\n  // the LRU.\n  value.size = size\n  updateLruSize(entry, size)\n}\n"],"names":["Fallback","createCacheMap","deleteFromCacheMap","deleteMapEntry","getFromCacheMap","isValueExpired","setInCacheMap","setSizeInCacheMap","Revalidation","cacheMap","parent","key","value","map","prev","next","size","getOrInitialize","keys","isRevalidation","entry","remainingKeys","previousKey","existingEntry","get","undefined","Map","newEntry","set","now","currentCacheVersion","rootEntry","getEntryWithFallbackImpl","lruPut","staleAt","version","lazilyEvictIfNeeded","result","fallbackEntry","setMapEntryValue","updateLruSize","dropRef","oldEntry","ref","deleteFromLru","parentMap","delete","revalidatingEntry"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 3395, "column": 0}, "map": {"version":3,"sources":["file:///D:/AconnectJP/node_modules/next/src/client/components/segment-cache/vary-path.ts"],"sourcesContent":["import { FetchStrategy } from './types'\nimport type {\n  NormalizedPathname,\n  NormalizedSearch,\n  NormalizedNextUrl,\n} from './cache-key'\nimport type { RouteTree } from './cache'\nimport { Fallback, type FallbackType } from './cache-map'\nimport { HEAD_REQUEST_KEY } from '../../../shared/lib/segment-cache/segment-value-encoding'\n\ntype Opaque<T, K> = T & { __brand: K }\n\n/**\n * A linked-list of all the params (or other param-like) inputs that a cache\n * entry may vary by. This is used by the CacheMap module to reuse cache entries\n * across different param values. If a param has a value of Fallback, it means\n * the cache entry is reusable for all possible values of that param. See\n * cache-map.ts for details.\n *\n * A segment's vary path is a pure function of a segment's position in a\n * particular route tree and the (post-rewrite) URL that is being queried. More\n * concretely, successive queries of the cache for the same segment always use\n * the same vary path.\n *\n * A route's vary path is simpler: it's comprised of the pathname, search\n * string, and Next-URL header.\n */\nexport type VaryPath = {\n  /**\n   * Identifies which param this vary path node corresponds to. Used by\n   * getFulfilledSegmentVaryPath to determine which params to replace with\n   * Fallback based on the varyParams set from the server.\n   *\n   * - For path params: the param name (e.g., 'slug')\n   * - For search params: '?'\n   * - For non-param nodes (request keys, etc.): null\n   */\n  id: string | null\n  value: string | null | FallbackType\n  parent: VaryPath | null\n}\n\n// Because it's so important for vary paths to line up across cache accesses,\n// we use opaque type aliases to ensure these are only created within\n// this module.\n\n// requestKey -> searchParams -> nextUrl\nexport type RouteVaryPath = Opaque<\n  {\n    id: null\n    value: NormalizedPathname\n    parent: {\n      id: '?'\n      value: NormalizedSearch\n      parent: {\n        id: null\n        value: NormalizedNextUrl | null | FallbackType\n        parent: null\n      }\n    }\n  },\n  'RouteVaryPath'\n>\n\n// requestKey -> pathParams\nexport type LayoutVaryPath = Opaque<\n  {\n    id: null\n    value: string\n    parent: PartialSegmentVaryPath | null\n  },\n  'LayoutVaryPath'\n>\n\n// requestKey -> searchParams -> pathParams\nexport type PageVaryPath = Opaque<\n  {\n    id: null\n    value: string\n    parent: {\n      id: '?'\n      value: NormalizedSearch | FallbackType\n      parent: PartialSegmentVaryPath | null\n    }\n  },\n  'PageVaryPath'\n>\n\nexport type SegmentVaryPath = LayoutVaryPath | PageVaryPath\n\n// Intermediate type used when building a vary path during a recursive traversal\n// of the route tree.\nexport type PartialSegmentVaryPath = Opaque<VaryPath, 'PartialSegmentVaryPath'>\n\nexport function getRouteVaryPath(\n  pathname: NormalizedPathname,\n  search: NormalizedSearch,\n  nextUrl: NormalizedNextUrl | null\n): RouteVaryPath {\n  // requestKey -> searchParams -> nextUrl\n  const varyPath: VaryPath = {\n    id: null,\n    value: pathname,\n    parent: {\n      id: '?',\n      value: search,\n      parent: {\n        id: null,\n        value: nextUrl,\n        parent: null,\n      },\n    },\n  }\n  return varyPath as RouteVaryPath\n}\n\nexport function getFulfilledRouteVaryPath(\n  pathname: NormalizedPathname,\n  search: NormalizedSearch,\n  nextUrl: NormalizedNextUrl | null,\n  couldBeIntercepted: boolean\n): RouteVaryPath {\n  // This is called when a route's data is fulfilled. The cache entry will be\n  // re-keyed based on which inputs the response varies by.\n  // requestKey -> searchParams -> nextUrl\n  const varyPath: VaryPath = {\n    id: null,\n    value: pathname,\n    parent: {\n      id: '?',\n      value: search,\n      parent: {\n        id: null,\n        value: couldBeIntercepted ? nextUrl : Fallback,\n        parent: null,\n      },\n    },\n  }\n  return varyPath as RouteVaryPath\n}\n\nexport function appendLayoutVaryPath(\n  parentPath: PartialSegmentVaryPath | null,\n  cacheKey: string,\n  paramName: string\n): PartialSegmentVaryPath {\n  const varyPathPart: VaryPath = {\n    id: paramName,\n    value: cacheKey,\n    parent: parentPath,\n  }\n  return varyPathPart as PartialSegmentVaryPath\n}\n\nexport function finalizeLayoutVaryPath(\n  requestKey: string,\n  varyPath: PartialSegmentVaryPath | null\n): LayoutVaryPath {\n  const layoutVaryPath: VaryPath = {\n    id: null,\n    value: requestKey,\n    parent: varyPath,\n  }\n  return layoutVaryPath as LayoutVaryPath\n}\n\nexport function getPartialLayoutVaryPath(\n  finalizedVaryPath: LayoutVaryPath\n): PartialSegmentVaryPath | null {\n  // This is the inverse of finalizeLayoutVaryPath.\n  return finalizedVaryPath.parent\n}\n\nexport function finalizePageVaryPath(\n  requestKey: string,\n  renderedSearch: NormalizedSearch,\n  varyPath: PartialSegmentVaryPath | null\n): PageVaryPath {\n  // Unlike layouts, a page segment's vary path also includes the search string.\n  // requestKey -> searchParams -> pathParams\n  const pageVaryPath: VaryPath = {\n    id: null,\n    value: requestKey,\n    parent: {\n      id: '?',\n      value: renderedSearch,\n      parent: varyPath,\n    },\n  }\n  return pageVaryPath as PageVaryPath\n}\n\nexport function getPartialPageVaryPath(\n  finalizedVaryPath: PageVaryPath\n): PartialSegmentVaryPath | null {\n  // This is the inverse of finalizePageVaryPath.\n  return finalizedVaryPath.parent.parent\n}\n\nexport function finalizeMetadataVaryPath(\n  pageRequestKey: string,\n  renderedSearch: NormalizedSearch,\n  varyPath: PartialSegmentVaryPath | null\n): PageVaryPath {\n  // The metadata \"segment\" is not a real segment because it doesn't exist in\n  // the normal structure of the route tree, but in terms of caching, it\n  // behaves like a page segment because it varies by all the same params as\n  // a page.\n  //\n  // To keep the protocol for querying the server simple, the request key for\n  // the metadata does not include any path information. It's unnecessary from\n  // the server's perspective, because unlike page segments, there's only one\n  // metadata response per URL, i.e. there's no need to distinguish multiple\n  // parallel pages.\n  //\n  // However, this means the metadata request key is insufficient for\n  // caching the the metadata in the client cache, because on the client we\n  // use the request key to distinguish the metadata entry from all other\n  // page's metadata entries.\n  //\n  // So instead we create a simulated request key based on the page segment.\n  // Conceptually this is equivalent to the request key the server would have\n  // assigned the metadata segment if it treated it as part of the actual\n  // route structure.\n\n  // If there are multiple parallel pages, we use whichever is the first one.\n  // This is fine because the only difference between request keys for\n  // different parallel pages are things like route groups and parallel\n  // route slots. As long as it's always the same one, it doesn't matter.\n  const pageVaryPath: VaryPath = {\n    id: null,\n    // Append the actual metadata request key to the page request key. Note\n    // that we're not using a separate vary path part; it's unnecessary because\n    // these are not conceptually separate inputs.\n    value: pageRequestKey + HEAD_REQUEST_KEY,\n    parent: {\n      id: '?',\n      value: renderedSearch,\n      parent: varyPath,\n    },\n  }\n  return pageVaryPath as PageVaryPath\n}\n\nexport function getSegmentVaryPathForRequest(\n  fetchStrategy: FetchStrategy,\n  tree: RouteTree\n): SegmentVaryPath {\n  // This is used for storing pending requests in the cache. We want to choose\n  // the most generic vary path based on the strategy used to fetch it, i.e.\n  // static/PPR versus runtime prefetching, so that it can be reused as much\n  // as possible.\n  //\n  // We may be able to re-key the response to something even more generic once\n  // we receive it  for example, if the server tells us that the response\n  // doesn't vary on a particular param  but even before we send the request,\n  // we know some params are reusable based on the fetch strategy alone. For\n  // example, a static prefetch will never vary on search params.\n  //\n  // The original vary path with all the params filled in is stored on the\n  // route tree object. We will clone this one to create a new vary path\n  // where certain params are replaced with Fallback.\n  //\n  // This result of this function is not stored anywhere. It's only used to\n  // access the cache a single time.\n  //\n  // TODO: Rather than create a new list object just to access the cache, the\n  // plan is to add the concept of a \"vary mask\". This will represent all the\n  // params that can be treated as Fallback. (Or perhaps the inverse.)\n  const originalVaryPath = tree.varyPath\n\n  // Only page segments (and the special \"metadata\" segment, which is treated\n  // like a page segment for the purposes of caching) may contain search\n  // params. There's no reason to include them in the vary path otherwise.\n  if (tree.isPage) {\n    // Only a runtime prefetch will include search params in the vary path.\n    // Static prefetches never include search params, so they can be reused\n    // across all possible search param values.\n    const doesVaryOnSearchParams =\n      fetchStrategy === FetchStrategy.Full ||\n      fetchStrategy === FetchStrategy.PPRRuntime\n\n    if (!doesVaryOnSearchParams) {\n      // The response from the the server will not vary on search params. Clone\n      // the end of the original vary path to replace the search params\n      // with Fallback.\n      //\n      // requestKey -> searchParams -> pathParams\n      //               ^ This part gets replaced with Fallback\n      const searchParamsVaryPath = (originalVaryPath as PageVaryPath).parent\n      const pathParamsVaryPath = searchParamsVaryPath.parent\n      const patchedVaryPath: VaryPath = {\n        id: null,\n        value: originalVaryPath.value,\n        parent: {\n          id: '?',\n          value: Fallback,\n          parent: pathParamsVaryPath,\n        },\n      }\n      return patchedVaryPath as SegmentVaryPath\n    }\n  }\n\n  // The request does vary on search params. We don't need to modify anything.\n  return originalVaryPath as SegmentVaryPath\n}\n\nexport function clonePageVaryPathWithNewSearchParams(\n  originalVaryPath: PageVaryPath,\n  newSearch: NormalizedSearch\n): PageVaryPath {\n  // requestKey -> searchParams -> pathParams\n  //               ^ This part gets replaced with newSearch\n  const searchParamsVaryPath = originalVaryPath.parent\n  const clonedVaryPath: VaryPath = {\n    id: null,\n    value: originalVaryPath.value,\n    parent: {\n      id: '?',\n      value: newSearch,\n      parent: searchParamsVaryPath.parent,\n    },\n  }\n  return clonedVaryPath as PageVaryPath\n}\n\nexport function getRenderedSearchFromVaryPath(\n  varyPath: PageVaryPath\n): NormalizedSearch | null {\n  const searchParams = varyPath.parent.value\n  return typeof searchParams === 'string'\n    ? (searchParams as NormalizedSearch)\n    : null\n}\n\nexport function getFulfilledSegmentVaryPath(\n  original: VaryPath,\n  varyParams: Set<string>\n): SegmentVaryPath {\n  // Re-keys a segment's vary path based on which params the segment actually\n  // depends on. Params that are NOT in the varyParams set are replaced with\n  // Fallback, allowing the cache entry to be reused across different values of\n  // those params.\n\n  // This is called when a segment is fulfilled with data from the server. The\n  // varyParams set comes from the server and indicates which params were\n  // accessed during rendering.\n  const clone: VaryPath = {\n    id: original.id,\n    // If the id is null, this node is not a param (e.g., it's a request key).\n    // If the id is in the varyParams set, keep the original value.\n    // Otherwise, replace with Fallback to make it reusable.\n    value:\n      original.id === null || varyParams.has(original.id)\n        ? original.value\n        : Fallback,\n    parent:\n      original.parent === null\n        ? null\n        : getFulfilledSegmentVaryPath(original.parent, varyParams),\n  }\n  return clone as SegmentVaryPath\n}\n"],"names":["appendLayoutVaryPath","clonePageVaryPathWithNewSearchParams","finalizeLayoutVaryPath","finalizeMetadataVaryPath","finalizePageVaryPath","getFulfilledRouteVaryPath","getFulfilledSegmentVaryPath","getPartialLayoutVaryPath","getPartialPageVaryPath","getRenderedSearchFromVaryPath","getRouteVaryPath","getSegmentVaryPathForRequest","pathname","search","nextUrl","varyPath","id","value","parent","couldBeIntercepted","Fallback","parentPath","cacheKey","paramName","varyPathPart","requestKey","layoutVaryPath","finalizedVaryPath","renderedSearch","pageVaryPath","pageRequestKey","HEAD_REQUEST_KEY","fetchStrategy","tree","originalVaryPath","isPage","doesVaryOnSearchParams","FetchStrategy","Full","PPRRuntime","searchParamsVaryPath","pathParamsVaryPath","patchedVaryPath","newSearch","clonedVaryPath","searchParams","original","varyParams","clone","has"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 3675, "column": 0}, "map": {"version":3,"sources":["file:///D:/AconnectJP/node_modules/next/src/client/components/segment-cache/cache-key.ts"],"sourcesContent":["// TypeScript trick to simulate opaque types, like in Flow.\ntype Opaque<K, T> = T & { __brand: K }\n\n// Only functions in this module should be allowed to create CacheKeys.\nexport type NormalizedPathname = Opaque<'NormalizedPathname', string>\nexport type NormalizedSearch = Opaque<'NormalizedSearch', string>\nexport type NormalizedNextUrl = Opaque<'NormalizedNextUrl', string>\n\nexport type RouteCacheKey = Opaque<\n  'RouteCacheKey',\n  {\n    pathname: NormalizedPathname\n    search: NormalizedSearch\n    nextUrl: NormalizedNextUrl | null\n\n    // TODO: Eventually the dynamic params will be added here, too.\n  }\n>\n\nexport function createCacheKey(\n  originalHref: string,\n  nextUrl: string | null\n): RouteCacheKey {\n  const originalUrl = new URL(originalHref)\n  const cacheKey = {\n    pathname: originalUrl.pathname as NormalizedPathname,\n    search: originalUrl.search as NormalizedSearch,\n    nextUrl: nextUrl as NormalizedNextUrl | null,\n  } as RouteCacheKey\n  return cacheKey\n}\n"],"names":["createCacheKey","originalHref","nextUrl","originalUrl","URL","cacheKey","pathname","search"],"mappings":"AAAA,2DAA2D;;;;+BAmB3CA,kBAAAA;;;eAAAA;;;AAAT,SAASA,eACdC,YAAoB,EACpBC,OAAsB;IAEtB,MAAMC,cAAc,IAAIC,IAAIH;IAC5B,MAAMI,WAAW;QACfC,UAAUH,YAAYG,QAAQ;QAC9BC,QAAQJ,YAAYI,MAAM;QAC1BL,SAASA;IACX;IACA,OAAOG;AACT","ignoreList":[0]}},
    {"offset": {"line": 3705, "column": 0}, "map": {"version":3,"sources":["file:///D:/AconnectJP/node_modules/next/src/client/components/segment-cache/scheduler.ts"],"sourcesContent":["import type {\n  FlightRouterState,\n  Segment as FlightRouterStateSegment,\n  Segment,\n} from '../../../shared/lib/app-router-types'\nimport { HasLoadingBoundary } from '../../../shared/lib/app-router-types'\nimport { matchSegment } from '../match-segments'\nimport {\n  readOrCreateRouteCacheEntry,\n  readOrCreateSegmentCacheEntry,\n  fetchRouteOnCacheMiss,\n  fetchSegmentOnCacheMiss,\n  EntryStatus,\n  type FulfilledRouteCacheEntry,\n  type RouteCacheEntry,\n  type SegmentCacheEntry,\n  type RouteTree,\n  fetchSegmentPrefetchesUsingDynamicRequest,\n  type PendingSegmentCacheEntry,\n  convertRouteTreeToFlightRouterState,\n  readOrCreateRevalidatingSegmentEntry,\n  upsertSegmentEntry,\n  type FulfilledSegmentCacheEntry,\n  upgradeToPendingSegment,\n  waitForSegmentCacheEntry,\n  overwriteRevalidatingSegmentCacheEntry,\n  canNewFetchStrategyProvideMoreContent,\n  attemptToFulfillDynamicSegmentFromBFCache,\n} from './cache'\nimport { getSegmentVaryPathForRequest, type SegmentVaryPath } from './vary-path'\nimport type { RouteCacheKey } from './cache-key'\nimport { createCacheKey } from './cache-key'\nimport {\n  FetchStrategy,\n  type PrefetchTaskFetchStrategy,\n  PrefetchPriority,\n} from './types'\nimport {\n  getCurrentRouteCacheVersion,\n  getCurrentSegmentCacheVersion,\n} from './cache'\nimport {\n  addSearchParamsIfPageSegment,\n  PAGE_SEGMENT_KEY,\n} from '../../../shared/lib/segment'\nimport type { SegmentRequestKey } from '../../../shared/lib/segment-cache/segment-value-encoding'\n\nconst scheduleMicrotask =\n  typeof queueMicrotask === 'function'\n    ? queueMicrotask\n    : (fn: () => unknown) =>\n        Promise.resolve()\n          .then(fn)\n          .catch((error) =>\n            setTimeout(() => {\n              throw error\n            })\n          )\n\nexport type PrefetchTask = {\n  key: RouteCacheKey\n\n  /**\n   * The FlightRouterState at the time the task was initiated. This is needed\n   * when falling back to the non-PPR behavior, which only prefetches up to\n   * the first loading boundary.\n   */\n  treeAtTimeOfPrefetch: FlightRouterState\n\n  /**\n   * The cache versions at the time the task was initiated. Used to determine\n   * if the cache was invalidated since the task was initiated. Route and\n   * segment caches have separate versions so they can be invalidated\n   * independently.\n   */\n  routeCacheVersion: number\n  segmentCacheVersion: number\n\n  /**\n   * Whether to prefetch dynamic data, in addition to static data. This is\n   * used by `<Link prefetch={true}>`.\n   *\n   * Note that a task with `FetchStrategy.PPR` might need to use\n   * `FetchStrategy.LoadingBoundary` instead if we find out that a route\n   * does not support PPR after doing the initial route prefetch.\n   */\n  fetchStrategy: PrefetchTaskFetchStrategy\n\n  /**\n   * sortId is an incrementing counter\n   *\n   * Newer prefetches are prioritized over older ones, so that as new links\n   * enter the viewport, they are not starved by older links that are no\n   * longer relevant. In the future, we can add additional prioritization\n   * heuristics, like removing prefetches once a link leaves the viewport.\n   *\n   * The sortId is assigned when the prefetch is initiated, and reassigned if\n   * the same task is prefetched again (effectively bumping it to the top of\n   * the queue).\n   *\n   * TODO: We can add additional fields here to indicate what kind of prefetch\n   * it is. For example, was it initiated by a link? Or was it an imperative\n   * call? If it was initiated by a link, we can remove it from the queue when\n   * the link leaves the viewport, but if it was an imperative call, then we\n   * should keep it in the queue until it's fulfilled.\n   *\n   * We can also add priority levels. For example, hovering over a link could\n   * increase the priority of its prefetch.\n   */\n  sortId: number\n\n  /**\n   * The priority of the task. Like sortId, this affects the task's position in\n   * the queue, so it must never be updated without resifting the heap.\n   */\n  priority: PrefetchPriority\n\n  /**\n   * The phase of the task. Tasks are split into multiple phases so that their\n   * priority can be adjusted based on what kind of work they're doing.\n   * Concretely, prefetching the route tree is higher priority than prefetching\n   * segment data.\n   */\n  phase: PrefetchPhase\n\n  /**\n   * These fields are temporary state for tracking the currently running task.\n   * They are reset after each iteration of the task queue.\n   */\n  hasBackgroundWork: boolean\n  spawnedRuntimePrefetches: Set<SegmentRequestKey> | null\n\n  /**\n   * True if the prefetch was cancelled.\n   */\n  isCanceled: boolean\n\n  /**\n   * The callback passed to `router.prefetch`, if given.\n   */\n  onInvalidate: null | (() => void)\n\n  /**\n   * The index of the task in the heap's backing array. Used to efficiently\n   * change the priority of a task by re-sifting it, which requires knowing\n   * where it is in the array. This is only used internally by the heap\n   * algorithm. The naive alternative is indexOf every time a task is queued,\n   * which has O(n) complexity.\n   *\n   * We also use this field to check whether a task is currently in the queue.\n   */\n  _heapIndex: number\n}\n\nconst enum PrefetchTaskExitStatus {\n  /**\n   * The task yielded because there are too many requests in progress.\n   */\n  InProgress,\n\n  /**\n   * The task is blocked. It needs more data before it can proceed.\n   *\n   * Currently the only reason this happens is we're still waiting to receive a\n   * route tree from the server, because we can't start prefetching the segments\n   * until we know what to prefetch.\n   */\n  Blocked,\n\n  /**\n   * There's nothing left to prefetch.\n   */\n  Done,\n}\n\n/**\n * Prefetch tasks are processed in two phases: first the route tree is fetched,\n * then the segments. We use this to priortize tasks that have not yet fetched\n * the route tree.\n */\nconst enum PrefetchPhase {\n  RouteTree = 1,\n  Segments = 0,\n}\n\nexport type PrefetchSubtaskResult<T> = {\n  /**\n   * A promise that resolves when the network connection is closed.\n   */\n  closed: Promise<void>\n  value: T\n}\n\nconst taskHeap: Array<PrefetchTask> = []\n\nlet inProgressRequests = 0\n\nlet sortIdCounter = 0\nlet didScheduleMicrotask = false\n\n// The most recently hovered (or touched, etc) link, i.e. the most recent task\n// scheduled at Intent priority. There's only ever a single task at Intent\n// priority at a time. We reserve special network bandwidth for this task only.\nlet mostRecentlyHoveredLink: PrefetchTask | null = null\n\n// CDN cache propagation delay after revalidation (in milliseconds)\nconst REVALIDATION_COOLDOWN_MS = 300\n\n// Timeout handle for the revalidation cooldown. When non-null, prefetch\n// requests are blocked to allow CDN cache propagation.\nlet revalidationCooldownTimeoutHandle: ReturnType<typeof setTimeout> | null =\n  null\n\n/**\n * Called by the cache when revalidation occurs. Starts a cooldown period\n * during which prefetch requests are blocked to allow CDN cache propagation.\n */\nexport function startRevalidationCooldown(): void {\n  // Clear any existing timeout in case multiple revalidations happen\n  // in quick succession.\n  if (revalidationCooldownTimeoutHandle !== null) {\n    clearTimeout(revalidationCooldownTimeoutHandle)\n  }\n\n  // Schedule the cooldown to expire after the delay.\n  revalidationCooldownTimeoutHandle = setTimeout(() => {\n    revalidationCooldownTimeoutHandle = null\n    // Retry the prefetch queue now that the cooldown has expired.\n    ensureWorkIsScheduled()\n  }, REVALIDATION_COOLDOWN_MS)\n}\n\nexport type IncludeDynamicData = null | 'full' | 'dynamic'\n\n/**\n * Initiates a prefetch task for the given URL. If a prefetch for the same URL\n * is already in progress, this will bump it to the top of the queue.\n *\n * This is not a user-facing function. By the time this is called, the href is\n * expected to be validated and normalized.\n *\n * @param key The RouteCacheKey to prefetch.\n * @param treeAtTimeOfPrefetch The app's current FlightRouterState\n * @param fetchStrategy Whether to prefetch dynamic data, in addition to\n * static data. This is used by `<Link prefetch={true}>`.\n */\nexport function schedulePrefetchTask(\n  key: RouteCacheKey,\n  treeAtTimeOfPrefetch: FlightRouterState,\n  fetchStrategy: PrefetchTaskFetchStrategy,\n  priority: PrefetchPriority,\n  onInvalidate: null | (() => void)\n): PrefetchTask {\n  // Spawn a new prefetch task\n  const task: PrefetchTask = {\n    key,\n    treeAtTimeOfPrefetch,\n    routeCacheVersion: getCurrentRouteCacheVersion(),\n    segmentCacheVersion: getCurrentSegmentCacheVersion(),\n    priority,\n    phase: PrefetchPhase.RouteTree,\n    hasBackgroundWork: false,\n    spawnedRuntimePrefetches: null,\n    fetchStrategy,\n    sortId: sortIdCounter++,\n    isCanceled: false,\n    onInvalidate,\n    _heapIndex: -1,\n  }\n\n  trackMostRecentlyHoveredLink(task)\n\n  heapPush(taskHeap, task)\n\n  // Schedule an async task to process the queue.\n  //\n  // The main reason we process the queue in an async task is for batching.\n  // It's common for a single JS task/event to trigger multiple prefetches.\n  // By deferring to a microtask, we only process the queue once per JS task.\n  // If they have different priorities, it also ensures they are processed in\n  // the optimal order.\n  ensureWorkIsScheduled()\n\n  return task\n}\n\nexport function cancelPrefetchTask(task: PrefetchTask): void {\n  // Remove the prefetch task from the queue. If the task already completed,\n  // then this is a no-op.\n  //\n  // We must also explicitly mark the task as canceled so that a blocked task\n  // does not get added back to the queue when it's pinged by the network.\n  task.isCanceled = true\n  heapDelete(taskHeap, task)\n}\n\nexport function reschedulePrefetchTask(\n  task: PrefetchTask,\n  treeAtTimeOfPrefetch: FlightRouterState,\n  fetchStrategy: PrefetchTaskFetchStrategy,\n  priority: PrefetchPriority\n): void {\n  // Bump the prefetch task to the top of the queue, as if it were a fresh\n  // task. This is essentially the same as canceling the task and scheduling\n  // a new one, except it reuses the original object.\n  //\n  // The primary use case is to increase the priority of a Link-initated\n  // prefetch on hover.\n\n  // Un-cancel the task, in case it was previously canceled.\n  task.isCanceled = false\n  task.phase = PrefetchPhase.RouteTree\n\n  // Assign a new sort ID to move it ahead of all other tasks at the same\n  // priority level. (Higher sort IDs are processed first.)\n  task.sortId = sortIdCounter++\n  task.priority =\n    // If this task is the most recently hovered link, maintain its\n    // Intent priority, even if the rescheduled priority is lower.\n    task === mostRecentlyHoveredLink ? PrefetchPriority.Intent : priority\n\n  task.treeAtTimeOfPrefetch = treeAtTimeOfPrefetch\n  task.fetchStrategy = fetchStrategy\n\n  trackMostRecentlyHoveredLink(task)\n\n  if (task._heapIndex !== -1) {\n    // The task is already in the queue.\n    heapResift(taskHeap, task)\n  } else {\n    heapPush(taskHeap, task)\n  }\n  ensureWorkIsScheduled()\n}\n\nexport function isPrefetchTaskDirty(\n  task: PrefetchTask,\n  nextUrl: string | null,\n  tree: FlightRouterState\n): boolean {\n  // This is used to quickly bail out of a prefetch task if the result is\n  // guaranteed to not have changed since the task was initiated. This is\n  // strictly an optimization  theoretically, if it always returned true, no\n  // behavior should change because a full prefetch task will effectively\n  // perform the same checks.\n  return (\n    task.routeCacheVersion !== getCurrentRouteCacheVersion() ||\n    task.segmentCacheVersion !== getCurrentSegmentCacheVersion() ||\n    task.treeAtTimeOfPrefetch !== tree ||\n    task.key.nextUrl !== nextUrl\n  )\n}\n\nfunction trackMostRecentlyHoveredLink(task: PrefetchTask) {\n  // Track the mostly recently hovered link, i.e. the most recently scheduled\n  // task at Intent priority. There must only be one such task at a time.\n  if (\n    task.priority === PrefetchPriority.Intent &&\n    task !== mostRecentlyHoveredLink\n  ) {\n    if (mostRecentlyHoveredLink !== null) {\n      // Bump the previously hovered link's priority down to Default.\n      if (mostRecentlyHoveredLink.priority !== PrefetchPriority.Background) {\n        mostRecentlyHoveredLink.priority = PrefetchPriority.Default\n        heapResift(taskHeap, mostRecentlyHoveredLink)\n      }\n    }\n    mostRecentlyHoveredLink = task\n  }\n}\n\nfunction ensureWorkIsScheduled() {\n  if (didScheduleMicrotask) {\n    // Already scheduled a task to process the queue\n    return\n  }\n  didScheduleMicrotask = true\n  scheduleMicrotask(processQueueInMicrotask)\n}\n\n/**\n * Checks if we've exceeded the maximum number of concurrent prefetch requests,\n * to avoid saturating the browser's internal network queue. This is a\n * cooperative limit  prefetch tasks should check this before issuing\n * new requests.\n *\n * Also checks if we're within the revalidation cooldown window, during which\n * prefetch requests are delayed to allow CDN cache propagation.\n */\nfunction hasNetworkBandwidth(task: PrefetchTask): boolean {\n  // Check if we're within the revalidation cooldown window\n  if (revalidationCooldownTimeoutHandle !== null) {\n    // We're within the cooldown window. Return false to prevent prefetching.\n    // When the cooldown expires, the timeout will call ensureWorkIsScheduled()\n    // to retry the queue.\n    return false\n  }\n\n  // TODO: Also check if there's an in-progress navigation. We should never\n  // add prefetch requests to the network queue if an actual navigation is\n  // taking place, to ensure there's sufficient bandwidth for render-blocking\n  // data and resources.\n\n  // TODO: Consider reserving some amount of bandwidth for static prefetches.\n\n  if (task.priority === PrefetchPriority.Intent) {\n    // The most recently hovered link is allowed to exceed the default limit.\n    //\n    // The goal is to always have enough bandwidth to start a new prefetch\n    // request when hovering over a link.\n    //\n    // However, because we don't abort in-progress requests, it's still possible\n    // we'll run out of bandwidth. When links are hovered in quick succession,\n    // there could be multiple hover requests running simultaneously.\n    return inProgressRequests < 12\n  }\n\n  // The default limit is lower than the limit for a hovered link.\n  return inProgressRequests < 4\n}\n\nfunction spawnPrefetchSubtask<T>(\n  prefetchSubtask: Promise<PrefetchSubtaskResult<T> | null>\n): Promise<T | null> {\n  // When the scheduler spawns an async task, we don't await its result.\n  // Instead, the async task writes its result directly into the cache, then\n  // pings the scheduler to continue.\n  //\n  // We process server responses streamingly, so the prefetch subtask will\n  // likely resolve before we're finished receiving all the data. The subtask\n  // result includes a promise that resolves once the network connection is\n  // closed. The scheduler uses this to control network bandwidth by tracking\n  // and limiting the number of concurrent requests.\n  inProgressRequests++\n  return prefetchSubtask.then((result) => {\n    if (result === null) {\n      // The prefetch task errored before it could start processing the\n      // network stream. Assume the connection is closed.\n      onPrefetchConnectionClosed()\n      return null\n    }\n    // Wait for the connection to close before freeing up more bandwidth.\n    result.closed.then(onPrefetchConnectionClosed)\n    return result.value\n  })\n}\n\nfunction onPrefetchConnectionClosed(): void {\n  inProgressRequests--\n\n  // Notify the scheduler that we have more bandwidth, and can continue\n  // processing tasks.\n  ensureWorkIsScheduled()\n}\n\n/**\n * Notify the scheduler that we've received new data for an in-progress\n * prefetch. The corresponding task will be added back to the queue (unless the\n * task has been canceled in the meantime).\n */\nexport function pingPrefetchTask(task: PrefetchTask) {\n  // \"Ping\" a prefetch that's already in progress to notify it of new data.\n  if (\n    // Check if prefetch was canceled.\n    task.isCanceled ||\n    // Check if prefetch is already queued.\n    task._heapIndex !== -1\n  ) {\n    return\n  }\n  // Add the task back to the queue.\n  heapPush(taskHeap, task)\n  ensureWorkIsScheduled()\n}\n\nfunction processQueueInMicrotask() {\n  didScheduleMicrotask = false\n\n  // We aim to minimize how often we read the current time. Since nearly all\n  // functions in the prefetch scheduler are synchronous, we can read the time\n  // once and pass it as an argument wherever it's needed.\n  const now = Date.now()\n\n  // Process the task queue until we run out of network bandwidth.\n  let task = heapPeek(taskHeap)\n  while (task !== null && hasNetworkBandwidth(task)) {\n    task.routeCacheVersion = getCurrentRouteCacheVersion()\n    task.segmentCacheVersion = getCurrentSegmentCacheVersion()\n\n    const exitStatus = pingRoute(now, task)\n\n    // These fields are only valid for a single attempt. Reset them after each\n    // iteration of the task queue.\n    const hasBackgroundWork = task.hasBackgroundWork\n    task.hasBackgroundWork = false\n    task.spawnedRuntimePrefetches = null\n\n    switch (exitStatus) {\n      case PrefetchTaskExitStatus.InProgress:\n        // The task yielded because there are too many requests in progress.\n        // Stop processing tasks until we have more bandwidth.\n        return\n      case PrefetchTaskExitStatus.Blocked:\n        // The task is blocked. It needs more data before it can proceed.\n        // Keep the task out of the queue until the server responds.\n        heapPop(taskHeap)\n        // Continue to the next task\n        task = heapPeek(taskHeap)\n        continue\n      case PrefetchTaskExitStatus.Done:\n        if (task.phase === PrefetchPhase.RouteTree) {\n          // Finished prefetching the route tree. Proceed to prefetching\n          // the segments.\n          task.phase = PrefetchPhase.Segments\n          heapResift(taskHeap, task)\n        } else if (hasBackgroundWork) {\n          // The task spawned additional background work. Reschedule the task\n          // at background priority.\n          task.priority = PrefetchPriority.Background\n          heapResift(taskHeap, task)\n        } else {\n          // The prefetch is complete. Continue to the next task.\n          heapPop(taskHeap)\n        }\n        task = heapPeek(taskHeap)\n        continue\n      default:\n        exitStatus satisfies never\n    }\n  }\n}\n\n/**\n * Check this during a prefetch task to determine if background work can be\n * performed. If so, it evaluates to `true`. Otherwise, it returns `false`,\n * while also scheduling a background task to run later. Usage:\n *\n * @example\n * if (background(task)) {\n *   // Perform background-pri work\n * }\n */\nfunction background(task: PrefetchTask): boolean {\n  if (task.priority === PrefetchPriority.Background) {\n    return true\n  }\n  task.hasBackgroundWork = true\n  return false\n}\n\nfunction pingRoute(now: number, task: PrefetchTask): PrefetchTaskExitStatus {\n  const key = task.key\n  const route = readOrCreateRouteCacheEntry(now, task, key)\n  const exitStatus = pingRootRouteTree(now, task, route)\n\n  if (exitStatus !== PrefetchTaskExitStatus.InProgress && key.search !== '') {\n    // If the URL has a non-empty search string, also prefetch the pathname\n    // without the search string. We use the searchless route tree as a base for\n    // optimistic routing; see requestOptimisticRouteCacheEntry for details.\n    //\n    // Note that we don't need to prefetch any of the segment data. Just the\n    // route tree.\n    //\n    // TODO: This is a temporary solution; the plan is to replace this by adding\n    // a wildcard lookup method to the TupleMap implementation. This is\n    // non-trivial to implement because it needs to account for things like\n    // fallback route entries, hence this temporary workaround.\n    const url = new URL(key.pathname, location.origin)\n    const keyWithoutSearch = createCacheKey(url.href, key.nextUrl)\n    const routeWithoutSearch = readOrCreateRouteCacheEntry(\n      now,\n      task,\n      keyWithoutSearch\n    )\n    switch (routeWithoutSearch.status) {\n      case EntryStatus.Empty: {\n        if (background(task)) {\n          routeWithoutSearch.status = EntryStatus.Pending\n          spawnPrefetchSubtask(\n            fetchRouteOnCacheMiss(routeWithoutSearch, task, keyWithoutSearch)\n          )\n        }\n        break\n      }\n      case EntryStatus.Pending:\n      case EntryStatus.Fulfilled:\n      case EntryStatus.Rejected: {\n        // Either the route tree is already cached, or there's already a\n        // request in progress. Since we don't need to fetch any segment data\n        // for this route, there's nothing left to do.\n        break\n      }\n      default:\n        routeWithoutSearch satisfies never\n    }\n  }\n\n  return exitStatus\n}\n\nfunction pingRootRouteTree(\n  now: number,\n  task: PrefetchTask,\n  route: RouteCacheEntry\n): PrefetchTaskExitStatus {\n  switch (route.status) {\n    case EntryStatus.Empty: {\n      // Route is not yet cached, and there's no request already in progress.\n      // Spawn a task to request the route, load it into the cache, and ping\n      // the task to continue.\n\n      // TODO: There are multiple strategies in the <Link> API for prefetching\n      // a route. Currently we've only implemented the main one: per-segment,\n      // static-data only.\n      //\n      // There's also `<Link prefetch={true}>`\n      // which prefetch both static *and* dynamic data.\n      // Similarly, we need to fallback to the old, per-page\n      // behavior if PPR is disabled for a route (via the incremental opt-in).\n      //\n      // Those cases will be handled here.\n      spawnPrefetchSubtask(fetchRouteOnCacheMiss(route, task, task.key))\n\n      // If the request takes longer than a minute, a subsequent request should\n      // retry instead of waiting for this one. When the response is received,\n      // this value will be replaced by a new value based on the stale time sent\n      // from the server.\n      // TODO: We should probably also manually abort the fetch task, to reclaim\n      // server bandwidth.\n      route.staleAt = now + 60 * 1000\n\n      // Upgrade to Pending so we know there's already a request in progress\n      route.status = EntryStatus.Pending\n\n      // Intentional fallthrough to the Pending branch\n    }\n    case EntryStatus.Pending: {\n      // Still pending. We can't start prefetching the segments until the route\n      // tree has loaded. Add the task to the set of blocked tasks so that it\n      // is notified when the route tree is ready.\n      const blockedTasks = route.blockedTasks\n      if (blockedTasks === null) {\n        route.blockedTasks = new Set([task])\n      } else {\n        blockedTasks.add(task)\n      }\n      return PrefetchTaskExitStatus.Blocked\n    }\n    case EntryStatus.Rejected: {\n      // Route tree failed to load. Treat as a 404.\n      return PrefetchTaskExitStatus.Done\n    }\n    case EntryStatus.Fulfilled: {\n      if (task.phase !== PrefetchPhase.Segments) {\n        // Do not prefetch segment data until we've entered the segment phase.\n        return PrefetchTaskExitStatus.Done\n      }\n      // Recursively fill in the segment tree.\n      if (!hasNetworkBandwidth(task)) {\n        // Stop prefetching segments until there's more bandwidth.\n        return PrefetchTaskExitStatus.InProgress\n      }\n      const tree = route.tree\n\n      // A task's fetch strategy gets set to `PPR` for any \"auto\" prefetch.\n      // If it turned out that the route isn't PPR-enabled, we need to use `LoadingBoundary` instead.\n      // We don't need to do this for runtime prefetches, because those are only available in\n      // `cacheComponents`, where every route is PPR.\n      const fetchStrategy =\n        task.fetchStrategy === FetchStrategy.PPR\n          ? route.isPPREnabled\n            ? FetchStrategy.PPR\n            : FetchStrategy.LoadingBoundary\n          : task.fetchStrategy\n\n      switch (fetchStrategy) {\n        case FetchStrategy.PPR: {\n          // For Cache Components pages, each segment may be prefetched\n          // statically or using a runtime request, based on various\n          // configurations and heuristics. We'll do this in two passes: first\n          // traverse the tree and perform all the static prefetches.\n          //\n          // Then, if there are any segments that need a runtime request,\n          // do another pass to perform a runtime prefetch.\n          pingStaticHead(now, task, route)\n          const exitStatus = pingSharedPartOfCacheComponentsTree(\n            now,\n            task,\n            route,\n            task.treeAtTimeOfPrefetch,\n            tree\n          )\n          if (exitStatus === PrefetchTaskExitStatus.InProgress) {\n            // Child yielded without finishing.\n            return PrefetchTaskExitStatus.InProgress\n          }\n          const spawnedRuntimePrefetches = task.spawnedRuntimePrefetches\n          if (spawnedRuntimePrefetches !== null) {\n            // During the first pass, we discovered segments that require a\n            // runtime prefetch. Do a second pass to construct a request tree.\n            const spawnedEntries = new Map<\n              SegmentRequestKey,\n              PendingSegmentCacheEntry\n            >()\n            pingRuntimeHead(\n              now,\n              task,\n              route,\n              spawnedEntries,\n              FetchStrategy.PPRRuntime\n            )\n            const requestTree = pingRuntimePrefetches(\n              now,\n              task,\n              route,\n              tree,\n              spawnedRuntimePrefetches,\n              spawnedEntries\n            )\n            let needsDynamicRequest = spawnedEntries.size > 0\n            if (needsDynamicRequest) {\n              // Perform a dynamic prefetch request and populate the cache with\n              // the result.\n              spawnPrefetchSubtask(\n                fetchSegmentPrefetchesUsingDynamicRequest(\n                  task,\n                  route,\n                  FetchStrategy.PPRRuntime,\n                  requestTree,\n                  spawnedEntries\n                )\n              )\n            }\n          }\n          return PrefetchTaskExitStatus.Done\n        }\n        case FetchStrategy.Full:\n        case FetchStrategy.PPRRuntime:\n        case FetchStrategy.LoadingBoundary: {\n          // Prefetch multiple segments using a single dynamic request.\n          // TODO: We can consolidate this branch with previous one by modeling\n          // it as if the first segment in the new tree has runtime prefetching\n          // enabled. Will do this as a follow-up refactor. Might want to remove\n          // the special metatdata case below first. In the meantime, it's not\n          // really that much duplication, just would be nice to remove one of\n          // these codepaths.\n          const spawnedEntries = new Map<\n            SegmentRequestKey,\n            PendingSegmentCacheEntry\n          >()\n          pingRuntimeHead(now, task, route, spawnedEntries, fetchStrategy)\n          const dynamicRequestTree = diffRouteTreeAgainstCurrent(\n            now,\n            task,\n            route,\n            task.treeAtTimeOfPrefetch,\n            tree,\n            spawnedEntries,\n            fetchStrategy\n          )\n          let needsDynamicRequest = spawnedEntries.size > 0\n          if (needsDynamicRequest) {\n            spawnPrefetchSubtask(\n              fetchSegmentPrefetchesUsingDynamicRequest(\n                task,\n                route,\n                fetchStrategy,\n                dynamicRequestTree,\n                spawnedEntries\n              )\n            )\n          }\n          return PrefetchTaskExitStatus.Done\n        }\n        default:\n          fetchStrategy satisfies never\n      }\n      break\n    }\n    default: {\n      route satisfies never\n    }\n  }\n  return PrefetchTaskExitStatus.Done\n}\n\nfunction pingStaticHead(\n  now: number,\n  task: PrefetchTask,\n  route: FulfilledRouteCacheEntry\n): void {\n  // The Head data for a page (metadata, viewport) is not really a route\n  // segment, in the sense that it doesn't appear in the route tree. But we\n  // store it in the cache as if it were, using a special key.\n  pingStaticSegmentData(\n    now,\n    task,\n    route,\n    readOrCreateSegmentCacheEntry(now, FetchStrategy.PPR, route.metadata),\n    task.key,\n    route.metadata\n  )\n}\n\nfunction pingRuntimeHead(\n  now: number,\n  task: PrefetchTask,\n  route: FulfilledRouteCacheEntry,\n  spawnedEntries: Map<SegmentRequestKey, PendingSegmentCacheEntry>,\n  fetchStrategy:\n    | FetchStrategy.Full\n    | FetchStrategy.PPRRuntime\n    | FetchStrategy.LoadingBoundary\n): void {\n  pingRouteTreeAndIncludeDynamicData(\n    now,\n    task,\n    route,\n    route.metadata,\n    false,\n    spawnedEntries,\n    // When prefetching the head, there's no difference between Full\n    // and LoadingBoundary\n    fetchStrategy === FetchStrategy.LoadingBoundary\n      ? FetchStrategy.Full\n      : fetchStrategy\n  )\n}\n\n// TODO: Rename dynamic -> runtime throughout this module\n\nfunction pingSharedPartOfCacheComponentsTree(\n  now: number,\n  task: PrefetchTask,\n  route: FulfilledRouteCacheEntry,\n  oldTree: FlightRouterState,\n  newTree: RouteTree\n): PrefetchTaskExitStatus {\n  // When Cache Components is enabled (or PPR, or a fully static route when PPR\n  // is disabled; those cases are treated equivalently to Cache Components), we\n  // start by prefetching each segment individually. Once we reach the \"new\"\n  // part of the tree  the part that doesn't exist on the current page  we\n  // may choose to switch to a runtime prefetch instead, based on the\n  // information sent by the server in the route tree.\n  //\n  // The traversal starts in the \"shared\" part of the tree. Once we reach the\n  // \"new\" part of the tree, we switch to a different traversal,\n  // pingNewPartOfCacheComponentsTree.\n\n  // Prefetch this segment's static data.\n  const segment = readOrCreateSegmentCacheEntry(\n    now,\n    task.fetchStrategy,\n    newTree\n  )\n  pingStaticSegmentData(now, task, route, segment, task.key, newTree)\n\n  // Recursively ping the children.\n  const oldTreeChildren = oldTree[1]\n  const newTreeChildren = newTree.slots\n  if (newTreeChildren !== null) {\n    for (const parallelRouteKey in newTreeChildren) {\n      if (!hasNetworkBandwidth(task)) {\n        // Stop prefetching segments until there's more bandwidth.\n        return PrefetchTaskExitStatus.InProgress\n      }\n      const newTreeChild = newTreeChildren[parallelRouteKey]\n      const newTreeChildSegment = newTreeChild.segment\n      const oldTreeChild: FlightRouterState | void =\n        oldTreeChildren[parallelRouteKey]\n      const oldTreeChildSegment: FlightRouterStateSegment | void =\n        oldTreeChild?.[0]\n      let childExitStatus\n      if (\n        oldTreeChildSegment !== undefined &&\n        doesCurrentSegmentMatchCachedSegment(\n          route,\n          newTreeChildSegment,\n          oldTreeChildSegment\n        )\n      ) {\n        // We're still in the \"shared\" part of the tree.\n        childExitStatus = pingSharedPartOfCacheComponentsTree(\n          now,\n          task,\n          route,\n          oldTreeChild,\n          newTreeChild\n        )\n      } else {\n        // We've entered the \"new\" part of the tree. Switch\n        // traversal functions.\n        childExitStatus = pingNewPartOfCacheComponentsTree(\n          now,\n          task,\n          route,\n          newTreeChild\n        )\n      }\n      if (childExitStatus === PrefetchTaskExitStatus.InProgress) {\n        // Child yielded without finishing.\n        return PrefetchTaskExitStatus.InProgress\n      }\n    }\n  }\n\n  return PrefetchTaskExitStatus.Done\n}\n\nfunction pingNewPartOfCacheComponentsTree(\n  now: number,\n  task: PrefetchTask,\n  route: FulfilledRouteCacheEntry,\n  tree: RouteTree\n): PrefetchTaskExitStatus.InProgress | PrefetchTaskExitStatus.Done {\n  // We're now prefetching in the \"new\" part of the tree, the part that doesn't\n  // exist on the current page. (In other words, we're deeper than the\n  // shared layouts.) Segments in here default to being prefetched statically.\n  // However, if the server instructs us to, we may switch to a runtime\n  // prefetch instead. Traverse the tree and check at each segment.\n  if (tree.hasRuntimePrefetch) {\n    // This route has a runtime prefetch response. Since we're below the shared\n    // layout, everything from this point should be prefetched using a single,\n    // combined runtime request, rather than using per-segment static requests.\n    // This is true even if some of the child segments are known to be fully\n    // static  once we've decided to perform a runtime prefetch, we might as\n    // well respond with the static segments in the same roundtrip. (That's how\n    // regular navigations work, too.) We'll still skip over segments that are\n    // already cached, though.\n    //\n    // It's the server's responsibility to set a reasonable value of\n    // `hasRuntimePrefetch`. Currently it's user-defined, but eventually, the\n    // server may send a value of `false` even if the user opts in, if it\n    // determines during build that the route is always fully static. There are\n    // more optimizations we can do once we implement fallback param\n    // tracking, too.\n    //\n    // Use the task object to collect the segments that need a runtime prefetch.\n    // This will signal to the outer task queue that a second traversal is\n    // required to construct a request tree.\n    if (task.spawnedRuntimePrefetches === null) {\n      task.spawnedRuntimePrefetches = new Set([tree.requestKey])\n    } else {\n      task.spawnedRuntimePrefetches.add(tree.requestKey)\n    }\n    // Then exit the traversal without prefetching anything further.\n    return PrefetchTaskExitStatus.Done\n  }\n\n  // This segment should not be runtime prefetched. Prefetch its static data.\n  const segment = readOrCreateSegmentCacheEntry(now, task.fetchStrategy, tree)\n  pingStaticSegmentData(now, task, route, segment, task.key, tree)\n  if (tree.slots !== null) {\n    if (!hasNetworkBandwidth(task)) {\n      // Stop prefetching segments until there's more bandwidth.\n      return PrefetchTaskExitStatus.InProgress\n    }\n    // Recursively ping the children.\n    for (const parallelRouteKey in tree.slots) {\n      const childTree = tree.slots[parallelRouteKey]\n      const childExitStatus = pingNewPartOfCacheComponentsTree(\n        now,\n        task,\n        route,\n        childTree\n      )\n      if (childExitStatus === PrefetchTaskExitStatus.InProgress) {\n        // Child yielded without finishing.\n        return PrefetchTaskExitStatus.InProgress\n      }\n    }\n  }\n  // This segment and all its children have finished prefetching.\n  return PrefetchTaskExitStatus.Done\n}\n\nfunction diffRouteTreeAgainstCurrent(\n  now: number,\n  task: PrefetchTask,\n  route: FulfilledRouteCacheEntry,\n  oldTree: FlightRouterState,\n  newTree: RouteTree,\n  spawnedEntries: Map<SegmentRequestKey, PendingSegmentCacheEntry>,\n  fetchStrategy:\n    | FetchStrategy.Full\n    | FetchStrategy.PPRRuntime\n    | FetchStrategy.LoadingBoundary\n): FlightRouterState {\n  // This is a single recursive traversal that does multiple things:\n  // - Finds the parts of the target route (newTree) that are not part of\n  //   of the current page (oldTree) by diffing them, using the same algorithm\n  //   as a real navigation.\n  // - Constructs a request tree (FlightRouterState) that describes which\n  //   segments need to be prefetched and which ones are already cached.\n  // - Creates a set of pending cache entries for the segments that need to\n  //   be prefetched, so that a subsequent prefetch task does not request the\n  //   same segments again.\n  const oldTreeChildren = oldTree[1]\n  const newTreeChildren = newTree.slots\n  let requestTreeChildren: Record<string, FlightRouterState> = {}\n  if (newTreeChildren !== null) {\n    for (const parallelRouteKey in newTreeChildren) {\n      const newTreeChild = newTreeChildren[parallelRouteKey]\n      const newTreeChildSegment = newTreeChild.segment\n      const oldTreeChild: FlightRouterState | void =\n        oldTreeChildren[parallelRouteKey]\n      const oldTreeChildSegment: FlightRouterStateSegment | void =\n        oldTreeChild?.[0]\n      if (\n        oldTreeChildSegment !== undefined &&\n        doesCurrentSegmentMatchCachedSegment(\n          route,\n          newTreeChildSegment,\n          oldTreeChildSegment\n        )\n      ) {\n        // This segment is already part of the current route. Keep traversing.\n        const requestTreeChild = diffRouteTreeAgainstCurrent(\n          now,\n          task,\n          route,\n          oldTreeChild,\n          newTreeChild,\n          spawnedEntries,\n          fetchStrategy\n        )\n        requestTreeChildren[parallelRouteKey] = requestTreeChild\n      } else {\n        // This segment is not part of the current route. We're entering a\n        // part of the tree that we need to prefetch (unless everything is\n        // already cached).\n        switch (fetchStrategy) {\n          case FetchStrategy.LoadingBoundary: {\n            // When PPR is disabled, we can't prefetch per segment. We must\n            // fallback to the old prefetch behavior and send a dynamic request.\n            // Only routes that include a loading boundary can be prefetched in\n            // this way.\n            //\n            // This is simlar to a \"full\" prefetch, but we're much more\n            // conservative about which segments to include in the request.\n            //\n            // The server will only render up to the first loading boundary\n            // inside new part of the tree. If there's no loading boundary\n            // anywhere in the tree, the server will never return any data, so\n            // we can skip the request.\n            const subtreeHasLoadingBoundary =\n              newTreeChild.hasLoadingBoundary !==\n              HasLoadingBoundary.SubtreeHasNoLoadingBoundary\n            const requestTreeChild = subtreeHasLoadingBoundary\n              ? pingPPRDisabledRouteTreeUpToLoadingBoundary(\n                  now,\n                  task,\n                  route,\n                  newTreeChild,\n                  null,\n                  spawnedEntries\n                )\n              : // There's no loading boundary within this tree. Bail out.\n                convertRouteTreeToFlightRouterState(newTreeChild)\n            requestTreeChildren[parallelRouteKey] = requestTreeChild\n            break\n          }\n          case FetchStrategy.PPRRuntime: {\n            // This is a runtime prefetch. Fetch all cacheable data in the tree,\n            // not just the static PPR shell.\n            const requestTreeChild = pingRouteTreeAndIncludeDynamicData(\n              now,\n              task,\n              route,\n              newTreeChild,\n              false,\n              spawnedEntries,\n              fetchStrategy\n            )\n            requestTreeChildren[parallelRouteKey] = requestTreeChild\n            break\n          }\n          case FetchStrategy.Full: {\n            // This is a \"full\" prefetch. Fetch all the data in the tree, both\n            // static and dynamic. We issue roughly the same request that we\n            // would during a real navigation. The goal is that once the\n            // navigation occurs, the router should not have to fetch any\n            // additional data.\n            //\n            // Although the response will include dynamic data, opting into a\n            // Full prefetch  via <Link prefetch={true}>  implicitly\n            // instructs the cache to treat the response as \"static\", or non-\n            // dynamic, since the whole point is to cache it for\n            // future navigations.\n            //\n            // Construct a tree (currently a FlightRouterState) that represents\n            // which segments need to be prefetched and which ones are already\n            // cached. If the tree is empty, then we can exit. Otherwise, we'll\n            // send the request tree to the server and use the response to\n            // populate the segment cache.\n            const requestTreeChild = pingRouteTreeAndIncludeDynamicData(\n              now,\n              task,\n              route,\n              newTreeChild,\n              false,\n              spawnedEntries,\n              fetchStrategy\n            )\n            requestTreeChildren[parallelRouteKey] = requestTreeChild\n            break\n          }\n          default:\n            fetchStrategy satisfies never\n        }\n      }\n    }\n  }\n  const requestTree: FlightRouterState = [\n    newTree.segment,\n    requestTreeChildren,\n    null,\n    null,\n    newTree.isRootLayout,\n  ]\n  return requestTree\n}\n\nfunction pingPPRDisabledRouteTreeUpToLoadingBoundary(\n  now: number,\n  task: PrefetchTask,\n  route: FulfilledRouteCacheEntry,\n  tree: RouteTree,\n  refetchMarkerContext: 'refetch' | 'inside-shared-layout' | null,\n  spawnedEntries: Map<SegmentRequestKey, PendingSegmentCacheEntry>\n): FlightRouterState {\n  // This function is similar to pingRouteTreeAndIncludeDynamicData, except the\n  // server is only going to return a minimal loading state  it will stop\n  // rendering at the first loading boundary. Whereas a Full prefetch is\n  // intentionally aggressive and tries to pretfetch all the data that will be\n  // needed for a navigation, a LoadingBoundary prefetch is much more\n  // conservative. For example, it will omit from the request tree any segment\n  // that is already cached, regardles of whether it's partial or full. By\n  // contrast, a Full prefetch will refetch partial segments.\n\n  // \"inside-shared-layout\" tells the server where to start looking for a\n  // loading boundary.\n  let refetchMarker: 'refetch' | 'inside-shared-layout' | null =\n    refetchMarkerContext === null ? 'inside-shared-layout' : null\n\n  const segment = readOrCreateSegmentCacheEntry(now, task.fetchStrategy, tree)\n  switch (segment.status) {\n    case EntryStatus.Empty: {\n      // This segment is not cached. Add a refetch marker so the server knows\n      // to start rendering here.\n      // TODO: Instead of a \"refetch\" marker, we could just omit this subtree's\n      // FlightRouterState from the request tree. I think this would probably\n      // already work even without any updates to the server. For consistency,\n      // though, I'll send the full tree and we'll look into this later as part\n      // of a larger redesign of the request protocol.\n\n      // Add the pending cache entry to the result map.\n      spawnedEntries.set(\n        tree.requestKey,\n        upgradeToPendingSegment(\n          segment,\n          // Set the fetch strategy to LoadingBoundary to indicate that the server\n          // might not include it in the pending response. If another route is able\n          // to issue a per-segment request, we'll do that in the background.\n          FetchStrategy.LoadingBoundary\n        )\n      )\n      if (refetchMarkerContext !== 'refetch') {\n        refetchMarker = refetchMarkerContext = 'refetch'\n      } else {\n        // There's already a parent with a refetch marker, so we don't need\n        // to add another one.\n      }\n      break\n    }\n    case EntryStatus.Fulfilled: {\n      // The segment is already cached.\n      const segmentHasLoadingBoundary =\n        tree.hasLoadingBoundary === HasLoadingBoundary.SegmentHasLoadingBoundary\n      if (segmentHasLoadingBoundary) {\n        // This segment has a loading boundary, which means the server won't\n        // render its children. So there's nothing left to prefetch along this\n        // path. We can bail out.\n        return convertRouteTreeToFlightRouterState(tree)\n      }\n      // NOTE: If the cached segment were fetched using PPR, then it might be\n      // partial. We could get a more complete version of the segment by\n      // including it in this non-PPR request.\n      //\n      // We're intentionally choosing not to, though, because it's generally\n      // better to avoid doing a full prefetch whenever possible.\n      break\n    }\n    case EntryStatus.Pending: {\n      // There's another prefetch currently in progress. Don't add the refetch\n      // marker yet, so the server knows it can skip rendering this segment.\n      break\n    }\n    case EntryStatus.Rejected: {\n      // The segment failed to load. We shouldn't issue another request until\n      // the stale time has elapsed.\n      break\n    }\n    default:\n      segment satisfies never\n  }\n  const requestTreeChildren: Record<string, FlightRouterState> = {}\n  if (tree.slots !== null) {\n    for (const parallelRouteKey in tree.slots) {\n      const childTree = tree.slots[parallelRouteKey]\n      requestTreeChildren[parallelRouteKey] =\n        pingPPRDisabledRouteTreeUpToLoadingBoundary(\n          now,\n          task,\n          route,\n          childTree,\n          refetchMarkerContext,\n          spawnedEntries\n        )\n    }\n  }\n  const requestTree: FlightRouterState = [\n    tree.segment,\n    requestTreeChildren,\n    null,\n    refetchMarker,\n    tree.isRootLayout,\n  ]\n  return requestTree\n}\n\nfunction pingRouteTreeAndIncludeDynamicData(\n  now: number,\n  task: PrefetchTask,\n  route: FulfilledRouteCacheEntry,\n  tree: RouteTree,\n  isInsideRefetchingParent: boolean,\n  spawnedEntries: Map<SegmentRequestKey, PendingSegmentCacheEntry>,\n  fetchStrategy: FetchStrategy.Full | FetchStrategy.PPRRuntime\n): FlightRouterState {\n  // The tree we're constructing is the same shape as the tree we're navigating\n  // to. But even though this is a \"new\" tree, some of the individual segments\n  // may be cached as a result of other route prefetches.\n  //\n  // So we need to find the first uncached segment along each path add an\n  // explicit \"refetch\" marker so the server knows where to start rendering.\n  // Once the server starts rendering along a path, it keeps rendering the\n  // entire subtree.\n  const segment = readOrCreateSegmentCacheEntry(\n    now,\n    // Note that `fetchStrategy` might be different from `task.fetchStrategy`,\n    // and we have to use the former here.\n    // We can have a task with `FetchStrategy.PPR` where some of its segments are configured to\n    // always use runtime prefetching (via `export const prefetch`), and those should check for\n    // entries that include search params.\n    fetchStrategy,\n    tree\n  )\n\n  let spawnedSegment: PendingSegmentCacheEntry | null = null\n\n  switch (segment.status) {\n    case EntryStatus.Empty: {\n      // This segment is not cached.\n      if (fetchStrategy === FetchStrategy.Full) {\n        // Check if there's a matching entry in the bfcache. If so, fulfill the\n        // segment using the bfcache entry instead of issuing a new request.\n        const fulfilled = attemptToFulfillDynamicSegmentFromBFCache(\n          now,\n          segment,\n          tree\n        )\n        if (fulfilled !== null) {\n          break\n        }\n      }\n      // Include it in the request.\n      spawnedSegment = upgradeToPendingSegment(segment, fetchStrategy)\n      break\n    }\n    case EntryStatus.Fulfilled: {\n      // The segment is already cached.\n      if (\n        segment.isPartial &&\n        canNewFetchStrategyProvideMoreContent(\n          segment.fetchStrategy,\n          fetchStrategy\n        )\n      ) {\n        // The cached segment contains dynamic holes, and was prefetched using a less specific strategy than the current one.\n        // This means we're in one of these cases:\n        //   - we have a static prefetch, and we're doing a runtime prefetch\n        //   - we have a static or runtime prefetch, and we're doing a Full prefetch (or a navigation).\n        // In either case, we need to include it in the request to get a more specific (or full) version.\n        spawnedSegment = pingFullSegmentRevalidation(now, tree, fetchStrategy)\n      }\n      break\n    }\n    case EntryStatus.Pending:\n    case EntryStatus.Rejected: {\n      // There's either another prefetch currently in progress, or the previous\n      // attempt failed. If the new strategy can provide more content, fetch it again.\n      if (\n        canNewFetchStrategyProvideMoreContent(\n          segment.fetchStrategy,\n          fetchStrategy\n        )\n      ) {\n        spawnedSegment = pingFullSegmentRevalidation(now, tree, fetchStrategy)\n      }\n      break\n    }\n    default:\n      segment satisfies never\n  }\n  const requestTreeChildren: Record<string, FlightRouterState> = {}\n  if (tree.slots !== null) {\n    for (const parallelRouteKey in tree.slots) {\n      const childTree = tree.slots[parallelRouteKey]\n      requestTreeChildren[parallelRouteKey] =\n        pingRouteTreeAndIncludeDynamicData(\n          now,\n          task,\n          route,\n          childTree,\n          isInsideRefetchingParent || spawnedSegment !== null,\n          spawnedEntries,\n          fetchStrategy\n        )\n    }\n  }\n\n  if (spawnedSegment !== null) {\n    // Add the pending entry to the result map.\n    spawnedEntries.set(tree.requestKey, spawnedSegment)\n  }\n\n  // Don't bother to add a refetch marker if one is already present in a parent.\n  const refetchMarker =\n    !isInsideRefetchingParent && spawnedSegment !== null ? 'refetch' : null\n\n  const requestTree: FlightRouterState = [\n    tree.segment,\n    requestTreeChildren,\n    null,\n    refetchMarker,\n    tree.isRootLayout,\n  ]\n  return requestTree\n}\n\nfunction pingRuntimePrefetches(\n  now: number,\n  task: PrefetchTask,\n  route: FulfilledRouteCacheEntry,\n  tree: RouteTree,\n  spawnedRuntimePrefetches: Set<SegmentRequestKey>,\n  spawnedEntries: Map<SegmentRequestKey, PendingSegmentCacheEntry>\n): FlightRouterState {\n  // Construct a request tree (FlightRouterState) for a runtime prefetch. If\n  // a segment is part of the runtime prefetch, the tree is constructed by\n  // diffing against what's already in the prefetch cache. Otherwise, we send\n  // a regular FlightRouterState with no special markers.\n  //\n  // See pingRouteTreeAndIncludeDynamicData for details.\n  if (spawnedRuntimePrefetches.has(tree.requestKey)) {\n    // This segment needs a runtime prefetch.\n    return pingRouteTreeAndIncludeDynamicData(\n      now,\n      task,\n      route,\n      tree,\n      false,\n      spawnedEntries,\n      FetchStrategy.PPRRuntime\n    )\n  }\n  let requestTreeChildren: Record<string, FlightRouterState> = {}\n  const slots = tree.slots\n  if (slots !== null) {\n    for (const parallelRouteKey in slots) {\n      const childTree = slots[parallelRouteKey]\n      requestTreeChildren[parallelRouteKey] = pingRuntimePrefetches(\n        now,\n        task,\n        route,\n        childTree,\n        spawnedRuntimePrefetches,\n        spawnedEntries\n      )\n    }\n  }\n\n  // This segment is not part of the runtime prefetch. Clone the base tree.\n  const requestTree: FlightRouterState = [\n    tree.segment,\n    requestTreeChildren,\n    null,\n    null,\n  ]\n  return requestTree\n}\n\nfunction pingStaticSegmentData(\n  now: number,\n  task: PrefetchTask,\n  route: FulfilledRouteCacheEntry,\n  segment: SegmentCacheEntry,\n  routeKey: RouteCacheKey,\n  tree: RouteTree\n): void {\n  switch (segment.status) {\n    case EntryStatus.Empty:\n      // Upgrade to Pending so we know there's already a request in progress\n      spawnPrefetchSubtask(\n        fetchSegmentOnCacheMiss(\n          route,\n          upgradeToPendingSegment(segment, FetchStrategy.PPR),\n          routeKey,\n          tree\n        )\n      )\n      break\n    case EntryStatus.Pending: {\n      // There's already a request in progress. Depending on what kind of\n      // request it is, we may want to revalidate it.\n      switch (segment.fetchStrategy) {\n        case FetchStrategy.PPR:\n        case FetchStrategy.PPRRuntime:\n        case FetchStrategy.Full:\n          // There's already a request in progress. Don't do anything.\n          break\n        case FetchStrategy.LoadingBoundary:\n          // There's a pending request, but because it's using the old\n          // prefetching strategy, we can't be sure if it will be fulfilled by\n          // the response  it might be inside the loading boundary. Perform\n          // a revalidation, but because it's speculative, wait to do it at\n          // background priority.\n          if (background(task)) {\n            // TODO: Instead of speculatively revalidating, consider including\n            // `hasLoading` in the route tree prefetch response.\n            pingPPRSegmentRevalidation(now, route, routeKey, tree)\n          }\n          break\n        default:\n          segment.fetchStrategy satisfies never\n      }\n      break\n    }\n    case EntryStatus.Rejected: {\n      // The existing entry in the cache was rejected. Depending on how it\n      // was originally fetched, we may or may not want to revalidate it.\n      switch (segment.fetchStrategy) {\n        case FetchStrategy.PPR:\n        case FetchStrategy.PPRRuntime:\n        case FetchStrategy.Full:\n          // The previous attempt to fetch this entry failed. Don't attempt to\n          // fetch it again until the entry expires.\n          break\n        case FetchStrategy.LoadingBoundary:\n          // There's a rejected entry, but it was fetched using the loading\n          // boundary strategy. So the reason it wasn't returned by the server\n          // might just be because it was inside a loading boundary. Or because\n          // there was a dynamic rewrite. Revalidate it using the per-\n          // segment strategy.\n          //\n          // Because a rejected segment will definitely prevent the segment (and\n          // all of its children) from rendering, we perform this revalidation\n          // immediately instead of deferring it to a background task.\n          pingPPRSegmentRevalidation(now, route, routeKey, tree)\n          break\n        default:\n          segment.fetchStrategy satisfies never\n      }\n      break\n    }\n    case EntryStatus.Fulfilled:\n      // Segment is already cached. There's nothing left to prefetch.\n      break\n    default:\n      segment satisfies never\n  }\n\n  // Segments do not have dependent tasks, so once the prefetch is initiated,\n  // there's nothing else for us to do (except write the server data into the\n  // entry, which is handled by `fetchSegmentOnCacheMiss`).\n}\n\nfunction pingPPRSegmentRevalidation(\n  now: number,\n  route: FulfilledRouteCacheEntry,\n  routeKey: RouteCacheKey,\n  tree: RouteTree\n): void {\n  const revalidatingSegment = readOrCreateRevalidatingSegmentEntry(\n    now,\n    FetchStrategy.PPR,\n    tree\n  )\n  switch (revalidatingSegment.status) {\n    case EntryStatus.Empty:\n      // Spawn a prefetch request and upsert the segment into the cache\n      // upon completion.\n      upsertSegmentOnCompletion(\n        spawnPrefetchSubtask(\n          fetchSegmentOnCacheMiss(\n            route,\n            upgradeToPendingSegment(revalidatingSegment, FetchStrategy.PPR),\n            routeKey,\n            tree\n          )\n        ),\n        getSegmentVaryPathForRequest(FetchStrategy.PPR, tree)\n      )\n      break\n    case EntryStatus.Pending:\n      // There's already a revalidation in progress.\n      break\n    case EntryStatus.Fulfilled:\n    case EntryStatus.Rejected:\n      // A previous revalidation attempt finished, but we chose not to replace\n      // the existing entry in the cache. Don't try again until or unless the\n      // revalidation entry expires.\n      break\n    default:\n      revalidatingSegment satisfies never\n  }\n}\n\nfunction pingFullSegmentRevalidation(\n  now: number,\n  tree: RouteTree,\n  fetchStrategy: FetchStrategy.Full | FetchStrategy.PPRRuntime\n): PendingSegmentCacheEntry | null {\n  const revalidatingSegment = readOrCreateRevalidatingSegmentEntry(\n    now,\n    fetchStrategy,\n    tree\n  )\n  if (revalidatingSegment.status === EntryStatus.Empty) {\n    // During a Full/PPRRuntime prefetch, a single dynamic request is made for all the\n    // segments that we need. So we don't initiate a request here directly. By\n    // returning a pending entry from this function, it signals to the caller\n    // that this segment should be included in the request that's sent to\n    // the server.\n    const pendingSegment = upgradeToPendingSegment(\n      revalidatingSegment,\n      fetchStrategy\n    )\n    upsertSegmentOnCompletion(\n      waitForSegmentCacheEntry(pendingSegment),\n      getSegmentVaryPathForRequest(fetchStrategy, tree)\n    )\n    return pendingSegment\n  } else {\n    // There's already a revalidation in progress.\n    const nonEmptyRevalidatingSegment = revalidatingSegment\n    if (\n      canNewFetchStrategyProvideMoreContent(\n        nonEmptyRevalidatingSegment.fetchStrategy,\n        fetchStrategy\n      )\n    ) {\n      // The existing revalidation was fetched using a less specific strategy.\n      // Reset it and start a new revalidation.\n      const emptySegment = overwriteRevalidatingSegmentCacheEntry(\n        now,\n        fetchStrategy,\n        tree\n      )\n      const pendingSegment = upgradeToPendingSegment(\n        emptySegment,\n        fetchStrategy\n      )\n      upsertSegmentOnCompletion(\n        waitForSegmentCacheEntry(pendingSegment),\n        getSegmentVaryPathForRequest(fetchStrategy, tree)\n      )\n      return pendingSegment\n    }\n    switch (nonEmptyRevalidatingSegment.status) {\n      case EntryStatus.Pending:\n        // There's already an in-progress prefetch that includes this segment.\n        return null\n      case EntryStatus.Fulfilled:\n      case EntryStatus.Rejected:\n        // A previous revalidation attempt finished, but we chose not to replace\n        // the existing entry in the cache. Don't try again until or unless the\n        // revalidation entry expires.\n        return null\n      default:\n        nonEmptyRevalidatingSegment satisfies never\n        return null\n    }\n  }\n}\n\nconst noop = () => {}\n\nfunction upsertSegmentOnCompletion(\n  promise: Promise<FulfilledSegmentCacheEntry | null>,\n  varyPath: SegmentVaryPath\n) {\n  // Wait for a segment to finish loading, then upsert it into the cache\n  promise.then((fulfilled) => {\n    if (fulfilled !== null) {\n      // Received new data. Attempt to replace the existing entry in the cache.\n      upsertSegmentEntry(Date.now(), varyPath, fulfilled)\n    }\n  }, noop)\n}\n\nfunction doesCurrentSegmentMatchCachedSegment(\n  route: FulfilledRouteCacheEntry,\n  currentSegment: Segment,\n  cachedSegment: Segment\n): boolean {\n  if (cachedSegment === PAGE_SEGMENT_KEY) {\n    // In the FlightRouterState stored by the router, the page segment has the\n    // rendered search params appended to the name of the segment. In the\n    // prefetch cache, however, this is stored separately. So, when comparing\n    // the router's current FlightRouterState to the cached FlightRouterState,\n    // we need to make sure we compare both parts of the segment.\n    // TODO: This is not modeled clearly. We use the same type,\n    // FlightRouterState, for both the CacheNode tree _and_ the prefetch cache\n    // _and_ the server response format, when conceptually those are three\n    // different things and treated in different ways. We should encode more of\n    // this information into the type design so mistakes are less likely.\n    return (\n      currentSegment ===\n      addSearchParamsIfPageSegment(\n        PAGE_SEGMENT_KEY,\n        Object.fromEntries(new URLSearchParams(route.renderedSearch))\n      )\n    )\n  }\n  // Non-page segments are compared using the same function as the server\n  return matchSegment(cachedSegment, currentSegment)\n}\n\n// -----------------------------------------------------------------------------\n// The remainder of the module is a MinHeap implementation. Try not to put any\n// logic below here unless it's related to the heap algorithm. We can extract\n// this to a separate module if/when we need multiple kinds of heaps.\n// -----------------------------------------------------------------------------\n\nfunction compareQueuePriority(a: PrefetchTask, b: PrefetchTask) {\n  // Since the queue is a MinHeap, this should return a positive number if b is\n  // higher priority than a, and a negative number if a is higher priority\n  // than b.\n\n  // `priority` is an integer, where higher numbers are higher priority.\n  const priorityDiff = b.priority - a.priority\n  if (priorityDiff !== 0) {\n    return priorityDiff\n  }\n\n  // If the priority is the same, check which phase the prefetch is in  is it\n  // prefetching the route tree, or the segments? Route trees are prioritized.\n  const phaseDiff = b.phase - a.phase\n  if (phaseDiff !== 0) {\n    return phaseDiff\n  }\n\n  // Finally, check the insertion order. `sortId` is an incrementing counter\n  // assigned to prefetches. We want to process the newest prefetches first.\n  return b.sortId - a.sortId\n}\n\nfunction heapPush(heap: Array<PrefetchTask>, node: PrefetchTask): void {\n  const index = heap.length\n  heap.push(node)\n  node._heapIndex = index\n  heapSiftUp(heap, node, index)\n}\n\nfunction heapPeek(heap: Array<PrefetchTask>): PrefetchTask | null {\n  return heap.length === 0 ? null : heap[0]\n}\n\nfunction heapPop(heap: Array<PrefetchTask>): PrefetchTask | null {\n  if (heap.length === 0) {\n    return null\n  }\n  const first = heap[0]\n  first._heapIndex = -1\n  const last = heap.pop() as PrefetchTask\n  if (last !== first) {\n    heap[0] = last\n    last._heapIndex = 0\n    heapSiftDown(heap, last, 0)\n  }\n  return first\n}\n\nfunction heapDelete(heap: Array<PrefetchTask>, node: PrefetchTask): void {\n  const index = node._heapIndex\n  if (index !== -1) {\n    node._heapIndex = -1\n    if (heap.length !== 0) {\n      const last = heap.pop() as PrefetchTask\n      if (last !== node) {\n        heap[index] = last\n        last._heapIndex = index\n        heapSiftDown(heap, last, index)\n      }\n    }\n  }\n}\n\nfunction heapResift(heap: Array<PrefetchTask>, node: PrefetchTask): void {\n  const index = node._heapIndex\n  if (index !== -1) {\n    if (index === 0) {\n      heapSiftDown(heap, node, 0)\n    } else {\n      const parentIndex = (index - 1) >>> 1\n      const parent = heap[parentIndex]\n      if (compareQueuePriority(parent, node) > 0) {\n        // The parent is larger. Sift up.\n        heapSiftUp(heap, node, index)\n      } else {\n        // The parent is smaller (or equal). Sift down.\n        heapSiftDown(heap, node, index)\n      }\n    }\n  }\n}\n\nfunction heapSiftUp(\n  heap: Array<PrefetchTask>,\n  node: PrefetchTask,\n  i: number\n): void {\n  let index = i\n  while (index > 0) {\n    const parentIndex = (index - 1) >>> 1\n    const parent = heap[parentIndex]\n    if (compareQueuePriority(parent, node) > 0) {\n      // The parent is larger. Swap positions.\n      heap[parentIndex] = node\n      node._heapIndex = parentIndex\n      heap[index] = parent\n      parent._heapIndex = index\n\n      index = parentIndex\n    } else {\n      // The parent is smaller. Exit.\n      return\n    }\n  }\n}\n\nfunction heapSiftDown(\n  heap: Array<PrefetchTask>,\n  node: PrefetchTask,\n  i: number\n): void {\n  let index = i\n  const length = heap.length\n  const halfLength = length >>> 1\n  while (index < halfLength) {\n    const leftIndex = (index + 1) * 2 - 1\n    const left = heap[leftIndex]\n    const rightIndex = leftIndex + 1\n    const right = heap[rightIndex]\n\n    // If the left or right node is smaller, swap with the smaller of those.\n    if (compareQueuePriority(left, node) < 0) {\n      if (rightIndex < length && compareQueuePriority(right, left) < 0) {\n        heap[index] = right\n        right._heapIndex = index\n        heap[rightIndex] = node\n        node._heapIndex = rightIndex\n\n        index = rightIndex\n      } else {\n        heap[index] = left\n        left._heapIndex = index\n        heap[leftIndex] = node\n        node._heapIndex = leftIndex\n\n        index = leftIndex\n      }\n    } else if (rightIndex < length && compareQueuePriority(right, node) < 0) {\n      heap[index] = right\n      right._heapIndex = index\n      heap[rightIndex] = node\n      node._heapIndex = rightIndex\n\n      index = rightIndex\n    } else {\n      // Neither child is smaller. Exit.\n      return\n    }\n  }\n}\n"],"names":["cancelPrefetchTask","isPrefetchTaskDirty","pingPrefetchTask","reschedulePrefetchTask","schedulePrefetchTask","startRevalidationCooldown","scheduleMicrotask","queueMicrotask","fn","Promise","resolve","then","catch","error","setTimeout","taskHeap","inProgressRequests","sortIdCounter","didScheduleMicrotask","mostRecentlyHoveredLink","REVALIDATION_COOLDOWN_MS","revalidationCooldownTimeoutHandle","clearTimeout","ensureWorkIsScheduled","key","treeAtTimeOfPrefetch","fetchStrategy","priority","onInvalidate","task","routeCacheVersion","getCurrentRouteCacheVersion","segmentCacheVersion","getCurrentSegmentCacheVersion","phase","hasBackgroundWork","spawnedRuntimePrefetches","sortId","isCanceled","_heapIndex","trackMostRecentlyHoveredLink","heapPush","heapDelete","PrefetchPriority","Intent","heapResift","nextUrl","tree","Background","Default","processQueueInMicrotask","hasNetworkBandwidth","spawnPrefetchSubtask","prefetchSubtask","result","onPrefetchConnectionClosed","closed","value","now","Date","heapPeek","exitStatus","pingRoute","heapPop","background","route","readOrCreateRouteCacheEntry","pingRootRouteTree","search","url","URL","pathname","location","origin","keyWithoutSearch","createCacheKey","href","routeWithoutSearch","status","EntryStatus","Empty","Pending","fetchRouteOnCacheMiss","Fulfilled","Rejected","staleAt","blockedTasks","Set","add","FetchStrategy","PPR","isPPREnabled","LoadingBoundary","pingStaticHead","pingSharedPartOfCacheComponentsTree","spawnedEntries","Map","pingRuntimeHead","PPRRuntime","requestTree","pingRuntimePrefetches","needsDynamicRequest","size","fetchSegmentPrefetchesUsingDynamicRequest","Full","dynamicRequestTree","diffRouteTreeAgainstCurrent","pingStaticSegmentData","readOrCreateSegmentCacheEntry","metadata","pingRouteTreeAndIncludeDynamicData","oldTree","newTree","segment","oldTreeChildren","newTreeChildren","slots","parallelRouteKey","newTreeChild","newTreeChildSegment","oldTreeChild","oldTreeChildSegment","childExitStatus","undefined","doesCurrentSegmentMatchCachedSegment","pingNewPartOfCacheComponentsTree","hasRuntimePrefetch","requestKey","childTree","requestTreeChildren","requestTreeChild","subtreeHasLoadingBoundary","hasLoadingBoundary","HasLoadingBoundary","SubtreeHasNoLoadingBoundary","pingPPRDisabledRouteTreeUpToLoadingBoundary","convertRouteTreeToFlightRouterState","isRootLayout","refetchMarkerContext","refetchMarker","set","upgradeToPendingSegment","segmentHasLoadingBoundary","SegmentHasLoadingBoundary","isInsideRefetchingParent","spawnedSegment","fulfilled","attemptToFulfillDynamicSegmentFromBFCache","isPartial","canNewFetchStrategyProvideMoreContent","pingFullSegmentRevalidation","has","routeKey","fetchSegmentOnCacheMiss","pingPPRSegmentRevalidation","revalidatingSegment","readOrCreateRevalidatingSegmentEntry","upsertSegmentOnCompletion","getSegmentVaryPathForRequest","pendingSegment","waitForSegmentCacheEntry","nonEmptyRevalidatingSegment","emptySegment","overwriteRevalidatingSegmentCacheEntry","noop","promise","varyPath","upsertSegmentEntry","currentSegment","cachedSegment","PAGE_SEGMENT_KEY","addSearchParamsIfPageSegment","Object","fromEntries","URLSearchParams","renderedSearch","matchSegment","compareQueuePriority","a","b","priorityDiff","phaseDiff","heap","node","index","length","push","heapSiftUp","first","last","pop","heapSiftDown","parentIndex","parent","i","halfLength","leftIndex","left","rightIndex","right"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 4862, "column": 0}, "map": {"version":3,"sources":["file:///D:/AconnectJP/node_modules/next/src/client/normalize-trailing-slash.ts"],"sourcesContent":["import { removeTrailingSlash } from '../shared/lib/router/utils/remove-trailing-slash'\nimport { parsePath } from '../shared/lib/router/utils/parse-path'\n\n/**\n * Normalizes the trailing slash of a path according to the `trailingSlash` option\n * in `next.config.js`.\n */\nexport const normalizePathTrailingSlash = (path: string) => {\n  if (!path.startsWith('/') || process.env.__NEXT_MANUAL_TRAILING_SLASH) {\n    return path\n  }\n\n  const { pathname, query, hash } = parsePath(path)\n  if (process.env.__NEXT_TRAILING_SLASH) {\n    if (/\\.[^/]+\\/?$/.test(pathname)) {\n      return `${removeTrailingSlash(pathname)}${query}${hash}`\n    } else if (pathname.endsWith('/')) {\n      return `${pathname}${query}${hash}`\n    } else {\n      return `${pathname}/${query}${hash}`\n    }\n  }\n\n  return `${removeTrailingSlash(pathname)}${query}${hash}`\n}\n"],"names":["normalizePathTrailingSlash","path","startsWith","process","env","__NEXT_MANUAL_TRAILING_SLASH","pathname","query","hash","parsePath","__NEXT_TRAILING_SLASH","test","removeTrailingSlash","endsWith"],"mappings":"AAQ+BG,QAAQC,GAAG,CAACC,4BAA4B;;;;;+BAD1DL,8BAAAA;;;eAAAA;;;qCAPuB;2BACV;AAMnB,MAAMA,6BAA6B,CAACC;IACzC,IAAI,CAACA,KAAKC,UAAU,CAAC,kDAAkD;QACrE,OAAOD;IACT;IAEA,MAAM,EAAEK,QAAQ,EAAEC,KAAK,EAAEC,IAAI,EAAE,GAAGC,CAAAA,GAAAA,WAAAA,SAAS,EAACR;IAC5C,IAAIE,QAAQC,GAAG,CAACM,qBAAqB,EAAE;;IAUvC,OAAO,GAAGE,CAAAA,GAAAA,qBAAAA,mBAAmB,EAACN,YAAYC,QAAQC,MAAM;AAC1D","ignoreList":[0]}},
    {"offset": {"line": 4895, "column": 0}, "map": {"version":3,"sources":["file:///D:/AconnectJP/node_modules/next/src/client/add-base-path.ts"],"sourcesContent":["import { addPathPrefix } from '../shared/lib/router/utils/add-path-prefix'\nimport { normalizePathTrailingSlash } from './normalize-trailing-slash'\n\nconst basePath = (process.env.__NEXT_ROUTER_BASEPATH as string) || ''\n\nexport function addBasePath(path: string, required?: boolean): string {\n  return normalizePathTrailingSlash(\n    process.env.__NEXT_MANUAL_CLIENT_BASE_PATH && !required\n      ? path\n      : addPathPrefix(path, basePath)\n  )\n}\n"],"names":["addBasePath","basePath","process","env","__NEXT_ROUTER_BASEPATH","path","required","normalizePathTrailingSlash","__NEXT_MANUAL_CLIENT_BASE_PATH","addPathPrefix"],"mappings":"AAGkBE,QAAQC,GAAG,CAACC,sBAAsB;;;;;+BAEpCJ,eAAAA;;;eAAAA;;;+BALc;wCACa;AAE3C,MAAMC,mDAA6D;AAE5D,SAASD,YAAYK,IAAY,EAAEC,QAAkB;IAC1D,OAAOC,CAAAA,GAAAA,wBAAAA,0BAA0B,EAC/BL,QAAQC,GAAG,CAACK,0BACRH,IADsC,IAAI,CAACC,iBAE3CG,CAAAA,GAAAA,eAAAA,aAAa,EAACJ,MAAMJ;AAE5B","ignoreList":[0]}},
    {"offset": {"line": 4923, "column": 0}, "map": {"version":3,"sources":["file:///D:/AconnectJP/node_modules/next/src/client/components/app-router-utils.ts"],"sourcesContent":["import { isBot } from '../../shared/lib/router/utils/is-bot'\nimport { addBasePath } from '../add-base-path'\n\nexport function isExternalURL(url: URL) {\n  return url.origin !== window.location.origin\n}\n\n/**\n * Given a link href, constructs the URL that should be prefetched. Returns null\n * in cases where prefetching should be disabled, like external URLs, or\n * during development.\n * @param href The href passed to <Link>, router.prefetch(), or similar\n * @returns A URL object to prefetch, or null if prefetching should be disabled\n */\nexport function createPrefetchURL(href: string): URL | null {\n  // Don't prefetch for bots as they don't navigate.\n  if (isBot(window.navigator.userAgent)) {\n    return null\n  }\n\n  let url: URL\n  try {\n    url = new URL(addBasePath(href), window.location.href)\n  } catch (_) {\n    // TODO: Does this need to throw or can we just console.error instead? Does\n    // anyone rely on this throwing? (Seems unlikely.)\n    throw new Error(\n      `Cannot prefetch '${href}' because it cannot be converted to a URL.`\n    )\n  }\n\n  // Don't prefetch during development (improves compilation performance)\n  if (process.env.NODE_ENV === 'development') {\n    return null\n  }\n\n  // External urls can't be prefetched in the same way.\n  if (isExternalURL(url)) {\n    return null\n  }\n\n  return url\n}\n"],"names":["createPrefetchURL","isExternalURL","url","origin","window","location","href","isBot","navigator","userAgent","URL","addBasePath","_","Error","process","env","NODE_ENV"],"mappings":"AAgCMc,QAAQC,GAAG,CAACC,QAAQ,KAAK;;;;;;;;;;;;;;;;IAlBfhB,iBAAiB,EAAA;eAAjBA;;IAXAC,aAAa,EAAA;eAAbA;;;uBAHM;6BACM;AAErB,SAASA,cAAcC,GAAQ;IACpC,OAAOA,IAAIC,MAAM,KAAKC,OAAOC,QAAQ,CAACF,MAAM;AAC9C;AASO,SAASH,kBAAkBM,IAAY;IAC5C,kDAAkD;IAClD,IAAIC,CAAAA,GAAAA,OAAAA,KAAK,EAACH,OAAOI,SAAS,CAACC,SAAS,GAAG;QACrC,OAAO;IACT;IAEA,IAAIP;IACJ,IAAI;QACFA,MAAM,IAAIQ,IAAIC,CAAAA,GAAAA,aAAAA,WAAW,EAACL,OAAOF,OAAOC,QAAQ,CAACC,IAAI;IACvD,EAAE,OAAOM,GAAG;QACV,2EAA2E;QAC3E,kDAAkD;QAClD,MAAM,OAAA,cAEL,CAFK,IAAIC,MACR,CAAC,iBAAiB,EAAEP,KAAK,0CAA0C,CAAC,GADhE,qBAAA;mBAAA;wBAAA;0BAAA;QAEN;IACF;IAEA,uEAAuE;IACvE,wCAA4C;QAC1C,OAAO;IACT;;;AAQF","ignoreList":[0]}},
    {"offset": {"line": 4986, "column": 0}, "map": {"version":3,"sources":["file:///D:/AconnectJP/node_modules/next/src/client/components/links.ts"],"sourcesContent":["import type { FlightRouterState } from '../../shared/lib/app-router-types'\nimport type { AppRouterInstance } from '../../shared/lib/app-router-context.shared-runtime'\nimport {\n  FetchStrategy,\n  type PrefetchTaskFetchStrategy,\n  PrefetchPriority,\n} from './segment-cache/types'\nimport { createCacheKey } from './segment-cache/cache-key'\nimport {\n  type PrefetchTask,\n  schedulePrefetchTask as scheduleSegmentPrefetchTask,\n  cancelPrefetchTask,\n  reschedulePrefetchTask,\n  isPrefetchTaskDirty,\n} from './segment-cache/scheduler'\nimport { startTransition } from 'react'\n\ntype LinkElement = HTMLAnchorElement | SVGAElement\n\ntype Element = LinkElement | HTMLFormElement\n\n// Properties that are shared between Link and Form instances. We use the same\n// shape for both to prevent a polymorphic de-opt in the VM.\ntype LinkOrFormInstanceShared = {\n  router: AppRouterInstance\n  fetchStrategy: PrefetchTaskFetchStrategy\n\n  isVisible: boolean\n\n  // The most recently initiated prefetch task. It may or may not have\n  // already completed. The same prefetch task object can be reused across\n  // multiple prefetches of the same link.\n  prefetchTask: PrefetchTask | null\n}\n\nexport type FormInstance = LinkOrFormInstanceShared & {\n  prefetchHref: string\n  setOptimisticLinkStatus: null\n}\n\ntype PrefetchableLinkInstance = LinkOrFormInstanceShared & {\n  prefetchHref: string\n  setOptimisticLinkStatus: (status: { pending: boolean }) => void\n}\n\ntype NonPrefetchableLinkInstance = LinkOrFormInstanceShared & {\n  prefetchHref: null\n  setOptimisticLinkStatus: (status: { pending: boolean }) => void\n}\n\ntype PrefetchableInstance = PrefetchableLinkInstance | FormInstance\n\nexport type LinkInstance =\n  | PrefetchableLinkInstance\n  | NonPrefetchableLinkInstance\n\n// Tracks the most recently navigated link instance. When null, indicates\n// the current navigation was not initiated by a link click.\nlet linkForMostRecentNavigation: LinkInstance | null = null\n\n// Status object indicating link is pending\nexport const PENDING_LINK_STATUS = { pending: true }\n\n// Status object indicating link is idle\nexport const IDLE_LINK_STATUS = { pending: false }\n\n// Updates the loading state when navigating between links\n// - Resets the previous link's loading state\n// - Sets the new link's loading state\n// - Updates tracking of current navigation\nexport function setLinkForCurrentNavigation(link: LinkInstance | null) {\n  startTransition(() => {\n    linkForMostRecentNavigation?.setOptimisticLinkStatus(IDLE_LINK_STATUS)\n    link?.setOptimisticLinkStatus(PENDING_LINK_STATUS)\n    linkForMostRecentNavigation = link\n  })\n}\n\n// Unmounts the current link instance from navigation tracking\nexport function unmountLinkForCurrentNavigation(link: LinkInstance) {\n  if (linkForMostRecentNavigation === link) {\n    linkForMostRecentNavigation = null\n  }\n}\n\n// Use a WeakMap to associate a Link instance with its DOM element. This is\n// used by the IntersectionObserver to track the link's visibility.\nconst prefetchable:\n  | WeakMap<Element, PrefetchableInstance>\n  | Map<Element, PrefetchableInstance> =\n  typeof WeakMap === 'function' ? new WeakMap() : new Map()\n\n// A Set of the currently visible links. We re-prefetch visible links after a\n// cache invalidation, or when the current URL changes. It's a separate data\n// structure from the WeakMap above because only the visible links need to\n// be enumerated.\nconst prefetchableAndVisible: Set<PrefetchableInstance> = new Set()\n\n// A single IntersectionObserver instance shared by all <Link> components.\nconst observer: IntersectionObserver | null =\n  typeof IntersectionObserver === 'function'\n    ? new IntersectionObserver(handleIntersect, {\n        rootMargin: '200px',\n      })\n    : null\n\nfunction observeVisibility(element: Element, instance: PrefetchableInstance) {\n  const existingInstance = prefetchable.get(element)\n  if (existingInstance !== undefined) {\n    // This shouldn't happen because each <Link> component should have its own\n    // anchor tag instance, but it's defensive coding to avoid a memory leak in\n    // case there's a logical error somewhere else.\n    unmountPrefetchableInstance(element)\n  }\n  // Only track prefetchable links that have a valid prefetch URL\n  prefetchable.set(element, instance)\n  if (observer !== null) {\n    observer.observe(element)\n  }\n}\n\nfunction coercePrefetchableUrl(href: string): URL | null {\n  if (typeof window !== 'undefined') {\n    const { createPrefetchURL } =\n      require('./app-router-utils') as typeof import('./app-router-utils')\n\n    try {\n      return createPrefetchURL(href)\n    } catch {\n      // createPrefetchURL sometimes throws an error if an invalid URL is\n      // provided, though I'm not sure if it's actually necessary.\n      // TODO: Consider removing the throw from the inner function, or change it\n      // to reportError. Or maybe the error isn't even necessary for automatic\n      // prefetches, just navigations.\n      const reportErrorFn =\n        typeof reportError === 'function' ? reportError : console.error\n      reportErrorFn(\n        `Cannot prefetch '${href}' because it cannot be converted to a URL.`\n      )\n      return null\n    }\n  } else {\n    return null\n  }\n}\n\nexport function mountLinkInstance(\n  element: LinkElement,\n  href: string,\n  router: AppRouterInstance,\n  fetchStrategy: PrefetchTaskFetchStrategy,\n  prefetchEnabled: boolean,\n  setOptimisticLinkStatus: (status: { pending: boolean }) => void\n): LinkInstance {\n  if (prefetchEnabled) {\n    const prefetchURL = coercePrefetchableUrl(href)\n    if (prefetchURL !== null) {\n      const instance: PrefetchableLinkInstance = {\n        router,\n        fetchStrategy,\n        isVisible: false,\n        prefetchTask: null,\n        prefetchHref: prefetchURL.href,\n        setOptimisticLinkStatus,\n      }\n      // We only observe the link's visibility if it's prefetchable. For\n      // example, this excludes links to external URLs.\n      observeVisibility(element, instance)\n      return instance\n    }\n  }\n  // If the link is not prefetchable, we still create an instance so we can\n  // track its optimistic state (i.e. useLinkStatus).\n  const instance: NonPrefetchableLinkInstance = {\n    router,\n    fetchStrategy,\n    isVisible: false,\n    prefetchTask: null,\n    prefetchHref: null,\n    setOptimisticLinkStatus,\n  }\n  return instance\n}\n\nexport function mountFormInstance(\n  element: HTMLFormElement,\n  href: string,\n  router: AppRouterInstance,\n  fetchStrategy: PrefetchTaskFetchStrategy\n): void {\n  const prefetchURL = coercePrefetchableUrl(href)\n  if (prefetchURL === null) {\n    // This href is not prefetchable, so we don't track it.\n    // TODO: We currently observe/unobserve a form every time its href changes.\n    // For Links, this isn't a big deal because the href doesn't usually change,\n    // but for forms it's extremely common. We should optimize this.\n    return\n  }\n  const instance: FormInstance = {\n    router,\n    fetchStrategy,\n    isVisible: false,\n    prefetchTask: null,\n    prefetchHref: prefetchURL.href,\n    setOptimisticLinkStatus: null,\n  }\n  observeVisibility(element, instance)\n}\n\nexport function unmountPrefetchableInstance(element: Element) {\n  const instance = prefetchable.get(element)\n  if (instance !== undefined) {\n    prefetchable.delete(element)\n    prefetchableAndVisible.delete(instance)\n    const prefetchTask = instance.prefetchTask\n    if (prefetchTask !== null) {\n      cancelPrefetchTask(prefetchTask)\n    }\n  }\n  if (observer !== null) {\n    observer.unobserve(element)\n  }\n}\n\nfunction handleIntersect(entries: Array<IntersectionObserverEntry>) {\n  for (const entry of entries) {\n    // Some extremely old browsers or polyfills don't reliably support\n    // isIntersecting so we check intersectionRatio instead. (Do we care? Not\n    // really. But whatever this is fine.)\n    const isVisible = entry.intersectionRatio > 0\n    onLinkVisibilityChanged(entry.target as HTMLAnchorElement, isVisible)\n  }\n}\n\nexport function onLinkVisibilityChanged(element: Element, isVisible: boolean) {\n  if (process.env.NODE_ENV !== 'production') {\n    // Prefetching on viewport is disabled in development for performance\n    // reasons, because it requires compiling the target page.\n    // TODO: Investigate re-enabling this.\n    return\n  }\n\n  const instance = prefetchable.get(element)\n  if (instance === undefined) {\n    return\n  }\n\n  instance.isVisible = isVisible\n  if (isVisible) {\n    prefetchableAndVisible.add(instance)\n  } else {\n    prefetchableAndVisible.delete(instance)\n  }\n  rescheduleLinkPrefetch(instance, PrefetchPriority.Default)\n}\n\nexport function onNavigationIntent(\n  element: HTMLAnchorElement | SVGAElement,\n  unstable_upgradeToDynamicPrefetch: boolean\n) {\n  const instance = prefetchable.get(element)\n  if (instance === undefined) {\n    return\n  }\n  // Prefetch the link on hover/touchstart.\n  if (instance !== undefined) {\n    if (\n      process.env.__NEXT_DYNAMIC_ON_HOVER &&\n      unstable_upgradeToDynamicPrefetch\n    ) {\n      // Switch to a full prefetch\n      instance.fetchStrategy = FetchStrategy.Full\n    }\n    rescheduleLinkPrefetch(instance, PrefetchPriority.Intent)\n  }\n}\n\nfunction rescheduleLinkPrefetch(\n  instance: PrefetchableInstance,\n  priority: PrefetchPriority.Default | PrefetchPriority.Intent\n) {\n  // Ensures that app-router-instance is not compiled in the server bundle\n  if (typeof window !== 'undefined') {\n    const existingPrefetchTask = instance.prefetchTask\n\n    if (!instance.isVisible) {\n      // Cancel any in-progress prefetch task. (If it already finished then this\n      // is a no-op.)\n      if (existingPrefetchTask !== null) {\n        cancelPrefetchTask(existingPrefetchTask)\n      }\n      // We don't need to reset the prefetchTask to null upon cancellation; an\n      // old task object can be rescheduled with reschedulePrefetchTask. This is a\n      // micro-optimization but also makes the code simpler (don't need to\n      // worry about whether an old task object is stale).\n      return\n    }\n\n    const { getCurrentAppRouterState } =\n      require('./app-router-instance') as typeof import('./app-router-instance')\n\n    const appRouterState = getCurrentAppRouterState()\n    if (appRouterState !== null) {\n      const treeAtTimeOfPrefetch = appRouterState.tree\n      if (existingPrefetchTask === null) {\n        // Initiate a prefetch task.\n        const nextUrl = appRouterState.nextUrl\n        const cacheKey = createCacheKey(instance.prefetchHref, nextUrl)\n        instance.prefetchTask = scheduleSegmentPrefetchTask(\n          cacheKey,\n          treeAtTimeOfPrefetch,\n          instance.fetchStrategy,\n          priority,\n          null\n        )\n      } else {\n        // We already have an old task object that we can reschedule. This is\n        // effectively the same as canceling the old task and creating a new one.\n        reschedulePrefetchTask(\n          existingPrefetchTask,\n          treeAtTimeOfPrefetch,\n          instance.fetchStrategy,\n          priority\n        )\n      }\n    }\n  }\n}\n\nexport function pingVisibleLinks(\n  nextUrl: string | null,\n  tree: FlightRouterState\n) {\n  // For each currently visible link, cancel the existing prefetch task (if it\n  // exists) and schedule a new one. This is effectively the same as if all the\n  // visible links left and then re-entered the viewport.\n  //\n  // This is called when the Next-Url or the base tree changes, since those\n  // may affect the result of a prefetch task. It's also called after a\n  // cache invalidation.\n  for (const instance of prefetchableAndVisible) {\n    const task = instance.prefetchTask\n    if (task !== null && !isPrefetchTaskDirty(task, nextUrl, tree)) {\n      // The cache has not been invalidated, and none of the inputs have\n      // changed. Bail out.\n      continue\n    }\n    // Something changed. Cancel the existing prefetch task and schedule a\n    // new one.\n    if (task !== null) {\n      cancelPrefetchTask(task)\n    }\n    const cacheKey = createCacheKey(instance.prefetchHref, nextUrl)\n    instance.prefetchTask = scheduleSegmentPrefetchTask(\n      cacheKey,\n      tree,\n      instance.fetchStrategy,\n      PrefetchPriority.Default,\n      null\n    )\n  }\n}\n"],"names":["IDLE_LINK_STATUS","PENDING_LINK_STATUS","mountFormInstance","mountLinkInstance","onLinkVisibilityChanged","onNavigationIntent","pingVisibleLinks","setLinkForCurrentNavigation","unmountLinkForCurrentNavigation","unmountPrefetchableInstance","linkForMostRecentNavigation","pending","link","startTransition","setOptimisticLinkStatus","prefetchable","WeakMap","Map","prefetchableAndVisible","Set","observer","IntersectionObserver","handleIntersect","rootMargin","observeVisibility","element","instance","existingInstance","get","undefined","set","observe","coercePrefetchableUrl","href","window","createPrefetchURL","require","reportErrorFn","reportError","console","error","router","fetchStrategy","prefetchEnabled","prefetchURL","isVisible","prefetchTask","prefetchHref","delete","cancelPrefetchTask","unobserve","entries","entry","intersectionRatio","target","process","env","NODE_ENV","add","rescheduleLinkPrefetch","PrefetchPriority","Default","unstable_upgradeToDynamicPrefetch","__NEXT_DYNAMIC_ON_HOVER","FetchStrategy","Full","Intent","priority","existingPrefetchTask","getCurrentAppRouterState","appRouterState","treeAtTimeOfPrefetch","tree","nextUrl","cacheKey","createCacheKey","scheduleSegmentPrefetchTask","reschedulePrefetchTask","task","isPrefetchTaskDirty"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 5272, "column": 0}, "map": {"version":3,"sources":["file:///D:/AconnectJP/node_modules/next/src/client/components/segment-cache/bfcache.ts"],"sourcesContent":["import type { SegmentVaryPath } from './vary-path'\nimport {\n  setInCacheMap,\n  getFromCacheMap,\n  type UnknownMapEntry,\n  type CacheMap,\n  createCacheMap,\n} from './cache-map'\nimport { DYNAMIC_STALETIME_MS } from '../router-reducer/reducers/navigate-reducer'\n\nexport type BFCacheEntry = {\n  rsc: React.ReactNode | null\n  prefetchRsc: React.ReactNode | null\n  head: React.ReactNode | null\n  prefetchHead: React.ReactNode | null\n\n  ref: UnknownMapEntry | null\n  size: number\n  staleAt: number\n  version: number\n}\n\nconst bfcacheMap: CacheMap<BFCacheEntry> = createCacheMap()\n\nlet currentBfCacheVersion = 0\n\nexport function invalidateBfCache(): void {\n  currentBfCacheVersion++\n}\n\nexport function writeToBFCache(\n  now: number,\n  varyPath: SegmentVaryPath,\n  rsc: React.ReactNode,\n  prefetchRsc: React.ReactNode,\n  head: React.ReactNode,\n  prefetchHead: React.ReactNode\n): void {\n  const entry: BFCacheEntry = {\n    rsc,\n    prefetchRsc,\n\n    // TODO: These fields will be removed from both BFCacheEntry and\n    // SegmentCacheEntry. The head has its own separate cache entry.\n    head,\n    prefetchHead,\n\n    ref: null,\n    // TODO: This is just a heuristic. Getting the actual size of the segment\n    // isn't feasible because it's part of a larger streaming response. The\n    // LRU will still evict it, we just won't have a fully accurate total\n    // LRU size. However, we'll probably remove the size tracking from the LRU\n    // entirely and use memory pressure events instead.\n    size: 100,\n\n    // A back/forward navigation will disregard the stale time. This field is\n    // only relevant when staleTimes.dynamic is enabled.\n    staleAt: now + DYNAMIC_STALETIME_MS,\n    version: currentBfCacheVersion,\n  }\n  const isRevalidation = false\n  setInCacheMap(bfcacheMap, varyPath, entry, isRevalidation)\n}\n\nexport function writeHeadToBFCache(\n  now: number,\n  varyPath: SegmentVaryPath,\n  head: React.ReactNode,\n  prefetchHead: React.ReactNode\n): void {\n  // Read the special \"segment\" that represents the head data.\n  writeToBFCache(now, varyPath, head, prefetchHead, null, null)\n}\n\nexport function readFromBFCache(\n  varyPath: SegmentVaryPath\n): BFCacheEntry | null {\n  const isRevalidation = false\n  return getFromCacheMap(\n    // During a back/forward navigation, it doesn't matter how stale the data\n    // might be. Pass -1 instead of the actual current time to bypass\n    // staleness checks.\n    -1,\n    currentBfCacheVersion,\n    bfcacheMap,\n    varyPath,\n    isRevalidation\n  )\n}\n\nexport function readFromBFCacheDuringRegularNavigation(\n  now: number,\n  varyPath: SegmentVaryPath\n): BFCacheEntry | null {\n  const isRevalidation = false\n  return getFromCacheMap(\n    now,\n    currentBfCacheVersion,\n    bfcacheMap,\n    varyPath,\n    isRevalidation\n  )\n}\n"],"names":["invalidateBfCache","readFromBFCache","readFromBFCacheDuringRegularNavigation","writeHeadToBFCache","writeToBFCache","bfcacheMap","createCacheMap","currentBfCacheVersion","now","varyPath","rsc","prefetchRsc","head","prefetchHead","entry","ref","size","staleAt","DYNAMIC_STALETIME_MS","version","isRevalidation","setInCacheMap","getFromCacheMap"],"mappings":";;;;;;;;;;;;;;;;;IA0BgBA,iBAAiB,EAAA;eAAjBA;;IAgDAC,eAAe,EAAA;eAAfA;;IAgBAC,sCAAsC,EAAA;eAAtCA;;IA1BAC,kBAAkB,EAAA;eAAlBA;;IAlCAC,cAAc,EAAA;eAAdA;;;0BAvBT;iCAC8B;AAcrC,MAAMC,aAAqCC,CAAAA,GAAAA,UAAAA,cAAc;AAEzD,IAAIC,wBAAwB;AAErB,SAASP;IACdO;AACF;AAEO,SAASH,eACdI,GAAW,EACXC,QAAyB,EACzBC,GAAoB,EACpBC,WAA4B,EAC5BC,IAAqB,EACrBC,YAA6B;IAE7B,MAAMC,QAAsB;QAC1BJ;QACAC;QAEA,gEAAgE;QAChE,gEAAgE;QAChEC;QACAC;QAEAE,KAAK;QACL,yEAAyE;QACzE,uEAAuE;QACvE,qEAAqE;QACrE,0EAA0E;QAC1E,mDAAmD;QACnDC,MAAM;QAEN,yEAAyE;QACzE,oDAAoD;QACpDC,SAAST,MAAMU,iBAAAA,oBAAoB;QACnCC,SAASZ;IACX;IACA,MAAMa,iBAAiB;IACvBC,CAAAA,GAAAA,UAAAA,aAAa,EAAChB,YAAYI,UAAUK,OAAOM;AAC7C;AAEO,SAASjB,mBACdK,GAAW,EACXC,QAAyB,EACzBG,IAAqB,EACrBC,YAA6B;IAE7B,4DAA4D;IAC5DT,eAAeI,KAAKC,UAAUG,MAAMC,cAAc,MAAM;AAC1D;AAEO,SAASZ,gBACdQ,QAAyB;IAEzB,MAAMW,iBAAiB;IACvB,OAAOE,CAAAA,GAAAA,UAAAA,eAAe,EACpB,AACA,iEAAiE,QADQ;IAEzE,oBAAoB;IACpB,CAAC,GACDf,uBACAF,YACAI,UACAW;AAEJ;AAEO,SAASlB,uCACdM,GAAW,EACXC,QAAyB;IAEzB,MAAMW,iBAAiB;IACvB,OAAOE,CAAAA,GAAAA,UAAAA,eAAe,EACpBd,KACAD,uBACAF,YACAI,UACAW;AAEJ","ignoreList":[0]}},
    {"offset": {"line": 5360, "column": 0}, "map": {"version":3,"sources":["file:///D:/AconnectJP/node_modules/next/src/client/components/segment-cache/optimistic-routes.ts"],"sourcesContent":["/**\n * Optimistic Routing (Known Routes)\n *\n * This module enables the client to predict route structure for URLs that\n * haven't been prefetched yet, based on previously learned route patterns.\n * When successful, this allows skipping the route tree prefetch request\n * entirely.\n *\n * The core idea is that many URLs map to the same route structure. For example,\n * /blog/post-1 and /blog/post-2 both resolve to /blog/[slug]. Once we've\n * prefetched one, we can predict the structure of the other.\n *\n * However, we can't always make this prediction. Static siblings (like\n * /blog/featured alongside /blog/[slug]) have different route structures.\n * When we learn a dynamic route, we also learn its static siblings so we\n * know when NOT to apply the prediction.\n *\n * Main entry points:\n *\n * 1. discoverKnownRoute: Called after receiving a route tree from the server.\n *    Traverses the route tree, compares URL parts to segments, and populates\n *    the known route tree if they match. Routes are always inserted into the\n *    cache.\n *\n * 2. matchKnownRoute: Called when looking up a route with no cache entry.\n *    Matches the candidate URL against learned patterns. Returns a synthetic\n *    cache entry if successful, or null to fall back to server resolution.\n *\n * Rewrite detection happens during traversal: if a URL path part doesn't match\n * the corresponding route segment, we stop populating the known route tree\n * (since the mapping is incorrect) but still insert the route into the cache.\n *\n * The known route tree is append-only with no eviction. Route patterns are\n * derived from the filesystem, so they don't become stale within a session.\n * Cache invalidation on deploy clears everything anyway.\n *\n * Current limitations (deopt to server resolution):\n * - Rewrites: Detected during traversal (tree not populated, but route cached)\n * - Intercepted routes: Routes using (.), (..), (...) patterns\n */\n\nimport type { DynamicParamTypesShort } from '../../../shared/lib/app-router-types'\nimport type { RouteTree, FulfilledRouteCacheEntry } from './cache'\nimport {\n  EntryStatus,\n  writeRouteIntoCache,\n  fulfillRouteCacheEntry,\n  type PendingRouteCacheEntry,\n  createMetadataRouteTree,\n} from './cache'\nimport { doesStaticSegmentAppearInURL } from '../../route-params'\nimport type { NormalizedPathname, NormalizedSearch } from './cache-key'\nimport {\n  appendLayoutVaryPath,\n  finalizeLayoutVaryPath,\n  finalizePageVaryPath,\n  finalizeMetadataVaryPath,\n  type PartialSegmentVaryPath,\n  type PageVaryPath,\n} from './vary-path'\n\n/**\n * The known route tree is analogous to a route table. A different routing\n * implementation might use regexes or URLPattern; ours uses a trie indexed\n * by URL path segments.\n *\n * Each node (KnownRoutePart) represents a position in the URL and can have:\n * - staticChildren: Map of literal segments to child nodes\n * - dynamicChild: A single dynamic segment node ([slug], [...params], etc.)\n * - pattern: A cache entry template for routes that terminate here\n *\n * This tree only contains segments that correspond to actual filesystem routes.\n * Route groups like (marketing) and parallel routes like @modal are not\n * included since they don't appear in URLs. Similarly, if a URL is rewritten\n * to a different filesystem path, the original URL segments don't appear here\n *  only the resolved filesystem route structure is stored.\n *\n * Example tree after learning /blog/[slug], /blog/featured, and /about:\n *\n *    about\n *    blog\n *        featured\n *        [slug]\n *\n * When matching /blog/hello:\n *   1. \"blog\" matches static child\n *   2. \"hello\" doesn't match \"featured\", falls through to [slug]\n *   3. Returns [slug]'s pattern with resolved param { slug: \"hello\" }\n */\ntype KnownRoutePartBase = {\n  // Known static paths at this level. The null vs Map distinction is\n  // semantically meaningful:\n  // - null: Static siblings are UNKNOWN at this level (e.g., webpack dev mode\n  //   where routes are compiled on-demand). If there's a dynamicChild, we\n  //   can't safely match it because the URL might be an unknown static sibling.\n  // - Map (even if empty): Static siblings are KNOWN. We can safely match a\n  //   dynamicChild if the URL doesn't match any entry in the Map.\n  staticChildren: Map<string, KnownRoutePart> | null\n\n  // The cache entry that serves as a pattern for this route.\n  // When a URL matches, we clone this and substitute param values.\n  // null means we know this path exists (from static siblings) but haven't\n  // learned its structure yet.\n  pattern: FulfilledRouteCacheEntry | null\n\n  // TODO: For prefix rewrite support. When true, this part may not appear in\n  // the candidate URL because it was injected by a rewrite.\n  // mayBeSkippedInURL: boolean\n}\n\n// The dynamic child fields are structured as a union so that narrowing on\n// dynamicChild also narrows dynamicChildParamName and dynamicChildParamType.\ntype KnownRoutePartWithoutDynamicChild = KnownRoutePartBase & {\n  dynamicChild: null\n  dynamicChildParamName: null\n  dynamicChildParamType: null\n}\n\ntype KnownRoutePartWithDynamicChild = KnownRoutePartBase & {\n  dynamicChild: KnownRoutePart\n  dynamicChildParamName: string\n  dynamicChildParamType: DynamicParamTypesShort\n}\n\ntype KnownRoutePart =\n  | KnownRoutePartWithoutDynamicChild\n  | KnownRoutePartWithDynamicChild\n\n/**\n * Param values extracted during URL matching. Used to reify the template.\n * - string for regular dynamic [param]\n * - string[] for catch-all [...param] and optional catch-all [[...param]]\n */\ntype ResolvedParams = Map<string, string | string[]>\n\nfunction createEmptyPart(): KnownRoutePart {\n  return {\n    staticChildren: null,\n    dynamicChild: null,\n    dynamicChildParamName: null,\n    dynamicChildParamType: null,\n    pattern: null,\n  }\n}\n\n// The root of the known route tree.\nlet knownRouteTreeRoot: KnownRoutePart = createEmptyPart()\n\n/**\n * Learns a route pattern from a server response and inserts it into the cache.\n *\n * Called after receiving a route tree from the server (initial load, navigation,\n * or prefetch). Traverses the route tree, compares URL parts to segments, and\n * populates the known route tree if they match. Routes are always inserted into\n * the cache regardless of whether the URL matches the route structure.\n *\n * When pendingEntry is provided, it's fulfilled and used. When null, an entry\n * is created and inserted into the route cache map.\n *\n * When hasDynamicRewrite is true, the route entry is marked as having a\n * dynamic rewrite, which prevents it from being used as a template for future\n * predictions. This is set when we detect a mismatch between what we predicted\n * and what the server returned.\n *\n * Returns the fulfilled route cache entry.\n */\nexport function discoverKnownRoute(\n  now: number,\n  pathname: string,\n  pendingEntry: PendingRouteCacheEntry | null,\n  routeTree: RouteTree,\n  metadataVaryPath: PageVaryPath,\n  couldBeIntercepted: boolean,\n  canonicalUrl: string,\n  isPPREnabled: boolean,\n  hasDynamicRewrite: boolean\n): FulfilledRouteCacheEntry {\n  const tree = routeTree\n\n  const pathnameParts = pathname.split('/').filter((p) => p !== '')\n  const firstPart = pathnameParts.length > 0 ? pathnameParts[0] : null\n  const remainingParts = pathnameParts.length > 0 ? pathnameParts.slice(1) : []\n\n  if (pendingEntry !== null) {\n    // Fulfill the pending entry first\n    const fulfilledEntry = fulfillRouteCacheEntry(\n      now,\n      pendingEntry,\n      tree,\n      metadataVaryPath,\n      couldBeIntercepted,\n      canonicalUrl,\n      isPPREnabled\n    )\n    if (hasDynamicRewrite) {\n      fulfilledEntry.hasDynamicRewrite = true\n    }\n    // Populate the known route tree (handles rewrite detection internally).\n    // The entry is already in the cache; this just stores it as a pattern\n    // if the URL matches the route structure.\n    discoverKnownRoutePart(\n      knownRouteTreeRoot,\n      tree,\n      firstPart,\n      remainingParts,\n      fulfilledEntry,\n      now,\n      pathname,\n      tree,\n      metadataVaryPath,\n      couldBeIntercepted,\n      canonicalUrl,\n      isPPREnabled,\n      hasDynamicRewrite\n    )\n    return fulfilledEntry\n  }\n\n  // No pending entry - discoverKnownRoutePart will create one and insert it\n  // into the cache, or return an existing pattern if one exists.\n  return discoverKnownRoutePart(\n    knownRouteTreeRoot,\n    tree,\n    firstPart,\n    remainingParts,\n    null,\n    now,\n    pathname,\n    tree,\n    metadataVaryPath,\n    couldBeIntercepted,\n    canonicalUrl,\n    isPPREnabled,\n    hasDynamicRewrite\n  )\n}\n\n/**\n * Gets or creates the dynamic child node for a KnownRoutePart.\n * A node can have at most one dynamic child (you can't have both [slug] and\n * [id] at the same route level), so we either return existing or create new.\n */\nfunction discoverDynamicChild(\n  part: KnownRoutePart,\n  paramName: string,\n  paramType: DynamicParamTypesShort\n): KnownRoutePart {\n  if (part.dynamicChild !== null) {\n    return part.dynamicChild\n  }\n  const newChild = createEmptyPart()\n  // Type assertion needed because we're converting from \"without\" to \"with\"\n  // dynamic child variant.\n  const mutablePart = part as unknown as KnownRoutePartWithDynamicChild\n  mutablePart.dynamicChild = newChild\n  mutablePart.dynamicChildParamName = paramName\n  mutablePart.dynamicChildParamType = paramType\n  return newChild\n}\n\n/**\n * Recursive workhorse for discoverKnownRoute.\n *\n * Walks the route tree and URL parts in parallel, building out the known\n * route tree as it goes. At each step:\n * 1. Determines if the current segment appears in the URL (dynamic/static)\n * 2. Validates URL matches route structure (detects rewrites)\n * 3. Creates/updates the corresponding KnownRoutePart node\n * 4. Records static siblings for future matching\n * 5. Recurses into child slots (parallel routes)\n *\n * If a URL/route mismatch is detected (rewrite), we stop building the known\n * route tree but still cache the route entry for direct lookup.\n */\nfunction discoverKnownRoutePart(\n  parentKnownRoutePart: KnownRoutePart,\n  routeTree: RouteTree,\n  urlPart: string | null,\n  remainingParts: string[],\n  existingEntry: FulfilledRouteCacheEntry | null,\n  // These are passed through unchanged for entry creation at the leaf\n  now: number,\n  pathname: string,\n  fullTree: RouteTree,\n  metadataVaryPath: PageVaryPath,\n  couldBeIntercepted: boolean,\n  canonicalUrl: string,\n  isPPREnabled: boolean,\n  hasDynamicRewrite: boolean\n): FulfilledRouteCacheEntry {\n  const segment = routeTree.segment\n\n  let segmentAppearsInURL: boolean\n  let paramName: string | null = null\n  let paramType: DynamicParamTypesShort | null = null\n  let staticSiblings: readonly string[] | null = null\n\n  if (typeof segment === 'string') {\n    segmentAppearsInURL = doesStaticSegmentAppearInURL(segment)\n  } else {\n    // Dynamic segment tuple: [paramName, paramCacheKey, paramType, staticSiblings]\n    paramName = segment[0]\n    paramType = segment[2]\n    staticSiblings = segment[3]\n    segmentAppearsInURL = true\n  }\n\n  let knownRoutePart: KnownRoutePart = parentKnownRoutePart\n  let nextUrlPart: string | null = urlPart\n  let nextRemainingParts: string[] = remainingParts\n\n  if (segmentAppearsInURL) {\n    // Check for mismatch: if this is a static segment, the URL part must match\n    if (paramName === null && urlPart !== segment) {\n      // URL doesn't match route structure (likely a rewrite).\n      // Don't populate the known route tree, just write the route into the\n      // cache and return immediately.\n      if (existingEntry !== null) {\n        return existingEntry\n      }\n      return writeRouteIntoCache(\n        now,\n        pathname as NormalizedPathname,\n        fullTree,\n        metadataVaryPath,\n        couldBeIntercepted,\n        canonicalUrl,\n        isPPREnabled\n      )\n    }\n\n    // URL matches route structure. Build the known route tree.\n    if (paramName !== null && paramType !== null) {\n      // Dynamic segment\n      knownRoutePart = discoverDynamicChild(\n        parentKnownRoutePart,\n        paramName,\n        paramType\n      )\n\n      // Record static siblings as placeholder parts.\n      // IMPORTANT: We use the null vs Map distinction to track whether\n      // siblings are known at this level:\n      // - staticChildren: null = siblings unknown (can't safely match dynamic)\n      // - staticChildren: Map = siblings known (even if empty)\n      // This matters in dev mode where webpack may not know all siblings yet.\n      if (staticSiblings !== null) {\n        // Siblings are known - ensure we have a Map (even if empty)\n        if (parentKnownRoutePart.staticChildren === null) {\n          parentKnownRoutePart.staticChildren = new Map()\n        }\n        for (const sibling of staticSiblings) {\n          if (!parentKnownRoutePart.staticChildren.has(sibling)) {\n            parentKnownRoutePart.staticChildren.set(sibling, createEmptyPart())\n          }\n        }\n      }\n    } else {\n      // Static segment\n      if (parentKnownRoutePart.staticChildren === null) {\n        parentKnownRoutePart.staticChildren = new Map()\n      }\n      let existingChild = parentKnownRoutePart.staticChildren.get(urlPart!)\n      if (existingChild === undefined) {\n        existingChild = createEmptyPart()\n        parentKnownRoutePart.staticChildren.set(urlPart!, existingChild)\n      }\n      knownRoutePart = existingChild\n    }\n\n    // Advance to next URL part\n    nextUrlPart = remainingParts.length > 0 ? remainingParts[0] : null\n    nextRemainingParts =\n      remainingParts.length > 0 ? remainingParts.slice(1) : []\n  }\n  // else: Transparent segment (route group, __PAGE__, etc.)\n  // Stay at the same known route part, don't advance URL parts\n\n  // Recurse into child routes. A route tree can have multiple parallel routes\n  // (e.g., @modal alongside children). Each parallel route is a separate\n  // branch, but they all share the same URL - we just need to traverse all\n  // branches to build out the known route tree.\n  const slots = routeTree.slots\n  let resultFromChildren: FulfilledRouteCacheEntry | null = null\n  if (slots !== null) {\n    for (const parallelRouteKey in slots) {\n      const childRouteTree = slots[parallelRouteKey]\n      // Skip branches with refreshState set - these were reused from a\n      // different route (e.g., a \"default\" parallel slot) and don't represent\n      // the actual route structure for this URL.\n      if (childRouteTree.refreshState !== null) {\n        continue\n      }\n      const result = discoverKnownRoutePart(\n        knownRoutePart,\n        childRouteTree,\n        nextUrlPart,\n        nextRemainingParts,\n        existingEntry,\n        now,\n        pathname,\n        fullTree,\n        metadataVaryPath,\n        couldBeIntercepted,\n        canonicalUrl,\n        isPPREnabled,\n        hasDynamicRewrite\n      )\n      // All parallel route branches share the same URL, so they should all\n      // reach compatible leaf nodes. We capture any result.\n      resultFromChildren = result\n    }\n    if (resultFromChildren !== null) {\n      return resultFromChildren\n    }\n    // Defensive fallback: no children returned a result. This shouldn't happen\n    // for valid route trees, but handle it gracefully.\n    if (existingEntry !== null) {\n      return existingEntry\n    }\n    return writeRouteIntoCache(\n      now,\n      pathname as NormalizedPathname,\n      fullTree,\n      metadataVaryPath,\n      couldBeIntercepted,\n      canonicalUrl,\n      isPPREnabled\n    )\n  }\n\n  // Reached a page node. Create/get the route cache entry and store as a\n  // pattern. First, check if there's already a pattern for this route.\n  if (knownRoutePart.pattern !== null) {\n    // If this route has a dynamic rewrite, mark the existing pattern.\n    if (hasDynamicRewrite) {\n      knownRoutePart.pattern.hasDynamicRewrite = true\n    }\n    return knownRoutePart.pattern\n  }\n\n  // Get or create the entry\n  let entry: FulfilledRouteCacheEntry\n  if (existingEntry !== null) {\n    // Already have a fulfilled entry, use it directly. It's already in the\n    // route cache map.\n    entry = existingEntry\n  } else {\n    // Create the entry and insert it into the route cache map.\n    entry = writeRouteIntoCache(\n      now,\n      pathname as NormalizedPathname,\n      fullTree,\n      metadataVaryPath,\n      couldBeIntercepted,\n      canonicalUrl,\n      isPPREnabled\n    )\n  }\n\n  if (hasDynamicRewrite) {\n    entry.hasDynamicRewrite = true\n  }\n\n  // Store as pattern\n  knownRoutePart.pattern = entry\n  return entry\n}\n\n/**\n * Attempts to match a URL against learned route patterns.\n *\n * Returns a synthetic FulfilledRouteCacheEntry if the URL matches a known\n * pattern, or null if no match is found (fall back to server resolution).\n */\nexport function matchKnownRoute(\n  pathname: string,\n  search: NormalizedSearch\n): FulfilledRouteCacheEntry | null {\n  const pathnameParts = pathname.split('/').filter((p) => p !== '')\n  const resolvedParams: ResolvedParams = new Map()\n  const match = matchKnownRoutePart(\n    knownRouteTreeRoot,\n    pathnameParts,\n    0,\n    resolvedParams\n  )\n\n  if (match === null) {\n    return null\n  }\n\n  const matchedPart = match.part\n  const pattern = match.pattern\n\n  // If the pattern could be intercepted, we can't safely use it for prediction\n  // because the route structure may vary based on the Next-Url header.\n  if (pattern.couldBeIntercepted) {\n    return null\n  }\n\n  // \"Reify\" the pattern: clone the template tree with concrete param values.\n  // This substitutes resolved params (e.g., slug: \"hello\") into dynamic\n  // segments and recomputes vary paths for correct segment cache keying.\n  const acc: ReifyAccumulator = { metadataVaryPath: null }\n  const reifiedTree = reifyRouteTree(\n    pattern.tree,\n    resolvedParams,\n    search,\n    null, // Start with null partial vary path at the root\n    acc\n  )\n\n  // The metadata tree is a flat page node without the intermediate layout\n  // structure. Clone it with the updated metadata vary path collected during\n  // the main tree traversal.\n  const metadataVaryPath = acc.metadataVaryPath\n  if (metadataVaryPath === null) {\n    // This shouldn't be reachable for a valid route tree.\n    return null\n  }\n  const reifiedMetadata = createMetadataRouteTree(metadataVaryPath)\n\n  // Create a synthetic (predicted) entry and store it as the new pattern.\n  //\n  // Why replace the pattern? We intentionally update the pattern with this\n  // synthetic entry so that if our prediction was wrong (server returns a\n  // different pathname due to dynamic rewrite), the entry gets marked with\n  // hasDynamicRewrite. Future predictions for this route will see the flag\n  // and bail out to server resolution instead of making the same mistake.\n  const syntheticEntry: FulfilledRouteCacheEntry = {\n    canonicalUrl: pathname + search,\n    status: EntryStatus.Fulfilled,\n    blockedTasks: null,\n    tree: reifiedTree,\n    metadata: reifiedMetadata,\n    couldBeIntercepted: pattern.couldBeIntercepted,\n    isPPREnabled: pattern.isPPREnabled,\n    hasDynamicRewrite: false,\n    renderedSearch: search,\n    ref: null,\n    size: pattern.size,\n    staleAt: pattern.staleAt,\n    version: pattern.version,\n  }\n\n  matchedPart.pattern = syntheticEntry\n\n  return syntheticEntry\n}\n\n/**\n * Result of a successful match: the matched tree node and its pattern.\n * We return both because the caller needs to update the pattern after\n * creating a synthetic entry (for dynamic rewrite detection).\n */\ntype KnownRouteMatch = {\n  part: KnownRoutePart\n  pattern: FulfilledRouteCacheEntry\n} | null\n\n/**\n * Recursively matches a URL against the known route tree.\n *\n * Matching priority (most specific first):\n * 1. Static children - exact path segment match\n * 2. Dynamic child - [param], [...param], [[...param]]\n * 3. Direct pattern - when no more URL parts remain\n *\n * Collects resolved param values in resolvedParams as it traverses.\n * Returns null if no match found (caller should fall back to server).\n */\nfunction matchKnownRoutePart(\n  part: KnownRoutePart,\n  pathnameParts: string[],\n  partIndex: number,\n  resolvedParams: ResolvedParams\n): KnownRouteMatch {\n  const urlPart =\n    partIndex < pathnameParts.length ? pathnameParts[partIndex] : null\n\n  // If staticChildren is null, we don't know what static routes exist at this\n  // level. This happens in webpack dev mode where routes are compiled\n  // on-demand. We can't safely match a dynamicChild because the URL part might\n  // be a static sibling we haven't discovered yet. Example: We know\n  // /blog/[slug] exists, but haven't compiled /blog/featured. A request for\n  // /blog/featured would incorrectly match /blog/[slug].\n  if (part.staticChildren === null) {\n    // The only safe match is a direct pattern when no URL parts remain.\n    if (urlPart === null) {\n      const pattern = part.pattern\n      if (pattern !== null && !pattern.hasDynamicRewrite) {\n        return { part, pattern }\n      }\n    }\n    return null\n  }\n\n  // Static children take priority over dynamic. This ensures /blog/featured\n  // matches its own route rather than /blog/[slug].\n  if (urlPart !== null) {\n    const staticChild = part.staticChildren.get(urlPart)\n    if (staticChild !== undefined) {\n      // Check if this is an \"unknown\" placeholder part. These are created when\n      // we learn about static siblings (from the route tree's staticSiblings\n      // field) but haven't prefetched them yet. We know the path exists but\n      // don't know its structure, so we can't predict it.\n      if (\n        staticChild.pattern === null &&\n        staticChild.dynamicChild === null &&\n        staticChild.staticChildren === null\n      ) {\n        // Bail out - server must resolve this route.\n        return null\n      }\n      const match = matchKnownRoutePart(\n        staticChild,\n        pathnameParts,\n        partIndex + 1,\n        resolvedParams\n      )\n      if (match !== null) {\n        return match\n      }\n      // Static child exists but didn't match (e.g., wrong depth).\n      // Fall through to try dynamic.\n    }\n  }\n\n  // Try dynamic child\n  if (part.dynamicChild !== null) {\n    const dynamicPart = part.dynamicChild\n    const paramName = part.dynamicChildParamName\n    const paramType = part.dynamicChildParamType\n    const dynamicPattern = dynamicPart.pattern\n\n    switch (paramType) {\n      case 'c':\n        // Required catch-all [...param]: consumes 1+ URL parts\n        if (\n          dynamicPattern !== null &&\n          !dynamicPattern.hasDynamicRewrite &&\n          urlPart !== null\n        ) {\n          resolvedParams.set(paramName, pathnameParts.slice(partIndex))\n          return { part: dynamicPart, pattern: dynamicPattern }\n        }\n        break\n      case 'oc':\n        // Optional catch-all [[...param]]: consumes 0+ URL parts\n        if (dynamicPattern !== null && !dynamicPattern.hasDynamicRewrite) {\n          if (urlPart !== null) {\n            resolvedParams.set(paramName, pathnameParts.slice(partIndex))\n            return { part: dynamicPart, pattern: dynamicPattern }\n          }\n          // urlPart is null - can match with zero parts, but a direct pattern\n          // (e.g., page.tsx alongside [[...param]]) takes precedence.\n          if (part.pattern === null || part.pattern.hasDynamicRewrite) {\n            resolvedParams.set(paramName, [])\n            return { part: dynamicPart, pattern: dynamicPattern }\n          }\n        }\n        break\n      case 'd':\n        // Regular dynamic [param]: consumes exactly 1 URL part.\n        // Unlike catch-all which terminates here, regular dynamic must\n        // continue recursing to find the leaf pattern.\n        if (urlPart !== null) {\n          resolvedParams.set(paramName, urlPart)\n          return matchKnownRoutePart(\n            dynamicPart,\n            pathnameParts,\n            partIndex + 1,\n            resolvedParams\n          )\n        }\n        break\n      // Intercepted routes use relative path markers like (.), (..), (...)\n      // Their behavior depends on navigation context (soft vs hard nav),\n      // so we can't predict them client-side. Defer to server.\n      case 'ci(..)(..)':\n      case 'ci(.)':\n      case 'ci(..)':\n      case 'ci(...)':\n      case 'di(..)(..)':\n      case 'di(.)':\n      case 'di(..)':\n      case 'di(...)':\n        return null\n      default:\n        paramType satisfies never\n    }\n  }\n\n  // No children matched. If we've consumed all URL parts, check for a direct\n  // pattern at this node (the route terminates here).\n  if (urlPart === null) {\n    const pattern = part.pattern\n    if (pattern !== null && !pattern.hasDynamicRewrite) {\n      return { part, pattern }\n    }\n  }\n\n  return null\n}\n\n/**\n * Accumulator for collecting data during reifyRouteTree traversal.\n * metadataVaryPath is collected from the first page node encountered\n * (parallel routes may have multiple pages, but metadata uses the first).\n */\ntype ReifyAccumulator = {\n  metadataVaryPath: PageVaryPath | null\n}\n\n/**\n * \"Reify\" means to make concrete - we take an abstract pattern (the template\n * route tree) and produce a concrete instance with actual param values.\n *\n * This function clones a RouteTree, substituting dynamic segment values from\n * resolvedParams and computing new vary paths. The vary path encodes param\n * values so segment cache entries can be correctly keyed.\n *\n * Example: Pattern for /blog/[slug] with resolvedParams { slug: \"hello\" }\n * produces a tree where segment [slug] has cacheKey \"hello\".\n */\nfunction reifyRouteTree(\n  pattern: RouteTree,\n  resolvedParams: ResolvedParams,\n  search: NormalizedSearch,\n  parentPartialVaryPath: PartialSegmentVaryPath | null,\n  acc: ReifyAccumulator\n): RouteTree {\n  const originalSegment = pattern.segment\n\n  let newSegment = originalSegment\n  let partialVaryPath: PartialSegmentVaryPath | null\n\n  if (typeof originalSegment !== 'string') {\n    // Dynamic segment: compute new cache key and append to partial vary path\n    const paramName = originalSegment[0]\n    const paramType = originalSegment[2]\n    const staticSiblings = originalSegment[3]\n    const newValue = resolvedParams.get(paramName)\n    if (newValue !== undefined) {\n      const newCacheKey = Array.isArray(newValue)\n        ? newValue.join('/')\n        : newValue\n      newSegment = [paramName, newCacheKey, paramType, staticSiblings]\n      partialVaryPath = appendLayoutVaryPath(\n        parentPartialVaryPath,\n        newCacheKey,\n        paramName\n      )\n    } else {\n      // Param not found in resolvedParams - keep original and inherit partial\n      // TODO: This should never happen. Bail out with null.\n      partialVaryPath = parentPartialVaryPath\n    }\n  } else {\n    // Static segment: inherit partial vary path from parent\n    partialVaryPath = parentPartialVaryPath\n  }\n\n  // Recurse into children with the (possibly updated) partial vary path\n  let newSlots: Record<string, RouteTree> | null = null\n  if (pattern.slots !== null) {\n    newSlots = {}\n    for (const key in pattern.slots) {\n      newSlots[key] = reifyRouteTree(\n        pattern.slots[key],\n        resolvedParams,\n        search,\n        partialVaryPath,\n        acc\n      )\n    }\n  }\n\n  if (pattern.isPage) {\n    // Page segment: finalize with search params\n    const newVaryPath = finalizePageVaryPath(\n      pattern.requestKey,\n      search,\n      partialVaryPath\n    )\n    // Collect metadata vary path (first page wins, same as original algorithm)\n    if (acc.metadataVaryPath === null) {\n      acc.metadataVaryPath = finalizeMetadataVaryPath(\n        pattern.requestKey,\n        search,\n        partialVaryPath\n      )\n    }\n    return {\n      requestKey: pattern.requestKey,\n      segment: newSegment,\n      refreshState: pattern.refreshState,\n      slots: newSlots,\n      isRootLayout: pattern.isRootLayout,\n      hasLoadingBoundary: pattern.hasLoadingBoundary,\n      hasRuntimePrefetch: pattern.hasRuntimePrefetch,\n      isPage: true,\n      varyPath: newVaryPath,\n    }\n  } else {\n    // Layout segment: finalize without search params\n    const newVaryPath = finalizeLayoutVaryPath(\n      pattern.requestKey,\n      partialVaryPath\n    )\n    return {\n      requestKey: pattern.requestKey,\n      segment: newSegment,\n      refreshState: pattern.refreshState,\n      slots: newSlots,\n      isRootLayout: pattern.isRootLayout,\n      hasLoadingBoundary: pattern.hasLoadingBoundary,\n      hasRuntimePrefetch: pattern.hasRuntimePrefetch,\n      isPage: false,\n      varyPath: newVaryPath,\n    }\n  }\n}\n\n/**\n * Resets the known route tree. Called during development when routes may\n * change due to hot reloading.\n */\nexport function resetKnownRoutes(): void {\n  knownRouteTreeRoot = createEmptyPart()\n}\n"],"names":["discoverKnownRoute","matchKnownRoute","resetKnownRoutes","createEmptyPart","staticChildren","dynamicChild","dynamicChildParamName","dynamicChildParamType","pattern","knownRouteTreeRoot","now","pathname","pendingEntry","routeTree","metadataVaryPath","couldBeIntercepted","canonicalUrl","isPPREnabled","hasDynamicRewrite","tree","pathnameParts","split","filter","p","firstPart","length","remainingParts","slice","fulfilledEntry","fulfillRouteCacheEntry","discoverKnownRoutePart","discoverDynamicChild","part","paramName","paramType","newChild","mutablePart","parentKnownRoutePart","urlPart","existingEntry","fullTree","segment","segmentAppearsInURL","staticSiblings","doesStaticSegmentAppearInURL","knownRoutePart","nextUrlPart","nextRemainingParts","writeRouteIntoCache","Map","sibling","has","set","existingChild","get","undefined","slots","resultFromChildren","parallelRouteKey","childRouteTree","refreshState","result","entry","search","resolvedParams","match","matchKnownRoutePart","matchedPart","acc","reifiedTree","reifyRouteTree","reifiedMetadata","createMetadataRouteTree","syntheticEntry","status","EntryStatus","Fulfilled","blockedTasks","metadata","renderedSearch","ref","size","staleAt","version","partIndex","staticChild","dynamicPart","dynamicPattern","parentPartialVaryPath","originalSegment","newSegment","partialVaryPath","newValue","newCacheKey","Array","isArray","join","appendLayoutVaryPath","newSlots","key","isPage","newVaryPath","finalizePageVaryPath","requestKey","finalizeMetadataVaryPath","isRootLayout","hasLoadingBoundary","hasRuntimePrefetch","varyPath","finalizeLayoutVaryPath"],"mappings":"AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAuCC;;;;;;;;;;;;;;;IA+HeA,kBAAkB,EAAA;eAAlBA;;IAqTAC,eAAe,EAAA;eAAfA;;IAkWAC,gBAAgB,EAAA;eAAhBA;;;uBA5wBT;6BACsC;0BAStC;AA4EP,SAASC;IACP,OAAO;QACLC,gBAAgB;QAChBC,cAAc;QACdC,uBAAuB;QACvBC,uBAAuB;QACvBC,SAAS;IACX;AACF;AAEA,oCAAoC;AACpC,IAAIC,qBAAqCN;AAoBlC,SAASH,mBACdU,GAAW,EACXC,QAAgB,EAChBC,YAA2C,EAC3CC,SAAoB,EACpBC,gBAA8B,EAC9BC,kBAA2B,EAC3BC,YAAoB,EACpBC,YAAqB,EACrBC,iBAA0B;IAE1B,MAAMC,OAAON;IAEb,MAAMO,gBAAgBT,SAASU,KAAK,CAAC,KAAKC,MAAM,CAAC,CAACC,IAAMA,MAAM;IAC9D,MAAMC,YAAYJ,cAAcK,MAAM,GAAG,IAAIL,aAAa,CAAC,EAAE,GAAG;IAChE,MAAMM,iBAAiBN,cAAcK,MAAM,GAAG,IAAIL,cAAcO,KAAK,CAAC,KAAK,EAAE;IAE7E,IAAIf,iBAAiB,MAAM;QACzB,kCAAkC;QAClC,MAAMgB,iBAAiBC,CAAAA,GAAAA,OAAAA,sBAAsB,EAC3CnB,KACAE,cACAO,MACAL,kBACAC,oBACAC,cACAC;QAEF,IAAIC,mBAAmB;YACrBU,eAAeV,iBAAiB,GAAG;QACrC;QACA,wEAAwE;QACxE,sEAAsE;QACtE,0CAA0C;QAC1CY,uBACErB,oBACAU,MACAK,WACAE,gBACAE,gBACAlB,KACAC,UACAQ,MACAL,kBACAC,oBACAC,cACAC,cACAC;QAEF,OAAOU;IACT;IAEA,0EAA0E;IAC1E,+DAA+D;IAC/D,OAAOE,uBACLrB,oBACAU,MACAK,WACAE,gBACA,MACAhB,KACAC,UACAQ,MACAL,kBACAC,oBACAC,cACAC,cACAC;AAEJ;AAEA;;;;CAIC,GACD,SAASa,qBACPC,IAAoB,EACpBC,SAAiB,EACjBC,SAAiC;IAEjC,IAAIF,KAAK3B,YAAY,KAAK,MAAM;QAC9B,OAAO2B,KAAK3B,YAAY;IAC1B;IACA,MAAM8B,WAAWhC;IACjB,0EAA0E;IAC1E,yBAAyB;IACzB,MAAMiC,cAAcJ;IACpBI,YAAY/B,YAAY,GAAG8B;IAC3BC,YAAY9B,qBAAqB,GAAG2B;IACpCG,YAAY7B,qBAAqB,GAAG2B;IACpC,OAAOC;AACT;AAEA;;;;;;;;;;;;;CAaC,GACD,SAASL,uBACPO,oBAAoC,EACpCxB,SAAoB,EACpByB,OAAsB,EACtBZ,cAAwB,EACxBa,aAA8C,EAC9C,AACA7B,GAAW,EACXC,QAAgB,EAChB6B,QAAmB,EACnB1B,gBAA8B,EAC9BC,kBAA2B,EAC3BC,KANoE,OAMhD,EACpBC,YAAqB,EACrBC,iBAA0B;IAE1B,MAAMuB,UAAU5B,UAAU4B,OAAO;IAEjC,IAAIC;IACJ,IAAIT,YAA2B;IAC/B,IAAIC,YAA2C;IAC/C,IAAIS,iBAA2C;IAE/C,IAAI,OAAOF,YAAY,UAAU;QAC/BC,sBAAsBE,CAAAA,GAAAA,aAAAA,4BAA4B,EAACH;IACrD,OAAO;QACL,+EAA+E;QAC/ER,YAAYQ,OAAO,CAAC,EAAE;QACtBP,YAAYO,OAAO,CAAC,EAAE;QACtBE,iBAAiBF,OAAO,CAAC,EAAE;QAC3BC,sBAAsB;IACxB;IAEA,IAAIG,iBAAiCR;IACrC,IAAIS,cAA6BR;IACjC,IAAIS,qBAA+BrB;IAEnC,IAAIgB,qBAAqB;QACvB,2EAA2E;QAC3E,IAAIT,cAAc,QAAQK,YAAYG,SAAS;YAC7C,wDAAwD;YACxD,qEAAqE;YACrE,gCAAgC;YAChC,IAAIF,kBAAkB,MAAM;gBAC1B,OAAOA;YACT;YACA,OAAOS,CAAAA,GAAAA,OAAAA,mBAAmB,EACxBtC,KACAC,UACA6B,UACA1B,kBACAC,oBACAC,cACAC;QAEJ;QAEA,2DAA2D;QAC3D,IAAIgB,cAAc,QAAQC,cAAc,MAAM;YAC5C,kBAAkB;YAClBW,iBAAiBd,qBACfM,sBACAJ,WACAC;YAGF,+CAA+C;YAC/C,iEAAiE;YACjE,oCAAoC;YACpC,yEAAyE;YACzE,yDAAyD;YACzD,wEAAwE;YACxE,IAAIS,mBAAmB,MAAM;gBAC3B,4DAA4D;gBAC5D,IAAIN,qBAAqBjC,cAAc,KAAK,MAAM;oBAChDiC,qBAAqBjC,cAAc,GAAG,IAAI6C;gBAC5C;gBACA,KAAK,MAAMC,WAAWP,eAAgB;oBACpC,IAAI,CAACN,qBAAqBjC,cAAc,CAAC+C,GAAG,CAACD,UAAU;wBACrDb,qBAAqBjC,cAAc,CAACgD,GAAG,CAACF,SAAS/C;oBACnD;gBACF;YACF;QACF,OAAO;YACL,iBAAiB;YACjB,IAAIkC,qBAAqBjC,cAAc,KAAK,MAAM;gBAChDiC,qBAAqBjC,cAAc,GAAG,IAAI6C;YAC5C;YACA,IAAII,gBAAgBhB,qBAAqBjC,cAAc,CAACkD,GAAG,CAAChB;YAC5D,IAAIe,kBAAkBE,WAAW;gBAC/BF,gBAAgBlD;gBAChBkC,qBAAqBjC,cAAc,CAACgD,GAAG,CAACd,SAAUe;YACpD;YACAR,iBAAiBQ;QACnB;QAEA,2BAA2B;QAC3BP,cAAcpB,eAAeD,MAAM,GAAG,IAAIC,cAAc,CAAC,EAAE,GAAG;QAC9DqB,qBACErB,eAAeD,MAAM,GAAG,IAAIC,eAAeC,KAAK,CAAC,KAAK,EAAE;IAC5D;IACA,0DAA0D;IAC1D,6DAA6D;IAE7D,4EAA4E;IAC5E,uEAAuE;IACvE,yEAAyE;IACzE,8CAA8C;IAC9C,MAAM6B,QAAQ3C,UAAU2C,KAAK;IAC7B,IAAIC,qBAAsD;IAC1D,IAAID,UAAU,MAAM;QAClB,IAAK,MAAME,oBAAoBF,MAAO;YACpC,MAAMG,iBAAiBH,KAAK,CAACE,iBAAiB;YAC9C,iEAAiE;YACjE,wEAAwE;YACxE,2CAA2C;YAC3C,IAAIC,eAAeC,YAAY,KAAK,MAAM;gBACxC;YACF;YACA,MAAMC,SAAS/B,uBACbe,gBACAc,gBACAb,aACAC,oBACAR,eACA7B,KACAC,UACA6B,UACA1B,kBACAC,oBACAC,cACAC,cACAC;YAEF,qEAAqE;YACrE,sDAAsD;YACtDuC,qBAAqBI;QACvB;QACA,IAAIJ,uBAAuB,MAAM;YAC/B,OAAOA;QACT;QACA,2EAA2E;QAC3E,mDAAmD;QACnD,IAAIlB,kBAAkB,MAAM;YAC1B,OAAOA;QACT;QACA,OAAOS,CAAAA,GAAAA,OAAAA,mBAAmB,EACxBtC,KACAC,UACA6B,UACA1B,kBACAC,oBACAC,cACAC;IAEJ;IAEA,uEAAuE;IACvE,qEAAqE;IACrE,IAAI4B,eAAerC,OAAO,KAAK,MAAM;QACnC,kEAAkE;QAClE,IAAIU,mBAAmB;YACrB2B,eAAerC,OAAO,CAACU,iBAAiB,GAAG;QAC7C;QACA,OAAO2B,eAAerC,OAAO;IAC/B;IAEA,0BAA0B;IAC1B,IAAIsD;IACJ,IAAIvB,kBAAkB,MAAM;QAC1B,uEAAuE;QACvE,mBAAmB;QACnBuB,QAAQvB;IACV,OAAO;QACL,2DAA2D;QAC3DuB,QAAQd,CAAAA,GAAAA,OAAAA,mBAAmB,EACzBtC,KACAC,UACA6B,UACA1B,kBACAC,oBACAC,cACAC;IAEJ;IAEA,IAAIC,mBAAmB;QACrB4C,MAAM5C,iBAAiB,GAAG;IAC5B;IAEA,mBAAmB;IACnB2B,eAAerC,OAAO,GAAGsD;IACzB,OAAOA;AACT;AAQO,SAAS7D,gBACdU,QAAgB,EAChBoD,MAAwB;IAExB,MAAM3C,gBAAgBT,SAASU,KAAK,CAAC,KAAKC,MAAM,CAAC,CAACC,IAAMA,MAAM;IAC9D,MAAMyC,iBAAiC,IAAIf;IAC3C,MAAMgB,QAAQC,oBACZzD,oBACAW,eACA,GACA4C;IAGF,IAAIC,UAAU,MAAM;QAClB,OAAO;IACT;IAEA,MAAME,cAAcF,MAAMjC,IAAI;IAC9B,MAAMxB,UAAUyD,MAAMzD,OAAO;IAE7B,6EAA6E;IAC7E,qEAAqE;IACrE,IAAIA,QAAQO,kBAAkB,EAAE;QAC9B,OAAO;IACT;IAEA,2EAA2E;IAC3E,sEAAsE;IACtE,uEAAuE;IACvE,MAAMqD,MAAwB;QAAEtD,kBAAkB;IAAK;IACvD,MAAMuD,cAAcC,eAClB9D,QAAQW,IAAI,EACZ6C,gBACAD,QACA,MACAK;IAGF,wEAAwE;IACxE,2EAA2E;IAC3E,2BAA2B;IAC3B,MAAMtD,mBAAmBsD,IAAItD,gBAAgB;IAC7C,IAAIA,qBAAqB,MAAM;QAC7B,sDAAsD;QACtD,OAAO;IACT;IACA,MAAMyD,kBAAkBC,CAAAA,GAAAA,OAAAA,uBAAuB,EAAC1D;IAEhD,wEAAwE;IACxE,EAAE;IACF,yEAAyE;IACzE,wEAAwE;IACxE,yEAAyE;IACzE,yEAAyE;IACzE,wEAAwE;IACxE,MAAM2D,iBAA2C;QAC/CzD,cAAcL,WAAWoD;QACzBW,QAAQC,OAAAA,WAAW,CAACC,SAAS;QAC7BC,cAAc;QACd1D,MAAMkD;QACNS,UAAUP;QACVxD,oBAAoBP,QAAQO,kBAAkB;QAC9CE,cAAcT,QAAQS,YAAY;QAClCC,mBAAmB;QACnB6D,gBAAgBhB;QAChBiB,KAAK;QACLC,MAAMzE,QAAQyE,IAAI;QAClBC,SAAS1E,QAAQ0E,OAAO;QACxBC,SAAS3E,QAAQ2E,OAAO;IAC1B;IAEAhB,YAAY3D,OAAO,GAAGiE;IAEtB,OAAOA;AACT;AAYA;;;;;;;;;;CAUC,GACD,SAASP,oBACPlC,IAAoB,EACpBZ,aAAuB,EACvBgE,SAAiB,EACjBpB,cAA8B;IAE9B,MAAM1B,UACJ8C,YAAYhE,cAAcK,MAAM,GAAGL,aAAa,CAACgE,UAAU,GAAG;IAEhE,4EAA4E;IAC5E,oEAAoE;IACpE,6EAA6E;IAC7E,kEAAkE;IAClE,0EAA0E;IAC1E,uDAAuD;IACvD,IAAIpD,KAAK5B,cAAc,KAAK,MAAM;QAChC,oEAAoE;QACpE,IAAIkC,YAAY,MAAM;YACpB,MAAM9B,UAAUwB,KAAKxB,OAAO;YAC5B,IAAIA,YAAY,QAAQ,CAACA,QAAQU,iBAAiB,EAAE;gBAClD,OAAO;oBAAEc;oBAAMxB;gBAAQ;YACzB;QACF;QACA,OAAO;IACT;IAEA,0EAA0E;IAC1E,kDAAkD;IAClD,IAAI8B,YAAY,MAAM;QACpB,MAAM+C,cAAcrD,KAAK5B,cAAc,CAACkD,GAAG,CAAChB;QAC5C,IAAI+C,gBAAgB9B,WAAW;YAC7B,yEAAyE;YACzE,uEAAuE;YACvE,sEAAsE;YACtE,oDAAoD;YACpD,IACE8B,YAAY7E,OAAO,KAAK,QACxB6E,YAAYhF,YAAY,KAAK,QAC7BgF,YAAYjF,cAAc,KAAK,MAC/B;gBACA,6CAA6C;gBAC7C,OAAO;YACT;YACA,MAAM6D,QAAQC,oBACZmB,aACAjE,eACAgE,YAAY,GACZpB;YAEF,IAAIC,UAAU,MAAM;gBAClB,OAAOA;YACT;QACA,4DAA4D;QAC5D,+BAA+B;QACjC;IACF;IAEA,oBAAoB;IACpB,IAAIjC,KAAK3B,YAAY,KAAK,MAAM;QAC9B,MAAMiF,cAActD,KAAK3B,YAAY;QACrC,MAAM4B,YAAYD,KAAK1B,qBAAqB;QAC5C,MAAM4B,YAAYF,KAAKzB,qBAAqB;QAC5C,MAAMgF,iBAAiBD,YAAY9E,OAAO;QAE1C,OAAQ0B;YACN,KAAK;gBACH,uDAAuD;gBACvD,IACEqD,mBAAmB,QACnB,CAACA,eAAerE,iBAAiB,IACjCoB,YAAY,MACZ;oBACA0B,eAAeZ,GAAG,CAACnB,WAAWb,cAAcO,KAAK,CAACyD;oBAClD,OAAO;wBAAEpD,MAAMsD;wBAAa9E,SAAS+E;oBAAe;gBACtD;gBACA;YACF,KAAK;gBACH,yDAAyD;gBACzD,IAAIA,mBAAmB,QAAQ,CAACA,eAAerE,iBAAiB,EAAE;oBAChE,IAAIoB,YAAY,MAAM;wBACpB0B,eAAeZ,GAAG,CAACnB,WAAWb,cAAcO,KAAK,CAACyD;wBAClD,OAAO;4BAAEpD,MAAMsD;4BAAa9E,SAAS+E;wBAAe;oBACtD;oBACA,oEAAoE;oBACpE,4DAA4D;oBAC5D,IAAIvD,KAAKxB,OAAO,KAAK,QAAQwB,KAAKxB,OAAO,CAACU,iBAAiB,EAAE;wBAC3D8C,eAAeZ,GAAG,CAACnB,WAAW,EAAE;wBAChC,OAAO;4BAAED,MAAMsD;4BAAa9E,SAAS+E;wBAAe;oBACtD;gBACF;gBACA;YACF,KAAK;gBACH,wDAAwD;gBACxD,+DAA+D;gBAC/D,+CAA+C;gBAC/C,IAAIjD,YAAY,MAAM;oBACpB0B,eAAeZ,GAAG,CAACnB,WAAWK;oBAC9B,OAAO4B,oBACLoB,aACAlE,eACAgE,YAAY,GACZpB;gBAEJ;gBACA;YACF,qEAAqE;YACrE,mEAAmE;YACnE,yDAAyD;YACzD,KAAK;YACL,KAAK;YACL,KAAK;YACL,KAAK;YACL,KAAK;YACL,KAAK;YACL,KAAK;YACL,KAAK;gBACH,OAAO;YACT;gBACE9B;QACJ;IACF;IAEA,2EAA2E;IAC3E,oDAAoD;IACpD,IAAII,YAAY,MAAM;QACpB,MAAM9B,UAAUwB,KAAKxB,OAAO;QAC5B,IAAIA,YAAY,QAAQ,CAACA,QAAQU,iBAAiB,EAAE;YAClD,OAAO;gBAAEc;gBAAMxB;YAAQ;QACzB;IACF;IAEA,OAAO;AACT;AAWA;;;;;;;;;;CAUC,GACD,SAAS8D,eACP9D,OAAkB,EAClBwD,cAA8B,EAC9BD,MAAwB,EACxByB,qBAAoD,EACpDpB,GAAqB;IAErB,MAAMqB,kBAAkBjF,QAAQiC,OAAO;IAEvC,IAAIiD,aAAaD;IACjB,IAAIE;IAEJ,IAAI,OAAOF,oBAAoB,UAAU;QACvC,yEAAyE;QACzE,MAAMxD,YAAYwD,eAAe,CAAC,EAAE;QACpC,MAAMvD,YAAYuD,eAAe,CAAC,EAAE;QACpC,MAAM9C,iBAAiB8C,eAAe,CAAC,EAAE;QACzC,MAAMG,WAAW5B,eAAeV,GAAG,CAACrB;QACpC,IAAI2D,aAAarC,WAAW;YAC1B,MAAMsC,cAAcC,MAAMC,OAAO,CAACH,YAC9BA,SAASI,IAAI,CAAC,OACdJ;YACJF,aAAa;gBAACzD;gBAAW4D;gBAAa3D;gBAAWS;aAAe;YAChEgD,kBAAkBM,CAAAA,GAAAA,UAAAA,oBAAoB,EACpCT,uBACAK,aACA5D;QAEJ,OAAO;YACL,wEAAwE;YACxE,sDAAsD;YACtD0D,kBAAkBH;QACpB;IACF,OAAO;QACL,wDAAwD;QACxDG,kBAAkBH;IACpB;IAEA,sEAAsE;IACtE,IAAIU,WAA6C;IACjD,IAAI1F,QAAQgD,KAAK,KAAK,MAAM;QAC1B0C,WAAW,CAAC;QACZ,IAAK,MAAMC,OAAO3F,QAAQgD,KAAK,CAAE;YAC/B0C,QAAQ,CAACC,IAAI,GAAG7B,eACd9D,QAAQgD,KAAK,CAAC2C,IAAI,EAClBnC,gBACAD,QACA4B,iBACAvB;QAEJ;IACF;IAEA,IAAI5D,QAAQ4F,MAAM,EAAE;QAClB,4CAA4C;QAC5C,MAAMC,cAAcC,CAAAA,GAAAA,UAAAA,oBAAoB,EACtC9F,QAAQ+F,UAAU,EAClBxC,QACA4B;QAEF,2EAA2E;QAC3E,IAAIvB,IAAItD,gBAAgB,KAAK,MAAM;YACjCsD,IAAItD,gBAAgB,GAAG0F,CAAAA,GAAAA,UAAAA,wBAAwB,EAC7ChG,QAAQ+F,UAAU,EAClBxC,QACA4B;QAEJ;QACA,OAAO;YACLY,YAAY/F,QAAQ+F,UAAU;YAC9B9D,SAASiD;YACT9B,cAAcpD,QAAQoD,YAAY;YAClCJ,OAAO0C;YACPO,cAAcjG,QAAQiG,YAAY;YAClCC,oBAAoBlG,QAAQkG,kBAAkB;YAC9CC,oBAAoBnG,QAAQmG,kBAAkB;YAC9CP,QAAQ;YACRQ,UAAUP;QACZ;IACF,OAAO;QACL,iDAAiD;QACjD,MAAMA,cAAcQ,CAAAA,GAAAA,UAAAA,sBAAsB,EACxCrG,QAAQ+F,UAAU,EAClBZ;QAEF,OAAO;YACLY,YAAY/F,QAAQ+F,UAAU;YAC9B9D,SAASiD;YACT9B,cAAcpD,QAAQoD,YAAY;YAClCJ,OAAO0C;YACPO,cAAcjG,QAAQiG,YAAY;YAClCC,oBAAoBlG,QAAQkG,kBAAkB;YAC9CC,oBAAoBnG,QAAQmG,kBAAkB;YAC9CP,QAAQ;YACRQ,UAAUP;QACZ;IACF;AACF;AAMO,SAASnG;IACdO,qBAAqBN;AACvB","ignoreList":[0]}},
    {"offset": {"line": 5890, "column": 0}, "map": {"version":3,"sources":["file:///D:/AconnectJP/node_modules/next/src/client/components/segment-cache/cache.ts"],"sourcesContent":["import type {\n  TreePrefetch,\n  RootTreePrefetch,\n  SegmentPrefetch,\n} from '../../../server/app-render/collect-segment-data'\nimport type {\n  CacheNodeSeedData,\n  Segment as FlightRouterStateSegment,\n} from '../../../shared/lib/app-router-types'\nimport {\n  readVaryParams,\n  type VaryParams,\n} from '../../../shared/lib/segment-cache/vary-params-decoding'\nimport { HasLoadingBoundary } from '../../../shared/lib/app-router-types'\nimport {\n  NEXT_DID_POSTPONE_HEADER,\n  NEXT_ROUTER_PREFETCH_HEADER,\n  NEXT_ROUTER_SEGMENT_PREFETCH_HEADER,\n  NEXT_ROUTER_STALE_TIME_HEADER,\n  NEXT_ROUTER_STATE_TREE_HEADER,\n  NEXT_URL,\n  RSC_CONTENT_TYPE_HEADER,\n  RSC_HEADER,\n} from '../app-router-headers'\nimport {\n  createFetch,\n  createFromNextReadableStream,\n  type RSCResponse,\n  type RequestHeaders,\n} from '../router-reducer/fetch-server-response'\nimport {\n  pingPrefetchTask,\n  isPrefetchTaskDirty,\n  type PrefetchTask,\n  type PrefetchSubtaskResult,\n} from './scheduler'\nimport {\n  type RouteVaryPath,\n  type SegmentVaryPath,\n  type PartialSegmentVaryPath,\n  getRouteVaryPath,\n  getFulfilledRouteVaryPath,\n  getFulfilledSegmentVaryPath,\n  getSegmentVaryPathForRequest,\n  appendLayoutVaryPath,\n  finalizeLayoutVaryPath,\n  finalizePageVaryPath,\n  clonePageVaryPathWithNewSearchParams,\n  type PageVaryPath,\n  type LayoutVaryPath,\n  finalizeMetadataVaryPath,\n  getPartialPageVaryPath,\n  getPartialLayoutVaryPath,\n  getRenderedSearchFromVaryPath,\n} from './vary-path'\nimport { getAppBuildId } from '../../app-build-id'\nimport { createHrefFromUrl } from '../router-reducer/create-href-from-url'\nimport type {\n  NormalizedPathname,\n  NormalizedSearch,\n  RouteCacheKey,\n} from './cache-key'\nimport { createCacheKey as createPrefetchRequestKey } from './cache-key'\nimport {\n  doesStaticSegmentAppearInURL,\n  getCacheKeyForDynamicParam,\n  getRenderedPathname,\n  getRenderedSearch,\n  parseDynamicParamFromURLPart,\n} from '../../route-params'\nimport {\n  createCacheMap,\n  getFromCacheMap,\n  setInCacheMap,\n  setSizeInCacheMap,\n  deleteFromCacheMap,\n  isValueExpired,\n  type CacheMap,\n  type UnknownMapEntry,\n} from './cache-map'\nimport {\n  appendSegmentRequestKeyPart,\n  convertSegmentPathToStaticExportFilename,\n  createSegmentRequestKeyPart,\n  HEAD_REQUEST_KEY,\n  ROOT_SEGMENT_REQUEST_KEY,\n  type SegmentRequestKey,\n} from '../../../shared/lib/segment-cache/segment-value-encoding'\nimport type {\n  FlightRouterState,\n  NavigationFlightResponse,\n} from '../../../shared/lib/app-router-types'\nimport {\n  normalizeFlightData,\n  prepareFlightRouterStateForRequest,\n} from '../../flight-data-helpers'\nimport {\n  DYNAMIC_STALETIME_MS,\n  STATIC_STALETIME_MS,\n} from '../router-reducer/reducers/navigate-reducer'\nimport { pingVisibleLinks } from '../links'\nimport { PAGE_SEGMENT_KEY } from '../../../shared/lib/segment'\nimport { FetchStrategy } from './types'\nimport { createPromiseWithResolvers } from '../../../shared/lib/promise-with-resolvers'\nimport { readFromBFCacheDuringRegularNavigation } from './bfcache'\nimport { discoverKnownRoute, matchKnownRoute } from './optimistic-routes'\n\n/**\n * Ensures a minimum stale time of 30s to avoid issues where the server sends a too\n * short-lived stale time, which would prevent anything from being prefetched.\n */\nexport function getStaleTimeMs(staleTimeSeconds: number): number {\n  return Math.max(staleTimeSeconds, 30) * 1000\n}\n\n// A note on async/await when working in the prefetch cache:\n//\n// Most async operations in the prefetch cache should *not* use async/await,\n// Instead, spawn a subtask that writes the results to a cache entry, and attach\n// a \"ping\" listener to notify the prefetch queue to try again.\n//\n// The reason is we need to be able to access the segment cache and traverse its\n// data structures synchronously. For example, if there's a synchronous update\n// we can take an immediate snapshot of the cache to produce something we can\n// render. Limiting the use of async/await also makes it easier to avoid race\n// conditions, which is especially important because is cache is mutable.\n//\n// Another reason is that while we're performing async work, it's possible for\n// existing entries to become stale, or for Link prefetches to be removed from\n// the queue. For optimal scheduling, we need to be able to \"cancel\" subtasks\n// that are no longer needed. So, when a segment is received from the server, we\n// restart from the root of the tree that's being prefetched, to confirm all the\n// parent segments are still cached. If the segment is no longer reachable from\n// the root, then it's effectively canceled. This is similar to the design of\n// Rust Futures, or React Suspense.\n\ntype RouteTreeShared = {\n  requestKey: SegmentRequestKey\n  // TODO: Remove the `segment` field, now that it can be reconstructed\n  // from `param`.\n  segment: FlightRouterStateSegment\n  refreshState: RefreshState | null\n  slots: null | {\n    [parallelRouteKey: string]: RouteTree\n  }\n  isRootLayout: boolean\n\n  // If this is a dynamic route, indicates whether there is a loading boundary\n  // somewhere in the tree. If not, we can skip the prefetch for the data,\n  // because we know it would be an empty response. (For a static/PPR route,\n  // this value is disregarded, because in that model `loading.tsx` is treated\n  // like any other Suspense boundary.)\n  hasLoadingBoundary: HasLoadingBoundary\n\n  // Indicates whether this route has a runtime prefetch that we can request.\n  // This is determined by the server; it's not purely a user configuration\n  // because the server may determine that a route is fully static and doesn't\n  // need runtime prefetching regardless of the configuration.\n  hasRuntimePrefetch: boolean\n}\n\nexport type RefreshState = {\n  canonicalUrl: string\n  renderedSearch: NormalizedSearch\n}\n\ntype LayoutRouteTree = RouteTreeShared & {\n  isPage: false\n  varyPath: LayoutVaryPath\n}\n\ntype PageRouteTree = RouteTreeShared & {\n  isPage: true\n  varyPath: PageVaryPath\n}\n\nexport type RouteTree = LayoutRouteTree | PageRouteTree\n\ntype RouteCacheEntryShared = {\n  // This is false only if we're certain the route cannot be intercepted. It's\n  // true in all other cases, including on initialization when we haven't yet\n  // received a response from the server.\n  couldBeIntercepted: boolean\n\n  // Map-related fields.\n  ref: UnknownMapEntry | null\n  size: number\n  staleAt: number\n  version: number\n}\n\n/**\n * Tracks the status of a cache entry as it progresses from no data (Empty),\n * waiting for server data (Pending), and finished (either Fulfilled or\n * Rejected depending on the response from the server.\n */\nexport const enum EntryStatus {\n  Empty = 0,\n  Pending = 1,\n  Fulfilled = 2,\n  Rejected = 3,\n}\n\nexport type PendingRouteCacheEntry = RouteCacheEntryShared & {\n  status: EntryStatus.Empty | EntryStatus.Pending\n  blockedTasks: Set<PrefetchTask> | null\n  canonicalUrl: null\n  renderedSearch: null\n  tree: null\n  metadata: null\n  isPPREnabled: false\n}\n\ntype RejectedRouteCacheEntry = RouteCacheEntryShared & {\n  status: EntryStatus.Rejected\n  blockedTasks: Set<PrefetchTask> | null\n  canonicalUrl: null\n  renderedSearch: null\n  tree: null\n  metadata: null\n  isPPREnabled: boolean\n}\n\nexport type FulfilledRouteCacheEntry = RouteCacheEntryShared & {\n  status: EntryStatus.Fulfilled\n  blockedTasks: null\n  canonicalUrl: string\n  renderedSearch: NormalizedSearch\n  tree: RouteTree\n  metadata: RouteTree\n  isPPREnabled: boolean\n  // When true, this entry should not be used as a template for route\n  // prediction. Set when we discover that the URL was rewritten by middleware\n  // to a different route structure (e.g., /foo was rewritten to /bar). Since\n  // rewrite behavior can vary by param value, we can't safely predict the\n  // route structure for other URLs matching this pattern.\n  hasDynamicRewrite: boolean\n}\n\nexport type RouteCacheEntry =\n  | PendingRouteCacheEntry\n  | FulfilledRouteCacheEntry\n  | RejectedRouteCacheEntry\n\ntype SegmentCacheEntryShared = {\n  fetchStrategy: FetchStrategy\n\n  // Map-related fields.\n  ref: UnknownMapEntry | null\n  size: number\n  staleAt: number\n  version: number\n}\n\nexport type EmptySegmentCacheEntry = SegmentCacheEntryShared & {\n  status: EntryStatus.Empty\n  rsc: null\n  isPartial: true\n  promise: null\n}\n\nexport type PendingSegmentCacheEntry = SegmentCacheEntryShared & {\n  status: EntryStatus.Pending\n  rsc: null\n  isPartial: boolean\n  promise: null | PromiseWithResolvers<FulfilledSegmentCacheEntry | null>\n}\n\ntype RejectedSegmentCacheEntry = SegmentCacheEntryShared & {\n  status: EntryStatus.Rejected\n  rsc: null\n  isPartial: true\n  promise: null\n}\n\nexport type FulfilledSegmentCacheEntry = SegmentCacheEntryShared & {\n  status: EntryStatus.Fulfilled\n  rsc: React.ReactNode | null\n  isPartial: boolean\n  promise: null\n}\n\nexport type SegmentCacheEntry =\n  | EmptySegmentCacheEntry\n  | PendingSegmentCacheEntry\n  | RejectedSegmentCacheEntry\n  | FulfilledSegmentCacheEntry\n\nexport type NonEmptySegmentCacheEntry = Exclude<\n  SegmentCacheEntry,\n  EmptySegmentCacheEntry\n>\n\nconst isOutputExportMode =\n  process.env.NODE_ENV === 'production' &&\n  process.env.__NEXT_CONFIG_OUTPUT === 'export'\n\nconst MetadataOnlyRequestTree: FlightRouterState = [\n  '',\n  {},\n  null,\n  'metadata-only',\n]\n\nlet routeCacheMap: CacheMap<RouteCacheEntry> = createCacheMap()\nlet segmentCacheMap: CacheMap<SegmentCacheEntry> = createCacheMap()\n\n// All invalidation listeners for the whole cache are tracked in single set.\n// Since we don't yet support tag or path-based invalidation, there's no point\n// tracking them any more granularly than this. Once we add granular\n// invalidation, that may change, though generally the model is to just notify\n// the listeners and allow the caller to poll the prefetch cache with a new\n// prefetch task if desired.\nlet invalidationListeners: Set<PrefetchTask> | null = null\n\n// Incrementing counters used to track cache invalidations. Route and segment\n// caches have separate versions so they can be invalidated independently.\n// Invalidation does not eagerly evict anything from the cache; entries are\n// lazily evicted when read.\nlet currentRouteCacheVersion = 0\nlet currentSegmentCacheVersion = 0\n\nexport function getCurrentRouteCacheVersion(): number {\n  return currentRouteCacheVersion\n}\n\nexport function getCurrentSegmentCacheVersion(): number {\n  return currentSegmentCacheVersion\n}\n\n/**\n * Invalidates all prefetch cache entries (both route and segment caches).\n *\n * After invalidation, triggers re-prefetching of visible links and notifies\n * invalidation listeners.\n */\nexport function invalidateEntirePrefetchCache(\n  nextUrl: string | null,\n  tree: FlightRouterState\n): void {\n  currentRouteCacheVersion++\n  currentSegmentCacheVersion++\n\n  pingVisibleLinks(nextUrl, tree)\n  pingInvalidationListeners(nextUrl, tree)\n}\n\n/**\n * Invalidates all route cache entries. Route entries contain the tree structure\n * (which segments exist at a given URL) but not the segment data itself.\n *\n * After invalidation, triggers re-prefetching of visible links and notifies\n * invalidation listeners.\n */\nexport function invalidateRouteCacheEntries(\n  nextUrl: string | null,\n  tree: FlightRouterState\n): void {\n  currentRouteCacheVersion++\n\n  pingVisibleLinks(nextUrl, tree)\n  pingInvalidationListeners(nextUrl, tree)\n}\n\n/**\n * Invalidates all segment cache entries. Segment entries contain the actual\n * RSC data for each segment.\n *\n * After invalidation, triggers re-prefetching of visible links and notifies\n * invalidation listeners.\n */\nexport function invalidateSegmentCacheEntries(\n  nextUrl: string | null,\n  tree: FlightRouterState\n): void {\n  currentSegmentCacheVersion++\n\n  pingVisibleLinks(nextUrl, tree)\n  pingInvalidationListeners(nextUrl, tree)\n}\n\nfunction attachInvalidationListener(task: PrefetchTask): void {\n  // This function is called whenever a prefetch task reads a cache entry. If\n  // the task has an onInvalidate function associated with it  i.e. the one\n  // optionally passed to router.prefetch(onInvalidate)  then we attach that\n  // listener to the every cache entry that the task reads. Then, if an entry\n  // is invalidated, we call the function.\n  if (task.onInvalidate !== null) {\n    if (invalidationListeners === null) {\n      invalidationListeners = new Set([task])\n    } else {\n      invalidationListeners.add(task)\n    }\n  }\n}\n\nfunction notifyInvalidationListener(task: PrefetchTask): void {\n  const onInvalidate = task.onInvalidate\n  if (onInvalidate !== null) {\n    // Clear the callback from the task object to guarantee it's not called more\n    // than once.\n    task.onInvalidate = null\n\n    // This is a user-space function, so we must wrap in try/catch.\n    try {\n      onInvalidate()\n    } catch (error) {\n      if (typeof reportError === 'function') {\n        reportError(error)\n      } else {\n        console.error(error)\n      }\n    }\n  }\n}\n\nexport function pingInvalidationListeners(\n  nextUrl: string | null,\n  tree: FlightRouterState\n): void {\n  // The rough equivalent of pingVisibleLinks, but for onInvalidate callbacks.\n  // This is called when the Next-Url or the base tree changes, since those\n  // may affect the result of a prefetch task. It's also called after a\n  // cache invalidation.\n  if (invalidationListeners !== null) {\n    const tasks = invalidationListeners\n    invalidationListeners = null\n    for (const task of tasks) {\n      if (isPrefetchTaskDirty(task, nextUrl, tree)) {\n        notifyInvalidationListener(task)\n      }\n    }\n  }\n}\n\nexport function readRouteCacheEntry(\n  now: number,\n  key: RouteCacheKey\n): RouteCacheEntry | null {\n  const varyPath: RouteVaryPath = getRouteVaryPath(\n    key.pathname,\n    key.search,\n    key.nextUrl\n  )\n  const isRevalidation = false\n  const existingEntry = getFromCacheMap(\n    now,\n    getCurrentRouteCacheVersion(),\n    routeCacheMap,\n    varyPath,\n    isRevalidation\n  )\n  if (existingEntry !== null) {\n    return existingEntry\n  }\n\n  // No cache hit. Attempt to construct from template using the new\n  // optimistic routing mechanism (pattern-based matching).\n  if (process.env.__NEXT_OPTIMISTIC_ROUTING) {\n    return matchKnownRoute(key.pathname, key.search)\n  }\n\n  return null\n}\n\nexport function readSegmentCacheEntry(\n  now: number,\n  varyPath: SegmentVaryPath\n): SegmentCacheEntry | null {\n  const isRevalidation = false\n  return getFromCacheMap(\n    now,\n    getCurrentSegmentCacheVersion(),\n    segmentCacheMap,\n    varyPath,\n    isRevalidation\n  )\n}\n\nfunction readRevalidatingSegmentCacheEntry(\n  now: number,\n  varyPath: SegmentVaryPath\n): SegmentCacheEntry | null {\n  const isRevalidation = true\n  return getFromCacheMap(\n    now,\n    getCurrentSegmentCacheVersion(),\n    segmentCacheMap,\n    varyPath,\n    isRevalidation\n  )\n}\n\nexport function waitForSegmentCacheEntry(\n  pendingEntry: PendingSegmentCacheEntry\n): Promise<FulfilledSegmentCacheEntry | null> {\n  // Because the entry is pending, there's already a in-progress request.\n  // Attach a promise to the entry that will resolve when the server responds.\n  let promiseWithResolvers = pendingEntry.promise\n  if (promiseWithResolvers === null) {\n    promiseWithResolvers = pendingEntry.promise =\n      createPromiseWithResolvers<FulfilledSegmentCacheEntry | null>()\n  } else {\n    // There's already a promise we can use\n  }\n  return promiseWithResolvers.promise\n}\n\nfunction createDetachedRouteCacheEntry(): PendingRouteCacheEntry {\n  return {\n    canonicalUrl: null,\n    status: EntryStatus.Empty,\n    blockedTasks: null,\n    tree: null,\n    metadata: null,\n    // This is initialized to true because we don't know yet whether the route\n    // could be intercepted. It's only set to false once we receive a response\n    // from the server.\n    couldBeIntercepted: true,\n    // Similarly, we don't yet know if the route supports PPR.\n    isPPREnabled: false,\n    renderedSearch: null,\n\n    // Map-related fields\n    ref: null,\n    size: 0,\n    // Since this is an empty entry, there's no reason to ever evict it. It will\n    // be updated when the data is populated.\n    staleAt: Infinity,\n    version: getCurrentRouteCacheVersion(),\n  }\n}\n\n/**\n * Checks if an entry for a route exists in the cache. If so, it returns the\n * entry, If not, it adds an empty entry to the cache and returns it.\n */\nexport function readOrCreateRouteCacheEntry(\n  now: number,\n  task: PrefetchTask,\n  key: RouteCacheKey\n): RouteCacheEntry {\n  attachInvalidationListener(task)\n\n  const existingEntry = readRouteCacheEntry(now, key)\n  if (existingEntry !== null) {\n    return existingEntry\n  }\n  // Create a pending entry and add it to the cache.\n  const pendingEntry = createDetachedRouteCacheEntry()\n  const varyPath: RouteVaryPath = getRouteVaryPath(\n    key.pathname,\n    key.search,\n    key.nextUrl\n  )\n  const isRevalidation = false\n  setInCacheMap(routeCacheMap, varyPath, pendingEntry, isRevalidation)\n  return pendingEntry\n}\n\n// TODO: This function predates the new optimisticRouting feature and will be\n// removed once optimisticRouting is stable. The new mechanism (matchKnownRoute)\n// handles search param variations more robustly as part of the general route\n// prediction system. This fallback remains for when optimisticRouting is\n// disabled (staticChildren is null).\nexport function deprecated_requestOptimisticRouteCacheEntry(\n  now: number,\n  requestedUrl: URL,\n  nextUrl: string | null\n): FulfilledRouteCacheEntry | null {\n  // This function is called during a navigation when there was no matching\n  // route tree in the prefetch cache. Before de-opting to a blocking,\n  // unprefetched navigation, we will first attempt to construct an \"optimistic\"\n  // route tree by checking the cache for similar routes.\n  //\n  // Check if there's a route with the same pathname, but with different\n  // search params. We can then base our optimistic route tree on this entry.\n  //\n  // Conceptually, we are simulating what would happen if we did perform a\n  // prefetch the requested URL, under the assumption that the server will\n  // not redirect or rewrite the request in a different manner than the\n  // base route tree. This assumption might not hold, in which case we'll have\n  // to recover when we perform the dynamic navigation request. However, this\n  // is what would happen if a route were dynamically rewritten/redirected\n  // in between the prefetch and the navigation. So the logic needs to exist\n  // to handle this case regardless.\n\n  // Look for a route with the same pathname, but with an empty search string.\n  // TODO: There's nothing inherently special about the empty search string;\n  // it's chosen somewhat arbitrarily, with the rationale that it's the most\n  // likely one to exist. But we should update this to match _any_ search\n  // string. The plan is to generalize this logic alongside other improvements\n  // related to \"fallback\" cache entries.\n  const requestedSearch = requestedUrl.search as NormalizedSearch\n  if (requestedSearch === '') {\n    // The caller would have already checked if a route with an empty search\n    // string is in the cache. So we can bail out here.\n    return null\n  }\n  const urlWithoutSearchParams = new URL(requestedUrl)\n  urlWithoutSearchParams.search = ''\n  const routeWithNoSearchParams = readRouteCacheEntry(\n    now,\n    createPrefetchRequestKey(urlWithoutSearchParams.href, nextUrl)\n  )\n\n  if (\n    routeWithNoSearchParams === null ||\n    routeWithNoSearchParams.status !== EntryStatus.Fulfilled\n  ) {\n    // Bail out of constructing an optimistic route tree. This will result in\n    // a blocking, unprefetched navigation.\n    return null\n  }\n\n  // Now we have a base route tree we can \"patch\" with our optimistic values.\n\n  // Optimistically assume that redirects for the requested pathname do\n  // not vary on the search string. Therefore, if the base route was\n  // redirected to a different search string, then the optimistic route\n  // should be redirected to the same search string. Otherwise, we use\n  // the requested search string.\n  const canonicalUrlForRouteWithNoSearchParams = new URL(\n    routeWithNoSearchParams.canonicalUrl,\n    requestedUrl.origin\n  )\n  const optimisticCanonicalSearch =\n    canonicalUrlForRouteWithNoSearchParams.search !== ''\n      ? // Base route was redirected. Reuse the same redirected search string.\n        canonicalUrlForRouteWithNoSearchParams.search\n      : requestedSearch\n\n  // Similarly, optimistically assume that rewrites for the requested\n  // pathname do not vary on the search string. Therefore, if the base\n  // route was rewritten to a different search string, then the optimistic\n  // route should be rewritten to the same search string. Otherwise, we use\n  // the requested search string.\n  const optimisticRenderedSearch =\n    routeWithNoSearchParams.renderedSearch !== ''\n      ? // Base route was rewritten. Reuse the same rewritten search string.\n        routeWithNoSearchParams.renderedSearch\n      : requestedSearch\n\n  const optimisticUrl = new URL(\n    routeWithNoSearchParams.canonicalUrl,\n    location.origin\n  )\n  optimisticUrl.search = optimisticCanonicalSearch\n  const optimisticCanonicalUrl = createHrefFromUrl(optimisticUrl)\n\n  const optimisticRouteTree = deprecated_createOptimisticRouteTree(\n    routeWithNoSearchParams.tree,\n    optimisticRenderedSearch\n  )\n  const optimisticMetadataTree = deprecated_createOptimisticRouteTree(\n    routeWithNoSearchParams.metadata,\n    optimisticRenderedSearch\n  )\n\n  // Clone the base route tree, and override the relevant fields with our\n  // optimistic values.\n  const optimisticEntry: FulfilledRouteCacheEntry = {\n    canonicalUrl: optimisticCanonicalUrl,\n\n    status: EntryStatus.Fulfilled,\n    // This isn't cloned because it's instance-specific\n    blockedTasks: null,\n    tree: optimisticRouteTree,\n    metadata: optimisticMetadataTree,\n    couldBeIntercepted: routeWithNoSearchParams.couldBeIntercepted,\n    isPPREnabled: routeWithNoSearchParams.isPPREnabled,\n    hasDynamicRewrite: routeWithNoSearchParams.hasDynamicRewrite,\n\n    // Override the rendered search with the optimistic value.\n    renderedSearch: optimisticRenderedSearch,\n\n    // Map-related fields\n    ref: null,\n    size: 0,\n    staleAt: routeWithNoSearchParams.staleAt,\n    version: routeWithNoSearchParams.version,\n  }\n\n  // Do not insert this entry into the cache. It only exists so we can\n  // perform the current navigation. Just return it to the caller.\n  return optimisticEntry\n}\n\nfunction deprecated_createOptimisticRouteTree(\n  tree: RouteTree,\n  newRenderedSearch: NormalizedSearch\n): RouteTree {\n  // Create a new route tree that identical to the original one except for\n  // the rendered search string, which is contained in the vary path.\n\n  let clonedSlots: Record<string, RouteTree> | null = null\n  const originalSlots = tree.slots\n  if (originalSlots !== null) {\n    clonedSlots = {}\n    for (const parallelRouteKey in originalSlots) {\n      const childTree = originalSlots[parallelRouteKey]\n      clonedSlots[parallelRouteKey] = deprecated_createOptimisticRouteTree(\n        childTree,\n        newRenderedSearch\n      )\n    }\n  }\n\n  // We only need to clone the vary path if the route is a page.\n  if (tree.isPage) {\n    return {\n      requestKey: tree.requestKey,\n      segment: tree.segment,\n      refreshState: tree.refreshState,\n      varyPath: clonePageVaryPathWithNewSearchParams(\n        tree.varyPath,\n        newRenderedSearch\n      ),\n      isPage: true,\n      slots: clonedSlots,\n      isRootLayout: tree.isRootLayout,\n      hasLoadingBoundary: tree.hasLoadingBoundary,\n      hasRuntimePrefetch: tree.hasRuntimePrefetch,\n    }\n  }\n\n  return {\n    requestKey: tree.requestKey,\n    segment: tree.segment,\n    refreshState: tree.refreshState,\n    varyPath: tree.varyPath,\n    isPage: false,\n    slots: clonedSlots,\n    isRootLayout: tree.isRootLayout,\n    hasLoadingBoundary: tree.hasLoadingBoundary,\n    hasRuntimePrefetch: tree.hasRuntimePrefetch,\n  }\n}\n\n/**\n * Checks if an entry for a segment exists in the cache. If so, it returns the\n * entry, If not, it adds an empty entry to the cache and returns it.\n */\nexport function readOrCreateSegmentCacheEntry(\n  now: number,\n  fetchStrategy: FetchStrategy,\n  tree: RouteTree\n): SegmentCacheEntry {\n  const existingEntry = readSegmentCacheEntry(now, tree.varyPath)\n  if (existingEntry !== null) {\n    return existingEntry\n  }\n  // Create a pending entry and add it to the cache. The stale time is set to a\n  // default value; the actual stale time will be set when the entry is\n  // fulfilled with data from the server response.\n  const varyPathForRequest = getSegmentVaryPathForRequest(fetchStrategy, tree)\n  const pendingEntry = createDetachedSegmentCacheEntry(now)\n  const isRevalidation = false\n  setInCacheMap(\n    segmentCacheMap,\n    varyPathForRequest,\n    pendingEntry,\n    isRevalidation\n  )\n  return pendingEntry\n}\n\nexport function readOrCreateRevalidatingSegmentEntry(\n  now: number,\n  fetchStrategy: FetchStrategy,\n  tree: RouteTree\n): SegmentCacheEntry {\n  // This function is called when we've already confirmed that a particular\n  // segment is cached, but we want to perform another request anyway in case it\n  // returns more complete and/or fresher data than we already have. The logic\n  // for deciding whether to replace the existing entry is handled elsewhere;\n  // this function just handles retrieving a cache entry that we can use to\n  // track the revalidation.\n  //\n  // The reason revalidations are stored in the cache is because we need to be\n  // able to dedupe multiple revalidation requests. The reason they have to be\n  // handled specially is because we shouldn't overwrite a \"normal\" entry if\n  // one exists at the same keypath. So, for each internal cache location, there\n  // is a special \"revalidation\" slot that is used solely for this purpose.\n  //\n  // You can think of it as if all the revalidation entries were stored in a\n  // separate cache map from the canonical entries, and then transfered to the\n  // canonical cache map once the request is complete  this isn't how it's\n  // actually implemented, since it's more efficient to store them in the same\n  // data structure as the normal entries, but that's how it's modeled\n  // conceptually.\n\n  // TODO: Once we implement Fallback behavior for params, where an entry is\n  // re-keyed based on response information, we'll need to account for the\n  // possibility that the keypath of the previous entry is more generic than\n  // the keypath of the revalidating entry. In other words, the server could\n  // return a less generic entry upon revalidation. For now, though, this isn't\n  // a concern because the keypath is based solely on the prefetch strategy,\n  // not on data contained in the response.\n  const existingEntry = readRevalidatingSegmentCacheEntry(now, tree.varyPath)\n  if (existingEntry !== null) {\n    return existingEntry\n  }\n  // Create a pending entry and add it to the cache. The stale time is set to a\n  // default value; the actual stale time will be set when the entry is\n  // fulfilled with data from the server response.\n  const varyPathForRequest = getSegmentVaryPathForRequest(fetchStrategy, tree)\n  const pendingEntry = createDetachedSegmentCacheEntry(now)\n  const isRevalidation = true\n  setInCacheMap(\n    segmentCacheMap,\n    varyPathForRequest,\n    pendingEntry,\n    isRevalidation\n  )\n  return pendingEntry\n}\n\nexport function overwriteRevalidatingSegmentCacheEntry(\n  now: number,\n  fetchStrategy: FetchStrategy,\n  tree: RouteTree\n) {\n  // This function is called when we've already decided to replace an existing\n  // revalidation entry. Create a new entry and write it into the cache,\n  // overwriting the previous value. The stale time is set to a default value;\n  // the actual stale time will be set when the entry is fulfilled with data\n  // from the server response.\n  const varyPathForRequest = getSegmentVaryPathForRequest(fetchStrategy, tree)\n  const pendingEntry = createDetachedSegmentCacheEntry(now)\n  const isRevalidation = true\n  setInCacheMap(\n    segmentCacheMap,\n    varyPathForRequest,\n    pendingEntry,\n    isRevalidation\n  )\n  return pendingEntry\n}\n\nexport function upsertSegmentEntry(\n  now: number,\n  varyPath: SegmentVaryPath,\n  candidateEntry: SegmentCacheEntry\n): SegmentCacheEntry | null {\n  // We have a new entry that has not yet been inserted into the cache. Before\n  // we do so, we need to confirm whether it takes precedence over the existing\n  // entry (if one exists).\n  // TODO: We should not upsert an entry if its key was invalidated in the time\n  // since the request was made. We can do that by passing the \"owner\" entry to\n  // this function and confirming it's the same as `existingEntry`.\n\n  if (isValueExpired(now, getCurrentSegmentCacheVersion(), candidateEntry)) {\n    // The entry is expired. We cannot upsert it.\n    return null\n  }\n\n  const existingEntry = readSegmentCacheEntry(now, varyPath)\n  if (existingEntry !== null) {\n    // Don't replace a more specific segment with a less-specific one. A case where this\n    // might happen is if the existing segment was fetched via\n    // `<Link prefetch={true}>`.\n    if (\n      // We fetched the new segment using a different, less specific fetch strategy\n      // than the segment we already have in the cache, so it can't have more content.\n      (candidateEntry.fetchStrategy !== existingEntry.fetchStrategy &&\n        !canNewFetchStrategyProvideMoreContent(\n          existingEntry.fetchStrategy,\n          candidateEntry.fetchStrategy\n        )) ||\n      // The existing entry isn't partial, but the new one is.\n      // (TODO: can this be true if `candidateEntry.fetchStrategy >= existingEntry.fetchStrategy`?)\n      (!existingEntry.isPartial && candidateEntry.isPartial)\n    ) {\n      // We're going to leave revalidating entry in the cache so that it doesn't\n      // get revalidated again unnecessarily. Downgrade the Fulfilled entry to\n      // Rejected and null out the data so it can be garbage collected. We leave\n      // `staleAt` intact to prevent subsequent revalidation attempts only until\n      // the entry expires.\n      const rejectedEntry: RejectedSegmentCacheEntry = candidateEntry as any\n      rejectedEntry.status = EntryStatus.Rejected\n      rejectedEntry.rsc = null\n      return null\n    }\n\n    // Evict the existing entry from the cache.\n    deleteFromCacheMap(existingEntry)\n  }\n\n  const isRevalidation = false\n  setInCacheMap(segmentCacheMap, varyPath, candidateEntry, isRevalidation)\n  return candidateEntry\n}\n\nexport function createDetachedSegmentCacheEntry(\n  now: number\n): EmptySegmentCacheEntry {\n  // Default stale time for pending segment cache entries. The actual stale time\n  // is set when the entry is fulfilled with data from the server response.\n  const staleAt = now + 30 * 1000\n  const emptyEntry: EmptySegmentCacheEntry = {\n    status: EntryStatus.Empty,\n    // Default to assuming the fetch strategy will be PPR. This will be updated\n    // when a fetch is actually initiated.\n    fetchStrategy: FetchStrategy.PPR,\n    rsc: null,\n    isPartial: true,\n    promise: null,\n\n    // Map-related fields\n    ref: null,\n    size: 0,\n    staleAt,\n    version: 0,\n  }\n  return emptyEntry\n}\n\nexport function upgradeToPendingSegment(\n  emptyEntry: EmptySegmentCacheEntry,\n  fetchStrategy: FetchStrategy\n): PendingSegmentCacheEntry {\n  const pendingEntry: PendingSegmentCacheEntry = emptyEntry as any\n  pendingEntry.status = EntryStatus.Pending\n  pendingEntry.fetchStrategy = fetchStrategy\n\n  if (fetchStrategy === FetchStrategy.Full) {\n    // We can assume the response will contain the full segment data. Set this\n    // to false so we know it's OK to omit this segment from any navigation\n    // requests that may happen while the data is still pending.\n    pendingEntry.isPartial = false\n  }\n\n  // Set the version here, since this is right before the request is initiated.\n  // The next time the segment cache version is incremented, the entry will\n  // effectively be evicted. This happens before initiating the request, rather\n  // than when receiving the response, because it's guaranteed to happen\n  // before the data is read on the server.\n  pendingEntry.version = getCurrentSegmentCacheVersion()\n  return pendingEntry\n}\n\nexport function attemptToFulfillDynamicSegmentFromBFCache(\n  now: number,\n  segment: EmptySegmentCacheEntry,\n  tree: RouteTree\n): FulfilledSegmentCacheEntry | null {\n  // Attempts to fulfill an empty segment cache entry using data from the\n  // bfcache. This is only valid during a Full prefetch (i.e. one that includes\n  // dynamic data), because the bfcache stores data from navigations which\n  // always include dynamic data.\n\n  // We always use the canonical vary path when checking the bfcache. This is\n  // the same operation we'd use to access the cache during a\n  // regular navigation.\n  const varyPath = tree.varyPath\n\n  // The stale time for dynamic prefetches (default: 5 mins) is different from\n  // the stale time for regular navigations (default: 0 secs). We adjust the\n  // current timestamp to account for the difference.\n  const adjustedCurrentTime = now - STATIC_STALETIME_MS + DYNAMIC_STALETIME_MS\n  const bfcacheEntry = readFromBFCacheDuringRegularNavigation(\n    adjustedCurrentTime,\n    varyPath\n  )\n  if (bfcacheEntry !== null) {\n    // Fulfill the prefetch using the bfcache entry.\n\n    // As explained above, the stale time of this prefetch entry is different\n    // than the one for the bfcache. Calculate when it was originally requested\n    // by subtracting the stale time used by the bfcache.\n    const requestedAt = bfcacheEntry.staleAt - DYNAMIC_STALETIME_MS\n    // Now add the stale time used by dynamic prefetches.\n    const dynamicPrefetchStaleAt = requestedAt + STATIC_STALETIME_MS\n\n    const pendingSegment = upgradeToPendingSegment(segment, FetchStrategy.Full)\n    const isPartial = false\n    return fulfillSegmentCacheEntry(\n      pendingSegment,\n      bfcacheEntry.rsc,\n      dynamicPrefetchStaleAt,\n      isPartial\n    )\n  }\n  return null\n}\n\nfunction pingBlockedTasks(entry: {\n  blockedTasks: Set<PrefetchTask> | null\n}): void {\n  const blockedTasks = entry.blockedTasks\n  if (blockedTasks !== null) {\n    for (const task of blockedTasks) {\n      pingPrefetchTask(task)\n    }\n    entry.blockedTasks = null\n  }\n}\n\nexport function createMetadataRouteTree(\n  metadataVaryPath: PageVaryPath\n): RouteTree {\n  // The Head is not actually part of the route tree, but other than that, it's\n  // fetched and cached like a segment. Some functions expect a RouteTree\n  // object, so rather than fork the logic in all those places, we use this\n  // \"fake\" one.\n  const metadata: RouteTree = {\n    requestKey: HEAD_REQUEST_KEY,\n    segment: HEAD_REQUEST_KEY,\n    refreshState: null,\n    varyPath: metadataVaryPath,\n    // The metadata isn't really a \"page\" (though it isn't really a \"segment\"\n    // either) but for the purposes of how this field is used, it behaves like\n    // one. If this logic ever gets more complex we can change this to an enum.\n    isPage: true,\n    slots: null,\n    isRootLayout: false,\n    hasLoadingBoundary: HasLoadingBoundary.SubtreeHasNoLoadingBoundary,\n    hasRuntimePrefetch: false,\n  }\n  return metadata\n}\n\nexport function fulfillRouteCacheEntry(\n  now: number,\n  entry: PendingRouteCacheEntry,\n  tree: RouteTree,\n  metadataVaryPath: PageVaryPath,\n  couldBeIntercepted: boolean,\n  canonicalUrl: string,\n  isPPREnabled: boolean\n): FulfilledRouteCacheEntry {\n  // Get the rendered search from the vary path\n  const renderedSearch =\n    getRenderedSearchFromVaryPath(metadataVaryPath) ?? ('' as NormalizedSearch)\n  const fulfilledEntry: FulfilledRouteCacheEntry = entry as any\n  fulfilledEntry.status = EntryStatus.Fulfilled\n  fulfilledEntry.tree = tree\n  fulfilledEntry.metadata = createMetadataRouteTree(metadataVaryPath)\n  // Route structure is essentially static  it only changes on deploy.\n  // Always use the static stale time.\n  // NOTE: An exception is rewrites/redirects in middleware or proxy, which can\n  // change routes dynamically. We have other strategies for handling those.\n  fulfilledEntry.staleAt = now + STATIC_STALETIME_MS\n  fulfilledEntry.couldBeIntercepted = couldBeIntercepted\n  fulfilledEntry.canonicalUrl = canonicalUrl\n  fulfilledEntry.renderedSearch = renderedSearch\n  fulfilledEntry.isPPREnabled = isPPREnabled\n  fulfilledEntry.hasDynamicRewrite = false\n  pingBlockedTasks(entry)\n  return fulfilledEntry\n}\n\nexport function writeRouteIntoCache(\n  now: number,\n  pathname: NormalizedPathname,\n  tree: RouteTree,\n  metadataVaryPath: PageVaryPath,\n  couldBeIntercepted: boolean,\n  canonicalUrl: string,\n  isPPREnabled: boolean\n): FulfilledRouteCacheEntry {\n  const pendingEntry = createDetachedRouteCacheEntry()\n  const fulfilledEntry = fulfillRouteCacheEntry(\n    now,\n    pendingEntry,\n    tree,\n    metadataVaryPath,\n    couldBeIntercepted,\n    canonicalUrl,\n    isPPREnabled\n  )\n  // nextUrl is always null here because we only write to the route cache for\n  // non-intercepted routes. Intercepted routes are deopted in attemptOptimisticRouting.\n  const renderedSearch = fulfilledEntry.renderedSearch\n  const varyPath = getRouteVaryPath(pathname, renderedSearch, null)\n  const isRevalidation = false\n  setInCacheMap(routeCacheMap, varyPath, fulfilledEntry, isRevalidation)\n  return fulfilledEntry\n}\n\n/**\n * Marks a route cache entry as having a dynamic rewrite. Called when we\n * discover that a route pattern has dynamic rewrite behavior - i.e., we used\n * an optimistic route tree for prediction, but the server responded with a\n * different rendered pathname.\n *\n * Once marked, attempts to use this entry as a template for prediction will\n * bail out to server resolution.\n */\nexport function markRouteEntryAsDynamicRewrite(\n  entry: FulfilledRouteCacheEntry\n): void {\n  entry.hasDynamicRewrite = true\n  // Note: The caller is responsible for also calling invalidateRouteCacheEntries\n  // to invalidate other entries that may have been derived from this template\n  // before we knew it had a dynamic rewrite.\n}\n\nfunction fulfillSegmentCacheEntry(\n  segmentCacheEntry: PendingSegmentCacheEntry,\n  rsc: React.ReactNode,\n  staleAt: number,\n  isPartial: boolean\n): FulfilledSegmentCacheEntry {\n  const fulfilledEntry: FulfilledSegmentCacheEntry = segmentCacheEntry as any\n  fulfilledEntry.status = EntryStatus.Fulfilled\n  fulfilledEntry.rsc = rsc\n  fulfilledEntry.staleAt = staleAt\n  fulfilledEntry.isPartial = isPartial\n  // Resolve any listeners that were waiting for this data.\n  if (segmentCacheEntry.promise !== null) {\n    segmentCacheEntry.promise.resolve(fulfilledEntry)\n    // Free the promise for garbage collection.\n    fulfilledEntry.promise = null\n  }\n  return fulfilledEntry\n}\n\nfunction rejectRouteCacheEntry(\n  entry: PendingRouteCacheEntry,\n  staleAt: number\n): void {\n  const rejectedEntry: RejectedRouteCacheEntry = entry as any\n  rejectedEntry.status = EntryStatus.Rejected\n  rejectedEntry.staleAt = staleAt\n  pingBlockedTasks(entry)\n}\n\nfunction rejectSegmentCacheEntry(\n  entry: PendingSegmentCacheEntry,\n  staleAt: number\n): void {\n  const rejectedEntry: RejectedSegmentCacheEntry = entry as any\n  rejectedEntry.status = EntryStatus.Rejected\n  rejectedEntry.staleAt = staleAt\n  if (entry.promise !== null) {\n    // NOTE: We don't currently propagate the reason the prefetch was canceled\n    // but we could by accepting a `reason` argument.\n    entry.promise.resolve(null)\n    entry.promise = null\n  }\n}\n\ntype RouteTreeAccumulator = {\n  metadataVaryPath: PageVaryPath | null\n}\n\nfunction convertRootTreePrefetchToRouteTree(\n  rootTree: RootTreePrefetch,\n  renderedPathname: string,\n  renderedSearch: NormalizedSearch,\n  acc: RouteTreeAccumulator\n) {\n  // Remove trailing and leading slashes\n  const pathnameParts = renderedPathname.split('/').filter((p) => p !== '')\n  const index = 0\n  const rootSegment = ROOT_SEGMENT_REQUEST_KEY\n  return convertTreePrefetchToRouteTree(\n    rootTree.tree,\n    rootSegment,\n    null,\n    ROOT_SEGMENT_REQUEST_KEY,\n    pathnameParts,\n    index,\n    renderedSearch,\n    acc\n  )\n}\n\nfunction convertTreePrefetchToRouteTree(\n  prefetch: TreePrefetch,\n  segment: FlightRouterStateSegment,\n  partialVaryPath: PartialSegmentVaryPath | null,\n  requestKey: SegmentRequestKey,\n  pathnameParts: Array<string>,\n  pathnamePartsIndex: number,\n  renderedSearch: NormalizedSearch,\n  acc: RouteTreeAccumulator\n): RouteTree {\n  // Converts the route tree sent by the server into the format used by the\n  // cache. The cached version of the tree includes additional fields, such as a\n  // cache key for each segment. Since this is frequently accessed, we compute\n  // it once instead of on every access. This same cache key is also used to\n  // request the segment from the server.\n\n  let slots: { [parallelRouteKey: string]: RouteTree } | null = null\n  let isPage: boolean\n  let varyPath: SegmentVaryPath\n  const prefetchSlots = prefetch.slots\n  if (prefetchSlots !== null) {\n    isPage = false\n    varyPath = finalizeLayoutVaryPath(requestKey, partialVaryPath)\n\n    slots = {}\n    for (let parallelRouteKey in prefetchSlots) {\n      const childPrefetch = prefetchSlots[parallelRouteKey]\n      const childSegmentName = childPrefetch.name\n      const childParam = childPrefetch.param\n\n      let childDoesAppearInURL: boolean\n      let childSegment: FlightRouterStateSegment\n      let childPartialVaryPath: PartialSegmentVaryPath | null\n      if (childParam !== null) {\n        // This segment is parameterized. Get the param from the pathname.\n        const childParamValue = parseDynamicParamFromURLPart(\n          childParam.type,\n          pathnameParts,\n          pathnamePartsIndex\n        )\n\n        // Assign a cache key to the segment, based on the param value. In the\n        // pre-Segment Cache implementation, the server computes this and sends\n        // it in the body of the response. In the Segment Cache implementation,\n        // the server sends an empty string and we fill it in here.\n\n        // TODO: We're intentionally not adding the search param to page\n        // segments here; it's tracked separately and added back during a read.\n        // This would clearer if we waited to construct the segment until it's\n        // read from the cache, since that's effectively what we're\n        // doing anyway.\n        const childParamKey =\n          // The server omits this field from the prefetch response when\n          // cacheComponents is enabled.\n          childParam.key !== null\n            ? childParam.key\n            : // If no param key was sent, use the value parsed on the client.\n              getCacheKeyForDynamicParam(\n                childParamValue,\n                '' as NormalizedSearch\n              )\n\n        childPartialVaryPath = appendLayoutVaryPath(\n          partialVaryPath,\n          childParamKey,\n          childSegmentName\n        )\n        childSegment = [\n          childSegmentName,\n          childParamKey,\n          childParam.type,\n          childParam.siblings,\n        ]\n        childDoesAppearInURL = true\n      } else {\n        // This segment does not have a param. Inherit the partial vary path of\n        // the parent.\n        childPartialVaryPath = partialVaryPath\n        childSegment = childSegmentName\n        childDoesAppearInURL = doesStaticSegmentAppearInURL(childSegmentName)\n      }\n\n      // Only increment the index if the segment appears in the URL. If it's a\n      // \"virtual\" segment, like a route group, it remains the same.\n      const childPathnamePartsIndex = childDoesAppearInURL\n        ? pathnamePartsIndex + 1\n        : pathnamePartsIndex\n\n      const childRequestKeyPart = createSegmentRequestKeyPart(childSegment)\n      const childRequestKey = appendSegmentRequestKeyPart(\n        requestKey,\n        parallelRouteKey,\n        childRequestKeyPart\n      )\n      slots[parallelRouteKey] = convertTreePrefetchToRouteTree(\n        childPrefetch,\n        childSegment,\n        childPartialVaryPath,\n        childRequestKey,\n        pathnameParts,\n        childPathnamePartsIndex,\n        renderedSearch,\n        acc\n      )\n    }\n  } else {\n    if (requestKey.endsWith(PAGE_SEGMENT_KEY)) {\n      // This is a page segment.\n      isPage = true\n      varyPath = finalizePageVaryPath(\n        requestKey,\n        renderedSearch,\n        partialVaryPath\n      )\n      // The metadata \"segment\" is not part the route tree, but it has the same\n      // conceptual params as a page segment. Write the vary path into the\n      // accumulator object. If there are multiple parallel pages, we use the\n      // first one. Which page we choose is arbitrary as long as it's\n      // consistently the same one every time every time. See\n      // finalizeMetadataVaryPath for more details.\n      if (acc.metadataVaryPath === null) {\n        acc.metadataVaryPath = finalizeMetadataVaryPath(\n          requestKey,\n          renderedSearch,\n          partialVaryPath\n        )\n      }\n    } else {\n      // This is a layout segment.\n      isPage = false\n      varyPath = finalizeLayoutVaryPath(requestKey, partialVaryPath)\n    }\n  }\n\n  return {\n    requestKey,\n    segment,\n    refreshState: null,\n    // TODO: Cheating the type system here a bit because TypeScript can't tell\n    // that the type of isPage and varyPath are consistent. The fix would be to\n    // create separate constructors and call the appropriate one from each of\n    // the branches above. Just seems a bit overkill only for one field so I'll\n    // leave it as-is for now. If isPage were wrong it would break the behavior\n    // and we'd catch it quickly, anyway.\n    varyPath: varyPath as any,\n    isPage: isPage as boolean as any,\n    slots,\n    isRootLayout: prefetch.isRootLayout,\n    // This field is only relevant to dynamic routes. For a PPR/static route,\n    // there's always some partial loading state we can fetch.\n    hasLoadingBoundary: HasLoadingBoundary.SegmentHasLoadingBoundary,\n    hasRuntimePrefetch: prefetch.hasRuntimePrefetch,\n  }\n}\n\nexport function convertRootFlightRouterStateToRouteTree(\n  flightRouterState: FlightRouterState,\n  renderedSearch: NormalizedSearch,\n  acc: RouteTreeAccumulator\n): RouteTree {\n  return convertFlightRouterStateToRouteTree(\n    flightRouterState,\n    ROOT_SEGMENT_REQUEST_KEY,\n    null,\n    renderedSearch,\n    acc\n  )\n}\n\nexport function convertReusedFlightRouterStateToRouteTree(\n  parentRouteTree: RouteTree,\n  parallelRouteKey: string,\n  flightRouterState: FlightRouterState,\n  renderedSearch: NormalizedSearch,\n  acc: RouteTreeAccumulator\n) {\n  // Create a RouteTree for a FlightRouterState that was reused from an older\n  // route. This happens during a navigation when a parallel route slot does not\n  // match the target route; we reuse whatever slot was already active.\n\n  // Unlike a FlightRouterState, the RouteTree type contains backreferences to\n  // the parent segments. Append the vary path to the parent's vary path.\n  const parentPartialVaryPath = parentRouteTree.isPage\n    ? getPartialPageVaryPath(parentRouteTree.varyPath)\n    : getPartialLayoutVaryPath(parentRouteTree.varyPath)\n  const segment = flightRouterState[0]\n  // And the request key.\n  const parentRequestKey = parentRouteTree.requestKey\n  const requestKeyPart = createSegmentRequestKeyPart(segment)\n  const requestKey = appendSegmentRequestKeyPart(\n    parentRequestKey,\n    parallelRouteKey,\n    requestKeyPart\n  )\n  return convertFlightRouterStateToRouteTree(\n    flightRouterState,\n    requestKey,\n    parentPartialVaryPath,\n    renderedSearch,\n    acc\n  )\n}\n\nfunction convertFlightRouterStateToRouteTree(\n  flightRouterState: FlightRouterState,\n  requestKey: SegmentRequestKey,\n  parentPartialVaryPath: PartialSegmentVaryPath | null,\n  parentRenderedSearch: NormalizedSearch,\n  acc: RouteTreeAccumulator\n): RouteTree {\n  const originalSegment = flightRouterState[0]\n\n  // If the FlightRouterState has a refresh state, then this segment is part of\n  // an inactive parallel route. It has a different rendered search query than\n  // the outer parent route. In order to construct the inactive route correctly,\n  // we must restore the query that was originally used to render it.\n  const compressedRefreshState = flightRouterState[2] ?? null\n  const refreshState =\n    compressedRefreshState !== null\n      ? {\n          canonicalUrl: compressedRefreshState[0] as string,\n          renderedSearch: compressedRefreshState[1] as NormalizedSearch,\n        }\n      : null\n  const renderedSearch =\n    refreshState !== null ? refreshState.renderedSearch : parentRenderedSearch\n\n  let segment: FlightRouterStateSegment\n  let partialVaryPath: PartialSegmentVaryPath | null\n  let isPage: boolean\n  let varyPath: SegmentVaryPath\n  if (Array.isArray(originalSegment)) {\n    isPage = false\n    const paramCacheKey = originalSegment[1]\n    const paramName = originalSegment[0]\n    partialVaryPath = appendLayoutVaryPath(\n      parentPartialVaryPath,\n      paramCacheKey,\n      paramName\n    )\n    varyPath = finalizeLayoutVaryPath(requestKey, partialVaryPath)\n    segment = originalSegment\n  } else {\n    // This segment does not have a param. Inherit the partial vary path of\n    // the parent.\n    partialVaryPath = parentPartialVaryPath\n    if (requestKey.endsWith(PAGE_SEGMENT_KEY)) {\n      // This is a page segment.\n      isPage = true\n\n      // The navigation implementation expects the search params to be included\n      // in the segment. However, in the case of a static response, the search\n      // params are omitted. So the client needs to add them back in when reading\n      // from the Segment Cache.\n      //\n      // For consistency, we'll do this for dynamic responses, too.\n      //\n      // TODO: We should move search params out of FlightRouterState and handle\n      // them entirely on the client, similar to our plan for dynamic params.\n      segment = PAGE_SEGMENT_KEY\n      varyPath = finalizePageVaryPath(\n        requestKey,\n        renderedSearch,\n        partialVaryPath\n      )\n      // The metadata \"segment\" is not part the route tree, but it has the same\n      // conceptual params as a page segment. Write the vary path into the\n      // accumulator object. If there are multiple parallel pages, we use the\n      // first one. Which page we choose is arbitrary as long as it's\n      // consistently the same one every time every time. See\n      // finalizeMetadataVaryPath for more details.\n      if (acc.metadataVaryPath === null) {\n        acc.metadataVaryPath = finalizeMetadataVaryPath(\n          requestKey,\n          renderedSearch,\n          partialVaryPath\n        )\n      }\n    } else {\n      // This is a layout segment.\n      isPage = false\n      segment = originalSegment\n      varyPath = finalizeLayoutVaryPath(requestKey, partialVaryPath)\n    }\n  }\n\n  let slots: { [parallelRouteKey: string]: RouteTree } | null = null\n\n  const parallelRoutes = flightRouterState[1]\n  for (let parallelRouteKey in parallelRoutes) {\n    const childRouterState = parallelRoutes[parallelRouteKey]\n    const childSegment = childRouterState[0]\n    // TODO: Eventually, the param values will not be included in the response\n    // from the server. We'll instead fill them in on the client by parsing\n    // the URL. This is where we'll do that.\n    const childRequestKeyPart = createSegmentRequestKeyPart(childSegment)\n    const childRequestKey = appendSegmentRequestKeyPart(\n      requestKey,\n      parallelRouteKey,\n      childRequestKeyPart\n    )\n    const childTree = convertFlightRouterStateToRouteTree(\n      childRouterState,\n      childRequestKey,\n      partialVaryPath,\n      renderedSearch,\n      acc\n    )\n    if (slots === null) {\n      slots = {\n        [parallelRouteKey]: childTree,\n      }\n    } else {\n      slots[parallelRouteKey] = childTree\n    }\n  }\n\n  return {\n    requestKey,\n    segment,\n    refreshState,\n    // TODO: Cheating the type system here a bit because TypeScript can't tell\n    // that the type of isPage and varyPath are consistent. The fix would be to\n    // create separate constructors and call the appropriate one from each of\n    // the branches above. Just seems a bit overkill only for one field so I'll\n    // leave it as-is for now. If isPage were wrong it would break the behavior\n    // and we'd catch it quickly, anyway.\n    varyPath: varyPath as any,\n    isPage: isPage as boolean as any,\n    slots,\n    isRootLayout: flightRouterState[4] === true,\n    hasLoadingBoundary:\n      flightRouterState[5] !== undefined\n        ? flightRouterState[5]\n        : HasLoadingBoundary.SubtreeHasNoLoadingBoundary,\n\n    // Non-static tree responses are only used by apps that haven't adopted\n    // Cache Components. So this is always false.\n    hasRuntimePrefetch: false,\n  }\n}\n\nexport function convertRouteTreeToFlightRouterState(\n  routeTree: RouteTree\n): FlightRouterState {\n  const parallelRoutes: Record<string, FlightRouterState> = {}\n  if (routeTree.slots !== null) {\n    for (const parallelRouteKey in routeTree.slots) {\n      parallelRoutes[parallelRouteKey] = convertRouteTreeToFlightRouterState(\n        routeTree.slots[parallelRouteKey]\n      )\n    }\n  }\n  const flightRouterState: FlightRouterState = [\n    routeTree.segment,\n    parallelRoutes,\n    null,\n    null,\n    routeTree.isRootLayout,\n  ]\n  return flightRouterState\n}\n\nexport async function fetchRouteOnCacheMiss(\n  entry: PendingRouteCacheEntry,\n  task: PrefetchTask,\n  key: RouteCacheKey\n): Promise<PrefetchSubtaskResult<null> | null> {\n  // This function is allowed to use async/await because it contains the actual\n  // fetch that gets issued on a cache miss. Notice it writes the result to the\n  // cache entry directly, rather than return data that is then written by\n  // the caller.\n  const pathname = key.pathname\n  const search = key.search\n  const nextUrl = key.nextUrl\n  const segmentPath = '/_tree' as SegmentRequestKey\n\n  const headers: RequestHeaders = {\n    [RSC_HEADER]: '1',\n    [NEXT_ROUTER_PREFETCH_HEADER]: '1',\n    [NEXT_ROUTER_SEGMENT_PREFETCH_HEADER]: segmentPath,\n  }\n  if (nextUrl !== null) {\n    headers[NEXT_URL] = nextUrl\n  }\n\n  try {\n    const url = new URL(pathname + search, location.origin)\n    let response\n    let urlAfterRedirects\n    if (isOutputExportMode) {\n      // In output: \"export\" mode, we can't use headers to request a particular\n      // segment. Instead, we encode the extra request information into the URL.\n      // This is not part of the \"public\" interface of the app; it's an internal\n      // Next.js implementation detail that the app developer should not need to\n      // concern themselves with.\n      //\n      // For example, to request a segment:\n      //\n      //   Path passed to <Link>:   /path/to/page\n      //   Path passed to fetch:    /path/to/page/__next-segments/_tree\n      //\n      //   (This is not the exact protocol, just an illustration.)\n      //\n      // Before we do that, though, we need to account for redirects. Even in\n      // output: \"export\" mode, a proxy might redirect the page to a different\n      // location, but we shouldn't assume or expect that they also redirect all\n      // the segment files, too.\n      //\n      // To check whether the page is redirected, previously we perform a range\n      // request of 64 bytes of the HTML document to check if the target page\n      // is part of this app (by checking if build id matches). Only if the target\n      // page is part of this app do we determine the final canonical URL.\n      //\n      // However, as mentioned in https://github.com/vercel/next.js/pull/85903,\n      // some popular static hosting providers (like Cloudflare Pages or Render.com)\n      // do not support range requests, in the worst case, the entire HTML instead\n      // of 64 bytes could be returned, which is wasteful.\n      //\n      // So instead, we drops the check for build id here, and simply perform\n      // a HEAD request to rejects 1xx/4xx/5xx responses, and then determine the\n      // final URL after redirects.\n      //\n      // NOTE: We could embed the route tree into the HTML document, to avoid\n      // a second request. We're not doing that currently because it would make\n      // the HTML document larger and affect normal page loads.\n      const headResponse = await fetch(url, {\n        method: 'HEAD',\n      })\n      if (headResponse.status < 200 || headResponse.status >= 400) {\n        // The target page responded w/o a successful status code\n        // Could be a WAF serving a 403, or a 5xx from a backend\n        //\n        // Note that we can't use headResponse.ok here, because\n        // Response#ok returns `false` with 3xx responses.\n        rejectRouteCacheEntry(entry, Date.now() + 10 * 1000)\n        return null\n      }\n\n      urlAfterRedirects = headResponse.redirected\n        ? new URL(headResponse.url)\n        : url\n\n      response = await fetchPrefetchResponse(\n        addSegmentPathToUrlInOutputExportMode(urlAfterRedirects, segmentPath),\n        headers\n      )\n    } else {\n      // \"Server\" mode. We can use request headers instead of the pathname.\n      // TODO: The eventual plan is to get rid of our custom request headers and\n      // encode everything into the URL, using a similar strategy to the\n      // \"output: export\" block above.\n      response = await fetchPrefetchResponse(url, headers)\n      urlAfterRedirects =\n        response !== null && response.redirected ? new URL(response.url) : url\n    }\n\n    if (\n      !response ||\n      !response.ok ||\n      // 204 is a Cache miss. Though theoretically this shouldn't happen when\n      // PPR is enabled, because we always respond to route tree requests, even\n      // if it needs to be blockingly generated on demand.\n      response.status === 204 ||\n      !response.body\n    ) {\n      // Server responded with an error, or with a miss. We should still cache\n      // the response, but we can try again after 10 seconds.\n      rejectRouteCacheEntry(entry, Date.now() + 10 * 1000)\n      return null\n    }\n\n    // TODO: The canonical URL is the href without the origin. I think\n    // historically the reason for this is because the initial canonical URL\n    // gets passed as a prop to the top-level React component, which means it\n    // needs to be computed during SSR. If it were to include the origin, it\n    // would need to always be same as location.origin on the client, to prevent\n    // a hydration mismatch. To sidestep this complexity, we omit the origin.\n    //\n    // However, since this is neither a native URL object nor a fully qualified\n    // URL string, we need to be careful about how we use it. To prevent subtle\n    // mistakes, we should create a special type for it, instead of just string.\n    // Or, we should just use a (readonly) URL object instead. The type of the\n    // prop that we pass to seed the initial state does not need to be the same\n    // type as the state itself.\n    const canonicalUrl = createHrefFromUrl(urlAfterRedirects)\n\n    // Check whether the response varies based on the Next-Url header.\n    const varyHeader = response.headers.get('vary')\n    const couldBeIntercepted =\n      varyHeader !== null && varyHeader.includes(NEXT_URL)\n\n    // Track when the network connection closes.\n    const closed = createPromiseWithResolvers<void>()\n\n    // This checks whether the response was served from the per-segment cache,\n    // rather than the old prefetching flow. If it fails, it implies that PPR\n    // is disabled on this route.\n    const routeIsPPREnabled =\n      response.headers.get(NEXT_DID_POSTPONE_HEADER) === '2' ||\n      // In output: \"export\" mode, we can't rely on response headers. But if we\n      // receive a well-formed response, we can assume it's a static response,\n      // because all data is static in this mode.\n      isOutputExportMode\n\n    if (routeIsPPREnabled) {\n      const prefetchStream = createPrefetchResponseStream(\n        response.body,\n        closed.resolve,\n        function onResponseSizeUpdate(size) {\n          setSizeInCacheMap(entry, size)\n        }\n      )\n      const serverData = await createFromNextReadableStream<RootTreePrefetch>(\n        prefetchStream,\n        headers\n      )\n      if (serverData.buildId !== getAppBuildId()) {\n        // The server build does not match the client. Treat as a 404. During\n        // an actual navigation, the router will trigger an MPA navigation.\n        // TODO: Consider moving the build ID to a response header so we can check\n        // it before decoding the response, and so there's one way of checking\n        // across all response types.\n        // TODO: We should cache the fact that this is an MPA navigation.\n        rejectRouteCacheEntry(entry, Date.now() + 10 * 1000)\n        return null\n      }\n\n      // Get the params that were used to render the target page. These may\n      // be different from the params in the request URL, if the page\n      // was rewritten.\n      const renderedPathname = getRenderedPathname(response)\n      const renderedSearch = getRenderedSearch(response)\n\n      // Convert the server-sent data into the RouteTree format used by the\n      // client cache.\n      //\n      // During this traversal, we accumulate additional data into this\n      // \"accumulator\" object.\n      const acc: RouteTreeAccumulator = { metadataVaryPath: null }\n      const routeTree = convertRootTreePrefetchToRouteTree(\n        serverData,\n        renderedPathname,\n        renderedSearch,\n        acc\n      )\n      const metadataVaryPath = acc.metadataVaryPath\n      if (metadataVaryPath === null) {\n        rejectRouteCacheEntry(entry, Date.now() + 10 * 1000)\n        return null\n      }\n\n      discoverKnownRoute(\n        Date.now(),\n        pathname,\n        entry,\n        routeTree,\n        metadataVaryPath,\n        couldBeIntercepted,\n        canonicalUrl,\n        routeIsPPREnabled,\n        false // hasDynamicRewrite\n      )\n    } else {\n      // PPR is not enabled for this route. The server responds with a\n      // different format (FlightRouterState) that we need to convert.\n      // TODO: We will unify the responses eventually. I'm keeping the types\n      // separate for now because FlightRouterState has so many\n      // overloaded concerns.\n      const prefetchStream = createPrefetchResponseStream(\n        response.body,\n        closed.resolve,\n        function onResponseSizeUpdate(size) {\n          setSizeInCacheMap(entry, size)\n        }\n      )\n      const serverData =\n        await createFromNextReadableStream<NavigationFlightResponse>(\n          prefetchStream,\n          headers\n        )\n      if (serverData.b !== getAppBuildId()) {\n        // The server build does not match the client. Treat as a 404. During\n        // an actual navigation, the router will trigger an MPA navigation.\n        // TODO: Consider moving the build ID to a response header so we can check\n        // it before decoding the response, and so there's one way of checking\n        // across all response types.\n        // TODO: We should cache the fact that this is an MPA navigation.\n        rejectRouteCacheEntry(entry, Date.now() + 10 * 1000)\n        return null\n      }\n\n      // Read head vary params synchronously. Individual segments carry their\n      // own thenables in CacheNodeSeedData.\n      const headVaryParamsThenable = serverData.h\n      const headVaryParams =\n        headVaryParamsThenable !== null\n          ? readVaryParams(headVaryParamsThenable)\n          : null\n      writeDynamicTreeResponseIntoCache(\n        Date.now(),\n        task,\n        // The non-PPR response format is what we'd get if we prefetched these segments\n        // using the LoadingBoundary fetch strategy, so mark their cache entries accordingly.\n        FetchStrategy.LoadingBoundary,\n        response as RSCResponse<NavigationFlightResponse>,\n        serverData,\n        entry,\n        couldBeIntercepted,\n        canonicalUrl,\n        routeIsPPREnabled,\n        headVaryParams,\n        pathname\n      )\n    }\n\n    if (!couldBeIntercepted) {\n      // This route will never be intercepted. So we can use this entry for all\n      // requests to this route, regardless of the Next-Url header. This works\n      // because when reading the cache we always check for a valid\n      // non-intercepted entry first.\n\n      // Re-key the entry. The `set` implementation handles removing it from\n      // its previous position in the cache. We don't need to do anything to\n      // update the LRU, because the entry is already in it.\n      // TODO: Treat this as an upsert  should check if an entry already\n      // exists at the new keypath, and if so, whether we should keep that\n      // one instead.\n      const fulfilledVaryPath: RouteVaryPath = getFulfilledRouteVaryPath(\n        pathname,\n        search,\n        nextUrl,\n        couldBeIntercepted\n      )\n      const isRevalidation = false\n      setInCacheMap(routeCacheMap, fulfilledVaryPath, entry, isRevalidation)\n    }\n    // Return a promise that resolves when the network connection closes, so\n    // the scheduler can track the number of concurrent network connections.\n    return { value: null, closed: closed.promise }\n  } catch (error) {\n    // Either the connection itself failed, or something bad happened while\n    // decoding the response.\n    rejectRouteCacheEntry(entry, Date.now() + 10 * 1000)\n    return null\n  }\n}\n\nexport async function fetchSegmentOnCacheMiss(\n  route: FulfilledRouteCacheEntry,\n  segmentCacheEntry: PendingSegmentCacheEntry,\n  routeKey: RouteCacheKey,\n  tree: RouteTree\n): Promise<PrefetchSubtaskResult<FulfilledSegmentCacheEntry> | null> {\n  // This function is allowed to use async/await because it contains the actual\n  // fetch that gets issued on a cache miss. Notice it writes the result to the\n  // cache entry directly, rather than return data that is then written by\n  // the caller.\n  //\n  // Segment fetches are non-blocking so we don't need to ping the scheduler\n  // on completion.\n\n  // Use the canonical URL to request the segment, not the original URL. These\n  // are usually the same, but the canonical URL will be different if the route\n  // tree response was redirected. To avoid an extra waterfall on every segment\n  // request, we pass the redirected URL instead of the original one.\n  const url = new URL(route.canonicalUrl, location.origin)\n  const nextUrl = routeKey.nextUrl\n\n  const requestKey = tree.requestKey\n  const normalizedRequestKey =\n    requestKey === ROOT_SEGMENT_REQUEST_KEY\n      ? // The root segment is a special case. To simplify the server-side\n        // handling of these requests, we encode the root segment path as\n        // `_index` instead of as an empty string. This should be treated as\n        // an implementation detail and not as a stable part of the protocol.\n        // It just needs to match the equivalent logic that happens when\n        // prerendering the responses. It should not leak outside of Next.js.\n        ('/_index' as SegmentRequestKey)\n      : requestKey\n\n  const headers: RequestHeaders = {\n    [RSC_HEADER]: '1',\n    [NEXT_ROUTER_PREFETCH_HEADER]: '1',\n    [NEXT_ROUTER_SEGMENT_PREFETCH_HEADER]: normalizedRequestKey,\n  }\n  if (nextUrl !== null) {\n    headers[NEXT_URL] = nextUrl\n  }\n\n  const requestUrl = isOutputExportMode\n    ? // In output: \"export\" mode, we need to add the segment path to the URL.\n      addSegmentPathToUrlInOutputExportMode(url, normalizedRequestKey)\n    : url\n  try {\n    const response = await fetchPrefetchResponse(requestUrl, headers)\n    if (\n      !response ||\n      !response.ok ||\n      response.status === 204 || // Cache miss\n      // This checks whether the response was served from the per-segment cache,\n      // rather than the old prefetching flow. If it fails, it implies that PPR\n      // is disabled on this route. Theoretically this should never happen\n      // because we only issue requests for segments once we've verified that\n      // the route supports PPR.\n      (response.headers.get(NEXT_DID_POSTPONE_HEADER) !== '2' &&\n        // In output: \"export\" mode, we can't rely on response headers. But if\n        // we receive a well-formed response, we can assume it's a static\n        // response, because all data is static in this mode.\n        !isOutputExportMode) ||\n      !response.body\n    ) {\n      // Server responded with an error, or with a miss. We should still cache\n      // the response, but we can try again after 10 seconds.\n      rejectSegmentCacheEntry(segmentCacheEntry, Date.now() + 10 * 1000)\n      return null\n    }\n\n    // Track when the network connection closes.\n    const closed = createPromiseWithResolvers<void>()\n\n    // Wrap the original stream in a new stream that never closes. That way the\n    // Flight client doesn't error if there's a hanging promise.\n    const prefetchStream = createPrefetchResponseStream(\n      response.body,\n      closed.resolve,\n      function onResponseSizeUpdate(size) {\n        setSizeInCacheMap(segmentCacheEntry, size)\n      }\n    )\n    const serverData = await (createFromNextReadableStream(\n      prefetchStream,\n      headers\n    ) as Promise<SegmentPrefetch>)\n    if (serverData.buildId !== getAppBuildId()) {\n      // The server build does not match the client. Treat as a 404. During\n      // an actual navigation, the router will trigger an MPA navigation.\n      // TODO: Consider moving the build ID to a response header so we can check\n      // it before decoding the response, and so there's one way of checking\n      // across all response types.\n      rejectSegmentCacheEntry(segmentCacheEntry, Date.now() + 10 * 1000)\n      return null\n    }\n    const staleAt = Date.now() + getStaleTimeMs(serverData.staleTime)\n    const fulfilledEntry = fulfillSegmentCacheEntry(\n      segmentCacheEntry,\n      serverData.rsc,\n      staleAt,\n      serverData.isPartial\n    )\n\n    // If the server tells us which params the segment varies by, we can re-key\n    // the entry to a more generic vary path. This allows the entry to be reused\n    // across different param values for params that the segment doesn't\n    // actually depend on.\n    const varyParams = serverData.varyParams\n    if (process.env.__NEXT_VARY_PARAMS && varyParams !== null) {\n      // Re-key the entry by storing it at a more generic vary path where\n      // unused params are replaced with Fallback.\n      const fulfilledVaryPath = getFulfilledSegmentVaryPath(\n        tree.varyPath,\n        varyParams\n      )\n      const isRevalidation = false\n      setInCacheMap(\n        segmentCacheMap,\n        fulfilledVaryPath,\n        fulfilledEntry,\n        isRevalidation\n      )\n    }\n\n    return {\n      value: fulfilledEntry,\n      // Return a promise that resolves when the network connection closes, so\n      // the scheduler can track the number of concurrent network connections.\n      closed: closed.promise,\n    }\n  } catch (error) {\n    // Either the connection itself failed, or something bad happened while\n    // decoding the response.\n    rejectSegmentCacheEntry(segmentCacheEntry, Date.now() + 10 * 1000)\n    return null\n  }\n}\n\nexport async function fetchSegmentPrefetchesUsingDynamicRequest(\n  task: PrefetchTask,\n  route: FulfilledRouteCacheEntry,\n  fetchStrategy:\n    | FetchStrategy.LoadingBoundary\n    | FetchStrategy.PPRRuntime\n    | FetchStrategy.Full,\n  dynamicRequestTree: FlightRouterState,\n  spawnedEntries: Map<SegmentRequestKey, PendingSegmentCacheEntry>\n): Promise<PrefetchSubtaskResult<null> | null> {\n  const key = task.key\n  const url = new URL(route.canonicalUrl, location.origin)\n  const nextUrl = key.nextUrl\n\n  if (\n    spawnedEntries.size === 1 &&\n    spawnedEntries.has(route.metadata.requestKey)\n  ) {\n    // The only thing pending is the head. Instruct the server to\n    // skip over everything else.\n    dynamicRequestTree = MetadataOnlyRequestTree\n  }\n\n  const headers: RequestHeaders = {\n    [RSC_HEADER]: '1',\n    [NEXT_ROUTER_STATE_TREE_HEADER]:\n      prepareFlightRouterStateForRequest(dynamicRequestTree),\n  }\n  if (nextUrl !== null) {\n    headers[NEXT_URL] = nextUrl\n  }\n  switch (fetchStrategy) {\n    case FetchStrategy.Full: {\n      // We omit the prefetch header from a full prefetch because it's essentially\n      // just a navigation request that happens ahead of time  it should include\n      // all the same data in the response.\n      break\n    }\n    case FetchStrategy.PPRRuntime: {\n      headers[NEXT_ROUTER_PREFETCH_HEADER] = '2'\n      break\n    }\n    case FetchStrategy.LoadingBoundary: {\n      headers[NEXT_ROUTER_PREFETCH_HEADER] = '1'\n      break\n    }\n    default: {\n      fetchStrategy satisfies never\n    }\n  }\n\n  try {\n    const response = await fetchPrefetchResponse(url, headers)\n    if (!response || !response.ok || !response.body) {\n      // Server responded with an error, or with a miss. We should still cache\n      // the response, but we can try again after 10 seconds.\n      rejectSegmentEntriesIfStillPending(spawnedEntries, Date.now() + 10 * 1000)\n      return null\n    }\n\n    const renderedSearch = getRenderedSearch(response)\n    if (renderedSearch !== route.renderedSearch) {\n      // The search params that were used to render the target page are\n      // different from the search params in the request URL. This only happens\n      // when there's a dynamic rewrite in between the tree prefetch and the\n      // data prefetch.\n      // TODO: For now, since this is an edge case, we reject the prefetch, but\n      // the proper way to handle this is to evict the stale route tree entry\n      // then fill the cache with the new response.\n      rejectSegmentEntriesIfStillPending(spawnedEntries, Date.now() + 10 * 1000)\n      return null\n    }\n\n    // Track when the network connection closes.\n    const closed = createPromiseWithResolvers<void>()\n\n    let fulfilledEntries: Array<FulfilledSegmentCacheEntry> | null = null\n    const prefetchStream = createPrefetchResponseStream(\n      response.body,\n      closed.resolve,\n      function onResponseSizeUpdate(totalBytesReceivedSoFar) {\n        // When processing a dynamic response, we don't know how large each\n        // individual segment is, so approximate by assiging each segment\n        // the average of the total response size.\n        if (fulfilledEntries === null) {\n          // Haven't received enough data yet to know which segments\n          // were included.\n          return\n        }\n        const averageSize = totalBytesReceivedSoFar / fulfilledEntries.length\n        for (const entry of fulfilledEntries) {\n          setSizeInCacheMap(entry, averageSize)\n        }\n      }\n    )\n    const serverData = await (createFromNextReadableStream(\n      prefetchStream,\n      headers\n    ) as Promise<NavigationFlightResponse>)\n\n    const isResponsePartial =\n      fetchStrategy === FetchStrategy.PPRRuntime\n        ? // A runtime prefetch may have holes.\n          serverData.rp?.[0] === true\n        : // Full and LoadingBoundary prefetches cannot have holes.\n          // (even if we did set the prefetch header, we only use this codepath for non-PPR-enabled routes)\n          false\n    // Read head vary params synchronously. Individual segments carry their\n    // own thenables in CacheNodeSeedData.\n    const headVaryParamsThenable = serverData.h\n    const headVaryParams =\n      headVaryParamsThenable !== null\n        ? readVaryParams(headVaryParamsThenable)\n        : null\n\n    // Aside from writing the data into the cache, this function also returns\n    // the entries that were fulfilled, so we can streamingly update their sizes\n    // in the LRU as more data comes in.\n    fulfilledEntries = writeDynamicRenderResponseIntoCache(\n      Date.now(),\n      task,\n      fetchStrategy,\n      response as RSCResponse<NavigationFlightResponse>,\n      serverData,\n      isResponsePartial,\n      headVaryParams,\n      route,\n      spawnedEntries\n    )\n\n    // Return a promise that resolves when the network connection closes, so\n    // the scheduler can track the number of concurrent network connections.\n    return { value: null, closed: closed.promise }\n  } catch (error) {\n    rejectSegmentEntriesIfStillPending(spawnedEntries, Date.now() + 10 * 1000)\n    return null\n  }\n}\n\nfunction writeDynamicTreeResponseIntoCache(\n  now: number,\n  task: PrefetchTask,\n  fetchStrategy:\n    | FetchStrategy.LoadingBoundary\n    | FetchStrategy.PPRRuntime\n    | FetchStrategy.Full,\n  response: RSCResponse<NavigationFlightResponse>,\n  serverData: NavigationFlightResponse,\n  entry: PendingRouteCacheEntry,\n  couldBeIntercepted: boolean,\n  canonicalUrl: string,\n  routeIsPPREnabled: boolean,\n  headVaryParams: VaryParams | null,\n  originalPathname: string\n): void {\n  const renderedSearch = getRenderedSearch(response)\n\n  const normalizedFlightDataResult = normalizeFlightData(serverData.f)\n  if (\n    // A string result means navigating to this route will result in an\n    // MPA navigation.\n    typeof normalizedFlightDataResult === 'string' ||\n    normalizedFlightDataResult.length !== 1\n  ) {\n    rejectRouteCacheEntry(entry, now + 10 * 1000)\n    return\n  }\n  const flightData = normalizedFlightDataResult[0]\n  if (!flightData.isRootRender) {\n    // Unexpected response format.\n    rejectRouteCacheEntry(entry, now + 10 * 1000)\n    return\n  }\n\n  const flightRouterState = flightData.tree\n  // If the response contains dynamic holes, then we must conservatively assume\n  // that any individual segment might contain dynamic holes, and also the\n  // head. If it did not contain dynamic holes, then we can assume every segment\n  // and the head is completely static.\n  const isResponsePartial =\n    response.headers.get(NEXT_DID_POSTPONE_HEADER) === '1'\n\n  // Convert the server-sent data into the RouteTree format used by the\n  // client cache.\n  //\n  // During this traversal, we accumulate additional data into this\n  // \"accumulator\" object.\n  const acc: RouteTreeAccumulator = { metadataVaryPath: null }\n  const routeTree = convertRootFlightRouterStateToRouteTree(\n    flightRouterState,\n    renderedSearch,\n    acc\n  )\n  const metadataVaryPath = acc.metadataVaryPath\n  if (metadataVaryPath === null) {\n    rejectRouteCacheEntry(entry, now + 10 * 1000)\n    return\n  }\n\n  const fulfilledEntry = discoverKnownRoute(\n    now,\n    originalPathname,\n    entry,\n    routeTree,\n    metadataVaryPath,\n    couldBeIntercepted,\n    canonicalUrl,\n    routeIsPPREnabled,\n    false // hasDynamicRewrite\n  )\n\n  // If the server sent segment data as part of the response, we should write\n  // it into the cache to prevent a second, redundant prefetch request.\n  //\n  // TODO: When `clientSegmentCache` is enabled, the server does not include\n  // segment data when responding to a route tree prefetch request. However,\n  // when `clientSegmentCache` is set to \"client-only\", and PPR is enabled (or\n  // the page is fully static), the normal check is bypassed and the server\n  // responds with the full page. This is a temporary situation until we can\n  // remove the \"client-only\" option. Then, we can delete this function call.\n  writeDynamicRenderResponseIntoCache(\n    now,\n    task,\n    fetchStrategy,\n    response,\n    serverData,\n    isResponsePartial,\n    headVaryParams,\n    fulfilledEntry,\n    null\n  )\n}\n\nfunction rejectSegmentEntriesIfStillPending(\n  entries: Map<SegmentRequestKey, SegmentCacheEntry>,\n  staleAt: number\n): Array<FulfilledSegmentCacheEntry> {\n  const fulfilledEntries = []\n  for (const entry of entries.values()) {\n    if (entry.status === EntryStatus.Pending) {\n      rejectSegmentCacheEntry(entry, staleAt)\n    } else if (entry.status === EntryStatus.Fulfilled) {\n      fulfilledEntries.push(entry)\n    }\n  }\n  return fulfilledEntries\n}\n\nfunction writeDynamicRenderResponseIntoCache(\n  now: number,\n  task: PrefetchTask,\n  fetchStrategy:\n    | FetchStrategy.LoadingBoundary\n    | FetchStrategy.PPRRuntime\n    | FetchStrategy.Full,\n  response: RSCResponse<NavigationFlightResponse>,\n  serverData: NavigationFlightResponse,\n  isResponsePartial: boolean,\n  headVaryParams: VaryParams | null,\n  route: FulfilledRouteCacheEntry,\n  spawnedEntries: Map<SegmentRequestKey, PendingSegmentCacheEntry> | null\n): Array<FulfilledSegmentCacheEntry> | null {\n  if (serverData.b !== getAppBuildId()) {\n    // The server build does not match the client. Treat as a 404. During\n    // an actual navigation, the router will trigger an MPA navigation.\n    // TODO: Consider moving the build ID to a response header so we can check\n    // it before decoding the response, and so there's one way of checking\n    // across all response types.\n    if (spawnedEntries !== null) {\n      rejectSegmentEntriesIfStillPending(spawnedEntries, now + 10 * 1000)\n    }\n    return null\n  }\n\n  const flightDatas = normalizeFlightData(serverData.f)\n  if (typeof flightDatas === 'string') {\n    // This means navigating to this route will result in an MPA navigation.\n    // TODO: We should cache this, too, so that the MPA navigation is immediate.\n    return null\n  }\n\n  // For runtime prefetches, stale time is in the payload at rp[1].\n  // For other responses, fall back to the header.\n  const staleTimeSeconds =\n    typeof serverData.rp?.[1] === 'number'\n      ? serverData.rp[1]\n      : parseInt(response.headers.get(NEXT_ROUTER_STALE_TIME_HEADER) ?? '', 10)\n  const staleTimeMs = !isNaN(staleTimeSeconds)\n    ? getStaleTimeMs(staleTimeSeconds)\n    : STATIC_STALETIME_MS\n  const staleAt = now + staleTimeMs\n\n  for (const flightData of flightDatas) {\n    const seedData = flightData.seedData\n    if (seedData !== null) {\n      // The data sent by the server represents only a subtree of the app. We\n      // need to find the part of the task tree that matches the response.\n      //\n      // segmentPath represents the parent path of subtree. It's a repeating\n      // pattern of parallel route key and segment:\n      //\n      //   [string, Segment, string, Segment, string, Segment, ...]\n      const segmentPath = flightData.segmentPath\n      let tree = route.tree\n      for (let i = 0; i < segmentPath.length; i += 2) {\n        const parallelRouteKey: string = segmentPath[i]\n        if (tree?.slots?.[parallelRouteKey] !== undefined) {\n          tree = tree.slots[parallelRouteKey]\n        } else {\n          if (spawnedEntries !== null) {\n            rejectSegmentEntriesIfStillPending(spawnedEntries, now + 10 * 1000)\n          }\n          return null\n        }\n      }\n\n      writeSeedDataIntoCache(\n        now,\n        task,\n        fetchStrategy,\n        tree,\n        staleAt,\n        seedData,\n        isResponsePartial,\n        spawnedEntries\n      )\n    }\n\n    const head = flightData.head\n    if (head !== null) {\n      // For head entries, use the head-specific vary params passed as parameter.\n      fulfillEntrySpawnedByRuntimePrefetch(\n        now,\n        fetchStrategy,\n        head,\n        flightData.isHeadPartial,\n        staleAt,\n        headVaryParams,\n        route.metadata,\n        spawnedEntries\n      )\n    }\n  }\n  // Any entry that's still pending was intentionally not rendered by the\n  // server, because it was inside the loading boundary. Mark them as rejected\n  // so we know not to fetch them again.\n  // TODO: If PPR is enabled on some routes but not others, then it's possible\n  // that a different page is able to do a per-segment prefetch of one of the\n  // segments we're marking as rejected here. We should mark on the segment\n  // somehow that the reason for the rejection is because of a non-PPR prefetch.\n  // That way a per-segment prefetch knows to disregard the rejection.\n  if (spawnedEntries !== null) {\n    const fulfilledEntries = rejectSegmentEntriesIfStillPending(\n      spawnedEntries,\n      now + 10 * 1000\n    )\n    return fulfilledEntries\n  }\n  return null\n}\n\nfunction writeSeedDataIntoCache(\n  now: number,\n  task: PrefetchTask,\n  fetchStrategy:\n    | FetchStrategy.LoadingBoundary\n    | FetchStrategy.PPRRuntime\n    | FetchStrategy.Full,\n  tree: RouteTree,\n  staleAt: number,\n  seedData: CacheNodeSeedData,\n  isResponsePartial: boolean,\n  entriesOwnedByCurrentTask: Map<\n    SegmentRequestKey,\n    PendingSegmentCacheEntry\n  > | null\n) {\n  // This function is used to write the result of a runtime server request\n  // (CacheNodeSeedData) into the prefetch cache.\n  const rsc = seedData[0]\n  const isPartial = rsc === null || isResponsePartial\n  const varyParamsThenable = seedData[5]\n  // Each segment carries its own vary params thenable in the seed data. The\n  // thenable resolves to the set of params the segment accessed during render.\n  // A null thenable means tracking was not enabled (not a prerender).\n  const varyParams =\n    varyParamsThenable !== null ? readVaryParams(varyParamsThenable) : null\n  fulfillEntrySpawnedByRuntimePrefetch(\n    now,\n    fetchStrategy,\n    rsc,\n    isPartial,\n    staleAt,\n    varyParams,\n    tree,\n    entriesOwnedByCurrentTask\n  )\n\n  // Recursively write the child data into the cache.\n  const slots = tree.slots\n  if (slots !== null) {\n    const seedDataChildren = seedData[1]\n    for (const parallelRouteKey in slots) {\n      const childTree = slots[parallelRouteKey]\n      const childSeedData: CacheNodeSeedData | null | void =\n        seedDataChildren[parallelRouteKey]\n      if (childSeedData !== null && childSeedData !== undefined) {\n        writeSeedDataIntoCache(\n          now,\n          task,\n          fetchStrategy,\n          childTree,\n          staleAt,\n          childSeedData,\n          isResponsePartial,\n          entriesOwnedByCurrentTask\n        )\n      }\n    }\n  }\n}\n\nfunction fulfillEntrySpawnedByRuntimePrefetch(\n  now: number,\n  fetchStrategy:\n    | FetchStrategy.LoadingBoundary\n    | FetchStrategy.PPRRuntime\n    | FetchStrategy.Full,\n  rsc: React.ReactNode,\n  isPartial: boolean,\n  staleAt: number,\n  segmentVaryParams: Set<string> | null,\n  tree: RouteTree,\n  entriesOwnedByCurrentTask: Map<\n    SegmentRequestKey,\n    PendingSegmentCacheEntry\n  > | null\n) {\n  // We should only write into cache entries that are owned by us. Or create\n  // a new one and write into that. We must never write over an entry that was\n  // created by a different task, because that causes data races.\n  const ownedEntry =\n    entriesOwnedByCurrentTask !== null\n      ? entriesOwnedByCurrentTask.get(tree.requestKey)\n      : undefined\n  if (ownedEntry !== undefined) {\n    const fulfilledEntry = fulfillSegmentCacheEntry(\n      ownedEntry,\n      rsc,\n      staleAt,\n      isPartial\n    )\n    // Re-key the entry based on which params the segment actually depends on.\n    if (process.env.__NEXT_VARY_PARAMS && segmentVaryParams !== null) {\n      const fulfilledVaryPath = getFulfilledSegmentVaryPath(\n        tree.varyPath,\n        segmentVaryParams\n      )\n      const isRevalidation = false\n      setInCacheMap(\n        segmentCacheMap,\n        fulfilledVaryPath,\n        fulfilledEntry,\n        isRevalidation\n      )\n    }\n  } else {\n    // There's no matching entry. Attempt to create a new one.\n    const possiblyNewEntry = readOrCreateSegmentCacheEntry(\n      now,\n      fetchStrategy,\n      tree\n    )\n    if (possiblyNewEntry.status === EntryStatus.Empty) {\n      // Confirmed this is a new entry. We can fulfill it.\n      const newEntry = possiblyNewEntry\n      const fulfilledEntry = fulfillSegmentCacheEntry(\n        upgradeToPendingSegment(newEntry, fetchStrategy),\n        rsc,\n        staleAt,\n        isPartial\n      )\n      // Re-key the entry based on which params the segment actually depends on.\n      if (process.env.__NEXT_VARY_PARAMS && segmentVaryParams !== null) {\n        const fulfilledVaryPath = getFulfilledSegmentVaryPath(\n          tree.varyPath,\n          segmentVaryParams\n        )\n        const isRevalidation = false\n        setInCacheMap(\n          segmentCacheMap,\n          fulfilledVaryPath,\n          fulfilledEntry,\n          isRevalidation\n        )\n      }\n    } else {\n      // There was already an entry in the cache. But we may be able to\n      // replace it with the new one from the server.\n      const newEntry = fulfillSegmentCacheEntry(\n        upgradeToPendingSegment(\n          createDetachedSegmentCacheEntry(now),\n          fetchStrategy\n        ),\n        rsc,\n        staleAt,\n        isPartial\n      )\n      // Use the fulfilled vary path if available, otherwise fall back to\n      // the request vary path.\n      const varyPath =\n        process.env.__NEXT_VARY_PARAMS && segmentVaryParams !== null\n          ? getFulfilledSegmentVaryPath(tree.varyPath, segmentVaryParams)\n          : getSegmentVaryPathForRequest(fetchStrategy, tree)\n      upsertSegmentEntry(now, varyPath, newEntry)\n    }\n  }\n}\n\nasync function fetchPrefetchResponse<T>(\n  url: URL,\n  headers: RequestHeaders\n): Promise<RSCResponse<T> | null> {\n  const fetchPriority = 'low'\n  // When issuing a prefetch request, don't immediately decode the response; we\n  // use the lower level `createFromResponse` API instead because we need to do\n  // some extra processing of the response stream. See\n  // `createPrefetchResponseStream` for more details.\n  const shouldImmediatelyDecode = false\n  const response = await createFetch<T>(\n    url,\n    headers,\n    fetchPriority,\n    shouldImmediatelyDecode\n  )\n  if (!response.ok) {\n    return null\n  }\n\n  // Check the content type\n  if (isOutputExportMode) {\n    // In output: \"export\" mode, we relaxed about the content type, since it's\n    // not Next.js that's serving the response. If the status is OK, assume the\n    // response is valid. If it's not a valid response, the Flight client won't\n    // be able to decode it, and we'll treat it as a miss.\n  } else {\n    const contentType = response.headers.get('content-type')\n    const isFlightResponse =\n      contentType && contentType.startsWith(RSC_CONTENT_TYPE_HEADER)\n    if (!isFlightResponse) {\n      return null\n    }\n  }\n  return response\n}\n\nfunction createPrefetchResponseStream(\n  originalFlightStream: ReadableStream<Uint8Array>,\n  onStreamClose: () => void,\n  onResponseSizeUpdate: (size: number) => void\n): ReadableStream<Uint8Array> {\n  // When PPR is enabled, prefetch streams may contain references that never\n  // resolve, because that's how we encode dynamic data access. In the decoded\n  // object returned by the Flight client, these are reified into hanging\n  // promises that suspend during render, which is effectively what we want.\n  // The UI resolves when it switches to the dynamic data stream\n  // (via useDeferredValue(dynamic, static)).\n  //\n  // However, the Flight implementation currently errors if the server closes\n  // the response before all the references are resolved. As a cheat to work\n  // around this, we wrap the original stream in a new stream that never closes,\n  // and therefore doesn't error.\n  //\n  // While processing the original stream, we also incrementally update the size\n  // of the cache entry in the LRU.\n  let totalByteLength = 0\n  const reader = originalFlightStream.getReader()\n  return new ReadableStream({\n    async pull(controller) {\n      while (true) {\n        const { done, value } = await reader.read()\n        if (!done) {\n          // Pass to the target stream and keep consuming the Flight response\n          // from the server.\n          controller.enqueue(value)\n\n          // Incrementally update the size of the cache entry in the LRU.\n          // NOTE: Since prefetch responses are delivered in a single chunk,\n          // it's not really necessary to do this streamingly, but I'm doing it\n          // anyway in case this changes in the future.\n          totalByteLength += value.byteLength\n          onResponseSizeUpdate(totalByteLength)\n          continue\n        }\n        // The server stream has closed. Exit, but intentionally do not close\n        // the target stream. We do notify the caller, though.\n        onStreamClose()\n        return\n      }\n    },\n  })\n}\n\nfunction addSegmentPathToUrlInOutputExportMode(\n  url: URL,\n  segmentPath: SegmentRequestKey\n): URL {\n  if (isOutputExportMode) {\n    // In output: \"export\" mode, we cannot use a header to encode the segment\n    // path. Instead, we append it to the end of the pathname.\n    const staticUrl = new URL(url)\n    const routeDir = staticUrl.pathname.endsWith('/')\n      ? staticUrl.pathname.slice(0, -1)\n      : staticUrl.pathname\n    const staticExportFilename =\n      convertSegmentPathToStaticExportFilename(segmentPath)\n    staticUrl.pathname = `${routeDir}/${staticExportFilename}`\n    return staticUrl\n  }\n  return url\n}\n\n/**\n * Checks whether the new fetch strategy is likely to provide more content than the old one.\n *\n * Generally, when an app uses dynamic data, a \"more specific\" fetch strategy is expected to provide more content:\n * - `LoadingBoundary` only provides static layouts\n * - `PPR` can provide shells for each segment (even for segments that use dynamic data)\n * - `PPRRuntime` can additionally include content that uses searchParams, params, or cookies\n * - `Full` includes all the content, even if it uses dynamic data\n *\n * However, it's possible that a more specific fetch strategy *won't* give us more content if:\n * - a segment is fully static\n *   (then, `PPR`/`PPRRuntime`/`Full` will all yield equivalent results)\n * - providing searchParams/params/cookies doesn't reveal any more content, e.g. because of an `await connection()`\n *   (then, `PPR` and `PPRRuntime` will yield equivalent results, only `Full` will give us more)\n * Because of this, when comparing two segments, we should also check if the existing segment is partial.\n * If it's not partial, then there's no need to prefetch it again, even using a \"more specific\" strategy.\n * There's currently no way to know if `PPRRuntime` will yield more data that `PPR`, so we have to assume it will.\n *\n * Also note that, in practice, we don't expect to be comparing `LoadingBoundary` to `PPR`/`PPRRuntime`,\n * because a non-PPR-enabled route wouldn't ever use the latter strategies. It might however use `Full`.\n */\nexport function canNewFetchStrategyProvideMoreContent(\n  currentStrategy: FetchStrategy,\n  newStrategy: FetchStrategy\n): boolean {\n  return currentStrategy < newStrategy\n}\n"],"names":["EntryStatus","attemptToFulfillDynamicSegmentFromBFCache","canNewFetchStrategyProvideMoreContent","convertReusedFlightRouterStateToRouteTree","convertRootFlightRouterStateToRouteTree","convertRouteTreeToFlightRouterState","createDetachedSegmentCacheEntry","createMetadataRouteTree","deprecated_requestOptimisticRouteCacheEntry","fetchRouteOnCacheMiss","fetchSegmentOnCacheMiss","fetchSegmentPrefetchesUsingDynamicRequest","fulfillRouteCacheEntry","getCurrentRouteCacheVersion","getCurrentSegmentCacheVersion","getStaleTimeMs","invalidateEntirePrefetchCache","invalidateRouteCacheEntries","invalidateSegmentCacheEntries","markRouteEntryAsDynamicRewrite","overwriteRevalidatingSegmentCacheEntry","pingInvalidationListeners","readOrCreateRevalidatingSegmentEntry","readOrCreateRouteCacheEntry","readOrCreateSegmentCacheEntry","readRouteCacheEntry","readSegmentCacheEntry","upgradeToPendingSegment","upsertSegmentEntry","waitForSegmentCacheEntry","writeRouteIntoCache","staleTimeSeconds","Math","max","isOutputExportMode","process","env","NODE_ENV","__NEXT_CONFIG_OUTPUT","MetadataOnlyRequestTree","routeCacheMap","createCacheMap","segmentCacheMap","invalidationListeners","currentRouteCacheVersion","currentSegmentCacheVersion","nextUrl","tree","pingVisibleLinks","attachInvalidationListener","task","onInvalidate","Set","add","notifyInvalidationListener","error","reportError","console","tasks","isPrefetchTaskDirty","now","key","varyPath","getRouteVaryPath","pathname","search","isRevalidation","existingEntry","getFromCacheMap","__NEXT_OPTIMISTIC_ROUTING","matchKnownRoute","readRevalidatingSegmentCacheEntry","pendingEntry","promiseWithResolvers","promise","createPromiseWithResolvers","createDetachedRouteCacheEntry","canonicalUrl","status","blockedTasks","metadata","couldBeIntercepted","isPPREnabled","renderedSearch","ref","size","staleAt","Infinity","version","setInCacheMap","requestedUrl","requestedSearch","urlWithoutSearchParams","URL","routeWithNoSearchParams","createPrefetchRequestKey","href","canonicalUrlForRouteWithNoSearchParams","origin","optimisticCanonicalSearch","optimisticRenderedSearch","optimisticUrl","location","optimisticCanonicalUrl","createHrefFromUrl","optimisticRouteTree","deprecated_createOptimisticRouteTree","optimisticMetadataTree","optimisticEntry","hasDynamicRewrite","newRenderedSearch","clonedSlots","originalSlots","slots","parallelRouteKey","childTree","isPage","requestKey","segment","refreshState","clonePageVaryPathWithNewSearchParams","isRootLayout","hasLoadingBoundary","hasRuntimePrefetch","fetchStrategy","varyPathForRequest","getSegmentVaryPathForRequest","candidateEntry","isValueExpired","isPartial","rejectedEntry","rsc","deleteFromCacheMap","emptyEntry","FetchStrategy","PPR","Full","adjustedCurrentTime","STATIC_STALETIME_MS","DYNAMIC_STALETIME_MS","bfcacheEntry","readFromBFCacheDuringRegularNavigation","requestedAt","dynamicPrefetchStaleAt","pendingSegment","fulfillSegmentCacheEntry","pingBlockedTasks","entry","pingPrefetchTask","metadataVaryPath","HEAD_REQUEST_KEY","HasLoadingBoundary","SubtreeHasNoLoadingBoundary","getRenderedSearchFromVaryPath","fulfilledEntry","segmentCacheEntry","resolve","rejectRouteCacheEntry","rejectSegmentCacheEntry","convertRootTreePrefetchToRouteTree","rootTree","renderedPathname","acc","pathnameParts","split","filter","p","index","rootSegment","ROOT_SEGMENT_REQUEST_KEY","convertTreePrefetchToRouteTree","prefetch","partialVaryPath","pathnamePartsIndex","prefetchSlots","finalizeLayoutVaryPath","childPrefetch","childSegmentName","name","childParam","param","childDoesAppearInURL","childSegment","childPartialVaryPath","childParamValue","parseDynamicParamFromURLPart","type","childParamKey","getCacheKeyForDynamicParam","appendLayoutVaryPath","siblings","doesStaticSegmentAppearInURL","childPathnamePartsIndex","childRequestKeyPart","createSegmentRequestKeyPart","childRequestKey","appendSegmentRequestKeyPart","endsWith","PAGE_SEGMENT_KEY","finalizePageVaryPath","finalizeMetadataVaryPath","SegmentHasLoadingBoundary","flightRouterState","convertFlightRouterStateToRouteTree","parentRouteTree","parentPartialVaryPath","getPartialPageVaryPath","getPartialLayoutVaryPath","parentRequestKey","requestKeyPart","parentRenderedSearch","originalSegment","compressedRefreshState","Array","isArray","paramCacheKey","paramName","parallelRoutes","childRouterState","undefined","routeTree","segmentPath","headers","RSC_HEADER","NEXT_ROUTER_PREFETCH_HEADER","NEXT_ROUTER_SEGMENT_PREFETCH_HEADER","NEXT_URL","url","response","urlAfterRedirects","headResponse","fetch","method","Date","redirected","fetchPrefetchResponse","addSegmentPathToUrlInOutputExportMode","ok","body","varyHeader","get","includes","closed","routeIsPPREnabled","NEXT_DID_POSTPONE_HEADER","prefetchStream","createPrefetchResponseStream","onResponseSizeUpdate","setSizeInCacheMap","serverData","createFromNextReadableStream","buildId","getAppBuildId","getRenderedPathname","getRenderedSearch","discoverKnownRoute","b","headVaryParamsThenable","h","headVaryParams","readVaryParams","writeDynamicTreeResponseIntoCache","LoadingBoundary","fulfilledVaryPath","getFulfilledRouteVaryPath","value","route","routeKey","normalizedRequestKey","requestUrl","staleTime","varyParams","__NEXT_VARY_PARAMS","getFulfilledSegmentVaryPath","dynamicRequestTree","spawnedEntries","has","NEXT_ROUTER_STATE_TREE_HEADER","prepareFlightRouterStateForRequest","PPRRuntime","rejectSegmentEntriesIfStillPending","fulfilledEntries","totalBytesReceivedSoFar","averageSize","length","isResponsePartial","rp","writeDynamicRenderResponseIntoCache","originalPathname","normalizedFlightDataResult","normalizeFlightData","f","flightData","isRootRender","entries","values","push","flightDatas","parseInt","NEXT_ROUTER_STALE_TIME_HEADER","staleTimeMs","isNaN","seedData","i","writeSeedDataIntoCache","head","fulfillEntrySpawnedByRuntimePrefetch","isHeadPartial","entriesOwnedByCurrentTask","varyParamsThenable","seedDataChildren","childSeedData","segmentVaryParams","ownedEntry","possiblyNewEntry","newEntry","fetchPriority","shouldImmediatelyDecode","createFetch","contentType","isFlightResponse","startsWith","RSC_CONTENT_TYPE_HEADER","originalFlightStream","onStreamClose","totalByteLength","reader","getReader","ReadableStream","pull","controller","done","read","enqueue","byteLength","staticUrl","routeDir","slice","staticExportFilename","convertSegmentPathToStaticExportFilename","currentStrategy","newStrategy"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 7441, "column": 0}, "map": {"version":3,"sources":["file:///D:/AconnectJP/node_modules/next/src/client/components/router-reducer/ppr-navigations.ts"],"sourcesContent":["import type {\n  CacheNodeSeedData,\n  FlightRouterState,\n  FlightSegmentPath,\n  Segment,\n} from '../../../shared/lib/app-router-types'\nimport type { CacheNode } from '../../../shared/lib/app-router-types'\nimport type { HeadData } from '../../../shared/lib/app-router-types'\nimport {\n  PAGE_SEGMENT_KEY,\n  DEFAULT_SEGMENT_KEY,\n  NOT_FOUND_SEGMENT_KEY,\n} from '../../../shared/lib/segment'\nimport { matchSegment } from '../match-segments'\nimport { createHrefFromUrl } from './create-href-from-url'\nimport { fetchServerResponse } from './fetch-server-response'\nimport { dispatchAppRouterAction } from '../use-action-queue'\nimport {\n  ACTION_SERVER_PATCH,\n  type ServerPatchAction,\n} from './router-reducer-types'\nimport { isNavigatingToNewRootLayout } from './is-navigating-to-new-root-layout'\nimport {\n  convertServerPatchToFullTree,\n  type NavigationSeed,\n} from '../segment-cache/navigation'\nimport {\n  type RouteTree,\n  type RefreshState,\n  type FulfilledRouteCacheEntry,\n  convertReusedFlightRouterStateToRouteTree,\n  readSegmentCacheEntry,\n  waitForSegmentCacheEntry,\n  markRouteEntryAsDynamicRewrite,\n  invalidateRouteCacheEntries,\n  EntryStatus,\n} from '../segment-cache/cache'\nimport { discoverKnownRoute } from '../segment-cache/optimistic-routes'\nimport type { NormalizedSearch } from '../segment-cache/cache-key'\nimport {\n  getRenderedSearchFromVaryPath,\n  type PageVaryPath,\n} from '../segment-cache/vary-path'\nimport {\n  readFromBFCache,\n  readFromBFCacheDuringRegularNavigation,\n  writeToBFCache,\n  writeHeadToBFCache,\n} from '../segment-cache/bfcache'\nimport { DYNAMIC_STALETIME_MS } from './reducers/navigate-reducer'\n\n// This is yet another tree type that is used to track pending promises that\n// need to be fulfilled once the dynamic data is received. The terminal nodes of\n// this tree represent the new Cache Node trees that were created during this\n// request. We can't use the Cache Node tree or Route State tree directly\n// because those include reused nodes, too. This tree is discarded as soon as\n// the navigation response is received.\nexport type NavigationTask = {\n  status: NavigationTaskStatus\n  // The router state that corresponds to the tree that this Task represents.\n  route: FlightRouterState\n  // The CacheNode that corresponds to the tree that this Task represents.\n  node: CacheNode\n  // The tree sent to the server during the dynamic request. If all the segments\n  // are static, then this will be null, and no server request is required.\n  // Otherwise, this is the same as `route`, except with the `refetch` marker\n  // set on the top-most segment that needs to be fetched.\n  dynamicRequestTree: FlightRouterState | null\n  // The URL that should be used to fetch the dynamic data. This is only set\n  // when the segment cannot be refetched from the current route, because it's\n  // part of a \"default\" parallel slot that was reused during a navigation.\n  refreshState: RefreshState | null\n  children: Map<string, NavigationTask> | null\n}\n\nexport const enum FreshnessPolicy {\n  Default,\n  Hydration,\n  HistoryTraversal,\n  RefreshAll,\n  HMRRefresh,\n  Gesture,\n}\n\nconst enum NavigationTaskStatus {\n  Pending,\n  Fulfilled,\n  Rejected,\n}\n\n/**\n * When a NavigationTask finishes, there may or may not be data still missing,\n * necessitating a retry.\n */\nconst enum NavigationTaskExitStatus {\n  /**\n   * No additional navigation is required.\n   */\n  Done = 0,\n  /**\n   * Some data failed to load, presumably due to a route tree mismatch. Perform\n   * a soft retry to reload the entire tree.\n   */\n  SoftRetry = 1,\n  /**\n   * Some data failed to load in an unrecoverable way, e.g. in an inactive\n   * parallel route. Fall back to a hard (MPA-style) retry.\n   */\n  HardRetry = 2,\n}\n\nexport type NavigationRequestAccumulation = {\n  scrollableSegments: Array<FlightSegmentPath> | null\n  separateRefreshUrls: Set<string> | null\n}\n\nconst noop = () => {}\n\nexport function createInitialCacheNodeForHydration(\n  navigatedAt: number,\n  initialTree: RouteTree,\n  seedData: CacheNodeSeedData | null,\n  seedHead: HeadData\n): NavigationTask {\n  // Create the initial cache node tree, using the data embedded into the\n  // HTML document.\n  const accumulation: NavigationRequestAccumulation = {\n    scrollableSegments: null,\n    separateRefreshUrls: null,\n  }\n  const task = createCacheNodeOnNavigation(\n    navigatedAt,\n    initialTree,\n    null,\n    FreshnessPolicy.Hydration,\n    seedData,\n    seedHead,\n    null,\n    null,\n    false,\n    accumulation\n  )\n  return task\n}\n\n// Creates a new Cache Node tree (i.e. copy-on-write) that represents the\n// optimistic result of a navigation, using both the current Cache Node tree and\n// data that was prefetched prior to navigation.\n//\n// At the moment we call this function, we haven't yet received the navigation\n// response from the server. It could send back something completely different\n// from the tree that was prefetched  due to rewrites, default routes, parallel\n// routes, etc.\n//\n// But in most cases, it will return the same tree that we prefetched, just with\n// the dynamic holes filled in. So we optimistically assume this will happen,\n// and accept that the real result could be arbitrarily different.\n//\n// We'll reuse anything that was already in the previous tree, since that's what\n// the server does.\n//\n// New segments (ones that don't appear in the old tree) are assigned an\n// unresolved promise. The data for these promises will be fulfilled later, when\n// the navigation response is received.\n//\n// The tree can be rendered immediately after it is created (that's why this is\n// a synchronous function). Any new trees that do not have prefetch data will\n// suspend during rendering, until the dynamic data streams in.\n//\n// Returns a Task object, which contains both the updated Cache Node and a path\n// to the pending subtrees that need to be resolved by the navigation response.\n//\n// A return value of `null` means there were no changes, and the previous tree\n// can be reused without initiating a server request.\nexport function startPPRNavigation(\n  navigatedAt: number,\n  oldUrl: URL,\n  oldRenderedSearch: string,\n  oldCacheNode: CacheNode | null,\n  oldRouterState: FlightRouterState,\n  newRouteTree: RouteTree,\n  newMetadataVaryPath: PageVaryPath | null,\n  freshness: FreshnessPolicy,\n  seedData: CacheNodeSeedData | null,\n  seedHead: HeadData | null,\n  isSamePageNavigation: boolean,\n  accumulation: NavigationRequestAccumulation\n): NavigationTask | null {\n  const didFindRootLayout = false\n  const parentNeedsDynamicRequest = false\n  const parentRefreshState = null\n  const oldRootRefreshState: RefreshState = {\n    canonicalUrl: createHrefFromUrl(oldUrl),\n    renderedSearch: oldRenderedSearch as NormalizedSearch,\n  }\n  return updateCacheNodeOnNavigation(\n    navigatedAt,\n    oldUrl,\n    oldCacheNode !== null ? oldCacheNode : undefined,\n    oldRouterState,\n    newRouteTree,\n    newMetadataVaryPath,\n    freshness,\n    didFindRootLayout,\n    seedData,\n    seedHead,\n    isSamePageNavigation,\n    null,\n    null,\n    parentNeedsDynamicRequest,\n    oldRootRefreshState,\n    parentRefreshState,\n    accumulation\n  )\n}\n\nfunction updateCacheNodeOnNavigation(\n  navigatedAt: number,\n  oldUrl: URL,\n  oldCacheNode: CacheNode | void,\n  oldRouterState: FlightRouterState,\n  newRouteTree: RouteTree,\n  newMetadataVaryPath: PageVaryPath | null,\n  freshness: FreshnessPolicy,\n  didFindRootLayout: boolean,\n  seedData: CacheNodeSeedData | null,\n  seedHead: HeadData | null,\n  isSamePageNavigation: boolean,\n  parentSegmentPath: FlightSegmentPath | null,\n  parentParallelRouteKey: string | null,\n  parentNeedsDynamicRequest: boolean,\n  oldRootRefreshState: RefreshState,\n  parentRefreshState: RefreshState | null,\n  accumulation: NavigationRequestAccumulation\n): NavigationTask | null {\n  // Check if this segment matches the one in the previous route.\n  const oldSegment = oldRouterState[0]\n  const newSegment = createSegmentFromRouteTree(newRouteTree)\n  if (!matchSegment(newSegment, oldSegment)) {\n    // This segment does not match the previous route. We're now entering the\n    // new part of the target route. Switch to the \"create\" path.\n    if (\n      // Check if the route tree changed before we reached a layout. (The\n      // highest-level layout in a route tree is referred to as the \"root\"\n      // layout.) This could mean that we're navigating between two different\n      // root layouts. When this happens, we perform a full-page (MPA-style)\n      // navigation.\n      //\n      // However, the algorithm for deciding where to start rendering a route\n      // (i.e. the one performed in order to reach this function) is stricter\n      // than the one used to detect a change in the root layout. So just\n      // because we're re-rendering a segment outside of the root layout does\n      // not mean we should trigger a full-page navigation.\n      //\n      // Specifically, we handle dynamic parameters differently: two segments\n      // are considered the same even if their parameter values are different.\n      //\n      // Refer to isNavigatingToNewRootLayout for details.\n      //\n      // Note that we only have to perform this extra traversal if we didn't\n      // already discover a root layout in the part of the tree that is\n      // unchanged. We also only need to compare the subtree that is not\n      // shared. In the common case, this branch is skipped completely.\n      (!didFindRootLayout &&\n        isNavigatingToNewRootLayout(oldRouterState, newRouteTree)) ||\n      // The global Not Found route (app/global-not-found.tsx) is a special\n      // case, because it acts like a root layout, but in the router tree, it\n      // is rendered in the same position as app/layout.tsx.\n      //\n      // Any navigation to the global Not Found route should trigger a\n      // full-page navigation.\n      //\n      // TODO: We should probably model this by changing the key of the root\n      // segment when this happens. Then the root layout check would work\n      // as expected, without a special case.\n      newSegment === NOT_FOUND_SEGMENT_KEY\n    ) {\n      return null\n    }\n    if (parentSegmentPath === null || parentParallelRouteKey === null) {\n      // The root should never mismatch. If it does, it suggests an internal\n      // Next.js error, or a malformed server response. Trigger a full-\n      // page navigation.\n      return null\n    }\n    return createCacheNodeOnNavigation(\n      navigatedAt,\n      newRouteTree,\n      newMetadataVaryPath,\n      freshness,\n      seedData,\n      seedHead,\n      parentSegmentPath,\n      parentParallelRouteKey,\n      parentNeedsDynamicRequest,\n      accumulation\n    )\n  }\n\n  // TODO: The segment paths are tracked so that LayoutRouter knows which\n  // segments to scroll to after a navigation. But we should just mark this\n  // information on the CacheNode directly. It used to be necessary to do this\n  // separately because CacheNodes were created lazily during render, not when\n  // rather than when creating the route tree.\n  const segmentPath =\n    parentParallelRouteKey !== null && parentSegmentPath !== null\n      ? parentSegmentPath.concat([parentParallelRouteKey, newSegment])\n      : // NOTE: The root segment is intentionally omitted from the segment path\n        []\n\n  const newSlots = newRouteTree.slots\n  const oldRouterStateChildren = oldRouterState[1]\n  const seedDataChildren = seedData !== null ? seedData[1] : null\n\n  // We're currently traversing the part of the tree that was also part of\n  // the previous route. If we discover a root layout, then we don't need to\n  // trigger an MPA navigation.\n  const childDidFindRootLayout = didFindRootLayout || newRouteTree.isRootLayout\n\n  let shouldRefreshDynamicData: boolean = false\n  switch (freshness) {\n    case FreshnessPolicy.Default:\n    case FreshnessPolicy.HistoryTraversal:\n    case FreshnessPolicy.Hydration: // <- shouldn't happen during client nav\n    case FreshnessPolicy.Gesture:\n      // We should never drop dynamic data in shared layouts, except during\n      // a refresh.\n      shouldRefreshDynamicData = false\n      break\n    case FreshnessPolicy.RefreshAll:\n    case FreshnessPolicy.HMRRefresh:\n      shouldRefreshDynamicData = true\n      break\n    default:\n      freshness satisfies never\n      break\n  }\n\n  // TODO: We're not consistent about how we do this check. Some places\n  // check if the segment starts with PAGE_SEGMENT_KEY, but most seem to\n  // check if there any any children, which is why I'm doing it here. We\n  // should probably encode an empty children set as `null` though. Either\n  // way, we should update all the checks to be consistent.\n  const isLeafSegment = newSlots === null\n\n  // Get the data for this segment. Since it was part of the previous route,\n  // usually we just clone the data from the old CacheNode. However, during a\n  // refresh or a revalidation, there won't be any existing CacheNode. So we\n  // may need to consult the prefetch cache, like we would for a new segment.\n  let newCacheNode: CacheNode\n  let needsDynamicRequest: boolean\n  if (\n    oldCacheNode !== undefined &&\n    !shouldRefreshDynamicData &&\n    // During a same-page navigation, we always refetch the page segments\n    !(isLeafSegment && isSamePageNavigation)\n  ) {\n    // Reuse the existing CacheNode\n    const dropPrefetchRsc = false\n    newCacheNode = reuseSharedCacheNode(dropPrefetchRsc, oldCacheNode)\n    needsDynamicRequest = false\n  } else {\n    // If this is part of a refresh, ignore the existing CacheNode and create a\n    // new one.\n    const seedRsc = seedData !== null ? seedData[0] : null\n    const result = createCacheNodeForSegment(\n      navigatedAt,\n      newRouteTree,\n      seedRsc,\n      newMetadataVaryPath,\n      seedHead,\n      freshness\n    )\n    newCacheNode = result.cacheNode\n    needsDynamicRequest = result.needsDynamicRequest\n  }\n\n  // During a refresh navigation, there's a special case that happens when\n  // entering a \"default\" slot. The default slot may not be part of the\n  // current route; it may have been reused from an older route. If so,\n  // we need to fetch its data from the old route's URL rather than current\n  // route's URL. Keep track of this as we traverse the tree.\n  const maybeRefreshState = newRouteTree.refreshState\n  const refreshState =\n    maybeRefreshState !== undefined && maybeRefreshState !== null\n      ? // This segment is not present in the current route. Track its\n        // refresh URL as we continue traversing the tree.\n        maybeRefreshState\n      : // Inherit the refresh URL from the parent.\n        parentRefreshState\n\n  // If this segment itself needs to fetch new data from the server, then by\n  // definition it is being refreshed. Track its refresh URL so we know which\n  // URL to request the data from.\n  if (needsDynamicRequest && refreshState !== null) {\n    accumulateRefreshUrl(accumulation, refreshState)\n  }\n\n  // As we diff the trees, we may sometimes modify (copy-on-write, not mutate)\n  // the Route Tree that was returned by the server  for example, in the case\n  // of default parallel routes, we preserve the currently active segment. To\n  // avoid mutating the original tree, we clone the router state children along\n  // the return path.\n  let patchedRouterStateChildren: {\n    [parallelRouteKey: string]: FlightRouterState\n  } = {}\n  let taskChildren = null\n\n  // Most navigations require a request to fetch additional data from the\n  // server, either because the data was not already prefetched, or because the\n  // target route contains dynamic data that cannot be prefetched.\n  //\n  // However, if the target route is fully static, and it's already completely\n  // loaded into the segment cache, then we can skip the server request.\n  //\n  // This starts off as `false`, and is set to `true` if any of the child\n  // routes requires a dynamic request.\n  let childNeedsDynamicRequest = false\n  // As we traverse the children, we'll construct a FlightRouterState that can\n  // be sent to the server to request the dynamic data. If it turns out that\n  // nothing in the subtree is dynamic (i.e. childNeedsDynamicRequest is false\n  // at the end), then this will be discarded.\n  // TODO: We can probably optimize the format of this data structure to only\n  // include paths that are dynamic. Instead of reusing the\n  // FlightRouterState type.\n  let dynamicRequestTreeChildren: {\n    [parallelRouteKey: string]: FlightRouterState\n  } = {}\n\n  let newCacheNodeSlots: Record<string, CacheNode> | null = null\n  if (newSlots !== null) {\n    const oldCacheNodeSlots =\n      oldCacheNode !== undefined ? oldCacheNode.slots : null\n\n    newCacheNode.slots = newCacheNodeSlots = {}\n    taskChildren = new Map()\n    for (let parallelRouteKey in newSlots) {\n      let newRouteTreeChild: RouteTree = newSlots[parallelRouteKey]\n      const oldRouterStateChild: FlightRouterState | void =\n        oldRouterStateChildren[parallelRouteKey]\n      if (oldRouterStateChild === undefined) {\n        // This should never happen, but if it does, it suggests a malformed\n        // server response. Trigger a full-page navigation.\n        return null\n      }\n\n      let seedDataChild: CacheNodeSeedData | void | null =\n        seedDataChildren !== null ? seedDataChildren[parallelRouteKey] : null\n\n      const oldSegmentChild = oldRouterStateChild[0]\n      let newSegmentChild = createSegmentFromRouteTree(newRouteTreeChild)\n      let seedHeadChild = seedHead\n      if (\n        // Skip this branch during a history traversal. We restore the tree that\n        // was stashed in the history entry as-is.\n        freshness !== FreshnessPolicy.HistoryTraversal &&\n        newSegmentChild === DEFAULT_SEGMENT_KEY &&\n        oldSegmentChild !== DEFAULT_SEGMENT_KEY\n      ) {\n        // This is a \"default\" segment. These are never sent by the server during\n        // a soft navigation; instead, the client reuses whatever segment was\n        // already active in that slot on the previous route.\n        newRouteTreeChild = reuseActiveSegmentInDefaultSlot(\n          newRouteTree,\n          parallelRouteKey,\n          oldRootRefreshState,\n          oldRouterStateChild\n        )\n        newSegmentChild = createSegmentFromRouteTree(newRouteTreeChild)\n\n        // Since we're switching to a different route tree, these are no\n        // longer valid, because they correspond to the outer tree.\n        seedDataChild = null\n        seedHeadChild = null\n      }\n\n      const oldCacheNodeChild =\n        oldCacheNodeSlots !== null\n          ? oldCacheNodeSlots[parallelRouteKey]\n          : undefined\n\n      const taskChild = updateCacheNodeOnNavigation(\n        navigatedAt,\n        oldUrl,\n        oldCacheNodeChild,\n        oldRouterStateChild,\n        newRouteTreeChild,\n        newMetadataVaryPath,\n        freshness,\n        childDidFindRootLayout,\n        seedDataChild ?? null,\n        seedHeadChild,\n        isSamePageNavigation,\n        segmentPath,\n        parallelRouteKey,\n        parentNeedsDynamicRequest || needsDynamicRequest,\n        oldRootRefreshState,\n        refreshState,\n        accumulation\n      )\n\n      if (taskChild === null) {\n        // One of the child tasks discovered a change to the root layout.\n        // Immediately unwind from this recursive traversal. This will trigger a\n        // full-page navigation.\n        return null\n      }\n\n      // Recursively propagate up the child tasks.\n      taskChildren.set(parallelRouteKey, taskChild)\n      newCacheNodeSlots[parallelRouteKey] = taskChild.node\n\n      // The child tree's route state may be different from the prefetched\n      // route sent by the server. We need to clone it as we traverse back up\n      // the tree.\n      const taskChildRoute = taskChild.route\n      patchedRouterStateChildren[parallelRouteKey] = taskChildRoute\n\n      const dynamicRequestTreeChild = taskChild.dynamicRequestTree\n      if (dynamicRequestTreeChild !== null) {\n        // Something in the child tree is dynamic.\n        childNeedsDynamicRequest = true\n        dynamicRequestTreeChildren[parallelRouteKey] = dynamicRequestTreeChild\n      } else {\n        dynamicRequestTreeChildren[parallelRouteKey] = taskChildRoute\n      }\n    }\n  }\n\n  const newFlightRouterState: FlightRouterState = [\n    createSegmentFromRouteTree(newRouteTree),\n    patchedRouterStateChildren,\n    refreshState !== null\n      ? [refreshState.canonicalUrl, refreshState.renderedSearch]\n      : null,\n    null,\n    newRouteTree.isRootLayout,\n  ]\n\n  return {\n    status: needsDynamicRequest\n      ? NavigationTaskStatus.Pending\n      : NavigationTaskStatus.Fulfilled,\n    route: newFlightRouterState,\n    node: newCacheNode,\n    dynamicRequestTree: createDynamicRequestTree(\n      newFlightRouterState,\n      dynamicRequestTreeChildren,\n      needsDynamicRequest,\n      childNeedsDynamicRequest,\n      parentNeedsDynamicRequest\n    ),\n    refreshState,\n    children: taskChildren,\n  }\n}\n\nfunction createCacheNodeOnNavigation(\n  navigatedAt: number,\n  newRouteTree: RouteTree,\n  newMetadataVaryPath: PageVaryPath | null,\n  freshness: FreshnessPolicy,\n  seedData: CacheNodeSeedData | null,\n  seedHead: HeadData | null,\n  parentSegmentPath: FlightSegmentPath | null,\n  parentParallelRouteKey: string | null,\n  parentNeedsDynamicRequest: boolean,\n  accumulation: NavigationRequestAccumulation\n): NavigationTask {\n  // Same traversal as updateCacheNodeNavigation, but simpler. We switch to this\n  // path once we reach the part of the tree that was not in the previous route.\n  // We don't need to diff against the old tree, we just need to create a new\n  // one. We also don't need to worry about any refresh-related logic.\n  //\n  // For the most part, this is a subset of updateCacheNodeOnNavigation, so any\n  // change that happens in this function likely needs to be applied to that\n  // one, too. However there are some places where the behavior intentionally\n  // diverges, which is why we keep them separate.\n\n  const newSegment = createSegmentFromRouteTree(newRouteTree)\n  const segmentPath =\n    parentParallelRouteKey !== null && parentSegmentPath !== null\n      ? parentSegmentPath.concat([parentParallelRouteKey, newSegment])\n      : // NOTE: The root segment is intentionally omitted from the segment path\n        []\n\n  const newSlots = newRouteTree.slots\n  const seedDataChildren = seedData !== null ? seedData[1] : null\n\n  const isLeafSegment = newSlots === null\n\n  if (isLeafSegment) {\n    // The segment path of every leaf segment (i.e. page) is collected into\n    // a result array. This is used by the LayoutRouter to scroll to ensure that\n    // new pages are visible after a navigation.\n    //\n    // This only happens for new pages, not for refreshed pages.\n    //\n    // TODO: We should use a string to represent the segment path instead of\n    // an array. We already use a string representation for the path when\n    // accessing the Segment Cache, so we can use the same one.\n    if (accumulation.scrollableSegments === null) {\n      accumulation.scrollableSegments = []\n    }\n    accumulation.scrollableSegments.push(segmentPath)\n  }\n\n  const seedRsc = seedData !== null ? seedData[0] : null\n  const result = createCacheNodeForSegment(\n    navigatedAt,\n    newRouteTree,\n    seedRsc,\n    newMetadataVaryPath,\n    seedHead,\n    freshness\n  )\n  const newCacheNode = result.cacheNode\n  const needsDynamicRequest = result.needsDynamicRequest\n\n  let patchedRouterStateChildren: {\n    [parallelRouteKey: string]: FlightRouterState\n  } = {}\n  let taskChildren = null\n\n  let childNeedsDynamicRequest = false\n  let dynamicRequestTreeChildren: {\n    [parallelRouteKey: string]: FlightRouterState\n  } = {}\n\n  let newCacheNodeSlots: Record<string, CacheNode> | null = null\n  if (newSlots !== null) {\n    newCacheNode.slots = newCacheNodeSlots = {}\n    taskChildren = new Map()\n    for (let parallelRouteKey in newSlots) {\n      const newRouteTreeChild: RouteTree = newSlots[parallelRouteKey]\n      const seedDataChild: CacheNodeSeedData | void | null =\n        seedDataChildren !== null ? seedDataChildren[parallelRouteKey] : null\n\n      const taskChild = createCacheNodeOnNavigation(\n        navigatedAt,\n        newRouteTreeChild,\n        newMetadataVaryPath,\n        freshness,\n        seedDataChild ?? null,\n        seedHead,\n        segmentPath,\n        parallelRouteKey,\n        parentNeedsDynamicRequest || needsDynamicRequest,\n        accumulation\n      )\n\n      taskChildren.set(parallelRouteKey, taskChild)\n      newCacheNodeSlots[parallelRouteKey] = taskChild.node\n\n      const taskChildRoute = taskChild.route\n      patchedRouterStateChildren[parallelRouteKey] = taskChildRoute\n\n      const dynamicRequestTreeChild = taskChild.dynamicRequestTree\n      if (dynamicRequestTreeChild !== null) {\n        childNeedsDynamicRequest = true\n        dynamicRequestTreeChildren[parallelRouteKey] = dynamicRequestTreeChild\n      } else {\n        dynamicRequestTreeChildren[parallelRouteKey] = taskChildRoute\n      }\n    }\n  }\n\n  const newFlightRouterState: FlightRouterState = [\n    newSegment,\n    patchedRouterStateChildren,\n    null,\n    null,\n    newRouteTree.isRootLayout,\n  ]\n\n  return {\n    status: needsDynamicRequest\n      ? NavigationTaskStatus.Pending\n      : NavigationTaskStatus.Fulfilled,\n    route: newFlightRouterState,\n    node: newCacheNode,\n    dynamicRequestTree: createDynamicRequestTree(\n      newFlightRouterState,\n      dynamicRequestTreeChildren,\n      needsDynamicRequest,\n      childNeedsDynamicRequest,\n      parentNeedsDynamicRequest\n    ),\n    // This route is not part of the current tree, so there's no reason to\n    // track the refresh URL.\n    refreshState: null,\n    children: taskChildren,\n  }\n}\n\nfunction createSegmentFromRouteTree(newRouteTree: RouteTree): Segment {\n  if (newRouteTree.isPage) {\n    // In a dynamic server response, the server embeds the search params into\n    // the segment key, but in a static one it's omitted. The client handles\n    // this inconsistency by adding the search params back right at the end.\n    //\n    // TODO: The only thing this is used for is to create a cache key for\n    // ChildSegmentMap. But we already track the `renderedSearch` everywhere as\n    // part of the varyPath. The plan is get rid of ChildSegmentMap and\n    // store the page data in a CacheMap using the varyPath, like we do\n    // for prefetches. Then we can remove it from the segment key.\n    //\n    // As an incremental step, we can grab the search params from the varyPath.\n    const renderedSearch = getRenderedSearchFromVaryPath(newRouteTree.varyPath)\n    if (renderedSearch === null) {\n      return PAGE_SEGMENT_KEY\n    }\n    // This is based on equivalent logic in addSearchParamsIfPageSegment, used\n    // on the server.\n    const stringifiedQuery = JSON.stringify(\n      Object.fromEntries(new URLSearchParams(renderedSearch))\n    )\n    return stringifiedQuery !== '{}'\n      ? PAGE_SEGMENT_KEY + '?' + stringifiedQuery\n      : PAGE_SEGMENT_KEY\n  }\n  return newRouteTree.segment\n}\n\nfunction patchRouterStateWithNewChildren(\n  baseRouterState: FlightRouterState,\n  newChildren: { [parallelRouteKey: string]: FlightRouterState }\n): FlightRouterState {\n  const clone: FlightRouterState = [baseRouterState[0], newChildren]\n  // Based on equivalent logic in apply-router-state-patch-to-tree, but should\n  // confirm whether we need to copy all of these fields. Not sure the server\n  // ever sends, e.g. the refetch marker.\n  if (2 in baseRouterState) {\n    clone[2] = baseRouterState[2]\n  }\n  if (3 in baseRouterState) {\n    clone[3] = baseRouterState[3]\n  }\n  if (4 in baseRouterState) {\n    clone[4] = baseRouterState[4]\n  }\n  return clone\n}\n\nfunction createDynamicRequestTree(\n  newRouterState: FlightRouterState,\n  dynamicRequestTreeChildren: Record<string, FlightRouterState>,\n  needsDynamicRequest: boolean,\n  childNeedsDynamicRequest: boolean,\n  parentNeedsDynamicRequest: boolean\n): FlightRouterState | null {\n  // Create a FlightRouterState that instructs the server how to render the\n  // requested segment.\n  //\n  // Or, if neither this segment nor any of the children require a new data,\n  // then we return `null` to skip the request.\n  let dynamicRequestTree: FlightRouterState | null = null\n  if (needsDynamicRequest) {\n    dynamicRequestTree = patchRouterStateWithNewChildren(\n      newRouterState,\n      dynamicRequestTreeChildren\n    )\n    // The \"refetch\" marker is set on the top-most segment that requires new\n    // data. We can omit it if a parent was already marked.\n    if (!parentNeedsDynamicRequest) {\n      dynamicRequestTree[3] = 'refetch'\n    }\n  } else if (childNeedsDynamicRequest) {\n    // This segment does not request new data, but at least one of its\n    // children does.\n    dynamicRequestTree = patchRouterStateWithNewChildren(\n      newRouterState,\n      dynamicRequestTreeChildren\n    )\n  } else {\n    dynamicRequestTree = null\n  }\n  return dynamicRequestTree\n}\n\nfunction accumulateRefreshUrl(\n  accumulation: NavigationRequestAccumulation,\n  refreshState: RefreshState\n) {\n  // This is a refresh navigation, and we're inside a \"default\" slot that's\n  // not part of the current route; it was reused from an older route. In\n  // order to get fresh data for this reused route, we need to issue a\n  // separate request using the old route's URL.\n  //\n  // Track these extra URLs in the accumulated result. Later, we'll construct\n  // an appropriate request for each unique URL in the final set. The reason\n  // we don't do it immediately here is so we can deduplicate multiple\n  // instances of the same URL into a single request. See\n  // listenForDynamicRequest for more details.\n  const refreshUrl = refreshState.canonicalUrl\n  const separateRefreshUrls = accumulation.separateRefreshUrls\n  if (separateRefreshUrls === null) {\n    accumulation.separateRefreshUrls = new Set([refreshUrl])\n  } else {\n    separateRefreshUrls.add(refreshUrl)\n  }\n}\n\nfunction reuseActiveSegmentInDefaultSlot(\n  parentRouteTree: RouteTree,\n  parallelRouteKey: string,\n  oldRootRefreshState: RefreshState,\n  oldRouterState: FlightRouterState\n): RouteTree {\n  // This is a \"default\" segment. These are never sent by the server during a\n  // soft navigation; instead, the client reuses whatever segment was already\n  // active in that slot on the previous route. This means if we later need to\n  // refresh the segment, it will have to be refetched from the previous route's\n  // URL. We store it in the Flight Router State.\n\n  let reusedUrl: string\n  let reusedRenderedSearch: NormalizedSearch\n  const oldRefreshState = oldRouterState[2]\n  if (oldRefreshState !== undefined && oldRefreshState !== null) {\n    // This segment was already reused from an even older route. Keep its\n    // existing URL and refresh state.\n    reusedUrl = oldRefreshState[0]\n    reusedRenderedSearch = oldRefreshState[1] as NormalizedSearch\n  } else {\n    // Since this route didn't already have a refresh state, it must have been\n    // reachable from the root of the old route. So we use the refresh state\n    // that represents the old route.\n    reusedUrl = oldRootRefreshState.canonicalUrl\n    reusedRenderedSearch = oldRootRefreshState.renderedSearch\n  }\n\n  const acc = { metadataVaryPath: null }\n  const reusedRouteTree = convertReusedFlightRouterStateToRouteTree(\n    parentRouteTree,\n    parallelRouteKey,\n    oldRouterState,\n    reusedRenderedSearch,\n    acc\n  )\n  reusedRouteTree.refreshState = {\n    canonicalUrl: reusedUrl,\n    renderedSearch: reusedRenderedSearch,\n  }\n  return reusedRouteTree\n}\n\nfunction reuseSharedCacheNode(\n  dropPrefetchRsc: boolean,\n  existingCacheNode: CacheNode\n): CacheNode {\n  // Clone the CacheNode that was already present in the previous tree\n  return createCacheNode(\n    existingCacheNode.rsc,\n    dropPrefetchRsc ? null : existingCacheNode.prefetchRsc,\n    existingCacheNode.head,\n    dropPrefetchRsc ? null : existingCacheNode.prefetchHead\n  )\n}\n\nfunction createCacheNodeForSegment(\n  now: number,\n  tree: RouteTree,\n  seedRsc: React.ReactNode | null,\n  metadataVaryPath: PageVaryPath | null,\n  seedHead: HeadData | null,\n  freshness: FreshnessPolicy\n): { cacheNode: CacheNode; needsDynamicRequest: boolean } {\n  // Construct a new CacheNode using data from the BFCache, the client's\n  // Segment Cache, or seeded from a server response.\n  //\n  // If there's a cache miss, or if we only have a partial hit, we'll render\n  // the partial state immediately, and spawn a request to the server to fill\n  // in the missing data.\n  //\n  // If the segment is fully cached on the client already, we can omit this\n  // segment from the server request.\n  //\n  // If we already have a dynamic data response associated with this navigation,\n  // as in the case of a Server Action-initiated redirect or refresh, we may\n  // also be able to use that data without spawning a new request. (This is\n  // referred to as the \"seed\" data.)\n\n  const isPage = tree.isPage\n\n  // During certain kinds of navigations, we may be able to render from\n  // the BFCache.\n  switch (freshness) {\n    case FreshnessPolicy.Default: {\n      // When experimental.staleTimes.dynamic config is set, we read from the\n      // BFCache even during regular navigations. (This is not a recommended API\n      // with Cache Components, but it's supported for backwards compatibility.\n      // Use cacheLife instead.)\n\n      // This outer check isn't semantically necessary; even if the configured\n      // stale time is 0, the bfcache will return null, because any entry would\n      // have immediately expired. Just an optimization.\n      if (DYNAMIC_STALETIME_MS > 0) {\n        const bfcacheEntry = readFromBFCacheDuringRegularNavigation(\n          now,\n          tree.varyPath\n        )\n        if (bfcacheEntry !== null) {\n          return {\n            cacheNode: createCacheNode(\n              bfcacheEntry.rsc,\n              bfcacheEntry.prefetchRsc,\n              bfcacheEntry.head,\n              bfcacheEntry.prefetchHead\n            ),\n            needsDynamicRequest: false,\n          }\n        }\n      }\n      break\n    }\n    case FreshnessPolicy.Hydration: {\n      // This is not related to the BFCache but it is a special case.\n      //\n      // We should never spawn network requests during hydration. We must treat\n      // the initial payload as authoritative, because the initial page load is\n      // used as a last-ditch mechanism for recovering the app.\n      //\n      // This is also an important safety check because if this leaks into the\n      // server rendering path (which theoretically it never should because the\n      // server payload should be consistent), the server would hang because these\n      // promises would never resolve.\n      //\n      // TODO: There is an existing case where the global \"not found\" boundary\n      // triggers this path. But it does render correctly despite that. That's an\n      // unusual render path so it's not surprising, but we should look into\n      // modeling it in a more consistent way. See also the /_notFound special\n      // case in updateCacheNodeOnNavigation.\n      const rsc = seedRsc\n      const prefetchRsc = null\n      const head = isPage ? seedHead : null\n      const prefetchHead = null\n      writeToBFCache(now, tree.varyPath, rsc, prefetchRsc, head, prefetchHead)\n      if (isPage && metadataVaryPath !== null) {\n        writeHeadToBFCache(now, metadataVaryPath, head, prefetchHead)\n      }\n      return {\n        cacheNode: createCacheNode(rsc, prefetchRsc, head, prefetchHead),\n        needsDynamicRequest: false,\n      }\n    }\n    case FreshnessPolicy.HistoryTraversal:\n      const bfcacheEntry = readFromBFCache(tree.varyPath)\n      if (bfcacheEntry !== null) {\n        // Only show prefetched data if the dynamic data is still pending. This\n        // avoids a flash back to the prefetch state in a case where it's highly\n        // likely to have already streamed in.\n        //\n        // Tehnically, what we're actually checking is whether the dynamic\n        // network response was received. But since it's a streaming response,\n        // this does not mean that all the dynamic data has fully streamed in.\n        // It just means that _some_ of the dynamic data was received. But as a\n        // heuristic, we assume that the rest dynamic data will stream in\n        // quickly, so it's still better to skip the prefetch state.\n        const oldRsc = bfcacheEntry.rsc\n        const oldRscDidResolve =\n          !isDeferredRsc(oldRsc) || oldRsc.status !== 'pending'\n        const dropPrefetchRsc = oldRscDidResolve\n        return {\n          cacheNode: createCacheNode(\n            bfcacheEntry.rsc,\n            dropPrefetchRsc ? null : bfcacheEntry.prefetchRsc,\n            bfcacheEntry.head,\n            dropPrefetchRsc ? null : bfcacheEntry.prefetchHead\n          ),\n          needsDynamicRequest: false,\n        }\n      }\n      break\n    case FreshnessPolicy.RefreshAll:\n    case FreshnessPolicy.HMRRefresh:\n    case FreshnessPolicy.Gesture:\n      // Don't consult the BFCache.\n      break\n    default:\n      freshness satisfies never\n      break\n  }\n\n  let cachedRsc: React.ReactNode | null = null\n  let isCachedRscPartial: boolean = true\n\n  const segmentEntry = readSegmentCacheEntry(now, tree.varyPath)\n  if (segmentEntry !== null) {\n    switch (segmentEntry.status) {\n      case EntryStatus.Fulfilled: {\n        // Happy path: a cache hit\n        cachedRsc = segmentEntry.rsc\n        isCachedRscPartial = segmentEntry.isPartial\n        break\n      }\n      case EntryStatus.Pending: {\n        // We haven't received data for this segment yet, but there's already\n        // an in-progress request. Since it's extremely likely to arrive\n        // before the dynamic data response, we might as well use it.\n        const promiseForFulfilledEntry = waitForSegmentCacheEntry(segmentEntry)\n        cachedRsc = promiseForFulfilledEntry.then((entry) =>\n          entry !== null ? entry.rsc : null\n        )\n        // Because the request is still pending, we typically don't know yet\n        // whether the response will be partial. We shouldn't skip this segment\n        // during the dynamic navigation request. Otherwise, we might need to\n        // do yet another request to fill in the remaining data, creating\n        // a waterfall.\n        //\n        // The one exception is if this segment is being fetched with via\n        // prefetch={true} (i.e. the \"force stale\" or \"full\" strategy). If so,\n        // we can assume the response will be full. This field is set to `false`\n        // for such segments.\n        isCachedRscPartial = segmentEntry.isPartial\n        break\n      }\n      case EntryStatus.Empty:\n      case EntryStatus.Rejected: {\n        break\n      }\n      default: {\n        segmentEntry satisfies never\n        break\n      }\n    }\n  }\n\n  // Now combine the cached data with the seed data to determine what we can\n  // render immediately, versus what needs to stream in later.\n\n  // A partial state to show immediately while we wait for the final data to\n  // arrive. If `rsc` is already a complete value (not partial), or if we\n  // don't have any useful partial state, this will be `null`.\n  let prefetchRsc: React.ReactNode | null\n  // The final, resolved segment data. If the data is missing, this will be a\n  // promise that resolves to the eventual data. A resolved value of `null`\n  // means the data failed to load; the LayoutRouter will suspend indefinitely\n  // until the router updates again (refer to finishNavigationTask).\n  let rsc: React.ReactNode | null\n  let doesSegmentNeedDynamicRequest: boolean\n\n  if (seedRsc !== null) {\n    // We already have a dynamic server response for this segment.\n    if (isCachedRscPartial) {\n      // The seed data may still be streaming in, so it's worth showing the\n      // partial cached state in the meantime.\n      prefetchRsc = cachedRsc\n      rsc = seedRsc\n    } else {\n      // We already have a completely cached segment. Ignore the seed data,\n      // which may still be streaming in. This shouldn't happen in the normal\n      // case because the client will inform the server which segments are\n      // already fully cached, and the server will skip rendering them.\n      prefetchRsc = null\n      rsc = cachedRsc\n    }\n    doesSegmentNeedDynamicRequest = false\n  } else {\n    if (isCachedRscPartial) {\n      // The cached data contains dynamic holes, or it's missing entirely. We'll\n      // show the partial state immediately (if available), and stream in the\n      // final data.\n      //\n      // Create a pending promise that we can later write to when the\n      // data arrives from the server.\n      prefetchRsc = cachedRsc\n      rsc = createDeferredRsc()\n    } else {\n      // The data is fully cached.\n      prefetchRsc = null\n      rsc = cachedRsc\n    }\n    doesSegmentNeedDynamicRequest = isCachedRscPartial\n  }\n\n  // If this is a page segment, we need to do the same for the head. This\n  // follows analogous logic to the segment data above.\n  // TODO: We don't need to store the head on the page segment's CacheNode; we\n  // can lift it to the main state object. Then we can also delete\n  // findHeadCache.\n\n  let prefetchHead: HeadData | null = null\n  let head: React.ReactNode | null = null\n  let doesHeadNeedDynamicRequest: boolean = isPage\n\n  if (isPage) {\n    let cachedHead: HeadData | null = null\n    let isCachedHeadPartial: boolean = true\n    if (metadataVaryPath !== null) {\n      const metadataEntry = readSegmentCacheEntry(now, metadataVaryPath)\n      if (metadataEntry !== null) {\n        switch (metadataEntry.status) {\n          case EntryStatus.Fulfilled: {\n            cachedHead = metadataEntry.rsc\n            isCachedHeadPartial = metadataEntry.isPartial\n            break\n          }\n          case EntryStatus.Pending: {\n            cachedHead = waitForSegmentCacheEntry(metadataEntry).then(\n              (entry) => (entry !== null ? entry.rsc : null)\n            )\n            isCachedHeadPartial = metadataEntry.isPartial\n            break\n          }\n          case EntryStatus.Empty:\n          case EntryStatus.Rejected: {\n            break\n          }\n          default: {\n            metadataEntry satisfies never\n            break\n          }\n        }\n      }\n    }\n\n    if (process.env.__NEXT_OPTIMISTIC_ROUTING && isCachedHeadPartial) {\n      // TODO: When optimistic routing is enabled, don't block on waiting for\n      // the viewport to resolve. This is a temporary workaround until Vary\n      // Params are tracked when rendering the metadata. We'll fix it before\n      // this feature is stable. However, it's not a critical issue because 1)\n      // it will stream in eventually anyway 2) metadata is wrapped in an\n      // internal Suspense boundary, so is always non-blocking; this only\n      // affects the viewport node, which is meant to blocking, however... 3)\n      // before Segment Cache landed this wasn't always the case, anyway, so\n      // it's unlikely that many people are relying on this behavior. Still,\n      // will be fixed before stable. It's the very next step in the sequence of\n      // work on this project.\n      //\n      // This line of code works because the App Router treats `null` as\n      // \"no renderable head available\", rather than an empty head. React treats\n      // an empty string as empty.\n      cachedHead = ''\n    }\n\n    if (seedHead !== null) {\n      if (isCachedHeadPartial) {\n        prefetchHead = cachedHead\n        head = seedHead\n      } else {\n        prefetchHead = null\n        head = cachedHead\n      }\n      doesHeadNeedDynamicRequest = false\n    } else {\n      if (isCachedHeadPartial) {\n        prefetchHead = cachedHead\n        head = createDeferredRsc()\n      } else {\n        prefetchHead = null\n        head = cachedHead\n      }\n      doesHeadNeedDynamicRequest = isCachedHeadPartial\n    }\n  }\n\n  // Now that we're creating a new segment, write its data to the BFCache. A\n  // subsequent back/forward navigation will reuse this same data, until or\n  // unless it's cleared by a refresh/revalidation.\n  //\n  // Skip BFCache writes for optimistic navigations since they are transient\n  // and will be replaced by the canonical navigation.\n  if (freshness !== FreshnessPolicy.Gesture) {\n    writeToBFCache(now, tree.varyPath, rsc, prefetchRsc, head, prefetchHead)\n    if (isPage && metadataVaryPath !== null) {\n      writeHeadToBFCache(now, metadataVaryPath, head, prefetchHead)\n    }\n  }\n\n  return {\n    cacheNode: createCacheNode(rsc, prefetchRsc, head, prefetchHead),\n    // TODO: We should store this field on the CacheNode itself. I think we can\n    // probably unify NavigationTask, CacheNode, and DeferredRsc into a\n    // single type. Or at least CacheNode and DeferredRsc.\n    needsDynamicRequest:\n      doesSegmentNeedDynamicRequest || doesHeadNeedDynamicRequest,\n  }\n}\n\nfunction createCacheNode(\n  rsc: React.ReactNode | null,\n  prefetchRsc: React.ReactNode | null,\n  head: React.ReactNode | null,\n  prefetchHead: HeadData | null\n): CacheNode {\n  return {\n    rsc,\n    prefetchRsc,\n    head,\n    prefetchHead,\n    slots: null,\n  }\n}\n\n// Represents whether the previuos navigation resulted in a route tree mismatch.\n// A mismatch results in a refresh of the page. If there are two successive\n// mismatches, we will fall back to an MPA navigation, to prevent a retry loop.\nlet previousNavigationDidMismatch = false\n\n// Writes a dynamic server response into the tree created by\n// updateCacheNodeOnNavigation. All pending promises that were spawned by the\n// navigation will be resolved, either with dynamic data from the server, or\n// `null` to indicate that the data is missing.\n//\n// A `null` value will trigger a lazy fetch during render, which will then patch\n// up the tree using the same mechanism as the non-PPR implementation\n// (serverPatchReducer).\n//\n// Usually, the server will respond with exactly the subset of data that we're\n// waiting for  everything below the nearest shared layout. But technically,\n// the server can return anything it wants.\n//\n// This does _not_ create a new tree; it modifies the existing one in place.\n// Which means it must follow the Suspense rules of cache safety.\nexport function spawnDynamicRequests(\n  task: NavigationTask,\n  primaryUrl: URL,\n  nextUrl: string | null,\n  freshnessPolicy: FreshnessPolicy,\n  accumulation: NavigationRequestAccumulation,\n  // The route cache entry used for this navigation, if it came from route\n  // prediction. Passed through so it can be marked as having a dynamic rewrite\n  // if the server returns a different pathname than expected (indicating\n  // dynamic rewrite behavior that varies by param value).\n  routeCacheEntry: FulfilledRouteCacheEntry | null\n): void {\n  const dynamicRequestTree = task.dynamicRequestTree\n  if (dynamicRequestTree === null) {\n    // This navigation was fully cached. There are no dynamic requests to spawn.\n    previousNavigationDidMismatch = false\n    return\n  }\n\n  // This is intentionally not an async function to discourage the caller from\n  // awaiting the result. Any subsequent async operations spawned by this\n  // function should result in a separate navigation task, rather than\n  // block the original one.\n  //\n  // In this function we spawn (but do not await) all the network requests that\n  // block the navigation, and collect the promises. The next function,\n  // `finishNavigationTask`, can await the promises in any order without\n  // accidentally introducing a network waterfall.\n  const primaryRequestPromise = fetchMissingDynamicData(\n    task,\n    dynamicRequestTree,\n    primaryUrl,\n    nextUrl,\n    freshnessPolicy\n  )\n\n  const separateRefreshUrls = accumulation.separateRefreshUrls\n  let refreshRequestPromises: Array<\n    ReturnType<typeof fetchMissingDynamicData>\n  > | null = null\n  if (separateRefreshUrls !== null) {\n    // There are multiple URLs that we need to request the data from. This\n    // happens when a \"default\" parallel route slot is present in the tree, and\n    // its data cannot be fetched from the current route. We need to split the\n    // combined dynamic request tree into separate requests per URL.\n\n    // TODO: Create a scoped dynamic request tree that omits anything that\n    // is not relevant to the given URL. Without doing this, the server may\n    // sometimes render more data than necessary; this is not a regression\n    // compared to the pre-Segment Cache implementation, though, just an\n    // optimization we can make in the future.\n\n    // Construct a request tree for each additional refresh URL. This will\n    // prune away everything except the parts of the tree that match the\n    // given refresh URL.\n    refreshRequestPromises = []\n    const canonicalUrl = createHrefFromUrl(primaryUrl)\n    for (const refreshUrl of separateRefreshUrls) {\n      if (refreshUrl === canonicalUrl) {\n        // We already initiated a request for the this URL, above. Skip it.\n        // TODO: This only happens because the main URL is not tracked as\n        // part of the separateRefreshURLs set. There's probably a better way\n        // to structure this so this case doesn't happen.\n        continue\n      }\n      // TODO: Create a scoped dynamic request tree that omits anything that\n      // is not relevant to the given URL. Without doing this, the server may\n      // sometimes render more data than necessary; this is not a regression\n      // compared to the pre-Segment Cache implementation, though, just an\n      // optimization we can make in the future.\n      // const scopedDynamicRequestTree = splitTaskByURL(task, refreshUrl)\n      const scopedDynamicRequestTree = dynamicRequestTree\n      if (scopedDynamicRequestTree !== null) {\n        refreshRequestPromises.push(\n          fetchMissingDynamicData(\n            task,\n            scopedDynamicRequestTree,\n            new URL(refreshUrl, location.origin),\n            // TODO: Just noticed that this should actually the Next-Url at the\n            // time the refresh URL was set, not the current Next-Url. Need to\n            // start tracking this alongside the refresh URL. In the meantime,\n            // if a refresh fails due to a mismatch, it will trigger a\n            // hard refresh.\n            nextUrl,\n            freshnessPolicy\n          )\n        )\n      }\n    }\n  }\n\n  // Further async operations are moved into this separate function to\n  // discourage sequential network requests.\n  const voidPromise = finishNavigationTask(\n    task,\n    nextUrl,\n    primaryRequestPromise,\n    refreshRequestPromises,\n    routeCacheEntry\n  )\n  // `finishNavigationTask` is responsible for error handling, so we can attach\n  // noop callbacks to this promise.\n  voidPromise.then(noop, noop)\n}\n\nasync function finishNavigationTask(\n  task: NavigationTask,\n  nextUrl: string | null,\n  primaryRequestPromise: ReturnType<typeof fetchMissingDynamicData>,\n  refreshRequestPromises: Array<\n    ReturnType<typeof fetchMissingDynamicData>\n  > | null,\n  routeCacheEntry: FulfilledRouteCacheEntry | null\n): Promise<void> {\n  // Wait for all the requests to finish, or for the first one to fail.\n  let exitStatus = await waitForRequestsToFinish(\n    primaryRequestPromise,\n    refreshRequestPromises\n  )\n\n  // Once the all the requests have finished, check the tree for any remaining\n  // pending tasks. If anything is still pending, it means the server response\n  // does not match the client, and we must refresh to get back to a consistent\n  // state. We can skip this step if we already detected a mismatch during the\n  // first phase; it doesn't matter in that case because we're going to refresh\n  // the whole tree regardless.\n  if (exitStatus === NavigationTaskExitStatus.Done) {\n    exitStatus = abortRemainingPendingTasks(task, null, null)\n  }\n\n  switch (exitStatus) {\n    case NavigationTaskExitStatus.Done: {\n      // The task has completely finished. There's no missing data. Exit.\n      previousNavigationDidMismatch = false\n      return\n    }\n    case NavigationTaskExitStatus.SoftRetry: {\n      // Some data failed to finish loading. Trigger a soft retry.\n      // TODO: As an extra precaution against soft retry loops, consider\n      // tracking whether a navigation was itself triggered by a retry. If two\n      // happen in a row, fall back to a hard retry.\n      const isHardRetry = false\n      const primaryRequestResult = await primaryRequestPromise\n      dispatchRetryDueToTreeMismatch(\n        isHardRetry,\n        primaryRequestResult.url,\n        nextUrl,\n        primaryRequestResult.seed,\n        task.route,\n        routeCacheEntry\n      )\n      return\n    }\n    case NavigationTaskExitStatus.HardRetry: {\n      // Some data failed to finish loading in a non-recoverable way, such as a\n      // network error. Trigger an MPA navigation.\n      //\n      // Hard navigating/refreshing is how we prevent an infinite retry loop\n      // caused by a network error  when the network fails, we fall back to the\n      // browser behavior for offline navigations. In the future, Next.js may\n      // introduce its own custom handling of offline navigations, but that\n      // doesn't exist yet.\n      const isHardRetry = true\n      const primaryRequestResult = await primaryRequestPromise\n      dispatchRetryDueToTreeMismatch(\n        isHardRetry,\n        primaryRequestResult.url,\n        nextUrl,\n        primaryRequestResult.seed,\n        task.route,\n        routeCacheEntry\n      )\n      return\n    }\n    default: {\n      return exitStatus satisfies never\n    }\n  }\n}\n\nfunction waitForRequestsToFinish(\n  primaryRequestPromise: ReturnType<typeof fetchMissingDynamicData>,\n  refreshRequestPromises: Array<\n    ReturnType<typeof fetchMissingDynamicData>\n  > | null\n) {\n  // Custom async combinator logic. This could be replaced by Promise.any but\n  // we don't assume that's available.\n  //\n  // Each promise resolves once the server responsds and the data is written\n  // into the CacheNode tree. Resolve the combined promise once all the\n  // requests finish.\n  //\n  // Or, resolve as soon as one of the requests fails, without waiting for the\n  // others to finish.\n  return new Promise<NavigationTaskExitStatus>((resolve) => {\n    const onFulfill = (result: { exitStatus: NavigationTaskExitStatus }) => {\n      if (result.exitStatus === NavigationTaskExitStatus.Done) {\n        remainingCount--\n        if (remainingCount === 0) {\n          // All the requests finished successfully.\n          resolve(NavigationTaskExitStatus.Done)\n        }\n      } else {\n        // One of the requests failed. Exit with a failing status.\n        // NOTE: It's possible for one of the requests to fail with SoftRetry\n        // and a later one to fail with HardRetry. In this case, we choose to\n        // retry immediately, rather than delay the retry until all the requests\n        // finish. If it fails again, we will hard retry on the next\n        // attempt, anyway.\n        resolve(result.exitStatus)\n      }\n    }\n    // onReject shouldn't ever be called because fetchMissingDynamicData's\n    // entire body is wrapped in a try/catch. This is just defensive.\n    const onReject = () => resolve(NavigationTaskExitStatus.HardRetry)\n\n    // Attach the listeners to the promises.\n    let remainingCount = 1\n    primaryRequestPromise.then(onFulfill, onReject)\n    if (refreshRequestPromises !== null) {\n      remainingCount += refreshRequestPromises.length\n      refreshRequestPromises.forEach((refreshRequestPromise) =>\n        refreshRequestPromise.then(onFulfill, onReject)\n      )\n    }\n  })\n}\n\nfunction dispatchRetryDueToTreeMismatch(\n  isHardRetry: boolean,\n  retryUrl: URL,\n  retryNextUrl: string | null,\n  seed: NavigationSeed | null,\n  baseTree: FlightRouterState,\n  // The route cache entry used for this navigation, if it came from route\n  // prediction. If the navigation results in a mismatch, we mark it as having\n  // a dynamic rewrite so future predictions bail out.\n  routeCacheEntry: FulfilledRouteCacheEntry | null\n) {\n  // If the navigation used a route prediction, mark it as having a dynamic\n  // rewrite since it resulted in a mismatch.\n  if (routeCacheEntry !== null) {\n    markRouteEntryAsDynamicRewrite(routeCacheEntry)\n  } else if (seed !== null) {\n    // Even without a direct reference to the route cache entry, we can still\n    // mark the route as having a dynamic rewrite by traversing the known route\n    // tree. This handles cases where the navigation didn't originate from a\n    // route prediction, but still needs to mark the pattern.\n    const metadataVaryPath = seed.metadataVaryPath\n    if (metadataVaryPath !== null) {\n      const now = Date.now()\n      discoverKnownRoute(\n        now,\n        retryUrl.pathname,\n        null,\n        seed.routeTree,\n        metadataVaryPath,\n        false, // couldBeIntercepted - doesn't matter, we're just marking hasDynamicRewrite\n        createHrefFromUrl(retryUrl),\n        false, // isPPREnabled - doesn't matter, we're just marking hasDynamicRewrite\n        true // hasDynamicRewrite\n      )\n    }\n  }\n\n  // Invalidate all route cache entries. Other entries may have been derived\n  // from the template before we knew it had a dynamic rewrite. This also\n  // triggers re-prefetching of visible links.\n  invalidateRouteCacheEntries(retryNextUrl, baseTree)\n\n  // If this is the second time in a row that a navigation resulted in a\n  // mismatch, fall back to a hard (MPA) refresh.\n  isHardRetry = isHardRetry || previousNavigationDidMismatch\n  previousNavigationDidMismatch = true\n  const retryAction: ServerPatchAction = {\n    type: ACTION_SERVER_PATCH,\n    previousTree: baseTree,\n    url: retryUrl,\n    nextUrl: retryNextUrl,\n    seed,\n    mpa: isHardRetry,\n  }\n  dispatchAppRouterAction(retryAction)\n}\n\nasync function fetchMissingDynamicData(\n  task: NavigationTask,\n  dynamicRequestTree: FlightRouterState,\n  url: URL,\n  nextUrl: string | null,\n  freshnessPolicy: FreshnessPolicy\n): Promise<{\n  exitStatus: NavigationTaskExitStatus\n  url: URL\n  seed: NavigationSeed | null\n}> {\n  try {\n    const result = await fetchServerResponse(url, {\n      flightRouterState: dynamicRequestTree,\n      nextUrl,\n      isHmrRefresh: freshnessPolicy === FreshnessPolicy.HMRRefresh,\n    })\n    if (typeof result === 'string') {\n      // fetchServerResponse will return an href to indicate that the SPA\n      // navigation failed. For example, if the server triggered a hard\n      // redirect, or the fetch request errored. Initiate an MPA navigation\n      // to the given href.\n      return {\n        exitStatus: NavigationTaskExitStatus.HardRetry,\n        url: new URL(result, location.origin),\n        seed: null,\n      }\n    }\n    const seed = convertServerPatchToFullTree(\n      task.route,\n      result.flightData,\n      result.renderedSearch\n    )\n    const didReceiveUnknownParallelRoute = writeDynamicDataIntoNavigationTask(\n      task,\n      seed.routeTree,\n      seed.data,\n      seed.head,\n      result.debugInfo\n    )\n    return {\n      exitStatus: didReceiveUnknownParallelRoute\n        ? NavigationTaskExitStatus.SoftRetry\n        : NavigationTaskExitStatus.Done,\n      url: new URL(result.canonicalUrl, location.origin),\n      seed,\n    }\n  } catch {\n    // This shouldn't happen because fetchServerResponse's entire body is\n    // wrapped in a try/catch. If it does, though, it implies the server failed\n    // to respond with any tree at all. So we must fall back to a hard retry.\n    return {\n      exitStatus: NavigationTaskExitStatus.HardRetry,\n      url: url,\n      seed: null,\n    }\n  }\n}\n\nfunction writeDynamicDataIntoNavigationTask(\n  task: NavigationTask,\n  serverRouteTree: RouteTree,\n  dynamicData: CacheNodeSeedData | null,\n  dynamicHead: HeadData,\n  debugInfo: Array<any> | null\n): boolean {\n  if (task.status === NavigationTaskStatus.Pending && dynamicData !== null) {\n    task.status = NavigationTaskStatus.Fulfilled\n    finishPendingCacheNode(task.node, dynamicData, dynamicHead, debugInfo)\n  }\n\n  const taskChildren = task.children\n  const serverChildren = serverRouteTree.slots\n  const dynamicDataChildren = dynamicData !== null ? dynamicData[1] : null\n\n  // Detect whether the server sends a parallel route slot that the client\n  // doesn't know about.\n  let didReceiveUnknownParallelRoute = false\n\n  if (taskChildren !== null) {\n    if (serverChildren !== null) {\n      for (const parallelRouteKey in serverChildren) {\n        const serverRouteTreeChild: RouteTree = serverChildren[parallelRouteKey]\n        const dynamicDataChild: CacheNodeSeedData | null | void =\n          dynamicDataChildren !== null\n            ? dynamicDataChildren[parallelRouteKey]\n            : null\n\n        const taskChild = taskChildren.get(parallelRouteKey)\n        if (taskChild === undefined) {\n          // The server sent a child segment that the client doesn't know about.\n          //\n          // When we receive an unknown parallel route, we must consider it a\n          // mismatch. This is unlike the case where the segment itself\n          // mismatches, because multiple routes can be active simultaneously.\n          // But a given layout should never have a mismatching set of\n          // child slots.\n          //\n          // Theoretically, this should only happen in development during an HMR\n          // refresh, because the set of parallel routes for a layout does not\n          // change over the lifetime of a build/deployment. In production, we\n          // should have already mismatched on either the build id or the segment\n          // path. But as an extra precaution, we validate in prod, too.\n          didReceiveUnknownParallelRoute = true\n        } else {\n          const taskSegment = taskChild.route[0]\n          const serverSegment = createSegmentFromRouteTree(serverRouteTreeChild)\n          if (\n            matchSegment(serverSegment, taskSegment) &&\n            dynamicDataChild !== null &&\n            dynamicDataChild !== undefined\n          ) {\n            // Found a match for this task. Keep traversing down the task tree.\n            const childDidReceiveUnknownParallelRoute =\n              writeDynamicDataIntoNavigationTask(\n                taskChild,\n                serverRouteTreeChild,\n                dynamicDataChild,\n                dynamicHead,\n                debugInfo\n              )\n            if (childDidReceiveUnknownParallelRoute) {\n              didReceiveUnknownParallelRoute = true\n            }\n          }\n        }\n      }\n    } else {\n      if (serverChildren !== null) {\n        // The server sent a child segment that the client doesn't know about.\n        didReceiveUnknownParallelRoute = true\n      }\n    }\n  }\n\n  return didReceiveUnknownParallelRoute\n}\n\nfunction finishPendingCacheNode(\n  cacheNode: CacheNode,\n  dynamicData: CacheNodeSeedData,\n  dynamicHead: HeadData,\n  debugInfo: Array<any> | null\n): void {\n  // Writes a dynamic response into an existing Cache Node tree. This does _not_\n  // create a new tree, it updates the existing tree in-place. So it must follow\n  // the Suspense rules of cache safety  it can resolve pending promises, but\n  // it cannot overwrite existing data. It can add segments to the tree (because\n  // a missing segment will cause the layout router to suspend).\n  // but it cannot delete them.\n  //\n  // We must resolve every promise in the tree, or else it will suspend\n  // indefinitely. If we did not receive data for a segment, we will resolve its\n  // data promise to `null` to trigger a lazy fetch during render.\n\n  // Use the dynamic data from the server to fulfill the deferred RSC promise\n  // on the Cache Node.\n  const rsc = cacheNode.rsc\n  const dynamicSegmentData = dynamicData[0]\n\n  if (dynamicSegmentData === null) {\n    // This is an empty CacheNode; this particular server request did not\n    // render this segment. There may be a separate pending request that will,\n    // though, so we won't abort the task until all pending requests finish.\n    return\n  }\n\n  if (rsc === null) {\n    // This is a lazy cache node. We can overwrite it. This is only safe\n    // because we know that the LayoutRouter suspends if `rsc` is `null`.\n    cacheNode.rsc = dynamicSegmentData\n  } else if (isDeferredRsc(rsc)) {\n    // This is a deferred RSC promise. We can fulfill it with the data we just\n    // received from the server. If it was already resolved by a different\n    // navigation, then this does nothing because we can't overwrite data.\n    rsc.resolve(dynamicSegmentData, debugInfo)\n  } else {\n    // This is not a deferred RSC promise, nor is it empty, so it must have\n    // been populated by a different navigation. We must not overwrite it.\n  }\n\n  // Check if this is a leaf segment. If so, it will have a `head` property with\n  // a pending promise that needs to be resolved with the dynamic head from\n  // the server.\n  const head = cacheNode.head\n  if (isDeferredRsc(head)) {\n    head.resolve(dynamicHead, debugInfo)\n  }\n}\n\nfunction abortRemainingPendingTasks(\n  task: NavigationTask,\n  error: any,\n  debugInfo: Array<any> | null\n): NavigationTaskExitStatus {\n  let exitStatus\n  if (task.status === NavigationTaskStatus.Pending) {\n    // The data for this segment is still missing.\n    task.status = NavigationTaskStatus.Rejected\n    abortPendingCacheNode(task.node, error, debugInfo)\n\n    // If the server failed to fulfill the data for this segment, it implies\n    // that the route tree received from the server mismatched the tree that\n    // was previously prefetched.\n    //\n    // In an app with fully static routes and no proxy-driven redirects or\n    // rewrites, this should never happen, because the route for a URL would\n    // always be the same across multiple requests. So, this implies that some\n    // runtime routing condition changed, likely in a proxy, without being\n    // pushed to the client.\n    //\n    // When this happens, we treat this the same as a refresh(). The entire\n    // tree will be re-rendered from the root.\n    if (task.refreshState === null) {\n      // Trigger a \"soft\" refresh. Essentially the same as calling `refresh()`\n      // in a Server Action.\n      exitStatus = NavigationTaskExitStatus.SoftRetry\n    } else {\n      // The mismatch was discovered inside an inactive parallel route. This\n      // implies the inactive parallel route is no longer reachable at the URL\n      // that originally rendered it. Fall back to an MPA refresh.\n      // TODO: An alternative could be to trigger a soft refresh but to _not_\n      // re-use the inactive parallel routes this time. Similar to what would\n      // happen if were to do a hard refrehs, but without the HTML page.\n      exitStatus = NavigationTaskExitStatus.HardRetry\n    }\n  } else {\n    // This segment finished. (An error here is treated as Done because they are\n    // surfaced to the application during render.)\n    exitStatus = NavigationTaskExitStatus.Done\n  }\n\n  const taskChildren = task.children\n  if (taskChildren !== null) {\n    for (const [, taskChild] of taskChildren) {\n      const childExitStatus = abortRemainingPendingTasks(\n        taskChild,\n        error,\n        debugInfo\n      )\n      // Propagate the exit status up the tree. The statuses are ordered by\n      // their precedence.\n      if (childExitStatus > exitStatus) {\n        exitStatus = childExitStatus\n      }\n    }\n  }\n\n  return exitStatus\n}\n\nfunction abortPendingCacheNode(\n  cacheNode: CacheNode,\n  error: any,\n  debugInfo: Array<any> | null\n): void {\n  const rsc = cacheNode.rsc\n  if (isDeferredRsc(rsc)) {\n    if (error === null) {\n      // This will trigger a lazy fetch during render.\n      rsc.resolve(null, debugInfo)\n    } else {\n      // This will trigger an error during rendering.\n      rsc.reject(error, debugInfo)\n    }\n  }\n\n  // Check if this is a leaf segment. If so, it will have a `head` property with\n  // a pending promise that needs to be resolved. If an error was provided, we\n  // will not resolve it with an error, since this is rendered at the root of\n  // the app. We want the segment to error, not the entire app.\n  const head = cacheNode.head\n  if (isDeferredRsc(head)) {\n    head.resolve(null, debugInfo)\n  }\n}\n\nconst DEFERRED = Symbol()\n\ntype PendingDeferredRsc<T> = Promise<T> & {\n  status: 'pending'\n  resolve: (value: T, debugInfo: Array<any> | null) => void\n  reject: (error: any, debugInfo: Array<any> | null) => void\n  tag: Symbol\n  _debugInfo: Array<any>\n}\n\ntype FulfilledDeferredRsc<T> = Promise<T> & {\n  status: 'fulfilled'\n  value: T\n  resolve: (value: T, debugInfo: Array<any> | null) => void\n  reject: (error: any, debugInfo: Array<any> | null) => void\n  tag: Symbol\n  _debugInfo: Array<any>\n}\n\ntype RejectedDeferredRsc<T> = Promise<T> & {\n  status: 'rejected'\n  reason: any\n  resolve: (value: T, debugInfo: Array<any> | null) => void\n  reject: (error: any, debugInfo: Array<any> | null) => void\n  tag: Symbol\n  _debugInfo: Array<any>\n}\n\ntype DeferredRsc<T extends React.ReactNode = React.ReactNode> =\n  | PendingDeferredRsc<T>\n  | FulfilledDeferredRsc<T>\n  | RejectedDeferredRsc<T>\n\n// This type exists to distinguish a DeferredRsc from a Flight promise. It's a\n// compromise to avoid adding an extra field on every Cache Node, which would be\n// awkward because the pre-PPR parts of codebase would need to account for it,\n// too. We can remove it once type Cache Node type is more settled.\nexport function isDeferredRsc(value: any): value is DeferredRsc {\n  return value && typeof value === 'object' && value.tag === DEFERRED\n}\n\nfunction createDeferredRsc<\n  T extends React.ReactNode = React.ReactNode,\n>(): PendingDeferredRsc<T> {\n  // Create an unresolved promise that represents data derived from a Flight\n  // response. The promise will be resolved later as soon as we start receiving\n  // data from the server, i.e. as soon as the Flight client decodes and returns\n  // the top-level response object.\n\n  // The `_debugInfo` field contains profiling information. Promises that are\n  // created by Flight already have this info added by React; for any derived\n  // promise created by the router, we need to transfer the Flight debug info\n  // onto the derived promise.\n  //\n  // The debug info represents the latency between the start of the navigation\n  // and the start of rendering. (It does not represent the time it takes for\n  // whole stream to finish.)\n  const debugInfo: Array<any> = []\n\n  let resolve: any\n  let reject: any\n  const pendingRsc = new Promise<T>((res, rej) => {\n    resolve = res\n    reject = rej\n  }) as PendingDeferredRsc<T>\n  pendingRsc.status = 'pending'\n  pendingRsc.resolve = (value: T, responseDebugInfo: Array<any> | null) => {\n    if (pendingRsc.status === 'pending') {\n      const fulfilledRsc: FulfilledDeferredRsc<T> = pendingRsc as any\n      fulfilledRsc.status = 'fulfilled'\n      fulfilledRsc.value = value\n      if (responseDebugInfo !== null) {\n        // Transfer the debug info to the derived promise.\n        debugInfo.push.apply(debugInfo, responseDebugInfo)\n      }\n      resolve(value)\n    }\n  }\n  pendingRsc.reject = (error: any, responseDebugInfo: Array<any> | null) => {\n    if (pendingRsc.status === 'pending') {\n      const rejectedRsc: RejectedDeferredRsc<T> = pendingRsc as any\n      rejectedRsc.status = 'rejected'\n      rejectedRsc.reason = error\n      if (responseDebugInfo !== null) {\n        // Transfer the debug info to the derived promise.\n        debugInfo.push.apply(debugInfo, responseDebugInfo)\n      }\n      reject(error)\n    }\n  }\n  pendingRsc.tag = DEFERRED\n  pendingRsc._debugInfo = debugInfo\n\n  return pendingRsc\n}\n"],"names":["FreshnessPolicy","createInitialCacheNodeForHydration","isDeferredRsc","spawnDynamicRequests","startPPRNavigation","noop","navigatedAt","initialTree","seedData","seedHead","accumulation","scrollableSegments","separateRefreshUrls","task","createCacheNodeOnNavigation","oldUrl","oldRenderedSearch","oldCacheNode","oldRouterState","newRouteTree","newMetadataVaryPath","freshness","isSamePageNavigation","didFindRootLayout","parentNeedsDynamicRequest","parentRefreshState","oldRootRefreshState","canonicalUrl","createHrefFromUrl","renderedSearch","updateCacheNodeOnNavigation","undefined","parentSegmentPath","parentParallelRouteKey","oldSegment","newSegment","createSegmentFromRouteTree","matchSegment","isNavigatingToNewRootLayout","NOT_FOUND_SEGMENT_KEY","segmentPath","concat","newSlots","slots","oldRouterStateChildren","seedDataChildren","childDidFindRootLayout","isRootLayout","shouldRefreshDynamicData","isLeafSegment","newCacheNode","needsDynamicRequest","dropPrefetchRsc","reuseSharedCacheNode","seedRsc","result","createCacheNodeForSegment","cacheNode","maybeRefreshState","refreshState","accumulateRefreshUrl","patchedRouterStateChildren","taskChildren","childNeedsDynamicRequest","dynamicRequestTreeChildren","newCacheNodeSlots","oldCacheNodeSlots","Map","parallelRouteKey","newRouteTreeChild","oldRouterStateChild","seedDataChild","oldSegmentChild","newSegmentChild","seedHeadChild","DEFAULT_SEGMENT_KEY","reuseActiveSegmentInDefaultSlot","oldCacheNodeChild","taskChild","set","node","taskChildRoute","route","dynamicRequestTreeChild","dynamicRequestTree","newFlightRouterState","status","createDynamicRequestTree","children","push","isPage","getRenderedSearchFromVaryPath","varyPath","PAGE_SEGMENT_KEY","stringifiedQuery","JSON","stringify","Object","fromEntries","URLSearchParams","segment","patchRouterStateWithNewChildren","baseRouterState","newChildren","clone","newRouterState","refreshUrl","Set","add","parentRouteTree","reusedUrl","reusedRenderedSearch","oldRefreshState","acc","metadataVaryPath","reusedRouteTree","convertReusedFlightRouterStateToRouteTree","existingCacheNode","createCacheNode","rsc","prefetchRsc","head","prefetchHead","now","tree","DYNAMIC_STALETIME_MS","bfcacheEntry","readFromBFCacheDuringRegularNavigation","writeToBFCache","writeHeadToBFCache","readFromBFCache","oldRsc","oldRscDidResolve","cachedRsc","isCachedRscPartial","segmentEntry","readSegmentCacheEntry","EntryStatus","Fulfilled","isPartial","Pending","promiseForFulfilledEntry","waitForSegmentCacheEntry","then","entry","Empty","Rejected","doesSegmentNeedDynamicRequest","createDeferredRsc","doesHeadNeedDynamicRequest","cachedHead","isCachedHeadPartial","metadataEntry","process","env","__NEXT_OPTIMISTIC_ROUTING","previousNavigationDidMismatch","primaryUrl","nextUrl","freshnessPolicy","routeCacheEntry","primaryRequestPromise","fetchMissingDynamicData","refreshRequestPromises","scopedDynamicRequestTree","URL","location","origin","voidPromise","finishNavigationTask","exitStatus","waitForRequestsToFinish","abortRemainingPendingTasks","isHardRetry","primaryRequestResult","dispatchRetryDueToTreeMismatch","url","seed","Promise","resolve","onFulfill","remainingCount","onReject","length","forEach","refreshRequestPromise","retryUrl","retryNextUrl","baseTree","markRouteEntryAsDynamicRewrite","Date","discoverKnownRoute","pathname","routeTree","invalidateRouteCacheEntries","retryAction","type","ACTION_SERVER_PATCH","previousTree","mpa","dispatchAppRouterAction","fetchServerResponse","flightRouterState","isHmrRefresh","convertServerPatchToFullTree","flightData","didReceiveUnknownParallelRoute","writeDynamicDataIntoNavigationTask","data","debugInfo","serverRouteTree","dynamicData","dynamicHead","finishPendingCacheNode","serverChildren","dynamicDataChildren","serverRouteTreeChild","dynamicDataChild","get","taskSegment","serverSegment","childDidReceiveUnknownParallelRoute","dynamicSegmentData","error","abortPendingCacheNode","childExitStatus","reject","DEFERRED","Symbol","value","tag","pendingRsc","res","rej","responseDebugInfo","fulfilledRsc","apply","rejectedRsc","reason","_debugInfo"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 8697, "column": 0}, "map": {"version":3,"sources":["file:///D:/AconnectJP/node_modules/next/src/client/components/router-reducer/compute-changed-path.ts"],"sourcesContent":["import type {\n  FlightRouterState,\n  Segment,\n} from '../../../shared/lib/app-router-types'\nimport { INTERCEPTION_ROUTE_MARKERS } from '../../../shared/lib/router/utils/interception-routes'\nimport type { Params } from '../../../server/request/params'\nimport {\n  isGroupSegment,\n  DEFAULT_SEGMENT_KEY,\n  PAGE_SEGMENT_KEY,\n} from '../../../shared/lib/segment'\nimport { matchSegment } from '../match-segments'\n\nconst removeLeadingSlash = (segment: string): string => {\n  return segment[0] === '/' ? segment.slice(1) : segment\n}\n\nconst segmentToPathname = (segment: Segment): string => {\n  if (typeof segment === 'string') {\n    // 'children' is not a valid path -- it's technically a parallel route that corresponds with the current segment's page\n    // if we don't skip it, then the computed pathname might be something like `/children` which doesn't make sense.\n    if (segment === 'children') return ''\n\n    return segment\n  }\n\n  return segment[1]\n}\n\nfunction normalizeSegments(segments: string[]): string {\n  return (\n    segments.reduce((acc, segment) => {\n      segment = removeLeadingSlash(segment)\n      if (segment === '' || isGroupSegment(segment)) {\n        return acc\n      }\n\n      return `${acc}/${segment}`\n    }, '') || '/'\n  )\n}\n\nexport function extractPathFromFlightRouterState(\n  flightRouterState: FlightRouterState\n): string | undefined {\n  const segment = Array.isArray(flightRouterState[0])\n    ? flightRouterState[0][1]\n    : flightRouterState[0]\n\n  if (\n    segment === DEFAULT_SEGMENT_KEY ||\n    INTERCEPTION_ROUTE_MARKERS.some((m) => segment.startsWith(m))\n  )\n    return undefined\n\n  if (segment.startsWith(PAGE_SEGMENT_KEY)) return ''\n\n  const segments = [segmentToPathname(segment)]\n  const parallelRoutes = flightRouterState[1] ?? {}\n\n  const childrenPath = parallelRoutes.children\n    ? extractPathFromFlightRouterState(parallelRoutes.children)\n    : undefined\n\n  if (childrenPath !== undefined) {\n    segments.push(childrenPath)\n  } else {\n    for (const [key, value] of Object.entries(parallelRoutes)) {\n      if (key === 'children') continue\n\n      const childPath = extractPathFromFlightRouterState(value)\n\n      if (childPath !== undefined) {\n        segments.push(childPath)\n      }\n    }\n  }\n\n  return normalizeSegments(segments)\n}\n\nfunction computeChangedPathImpl(\n  treeA: FlightRouterState,\n  treeB: FlightRouterState\n): string | null {\n  const [segmentA, parallelRoutesA] = treeA\n  const [segmentB, parallelRoutesB] = treeB\n\n  const normalizedSegmentA = segmentToPathname(segmentA)\n  const normalizedSegmentB = segmentToPathname(segmentB)\n\n  if (\n    INTERCEPTION_ROUTE_MARKERS.some(\n      (m) =>\n        normalizedSegmentA.startsWith(m) || normalizedSegmentB.startsWith(m)\n    )\n  ) {\n    return ''\n  }\n\n  if (!matchSegment(segmentA, segmentB)) {\n    // once we find where the tree changed, we compute the rest of the path by traversing the tree\n    return extractPathFromFlightRouterState(treeB) ?? ''\n  }\n\n  for (const parallelRouterKey in parallelRoutesA) {\n    if (parallelRoutesB[parallelRouterKey]) {\n      const changedPath = computeChangedPathImpl(\n        parallelRoutesA[parallelRouterKey],\n        parallelRoutesB[parallelRouterKey]\n      )\n      if (changedPath !== null) {\n        return `${segmentToPathname(segmentB)}/${changedPath}`\n      }\n    }\n  }\n\n  return null\n}\n\nexport function computeChangedPath(\n  treeA: FlightRouterState,\n  treeB: FlightRouterState\n): string | null {\n  const changedPath = computeChangedPathImpl(treeA, treeB)\n\n  if (changedPath == null || changedPath === '/') {\n    return changedPath\n  }\n\n  // lightweight normalization to remove route groups\n  return normalizeSegments(changedPath.split('/'))\n}\n\n/**\n * Recursively extracts dynamic parameters from FlightRouterState.\n */\nexport function getSelectedParams(\n  currentTree: FlightRouterState,\n  params: Params = {}\n): Params {\n  const parallelRoutes = currentTree[1]\n\n  for (const parallelRoute of Object.values(parallelRoutes)) {\n    const segment = parallelRoute[0]\n    const isDynamicParameter = Array.isArray(segment)\n    const segmentValue = isDynamicParameter ? segment[1] : segment\n    if (!segmentValue || segmentValue.startsWith(PAGE_SEGMENT_KEY)) continue\n\n    // Ensure catchAll and optional catchall are turned into an array\n    const isCatchAll =\n      isDynamicParameter && (segment[2] === 'c' || segment[2] === 'oc')\n\n    if (isCatchAll) {\n      params[segment[0]] = segment[1].split('/')\n    } else if (isDynamicParameter) {\n      params[segment[0]] = segment[1]\n    }\n\n    params = getSelectedParams(parallelRoute, params)\n  }\n\n  return params\n}\n"],"names":["computeChangedPath","extractPathFromFlightRouterState","getSelectedParams","removeLeadingSlash","segment","slice","segmentToPathname","normalizeSegments","segments","reduce","acc","isGroupSegment","flightRouterState","Array","isArray","DEFAULT_SEGMENT_KEY","INTERCEPTION_ROUTE_MARKERS","some","m","startsWith","undefined","PAGE_SEGMENT_KEY","parallelRoutes","childrenPath","children","push","key","value","Object","entries","childPath","computeChangedPathImpl","treeA","treeB","segmentA","parallelRoutesA","segmentB","parallelRoutesB","normalizedSegmentA","normalizedSegmentB","matchSegment","parallelRouterKey","changedPath","split","currentTree","params","parallelRoute","values","isDynamicParameter","segmentValue","isCatchAll"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 8827, "column": 0}, "map": {"version":3,"sources":["file:///D:/AconnectJP/node_modules/next/src/client/lib/javascript-url.ts"],"sourcesContent":["// Adapted from React's sanitizeURL function found here: https://github.com/facebook/react/blob/b565373afd0cc1988497e1107106e851e8cfb261/packages/react-dom-bindings/src/shared/sanitizeURL.js\n\n// A javascript: URL can contain leading C0 control or \\u0020 SPACE,\n// and any newline or tab are filtered out as if they're not part of the URL.\n// https://url.spec.whatwg.org/#url-parsing\n// Tab or newline are defined as \\r\\n\\t:\n// https://infra.spec.whatwg.org/#ascii-tab-or-newline\n// A C0 control is a code point in the range \\u0000 NULL to \\u001F\n// INFORMATION SEPARATOR ONE, inclusive:\n// https://infra.spec.whatwg.org/#c0-control-or-space\n\nconst isJavaScriptProtocol =\n  // eslint-disable-next-line no-control-regex\n  /^[\\u0000-\\u001F ]*j[\\r\\n\\t]*a[\\r\\n\\t]*v[\\r\\n\\t]*a[\\r\\n\\t]*s[\\r\\n\\t]*c[\\r\\n\\t]*r[\\r\\n\\t]*i[\\r\\n\\t]*p[\\r\\n\\t]*t[\\r\\n\\t]*:/i\n\nexport function isJavaScriptURLString(url: string): boolean {\n  return isJavaScriptProtocol.test('' + (url as unknown as string))\n}\n"],"names":["isJavaScriptURLString","isJavaScriptProtocol","url","test"],"mappings":"AAAA,8LAA8L;AAE9L,oEAAoE;AACpE,6EAA6E;AAC7E,2CAA2C;AAC3C,wCAAwC;AACxC,sDAAsD;AACtD,kEAAkE;AAClE,wCAAwC;AACxC,qDAAqD;;;;+BAMrCA,yBAAAA;;;eAAAA;;;AAJhB,MAAMC,uBACJ,AACA,4CAD4C;AAGvC,SAASD,sBAAsBE,GAAW;IAC/C,OAAOD,qBAAqBE,IAAI,CAAC,KAAMD;AACzC","ignoreList":[0]}},
    {"offset": {"line": 8860, "column": 0}, "map": {"version":3,"sources":["file:///D:/AconnectJP/node_modules/next/src/client/components/segment-cache/navigation.ts"],"sourcesContent":["import type {\n  CacheNodeSeedData,\n  FlightRouterState,\n  FlightSegmentPath,\n} from '../../../shared/lib/app-router-types'\nimport type { CacheNode } from '../../../shared/lib/app-router-types'\nimport type { HeadData } from '../../../shared/lib/app-router-types'\nimport type { NormalizedFlightData } from '../../flight-data-helpers'\nimport { fetchServerResponse } from '../router-reducer/fetch-server-response'\nimport {\n  startPPRNavigation,\n  spawnDynamicRequests,\n  FreshnessPolicy,\n  type NavigationRequestAccumulation,\n} from '../router-reducer/ppr-navigations'\nimport { createHrefFromUrl } from '../router-reducer/create-href-from-url'\nimport {\n  EntryStatus,\n  readRouteCacheEntry,\n  deprecated_requestOptimisticRouteCacheEntry,\n  convertRootFlightRouterStateToRouteTree,\n  type RouteTree,\n  type FulfilledRouteCacheEntry,\n} from './cache'\nimport { discoverKnownRoute } from './optimistic-routes'\nimport { createCacheKey, type NormalizedSearch } from './cache-key'\nimport type { PageVaryPath } from './vary-path'\nimport type { AppRouterState } from '../router-reducer/router-reducer-types'\nimport { computeChangedPath } from '../router-reducer/compute-changed-path'\nimport { isJavaScriptURLString } from '../../lib/javascript-url'\n\n/**\n * Navigate to a new URL, using the Segment Cache to construct a response.\n *\n * To allow for synchronous navigations whenever possible, this is not an async\n * function. It returns a promise only if there's no matching prefetch in\n * the cache. Otherwise it returns an immediate result and uses Suspense/RSC to\n * stream in any missing data.\n */\nexport function navigate(\n  state: AppRouterState,\n  url: URL,\n  currentUrl: URL,\n  currentRenderedSearch: string,\n  currentCacheNode: CacheNode | null,\n  currentFlightRouterState: FlightRouterState,\n  nextUrl: string | null,\n  freshnessPolicy: FreshnessPolicy,\n  shouldScroll: boolean,\n  navigateType: 'push' | 'replace'\n): AppRouterState | Promise<AppRouterState> {\n  const now = Date.now()\n  const href = url.href\n\n  const cacheKey = createCacheKey(href, nextUrl)\n  const route = readRouteCacheEntry(now, cacheKey)\n  if (route !== null && route.status === EntryStatus.Fulfilled) {\n    // We have a matching prefetch.\n    return navigateUsingPrefetchedRouteTree(\n      now,\n      state,\n      url,\n      currentUrl,\n      currentRenderedSearch,\n      nextUrl,\n      currentCacheNode,\n      currentFlightRouterState,\n      freshnessPolicy,\n      shouldScroll,\n      navigateType,\n      route\n    )\n  }\n\n  // There was no matching route tree in the cache. Let's see if we can\n  // construct an \"optimistic\" route tree using the deprecated search-params\n  // based matching. This is only used when the new optimisticRouting flag is\n  // disabled.\n  //\n  // Do not construct an optimistic route tree if there was a cache hit, but\n  // the entry has a rejected status, since it may have been rejected due to a\n  // rewrite or redirect based on the search params.\n  //\n  // TODO: There are multiple reasons a prefetch might be rejected; we should\n  // track them explicitly and choose what to do here based on that.\n  if (!process.env.__NEXT_OPTIMISTIC_ROUTING) {\n    if (route === null || route.status !== EntryStatus.Rejected) {\n      const optimisticRoute = deprecated_requestOptimisticRouteCacheEntry(\n        now,\n        url,\n        nextUrl\n      )\n      if (optimisticRoute !== null) {\n        // We have an optimistic route tree. Proceed with the normal flow.\n        return navigateUsingPrefetchedRouteTree(\n          now,\n          state,\n          url,\n          currentUrl,\n          currentRenderedSearch,\n          nextUrl,\n          currentCacheNode,\n          currentFlightRouterState,\n          freshnessPolicy,\n          shouldScroll,\n          navigateType,\n          optimisticRoute\n        )\n      }\n    }\n  }\n\n  // There's no matching prefetch for this route in the cache. We must lazily\n  // fetch it from the server before we can perform the navigation.\n  // TODO: If this is an gesture navigation, instead of performing a\n  // dynamic request, we should do a runtime prefetch.\n  return navigateToUnknownRoute(\n    now,\n    state,\n    url,\n    currentUrl,\n    currentRenderedSearch,\n    nextUrl,\n    currentCacheNode,\n    currentFlightRouterState,\n    freshnessPolicy,\n    shouldScroll,\n    navigateType\n  ).catch(() => {\n    // If the navigation fails, return the current state\n    return state\n  })\n}\n\nexport function navigateToKnownRoute(\n  now: number,\n  state: AppRouterState,\n  url: URL,\n  canonicalUrl: string,\n  navigationSeed: NavigationSeed,\n  currentUrl: URL,\n  currentRenderedSearch: string,\n  currentCacheNode: CacheNode | null,\n  currentFlightRouterState: FlightRouterState,\n  freshnessPolicy: FreshnessPolicy,\n  nextUrl: string | null,\n  shouldScroll: boolean,\n  navigateType: 'push' | 'replace',\n  debugInfo: Array<unknown> | null,\n  // The route cache entry used for this navigation, if it came from route\n  // prediction. Passed through so it can be marked as having a dynamic rewrite\n  // if the server returns a different pathname (indicating dynamic rewrite\n  // behavior).\n  //\n  // When null, the navigation did not use route prediction - either because\n  // the route was already fully cached, or it's a navigation that doesn't\n  // involve prediction (refresh, history traversal, server action, etc.).\n  // In these cases, if a mismatch occurs, we still mark the route as having a\n  // dynamic rewrite by traversing the known route tree (see\n  // dispatchRetryDueToTreeMismatch).\n  routeCacheEntry: FulfilledRouteCacheEntry | null\n): AppRouterState {\n  // A version of navigate() that accepts the target route tree as an argument\n  // rather than reading it from the prefetch cache.\n  const accumulation: NavigationRequestAccumulation = {\n    scrollableSegments: null,\n    separateRefreshUrls: null,\n  }\n  // We special case navigations to the exact same URL as the current location.\n  // It's a common UI pattern for apps to refresh when you click a link to the\n  // current page. So when this happens, we refresh the dynamic data in the page\n  // segments.\n  //\n  // Note that this does not apply if the any part of the hash or search query\n  // has changed. This might feel a bit weird but it makes more sense when you\n  // consider that the way to trigger this behavior is to click the same link\n  // multiple times.\n  //\n  // TODO: We should probably refresh the *entire* route when this case occurs,\n  // not just the page segments. Essentially treating it the same as a refresh()\n  // triggered by an action, which is the more explicit way of modeling the UI\n  // pattern described above.\n  //\n  // Also note that this only refreshes the dynamic data, not static/ cached\n  // data. If the page segment is fully static and prefetched, the request is\n  // skipped. (This is also how refresh() works.)\n  const isSamePageNavigation = url.href === currentUrl.href\n  const task = startPPRNavigation(\n    now,\n    currentUrl,\n    currentRenderedSearch,\n    currentCacheNode,\n    currentFlightRouterState,\n    navigationSeed.routeTree,\n    navigationSeed.metadataVaryPath,\n    freshnessPolicy,\n    navigationSeed.data,\n    navigationSeed.head,\n    isSamePageNavigation,\n    accumulation\n  )\n  if (task !== null) {\n    if (freshnessPolicy !== FreshnessPolicy.Gesture) {\n      spawnDynamicRequests(\n        task,\n        url,\n        nextUrl,\n        freshnessPolicy,\n        accumulation,\n        routeCacheEntry\n      )\n    }\n    return completeSoftNavigation(\n      state,\n      url,\n      nextUrl,\n      task.route,\n      task.node,\n      navigationSeed.renderedSearch,\n      canonicalUrl,\n      navigateType,\n      shouldScroll,\n      accumulation.scrollableSegments,\n      debugInfo\n    )\n  }\n  // Could not perform a SPA navigation. Revert to a full-page (MPA) navigation.\n  return completeHardNavigation(state, url, navigateType)\n}\n\nfunction navigateUsingPrefetchedRouteTree(\n  now: number,\n  state: AppRouterState,\n  url: URL,\n  currentUrl: URL,\n  currentRenderedSearch: string,\n  nextUrl: string | null,\n  currentCacheNode: CacheNode | null,\n  currentFlightRouterState: FlightRouterState,\n  freshnessPolicy: FreshnessPolicy,\n  shouldScroll: boolean,\n  navigateType: 'push' | 'replace',\n  route: FulfilledRouteCacheEntry\n): AppRouterState {\n  const routeTree = route.tree\n  const canonicalUrl = route.canonicalUrl + url.hash\n  const renderedSearch = route.renderedSearch\n  const prefetchSeed: NavigationSeed = {\n    renderedSearch,\n    routeTree,\n    metadataVaryPath: route.metadata.varyPath as any,\n    data: null,\n    head: null,\n  }\n  return navigateToKnownRoute(\n    now,\n    state,\n    url,\n    canonicalUrl,\n    prefetchSeed,\n    currentUrl,\n    currentRenderedSearch,\n    currentCacheNode,\n    currentFlightRouterState,\n    freshnessPolicy,\n    nextUrl,\n    shouldScroll,\n    navigateType,\n    null,\n    route\n  )\n}\n\n// Used to request all the dynamic data for a route, rather than just a subset,\n// e.g. during a refresh or a revalidation. Typically this gets constructed\n// during the normal flow when diffing the route tree, but for an unprefetched\n// navigation, where we don't know the structure of the target route, we use\n// this instead.\nconst DynamicRequestTreeForEntireRoute: FlightRouterState = [\n  '',\n  {},\n  null,\n  'refetch',\n]\n\nasync function navigateToUnknownRoute(\n  now: number,\n  state: AppRouterState,\n  url: URL,\n  currentUrl: URL,\n  currentRenderedSearch: string,\n  nextUrl: string | null,\n  currentCacheNode: CacheNode | null,\n  currentFlightRouterState: FlightRouterState,\n  freshnessPolicy: FreshnessPolicy,\n  shouldScroll: boolean,\n  navigateType: 'push' | 'replace'\n): Promise<AppRouterState> {\n  // Runs when a navigation happens but there's no cached prefetch we can use.\n  // Don't bother to wait for a prefetch response; go straight to a full\n  // navigation that contains both static and dynamic data in a single stream.\n  // (This is unlike the old navigation implementation, which instead blocks\n  // the dynamic request until a prefetch request is received.)\n  //\n  // To avoid duplication of logic, we're going to pretend that the tree\n  // returned by the dynamic request is, in fact, a prefetch tree. Then we can\n  // use the same server response to write the actual data into the CacheNode\n  // tree. So it's the same flow as the \"happy path\" (prefetch, then\n  // navigation), except we use a single server response for both stages.\n\n  let dynamicRequestTree: FlightRouterState\n  switch (freshnessPolicy) {\n    case FreshnessPolicy.Default:\n    case FreshnessPolicy.HistoryTraversal:\n    case FreshnessPolicy.Gesture:\n      dynamicRequestTree = currentFlightRouterState\n      break\n    case FreshnessPolicy.Hydration: // <- shouldn't happen during client nav\n    case FreshnessPolicy.RefreshAll:\n    case FreshnessPolicy.HMRRefresh:\n      dynamicRequestTree = DynamicRequestTreeForEntireRoute\n      break\n    default:\n      freshnessPolicy satisfies never\n      dynamicRequestTree = currentFlightRouterState\n      break\n  }\n\n  const promiseForDynamicServerResponse = fetchServerResponse(url, {\n    flightRouterState: dynamicRequestTree,\n    nextUrl,\n  })\n  const result = await promiseForDynamicServerResponse\n  if (typeof result === 'string') {\n    // This is an MPA navigation.\n    const redirectUrl = new URL(result, location.origin)\n    return completeHardNavigation(state, redirectUrl, navigateType)\n  }\n\n  const {\n    flightData,\n    canonicalUrl,\n    renderedSearch,\n    couldBeIntercepted,\n    prerendered,\n    debugInfo,\n  } = result\n\n  // Since the response format of dynamic requests and prefetches is slightly\n  // different, we'll need to massage the data a bit. Create FlightRouterState\n  // tree that simulates what we'd receive as the result of a prefetch.\n  const navigationSeed = convertServerPatchToFullTree(\n    currentFlightRouterState,\n    flightData,\n    renderedSearch\n  )\n\n  // Learn the route pattern so we can predict it for future navigations.\n  // hasDynamicRewrite is false because this is a fresh navigation to an\n  // unknown route - any rewrite detection happens during the traversal inside\n  // discoverKnownRoute. The hasDynamicRewrite param is only set to true when\n  // retrying after a tree mismatch (see dispatchRetryDueToTreeMismatch).\n  const metadataVaryPath = navigationSeed.metadataVaryPath\n  if (metadataVaryPath !== null) {\n    discoverKnownRoute(\n      now,\n      url.pathname,\n      null, // No pending entry\n      navigationSeed.routeTree,\n      metadataVaryPath,\n      couldBeIntercepted,\n      createHrefFromUrl(canonicalUrl),\n      prerendered,\n      false // hasDynamicRewrite - not a retry, rewrite detection happens during traversal\n    )\n  }\n\n  return navigateToKnownRoute(\n    now,\n    state,\n    url,\n    createHrefFromUrl(canonicalUrl),\n    navigationSeed,\n    currentUrl,\n    currentRenderedSearch,\n    currentCacheNode,\n    currentFlightRouterState,\n    freshnessPolicy,\n    nextUrl,\n    shouldScroll,\n    navigateType,\n    debugInfo,\n    // Unknown route navigations don't use route prediction - the route tree\n    // came directly from the server. If a mismatch occurs during dynamic data\n    // fetch, the retry handler will traverse the known route tree to mark the\n    // entry as having a dynamic rewrite.\n    null\n  )\n}\n\nexport function completeHardNavigation(\n  state: AppRouterState,\n  url: URL,\n  navigateType: 'push' | 'replace'\n): AppRouterState {\n  if (isJavaScriptURLString(url.href)) {\n    console.error(\n      'Next.js has blocked a javascript: URL as a security precaution.'\n    )\n    return state\n  }\n  const newState: AppRouterState = {\n    canonicalUrl:\n      url.origin === location.origin ? createHrefFromUrl(url) : url.href,\n    pushRef: {\n      pendingPush: navigateType === 'push',\n      mpaNavigation: true,\n      preserveCustomHistoryState: false,\n    },\n    // TODO: None of the rest of these values are consistent with the incoming\n    // navigation. We rely on the fact that AppRouter will suspend and trigger\n    // a hard navigation before it accesses any of these values. But instead\n    // we should trigger the hard navigation and blocking any subsequent\n    // router updates without updating React.\n    renderedSearch: state.renderedSearch,\n    focusAndScrollRef: state.focusAndScrollRef,\n    cache: state.cache,\n    tree: state.tree,\n    nextUrl: state.nextUrl,\n    previousNextUrl: state.previousNextUrl,\n    debugInfo: null,\n  }\n  return newState\n}\n\nexport function completeSoftNavigation(\n  oldState: AppRouterState,\n  url: URL,\n  referringNextUrl: string | null,\n  tree: FlightRouterState,\n  cache: CacheNode,\n  renderedSearch: string,\n  canonicalUrl: string,\n  navigateType: 'push' | 'replace',\n  shouldScroll: boolean,\n  scrollableSegments: Array<FlightSegmentPath> | null,\n  collectedDebugInfo: Array<unknown> | null\n) {\n  // The \"Next-Url\" is a special representation of the URL that Next.js\n  // uses to implement interception routes.\n  // TODO: Get rid of this extra traversal by computing this during the\n  // same traversal that computes the tree itself. We should also figure out\n  // what is the minimum information needed for the server to correctly\n  // intercept the route.\n  const changedPath = computeChangedPath(oldState.tree, tree)\n  const nextUrlForNewRoute = changedPath ? changedPath : oldState.nextUrl\n\n  // This value is stored on the state as `previousNextUrl`; the naming is\n  // confusing. What it represents is the \"Next-Url\" header that was used to\n  // fetch the incoming route. It's essentially the refererer URL, but in a\n  // Next.js specific format. During refreshes, this is sent back to the server\n  // instead of the current route's \"Next-Url\" so that the same interception\n  // logic is applied as during the original navigation.\n  const previousNextUrl = referringNextUrl\n\n  // Check if the only thing that changed was the hash fragment.\n  const oldUrl = new URL(oldState.canonicalUrl, url)\n  const onlyHashChange =\n    // We don't need to compare the origins, because client-driven\n    // navigations are always same-origin.\n    url.pathname === oldUrl.pathname &&\n    url.search === oldUrl.search &&\n    url.hash !== oldUrl.hash\n\n  // During a hash-only change, setting scrollableSegments to an empty\n  // array triggers a scroll for all new and updated segments. See\n  // `ScrollAndFocusHandler` for more details.\n  //\n  // TODO: Given the previous comment, I don't know why shouldScroll =\n  // false sets this to an empty array. Seems like an accident. I'm just\n  // preserving the logic that was already here. Clean this up when we\n  // move the per-segment scroll state to the CacheNode.\n  const segmentPathsToScrollTo =\n    onlyHashChange || !shouldScroll\n      ? []\n      : scrollableSegments !== null\n        ? scrollableSegments\n        : oldState.focusAndScrollRef.segmentPaths\n\n  const newState: AppRouterState = {\n    canonicalUrl,\n    renderedSearch,\n    pushRef: {\n      pendingPush: navigateType === 'push',\n      mpaNavigation: false,\n      preserveCustomHistoryState: false,\n    },\n    focusAndScrollRef: {\n      // TODO: We should track all the per-segment scroll state on the CacheNode\n      // instead of using the paths.\n      apply: shouldScroll\n        ? segmentPathsToScrollTo !== null\n          ? true\n          : oldState.focusAndScrollRef.apply\n        : oldState.focusAndScrollRef.apply,\n      onlyHashChange,\n      hashFragment:\n        // Remove leading # and decode hash to make non-latin hashes work.\n        //\n        // Empty hash should trigger default behavior of scrolling layout into\n        // view. #top is handled in layout-router.\n        //\n        // Refer to `ScrollAndFocusHandler` for details on how this is used.\n        shouldScroll && url.hash !== ''\n          ? decodeURIComponent(url.hash.slice(1))\n          : oldState.focusAndScrollRef.hashFragment,\n      segmentPaths: segmentPathsToScrollTo,\n    },\n    cache,\n    tree,\n    nextUrl: nextUrlForNewRoute,\n    previousNextUrl,\n    debugInfo: collectedDebugInfo,\n  }\n  return newState\n}\n\nexport function completeTraverseNavigation(\n  state: AppRouterState,\n  url: URL,\n  renderedSearch: string,\n  cache: CacheNode,\n  tree: FlightRouterState,\n  nextUrl: string | null\n) {\n  return {\n    // Set canonical url\n    canonicalUrl: createHrefFromUrl(url),\n    renderedSearch,\n    pushRef: {\n      pendingPush: false,\n      mpaNavigation: false,\n      // Ensures that the custom history state that was set is preserved when applying this update.\n      preserveCustomHistoryState: true,\n    },\n    focusAndScrollRef: state.focusAndScrollRef,\n    cache,\n    // Restore provided tree\n    tree,\n    nextUrl,\n    // TODO: We need to restore previousNextUrl, too, which represents the\n    // Next-Url that was used to fetch the data. Anywhere we fetch using the\n    // canonical URL, there should be a corresponding Next-Url.\n    previousNextUrl: null,\n    debugInfo: null,\n  }\n}\n\n// TODO: The rest of this file is related to converting the server response into\n// the data structures used by the client. Probably should move to a\n// separate module.\n\nexport type NavigationSeed = {\n  renderedSearch: string\n  routeTree: RouteTree\n  metadataVaryPath: PageVaryPath | null\n  data: CacheNodeSeedData | null\n  head: HeadData | null\n}\n\nexport function convertServerPatchToFullTree(\n  currentTree: FlightRouterState,\n  flightData: Array<NormalizedFlightData> | null,\n  renderedSearch: string\n): NavigationSeed {\n  // During a client navigation or prefetch, the server sends back only a patch\n  // for the parts of the tree that have changed.\n  //\n  // This applies the patch to the base tree to create a full representation of\n  // the resulting tree.\n  //\n  // The return type includes a full FlightRouterState tree and a full\n  // CacheNodeSeedData tree. (Conceptually these are the same tree, and should\n  // eventually be unified, but there's still lots of existing code that\n  // operates on FlightRouterState trees alone without the CacheNodeSeedData.)\n  //\n  // TODO: This similar to what apply-router-state-patch-to-tree does. It\n  // will eventually fully replace it. We should get rid of all the remaining\n  // places where we iterate over the server patch format. This should also\n  // eventually replace normalizeFlightData.\n\n  let baseTree: FlightRouterState = currentTree\n  let baseData: CacheNodeSeedData | null = null\n  let head: HeadData | null = null\n  if (flightData !== null) {\n    for (const {\n      segmentPath,\n      tree: treePatch,\n      seedData: dataPatch,\n      head: headPatch,\n    } of flightData) {\n      const result = convertServerPatchToFullTreeImpl(\n        baseTree,\n        baseData,\n        treePatch,\n        dataPatch,\n        segmentPath,\n        renderedSearch,\n        0\n      )\n      baseTree = result.tree\n      baseData = result.data\n      // This is the same for all patches per response, so just pick an\n      // arbitrary one\n      head = headPatch\n    }\n  }\n\n  const finalFlightRouterState = baseTree\n\n  // Convert the final FlightRouterState into a RouteTree type.\n  //\n  // TODO: Eventually, FlightRouterState will evolve to being a transport format\n  // only. The RouteTree type will become the main type used for dealing with\n  // routes on the client, and we'll store it in the state directly.\n  const acc = { metadataVaryPath: null }\n  const routeTree = convertRootFlightRouterStateToRouteTree(\n    finalFlightRouterState,\n    renderedSearch as NormalizedSearch,\n    acc\n  )\n\n  return {\n    routeTree,\n    metadataVaryPath: acc.metadataVaryPath,\n    data: baseData,\n    renderedSearch,\n    head,\n  }\n}\n\nfunction convertServerPatchToFullTreeImpl(\n  baseRouterState: FlightRouterState,\n  baseData: CacheNodeSeedData | null,\n  treePatch: FlightRouterState,\n  dataPatch: CacheNodeSeedData | null,\n  segmentPath: FlightSegmentPath,\n  renderedSearch: string,\n  index: number\n): { tree: FlightRouterState; data: CacheNodeSeedData | null } {\n  if (index === segmentPath.length) {\n    // We reached the part of the tree that we need to patch.\n    return {\n      tree: treePatch,\n      data: dataPatch,\n    }\n  }\n\n  // segmentPath represents the parent path of subtree. It's a repeating\n  // pattern of parallel route key and segment:\n  //\n  //   [string, Segment, string, Segment, string, Segment, ...]\n  //\n  // This path tells us which part of the base tree to apply the tree patch.\n  //\n  // NOTE: We receive the FlightRouterState patch in the same request as the\n  // seed data patch. Therefore we don't need to worry about diffing the segment\n  // values; we can assume the server sent us a correct result.\n  const updatedParallelRouteKey: string = segmentPath[index]\n  // const segment: Segment = segmentPath[index + 1] <-- Not used, see note above\n\n  const baseTreeChildren = baseRouterState[1]\n  const baseSeedDataChildren = baseData !== null ? baseData[1] : null\n  const newTreeChildren: Record<string, FlightRouterState> = {}\n  const newSeedDataChildren: Record<string, CacheNodeSeedData | null> = {}\n  for (const parallelRouteKey in baseTreeChildren) {\n    const childBaseRouterState = baseTreeChildren[parallelRouteKey]\n    const childBaseSeedData =\n      baseSeedDataChildren !== null\n        ? (baseSeedDataChildren[parallelRouteKey] ?? null)\n        : null\n    if (parallelRouteKey === updatedParallelRouteKey) {\n      const result = convertServerPatchToFullTreeImpl(\n        childBaseRouterState,\n        childBaseSeedData,\n        treePatch,\n        dataPatch,\n        segmentPath,\n        renderedSearch,\n        // Advance the index by two and keep cloning until we reach\n        // the end of the segment path.\n        index + 2\n      )\n\n      newTreeChildren[parallelRouteKey] = result.tree\n      newSeedDataChildren[parallelRouteKey] = result.data\n    } else {\n      // This child is not being patched. Copy it over as-is.\n      newTreeChildren[parallelRouteKey] = childBaseRouterState\n      newSeedDataChildren[parallelRouteKey] = childBaseSeedData\n    }\n  }\n\n  let clonedTree: FlightRouterState\n  let clonedSeedData: CacheNodeSeedData\n  // Clone all the fields except the children.\n\n  // Clone the FlightRouterState tree. Based on equivalent logic in\n  // apply-router-state-patch-to-tree, but should confirm whether we need to\n  // copy all of these fields. Not sure the server ever sends, e.g. the\n  // refetch marker.\n  clonedTree = [baseRouterState[0], newTreeChildren]\n  if (2 in baseRouterState) {\n    const compressedRefreshState = baseRouterState[2]\n    if (\n      compressedRefreshState !== undefined &&\n      compressedRefreshState !== null\n    ) {\n      // Since this part of the tree was patched with new data, any parent\n      // refresh states should be updated to reflect the new rendered search\n      // value. (The refresh state acts like a \"context provider\".) All pages\n      // within the same server response share the same renderedSearch value,\n      // but the same RouteTree could be composed from multiple different\n      // routes, and multiple responses.\n      clonedTree[2] = [compressedRefreshState[0], renderedSearch]\n    }\n  }\n  if (3 in baseRouterState) {\n    clonedTree[3] = baseRouterState[3]\n  }\n  if (4 in baseRouterState) {\n    clonedTree[4] = baseRouterState[4]\n  }\n\n  // Clone the CacheNodeSeedData tree.\n  const isEmptySeedDataPartial = true\n  clonedSeedData = [\n    null,\n    newSeedDataChildren,\n    null,\n    isEmptySeedDataPartial,\n    false,\n    null,\n  ]\n\n  return {\n    tree: clonedTree,\n    data: clonedSeedData,\n  }\n}\n"],"names":["completeHardNavigation","completeSoftNavigation","completeTraverseNavigation","convertServerPatchToFullTree","navigate","navigateToKnownRoute","state","url","currentUrl","currentRenderedSearch","currentCacheNode","currentFlightRouterState","nextUrl","freshnessPolicy","shouldScroll","navigateType","now","Date","href","cacheKey","createCacheKey","route","readRouteCacheEntry","status","EntryStatus","Fulfilled","navigateUsingPrefetchedRouteTree","process","env","__NEXT_OPTIMISTIC_ROUTING","Rejected","optimisticRoute","deprecated_requestOptimisticRouteCacheEntry","navigateToUnknownRoute","catch","canonicalUrl","navigationSeed","debugInfo","routeCacheEntry","accumulation","scrollableSegments","separateRefreshUrls","isSamePageNavigation","task","startPPRNavigation","routeTree","metadataVaryPath","data","head","FreshnessPolicy","Gesture","spawnDynamicRequests","node","renderedSearch","tree","hash","prefetchSeed","metadata","varyPath","DynamicRequestTreeForEntireRoute","dynamicRequestTree","Default","HistoryTraversal","Hydration","RefreshAll","HMRRefresh","promiseForDynamicServerResponse","fetchServerResponse","flightRouterState","result","redirectUrl","URL","location","origin","flightData","couldBeIntercepted","prerendered","discoverKnownRoute","pathname","createHrefFromUrl","isJavaScriptURLString","console","error","newState","pushRef","pendingPush","mpaNavigation","preserveCustomHistoryState","focusAndScrollRef","cache","previousNextUrl","oldState","referringNextUrl","collectedDebugInfo","changedPath","computeChangedPath","nextUrlForNewRoute","oldUrl","onlyHashChange","search","segmentPathsToScrollTo","segmentPaths","apply","hashFragment","decodeURIComponent","slice","currentTree","baseTree","baseData","segmentPath","treePatch","seedData","dataPatch","headPatch","convertServerPatchToFullTreeImpl","finalFlightRouterState","acc","convertRootFlightRouterStateToRouteTree","baseRouterState","index","length","updatedParallelRouteKey","baseTreeChildren","baseSeedDataChildren","newTreeChildren","newSeedDataChildren","parallelRouteKey","childBaseRouterState","childBaseSeedData","clonedTree","clonedSeedData","compressedRefreshState","undefined","isEmptySeedDataPartial"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 9325, "column": 0}, "map": {"version":3,"sources":["file:///D:/AconnectJP/node_modules/next/src/client/components/router-reducer/reducers/navigate-reducer.ts"],"sourcesContent":["import type {\n  NavigateAction,\n  ReadonlyReducerState,\n  ReducerState,\n} from '../router-reducer-types'\n\nimport {\n  completeHardNavigation,\n  navigate as navigateUsingSegmentCache,\n} from '../../segment-cache/navigation'\nimport { getStaleTimeMs } from '../../segment-cache/cache'\nimport { FreshnessPolicy } from '../ppr-navigations'\n\n// These values are set by `define-env-plugin` (based on `nextConfig.experimental.staleTimes`)\n// and default to 5 minutes (static) / 0 seconds (dynamic)\nexport const DYNAMIC_STALETIME_MS =\n  Number(process.env.__NEXT_CLIENT_ROUTER_DYNAMIC_STALETIME) * 1000\n\nexport const STATIC_STALETIME_MS = getStaleTimeMs(\n  Number(process.env.__NEXT_CLIENT_ROUTER_STATIC_STALETIME)\n)\n\nexport function navigateReducer(\n  state: ReadonlyReducerState,\n  action: NavigateAction\n): ReducerState {\n  const { url, isExternalUrl, navigateType, shouldScroll } = action\n\n  if (isExternalUrl) {\n    return completeHardNavigation(state, url, navigateType)\n  }\n\n  // Handles case where `<meta http-equiv=\"refresh\">` tag is present,\n  // which will trigger an MPA navigation.\n  if (document.getElementById('__next-page-redirect')) {\n    return completeHardNavigation(state, url, navigateType)\n  }\n\n  // Temporary glue code between the router reducer and the new navigation\n  // implementation. Eventually we'll rewrite the router reducer to a\n  // state machine.\n  const currentUrl = new URL(state.canonicalUrl, location.origin)\n  const currentRenderedSearch = state.renderedSearch\n  return navigateUsingSegmentCache(\n    state,\n    url,\n    currentUrl,\n    currentRenderedSearch,\n    state.cache,\n    state.tree,\n    state.nextUrl,\n    FreshnessPolicy.Default,\n    shouldScroll,\n    navigateType\n  )\n}\n"],"names":["DYNAMIC_STALETIME_MS","STATIC_STALETIME_MS","navigateReducer","Number","process","env","__NEXT_CLIENT_ROUTER_DYNAMIC_STALETIME","getStaleTimeMs","__NEXT_CLIENT_ROUTER_STATIC_STALETIME","state","action","url","isExternalUrl","navigateType","shouldScroll","completeHardNavigation","document","getElementById","currentUrl","URL","canonicalUrl","location","origin","currentRenderedSearch","renderedSearch","navigateUsingSegmentCache","cache","tree","nextUrl","FreshnessPolicy","Default"],"mappings":"AAgBSI,QAAQC,GAAG,CAACC,sCAAsC;;;;;;;;;;;;;;;;;IAD9CN,oBAAoB,EAAA;eAApBA;;IAGAC,mBAAmB,EAAA;eAAnBA;;IAIGC,eAAe,EAAA;eAAfA;;;4BAbT;uBACwB;gCACC;AAIzB,MAAMF,uBACXG,gDAA6D;AAExD,MAAMF,sBAAsBM,CAAAA,GAAAA,OAAAA,cAAc,EAC/CJ,OAAOC,QAAQC,GAAG,CAACG,qCAAqC;AAGnD,SAASN,gBACdO,KAA2B,EAC3BC,MAAsB;IAEtB,MAAM,EAAEC,GAAG,EAAEC,aAAa,EAAEC,YAAY,EAAEC,YAAY,EAAE,GAAGJ;IAE3D,IAAIE,eAAe;QACjB,OAAOG,CAAAA,GAAAA,YAAAA,sBAAsB,EAACN,OAAOE,KAAKE;IAC5C;IAEA,mEAAmE;IACnE,wCAAwC;IACxC,IAAIG,SAASC,cAAc,CAAC,yBAAyB;QACnD,OAAOF,CAAAA,GAAAA,YAAAA,sBAAsB,EAACN,OAAOE,KAAKE;IAC5C;IAEA,wEAAwE;IACxE,mEAAmE;IACnE,iBAAiB;IACjB,MAAMK,aAAa,IAAIC,IAAIV,MAAMW,YAAY,EAAEC,SAASC,MAAM;IAC9D,MAAMC,wBAAwBd,MAAMe,cAAc;IAClD,OAAOC,CAAAA,GAAAA,YAAAA,QAAyB,EAC9BhB,OACAE,KACAO,YACAK,uBACAd,MAAMiB,KAAK,EACXjB,MAAMkB,IAAI,EACVlB,MAAMmB,OAAO,EACbC,gBAAAA,eAAe,CAACC,OAAO,EACvBhB,cACAD;AAEJ","ignoreList":[0]}},
    {"offset": {"line": 9385, "column": 0}, "map": {"version":3,"sources":["file:///D:/AconnectJP/node_modules/next/src/client/components/router-reducer/reducers/has-interception-route-in-current-tree.ts"],"sourcesContent":["import type { FlightRouterState } from '../../../../shared/lib/app-router-types'\nimport { isInterceptionRouteAppPath } from '../../../../shared/lib/router/utils/interception-routes'\n\nexport function hasInterceptionRouteInCurrentTree([\n  segment,\n  parallelRoutes,\n]: FlightRouterState): boolean {\n  // If we have a dynamic segment, it's marked as an interception route by the presence of the `i` suffix.\n  if (\n    Array.isArray(segment) &&\n    (segment[2] === 'di(..)(..)' ||\n      segment[2] === 'ci(..)(..)' ||\n      segment[2] === 'di(.)' ||\n      segment[2] === 'ci(.)' ||\n      segment[2] === 'di(..)' ||\n      segment[2] === 'ci(..)' ||\n      segment[2] === 'di(...)' ||\n      segment[2] === 'ci(...)')\n  ) {\n    return true\n  }\n\n  // If segment is not an array, apply the existing string-based check\n  if (typeof segment === 'string' && isInterceptionRouteAppPath(segment)) {\n    return true\n  }\n\n  // Iterate through parallelRoutes if they exist\n  if (parallelRoutes) {\n    for (const key in parallelRoutes) {\n      if (hasInterceptionRouteInCurrentTree(parallelRoutes[key])) {\n        return true\n      }\n    }\n  }\n\n  return false\n}\n"],"names":["hasInterceptionRouteInCurrentTree","segment","parallelRoutes","Array","isArray","isInterceptionRouteAppPath","key"],"mappings":";;;+BAGgBA,qCAAAA;;;eAAAA;;;oCAF2B;AAEpC,SAASA,kCAAkC,CAChDC,SACAC,eACkB;IAClB,wGAAwG;IACxG,IACEC,MAAMC,OAAO,CAACH,YACbA,CAAAA,OAAO,CAAC,EAAE,KAAK,gBACdA,OAAO,CAAC,EAAE,KAAK,gBACfA,OAAO,CAAC,EAAE,KAAK,WACfA,OAAO,CAAC,EAAE,KAAK,WACfA,OAAO,CAAC,EAAE,KAAK,YACfA,OAAO,CAAC,EAAE,KAAK,YACfA,OAAO,CAAC,EAAE,KAAK,aACfA,OAAO,CAAC,EAAE,KAAK,SAAQ,GACzB;QACA,OAAO;IACT;IAEA,oEAAoE;IACpE,IAAI,OAAOA,YAAY,YAAYI,CAAAA,GAAAA,oBAAAA,0BAA0B,EAACJ,UAAU;QACtE,OAAO;IACT;IAEA,+CAA+C;IAC/C,IAAIC,gBAAgB;QAClB,IAAK,MAAMI,OAAOJ,eAAgB;YAChC,IAAIF,kCAAkCE,cAAc,CAACI,IAAI,GAAG;gBAC1D,OAAO;YACT;QACF;IACF;IAEA,OAAO;AACT","ignoreList":[0]}},
    {"offset": {"line": 9425, "column": 0}, "map": {"version":3,"sources":["file:///D:/AconnectJP/node_modules/next/src/client/components/router-reducer/reducers/refresh-reducer.ts"],"sourcesContent":["import type {\n  ReadonlyReducerState,\n  ReducerState,\n} from '../router-reducer-types'\nimport {\n  convertServerPatchToFullTree,\n  navigateToKnownRoute,\n} from '../../segment-cache/navigation'\nimport { invalidateSegmentCacheEntries } from '../../segment-cache/cache'\nimport { hasInterceptionRouteInCurrentTree } from './has-interception-route-in-current-tree'\nimport { FreshnessPolicy } from '../ppr-navigations'\nimport { invalidateBfCache } from '../../segment-cache/bfcache'\n\nexport function refreshReducer(state: ReadonlyReducerState): ReducerState {\n  // During a refresh, we invalidate the segment cache but not the route cache.\n  // The route cache contains the tree structure (which segments exist at a\n  // given URL) which doesn't change during a refresh. The segment cache\n  // contains the actual RSC data which needs to be re-fetched.\n  const currentNextUrl = state.nextUrl\n  const currentRouterState = state.tree\n  invalidateSegmentCacheEntries(currentNextUrl, currentRouterState)\n  return refreshDynamicData(state, FreshnessPolicy.RefreshAll)\n}\n\nexport function refreshDynamicData(\n  state: ReadonlyReducerState,\n  freshnessPolicy: FreshnessPolicy.RefreshAll | FreshnessPolicy.HMRRefresh\n): ReducerState {\n  // During a refresh, invalidate the BFCache, which may contain dynamic data.\n  invalidateBfCache()\n\n  const currentNextUrl = state.nextUrl\n\n  // We always send the last next-url, not the current when performing a dynamic\n  // request. This is because we update the next-url after a navigation, but we\n  // want the same interception route to be matched that used the last next-url.\n  const nextUrlForRefresh = hasInterceptionRouteInCurrentTree(state.tree)\n    ? state.previousNextUrl || currentNextUrl\n    : null\n\n  // A refresh is modeled as a navigation to the current URL, but where any\n  // existing dynamic data (including in shared layouts) is re-fetched.\n  const currentCanonicalUrl = state.canonicalUrl\n  const currentUrl = new URL(currentCanonicalUrl, location.origin)\n  const currentRenderedSearch = state.renderedSearch\n  const currentFlightRouterState = state.tree\n  const shouldScroll = false\n\n  // Create a NavigationSeed from the current FlightRouterState.\n  // TODO: Eventually we will store this type directly on the state object\n  // instead of reconstructing it on demand. Part of a larger series of\n  // refactors to unify the various tree types that the client deals with.\n  const refreshSeed = convertServerPatchToFullTree(\n    currentFlightRouterState,\n    null,\n    currentRenderedSearch\n  )\n\n  const now = Date.now()\n  const navigateType = 'replace'\n  return navigateToKnownRoute(\n    now,\n    state,\n    currentUrl,\n    currentCanonicalUrl,\n    refreshSeed,\n    currentUrl,\n    currentRenderedSearch,\n    state.cache,\n    currentFlightRouterState,\n    freshnessPolicy,\n    nextUrlForRefresh,\n    shouldScroll,\n    navigateType,\n    null,\n    // Refresh navigations don't use route prediction, so there's no route\n    // cache entry to mark as having a dynamic rewrite on mismatch. If a\n    // mismatch occurs, the retry handler will traverse the known route tree\n    // to find and mark the entry.\n    null\n  )\n}\n"],"names":["refreshDynamicData","refreshReducer","state","currentNextUrl","nextUrl","currentRouterState","tree","invalidateSegmentCacheEntries","FreshnessPolicy","RefreshAll","freshnessPolicy","invalidateBfCache","nextUrlForRefresh","hasInterceptionRouteInCurrentTree","previousNextUrl","currentCanonicalUrl","canonicalUrl","currentUrl","URL","location","origin","currentRenderedSearch","renderedSearch","currentFlightRouterState","shouldScroll","refreshSeed","convertServerPatchToFullTree","now","Date","navigateType","navigateToKnownRoute","cache"],"mappings":";;;;;;;;;;;;;;IAwBgBA,kBAAkB,EAAA;eAAlBA;;IAXAC,cAAc,EAAA;eAAdA;;;4BANT;uBACuC;mDACI;gCAClB;yBACE;AAE3B,SAASA,eAAeC,KAA2B;IACxD,6EAA6E;IAC7E,yEAAyE;IACzE,sEAAsE;IACtE,6DAA6D;IAC7D,MAAMC,iBAAiBD,MAAME,OAAO;IACpC,MAAMC,qBAAqBH,MAAMI,IAAI;IACrCC,CAAAA,GAAAA,OAAAA,6BAA6B,EAACJ,gBAAgBE;IAC9C,OAAOL,mBAAmBE,OAAOM,gBAAAA,eAAe,CAACC,UAAU;AAC7D;AAEO,SAAST,mBACdE,KAA2B,EAC3BQ,eAAwE;IAExE,4EAA4E;IAC5EC,CAAAA,GAAAA,SAAAA,iBAAiB;IAEjB,MAAMR,iBAAiBD,MAAME,OAAO;IAEpC,8EAA8E;IAC9E,6EAA6E;IAC7E,8EAA8E;IAC9E,MAAMQ,oBAAoBC,CAAAA,GAAAA,mCAAAA,iCAAiC,EAACX,MAAMI,IAAI,IAClEJ,MAAMY,eAAe,IAAIX,iBACzB;IAEJ,yEAAyE;IACzE,qEAAqE;IACrE,MAAMY,sBAAsBb,MAAMc,YAAY;IAC9C,MAAMC,aAAa,IAAIC,IAAIH,qBAAqBI,SAASC,MAAM;IAC/D,MAAMC,wBAAwBnB,MAAMoB,cAAc;IAClD,MAAMC,2BAA2BrB,MAAMI,IAAI;IAC3C,MAAMkB,eAAe;IAErB,8DAA8D;IAC9D,wEAAwE;IACxE,qEAAqE;IACrE,wEAAwE;IACxE,MAAMC,cAAcC,CAAAA,GAAAA,YAAAA,4BAA4B,EAC9CH,0BACA,MACAF;IAGF,MAAMM,MAAMC,KAAKD,GAAG;IACpB,MAAME,eAAe;IACrB,OAAOC,CAAAA,GAAAA,YAAAA,oBAAoB,EACzBH,KACAzB,OACAe,YACAF,qBACAU,aACAR,YACAI,uBACAnB,MAAM6B,KAAK,EACXR,0BACAb,iBACAE,mBACAY,cACAK,cACA,MACA,AACA,oEAAoE,EADE;IAEtE,wEAAwE;IACxE,8BAA8B;IAC9B;AAEJ","ignoreList":[0]}},
    {"offset": {"line": 9499, "column": 0}, "map": {"version":3,"sources":["file:///D:/AconnectJP/node_modules/next/src/client/components/router-reducer/reducers/server-patch-reducer.ts"],"sourcesContent":["import { createHrefFromUrl } from '../create-href-from-url'\nimport type {\n  ServerPatchAction,\n  ReducerState,\n  ReadonlyReducerState,\n} from '../router-reducer-types'\nimport {\n  completeHardNavigation,\n  navigateToKnownRoute,\n} from '../../segment-cache/navigation'\nimport { refreshReducer } from './refresh-reducer'\nimport { FreshnessPolicy } from '../ppr-navigations'\n\nexport function serverPatchReducer(\n  state: ReadonlyReducerState,\n  action: ServerPatchAction\n): ReducerState {\n  // A \"retry\" is a navigation that happens due to a route mismatch. It's\n  // similar to a refresh, because we will omit any existing dynamic data on\n  // the page. But we seed the retry navigation with the exact tree that the\n  // server just responded with.\n  const retryMpa = action.mpa\n  const retryUrl = new URL(action.url, location.origin)\n  const retrySeed = action.seed\n  // A retry should not create a new history entry.\n  const navigateType = 'replace'\n  if (retryMpa || retrySeed === null) {\n    // If the server did not send back data during the mismatch, fall back to\n    // an MPA navigation.\n    return completeHardNavigation(state, retryUrl, navigateType)\n  }\n  const currentUrl = new URL(state.canonicalUrl, location.origin)\n  const currentRenderedSearch = state.renderedSearch\n  if (action.previousTree !== state.tree) {\n    // There was another, more recent navigation since the once that\n    // mismatched. We can abort the retry, but we still need to refresh the\n    // page to evict any stale dynamic data.\n    return refreshReducer(state)\n  }\n  // There have been no new navigations since the mismatched one. Refresh,\n  // using the tree we just received from the server.\n  const retryCanonicalUrl = createHrefFromUrl(retryUrl)\n  const retryNextUrl = action.nextUrl\n  const shouldScroll = true\n  const now = Date.now()\n  return navigateToKnownRoute(\n    now,\n    state,\n    retryUrl,\n    retryCanonicalUrl,\n    retrySeed,\n    currentUrl,\n    currentRenderedSearch,\n    state.cache,\n    state.tree,\n    FreshnessPolicy.RefreshAll,\n    retryNextUrl,\n    shouldScroll,\n    navigateType,\n    null,\n    // Server patch (retry) navigations don't use route prediction. This is\n    // typically a retry after a previous mismatch, so the route was already\n    // marked as having a dynamic rewrite when the mismatch was detected.\n    null\n  )\n}\n"],"names":["serverPatchReducer","state","action","retryMpa","mpa","retryUrl","URL","url","location","origin","retrySeed","seed","navigateType","completeHardNavigation","currentUrl","canonicalUrl","currentRenderedSearch","renderedSearch","previousTree","tree","refreshReducer","retryCanonicalUrl","createHrefFromUrl","retryNextUrl","nextUrl","shouldScroll","now","Date","navigateToKnownRoute","cache","FreshnessPolicy","RefreshAll"],"mappings":";;;+BAagBA,sBAAAA;;;eAAAA;;;mCAbkB;4BAS3B;gCACwB;gCACC;AAEzB,SAASA,mBACdC,KAA2B,EAC3BC,MAAyB;IAEzB,uEAAuE;IACvE,0EAA0E;IAC1E,0EAA0E;IAC1E,8BAA8B;IAC9B,MAAMC,WAAWD,OAAOE,GAAG;IAC3B,MAAMC,WAAW,IAAIC,IAAIJ,OAAOK,GAAG,EAAEC,SAASC,MAAM;IACpD,MAAMC,YAAYR,OAAOS,IAAI;IAC7B,iDAAiD;IACjD,MAAMC,eAAe;IACrB,IAAIT,YAAYO,cAAc,MAAM;QAClC,yEAAyE;QACzE,qBAAqB;QACrB,OAAOG,CAAAA,GAAAA,YAAAA,sBAAsB,EAACZ,OAAOI,UAAUO;IACjD;IACA,MAAME,aAAa,IAAIR,IAAIL,MAAMc,YAAY,EAAEP,SAASC,MAAM;IAC9D,MAAMO,wBAAwBf,MAAMgB,cAAc;IAClD,IAAIf,OAAOgB,YAAY,KAAKjB,MAAMkB,IAAI,EAAE;QACtC,gEAAgE;QAChE,uEAAuE;QACvE,wCAAwC;QACxC,OAAOC,CAAAA,GAAAA,gBAAAA,cAAc,EAACnB;IACxB;IACA,wEAAwE;IACxE,mDAAmD;IACnD,MAAMoB,oBAAoBC,CAAAA,GAAAA,mBAAAA,iBAAiB,EAACjB;IAC5C,MAAMkB,eAAerB,OAAOsB,OAAO;IACnC,MAAMC,eAAe;IACrB,MAAMC,MAAMC,KAAKD,GAAG;IACpB,OAAOE,CAAAA,GAAAA,YAAAA,oBAAoB,EACzBF,KACAzB,OACAI,UACAgB,mBACAX,WACAI,YACAE,uBACAf,MAAM4B,KAAK,EACX5B,MAAMkB,IAAI,EACVW,gBAAAA,eAAe,CAACC,UAAU,EAC1BR,cACAE,cACAb,cACA,MACA,AACA,uEADuE,CACC;IACxE,qEAAqE;IACrE;AAEJ","ignoreList":[0]}},
    {"offset": {"line": 9556, "column": 0}, "map": {"version":3,"sources":["file:///D:/AconnectJP/node_modules/next/src/client/components/router-reducer/reducers/restore-reducer.ts"],"sourcesContent":["import type {\n  ReadonlyReducerState,\n  ReducerState,\n  RestoreAction,\n} from '../router-reducer-types'\nimport { extractPathFromFlightRouterState } from '../compute-changed-path'\nimport {\n  FreshnessPolicy,\n  spawnDynamicRequests,\n  startPPRNavigation,\n  type NavigationRequestAccumulation,\n} from '../ppr-navigations'\nimport type { FlightRouterState } from '../../../../shared/lib/app-router-types'\nimport {\n  completeHardNavigation,\n  completeTraverseNavigation,\n  convertServerPatchToFullTree,\n} from '../../segment-cache/navigation'\n\nexport function restoreReducer(\n  state: ReadonlyReducerState,\n  action: RestoreAction\n): ReducerState {\n  // This action is used to restore the router state from the history state.\n  // However, it's possible that the history state no longer contains the `FlightRouterState`.\n  // We will copy over the internal state on pushState/replaceState events, but if a history entry\n  // occurred before hydration, or if the user navigated to a hash using a regular anchor link,\n  // the history state will not contain the `FlightRouterState`.\n  // In this case, we'll continue to use the existing tree so the router doesn't get into an invalid state.\n  let treeToRestore: FlightRouterState | undefined\n  let renderedSearch: string | undefined\n  const historyState = action.historyState\n  if (historyState) {\n    treeToRestore = historyState.tree\n    renderedSearch = historyState.renderedSearch\n  } else {\n    treeToRestore = state.tree\n    renderedSearch = state.renderedSearch\n  }\n\n  const currentUrl = new URL(state.canonicalUrl, location.origin)\n  const restoredUrl = action.url\n  const restoredNextUrl =\n    extractPathFromFlightRouterState(treeToRestore) ?? restoredUrl.pathname\n\n  const now = Date.now()\n  const accumulation: NavigationRequestAccumulation = {\n    scrollableSegments: null,\n    separateRefreshUrls: null,\n  }\n  const restoreSeed = convertServerPatchToFullTree(\n    treeToRestore,\n    null,\n    renderedSearch\n  )\n  const task = startPPRNavigation(\n    now,\n    currentUrl,\n    state.renderedSearch,\n    state.cache,\n    state.tree,\n    restoreSeed.routeTree,\n    restoreSeed.metadataVaryPath,\n    FreshnessPolicy.HistoryTraversal,\n    null,\n    null,\n    false,\n    accumulation\n  )\n\n  if (task === null) {\n    return completeHardNavigation(state, restoredUrl, 'replace')\n  }\n  spawnDynamicRequests(\n    task,\n    restoredUrl,\n    restoredNextUrl,\n    FreshnessPolicy.HistoryTraversal,\n    accumulation,\n    // History traversal doesn't use route prediction, so there's no route\n    // cache entry to mark as having a dynamic rewrite on mismatch. If a\n    // mismatch occurs, the retry handler will traverse the known route tree\n    // to find and mark the entry.\n    null\n  )\n  return completeTraverseNavigation(\n    state,\n    restoredUrl,\n    renderedSearch,\n    task.node,\n    task.route,\n    restoredNextUrl\n  )\n}\n"],"names":["restoreReducer","state","action","treeToRestore","renderedSearch","historyState","tree","currentUrl","URL","canonicalUrl","location","origin","restoredUrl","url","restoredNextUrl","extractPathFromFlightRouterState","pathname","now","Date","accumulation","scrollableSegments","separateRefreshUrls","restoreSeed","convertServerPatchToFullTree","task","startPPRNavigation","cache","routeTree","metadataVaryPath","FreshnessPolicy","HistoryTraversal","completeHardNavigation","spawnDynamicRequests","completeTraverseNavigation","node","route"],"mappings":";;;+BAmBgBA,kBAAAA;;;eAAAA;;;oCAdiC;gCAM1C;4BAMA;AAEA,SAASA,eACdC,KAA2B,EAC3BC,MAAqB;IAErB,0EAA0E;IAC1E,4FAA4F;IAC5F,gGAAgG;IAChG,6FAA6F;IAC7F,8DAA8D;IAC9D,yGAAyG;IACzG,IAAIC;IACJ,IAAIC;IACJ,MAAMC,eAAeH,OAAOG,YAAY;IACxC,IAAIA,cAAc;QAChBF,gBAAgBE,aAAaC,IAAI;QACjCF,iBAAiBC,aAAaD,cAAc;IAC9C,OAAO;QACLD,gBAAgBF,MAAMK,IAAI;QAC1BF,iBAAiBH,MAAMG,cAAc;IACvC;IAEA,MAAMG,aAAa,IAAIC,IAAIP,MAAMQ,YAAY,EAAEC,SAASC,MAAM;IAC9D,MAAMC,cAAcV,OAAOW,GAAG;IAC9B,MAAMC,kBACJC,CAAAA,GAAAA,oBAAAA,gCAAgC,EAACZ,kBAAkBS,YAAYI,QAAQ;IAEzE,MAAMC,MAAMC,KAAKD,GAAG;IACpB,MAAME,eAA8C;QAClDC,oBAAoB;QACpBC,qBAAqB;IACvB;IACA,MAAMC,cAAcC,CAAAA,GAAAA,YAAAA,4BAA4B,EAC9CpB,eACA,MACAC;IAEF,MAAMoB,OAAOC,CAAAA,GAAAA,gBAAAA,kBAAkB,EAC7BR,KACAV,YACAN,MAAMG,cAAc,EACpBH,MAAMyB,KAAK,EACXzB,MAAMK,IAAI,EACVgB,YAAYK,SAAS,EACrBL,YAAYM,gBAAgB,EAC5BC,gBAAAA,eAAe,CAACC,gBAAgB,EAChC,MACA,MACA,OACAX;IAGF,IAAIK,SAAS,MAAM;QACjB,OAAOO,CAAAA,GAAAA,YAAAA,sBAAsB,EAAC9B,OAAOW,aAAa;IACpD;IACAoB,CAAAA,GAAAA,gBAAAA,oBAAoB,EAClBR,MACAZ,aACAE,iBACAe,gBAAAA,eAAe,CAACC,gBAAgB,EAChCX,cACA,AACA,oEAAoE,EADE;IAEtE,wEAAwE;IACxE,8BAA8B;IAC9B;IAEF,OAAOc,CAAAA,GAAAA,YAAAA,0BAA0B,EAC/BhC,OACAW,aACAR,gBACAoB,KAAKU,IAAI,EACTV,KAAKW,KAAK,EACVrB;AAEJ","ignoreList":[0]}},
    {"offset": {"line": 9615, "column": 0}, "map": {"version":3,"sources":["file:///D:/AconnectJP/node_modules/next/src/client/components/router-reducer/reducers/hmr-refresh-reducer.ts"],"sourcesContent":["import type {\n  ReadonlyReducerState,\n  ReducerState,\n} from '../router-reducer-types'\nimport { refreshDynamicData } from './refresh-reducer'\nimport { FreshnessPolicy } from '../ppr-navigations'\n\nexport function hmrRefreshReducer(state: ReadonlyReducerState): ReducerState {\n  return refreshDynamicData(state, FreshnessPolicy.HMRRefresh)\n}\n"],"names":["hmrRefreshReducer","state","refreshDynamicData","FreshnessPolicy","HMRRefresh"],"mappings":";;;+BAOgBA,qBAAAA;;;eAAAA;;;gCAHmB;gCACH;AAEzB,SAASA,kBAAkBC,KAA2B;IAC3D,OAAOC,CAAAA,GAAAA,gBAAAA,kBAAkB,EAACD,OAAOE,gBAAAA,eAAe,CAACC,UAAU;AAC7D","ignoreList":[0]}},
    {"offset": {"line": 9640, "column": 0}, "map": {"version":3,"sources":["file:///D:/AconnectJP/node_modules/next/src/client/components/unrecognized-action-error.ts"],"sourcesContent":["export class UnrecognizedActionError extends Error {\n  constructor(...args: ConstructorParameters<typeof Error>) {\n    super(...args)\n    this.name = 'UnrecognizedActionError'\n  }\n}\n\n/**\n * Check whether a server action call failed because the server action was not recognized by the server.\n * This can happen if the client and the server are not from the same deployment.\n *\n * Example usage:\n * ```ts\n * try {\n *   await myServerAction();\n * } catch (err) {\n *   if (unstable_isUnrecognizedActionError(err)) {\n *     // The client is from a different deployment than the server.\n *     // Reloading the page will fix this mismatch.\n *     window.alert(\"Please refresh the page and try again\");\n *     return;\n *   }\n * }\n * ```\n * */\nexport function unstable_isUnrecognizedActionError(\n  error: unknown\n): error is UnrecognizedActionError {\n  return !!(\n    error &&\n    typeof error === 'object' &&\n    error instanceof UnrecognizedActionError\n  )\n}\n"],"names":["UnrecognizedActionError","unstable_isUnrecognizedActionError","Error","constructor","args","name","error"],"mappings":";;;;;;;;;;;;;;IAAaA,uBAAuB,EAAA;eAAvBA;;IAyBGC,kCAAkC,EAAA;eAAlCA;;;AAzBT,MAAMD,gCAAgCE;IAC3CC,YAAY,GAAGC,IAAyC,CAAE;QACxD,KAAK,IAAIA;QACT,IAAI,CAACC,IAAI,GAAG;IACd;AACF;AAoBO,SAASJ,mCACdK,KAAc;IAEd,OAAO,CAAC,CACNA,CAAAA,SACA,OAAOA,UAAU,YACjBA,iBAAiBN,uBAAsB;AAE3C","ignoreList":[0]}},
    {"offset": {"line": 9681, "column": 0}, "map": {"version":3,"sources":["file:///D:/AconnectJP/node_modules/next/src/client/assign-location.ts"],"sourcesContent":["import { addBasePath } from './add-base-path'\n\n/**\n * Function to correctly assign location to URL\n *\n * The method will add basePath, and will also correctly add location (including if it is a relative path)\n * @param location Location that should be added to the url\n * @param url Base URL to which the location should be assigned\n */\nexport function assignLocation(location: string, url: URL): URL {\n  if (location.startsWith('.')) {\n    const urlBase = url.origin + url.pathname\n    return new URL(\n      // In order for a relative path to be added to the current url correctly, the current url must end with a slash\n      // new URL('./relative', 'https://example.com/subdir').href -> 'https://example.com/relative'\n      // new URL('./relative', 'https://example.com/subdir/').href -> 'https://example.com/subdir/relative'\n      (urlBase.endsWith('/') ? urlBase : urlBase + '/') + location\n    )\n  }\n\n  return new URL(addBasePath(location), url.href)\n}\n"],"names":["assignLocation","location","url","startsWith","urlBase","origin","pathname","URL","endsWith","addBasePath","href"],"mappings":";;;+BASgBA,kBAAAA;;;eAAAA;;;6BATY;AASrB,SAASA,eAAeC,QAAgB,EAAEC,GAAQ;IACvD,IAAID,SAASE,UAAU,CAAC,MAAM;QAC5B,MAAMC,UAAUF,IAAIG,MAAM,GAAGH,IAAII,QAAQ;QACzC,OAAO,IAAIC,IACT,AAGA,AAFA,6FAA6F,kBADkB;QAE/G,qGAAqG;QACpGH,CAAAA,QAAQI,QAAQ,CAAC,OAAOJ,UAAUA,UAAU,GAAE,IAAKH;IAExD;IAEA,OAAO,IAAIM,IAAIE,CAAAA,GAAAA,aAAAA,WAAW,EAACR,WAAWC,IAAIQ,IAAI;AAChD","ignoreList":[0]}},
    {"offset": {"line": 9711, "column": 0}, "map": {"version":3,"sources":["file:///D:/AconnectJP/node_modules/next/src/client/components/redirect.ts"],"sourcesContent":["import { RedirectStatusCode } from './redirect-status-code'\nimport {\n  type RedirectType,\n  type RedirectError,\n  isRedirectError,\n  REDIRECT_ERROR_CODE,\n} from './redirect-error'\n\nconst actionAsyncStorage =\n  typeof window === 'undefined'\n    ? (\n        require('../../server/app-render/action-async-storage.external') as typeof import('../../server/app-render/action-async-storage.external')\n      ).actionAsyncStorage\n    : undefined\n\nexport function getRedirectError(\n  url: string,\n  type: RedirectType,\n  statusCode: RedirectStatusCode = RedirectStatusCode.TemporaryRedirect\n): RedirectError {\n  const error = new Error(REDIRECT_ERROR_CODE) as RedirectError\n  error.digest = `${REDIRECT_ERROR_CODE};${type};${url};${statusCode};`\n  return error\n}\n\n/**\n * This function allows you to redirect the user to another URL. It can be used in\n * [Server Components](https://nextjs.org/docs/app/building-your-application/rendering/server-components),\n * [Route Handlers](https://nextjs.org/docs/app/building-your-application/routing/route-handlers), and\n * [Server Actions](https://nextjs.org/docs/app/building-your-application/data-fetching/server-actions-and-mutations).\n *\n * - In a Server Component, this will insert a meta tag to redirect the user to the target page.\n * - In a Route Handler or Server Action, it will serve a 307/303 to the caller.\n * - In a Server Action, type defaults to 'push' and 'replace' elsewhere.\n *\n * Read more: [Next.js Docs: `redirect`](https://nextjs.org/docs/app/api-reference/functions/redirect)\n */\nexport function redirect(\n  /** The URL to redirect to */\n  url: string,\n  type?: RedirectType\n): never {\n  type ??= actionAsyncStorage?.getStore()?.isAction ? 'push' : 'replace'\n\n  throw getRedirectError(url, type, RedirectStatusCode.TemporaryRedirect)\n}\n\n/**\n * This function allows you to redirect the user to another URL. It can be used in\n * [Server Components](https://nextjs.org/docs/app/building-your-application/rendering/server-components),\n * [Route Handlers](https://nextjs.org/docs/app/building-your-application/routing/route-handlers), and\n * [Server Actions](https://nextjs.org/docs/app/building-your-application/data-fetching/server-actions-and-mutations).\n *\n * - In a Server Component, this will insert a meta tag to redirect the user to the target page.\n * - In a Route Handler or Server Action, it will serve a 308/303 to the caller.\n *\n * Read more: [Next.js Docs: `redirect`](https://nextjs.org/docs/app/api-reference/functions/redirect)\n */\nexport function permanentRedirect(\n  /** The URL to redirect to */\n  url: string,\n  type: RedirectType = 'replace'\n): never {\n  throw getRedirectError(url, type, RedirectStatusCode.PermanentRedirect)\n}\n\n/**\n * Returns the encoded URL from the error if it's a RedirectError, null\n * otherwise. Note that this does not validate the URL returned.\n *\n * @param error the error that may be a redirect error\n * @return the url if the error was a redirect error\n */\nexport function getURLFromRedirectError(error: RedirectError): string\nexport function getURLFromRedirectError(error: unknown): string | null {\n  if (!isRedirectError(error)) return null\n\n  // Slices off the beginning of the digest that contains the code and the\n  // separating ';'.\n  return error.digest.split(';').slice(2, -2).join(';')\n}\n\nexport function getRedirectTypeFromError(error: RedirectError): RedirectType {\n  if (!isRedirectError(error)) {\n    throw new Error('Not a redirect error')\n  }\n\n  return error.digest.split(';', 2)[1] as RedirectType\n}\n\nexport function getRedirectStatusCodeFromError(error: RedirectError): number {\n  if (!isRedirectError(error)) {\n    throw new Error('Not a redirect error')\n  }\n\n  return Number(error.digest.split(';').at(-2))\n}\n"],"names":["getRedirectError","getRedirectStatusCodeFromError","getRedirectTypeFromError","getURLFromRedirectError","permanentRedirect","redirect","actionAsyncStorage","window","require","undefined","url","type","statusCode","RedirectStatusCode","TemporaryRedirect","error","Error","REDIRECT_ERROR_CODE","digest","getStore","isAction","PermanentRedirect","isRedirectError","split","slice","join","Number","at"],"mappings":";;;;;;;;;;;;;;;;;;IAegBA,gBAAgB,EAAA;eAAhBA;;IA2EAC,8BAA8B,EAAA;eAA9BA;;IARAC,wBAAwB,EAAA;eAAxBA;;IARAC,uBAAuB,EAAA;eAAvBA;;IAhBAC,iBAAiB,EAAA;eAAjBA;;IArBAC,QAAQ,EAAA;eAARA;;;oCArCmB;+BAM5B;AAEP,MAAMC,qBACJ,OAAOC,WAAW,cAEZC,QAAQ,iIACRF,kBAAkB,GACpBG;AAEC,SAAST,iBACdU,GAAW,EACXC,IAAkB,EAClBC,aAAiCC,oBAAAA,kBAAkB,CAACC,iBAAiB;IAErE,MAAMC,QAAQ,OAAA,cAA8B,CAA9B,IAAIC,MAAMC,eAAAA,mBAAmB,GAA7B,qBAAA;eAAA;oBAAA;sBAAA;IAA6B;IAC3CF,MAAMG,MAAM,GAAG,GAAGD,eAAAA,mBAAmB,CAAC,CAAC,EAAEN,KAAK,CAAC,EAAED,IAAI,CAAC,EAAEE,WAAW,CAAC,CAAC;IACrE,OAAOG;AACT;AAcO,SAASV,SACd,2BAA2B,GAC3BK,GAAW,EACXC,IAAmB;IAEnBA,SAASL,oBAAoBa,YAAYC,WAAW,SAAS;IAE7D,MAAMpB,iBAAiBU,KAAKC,MAAME,oBAAAA,kBAAkB,CAACC,iBAAiB;AACxE;AAaO,SAASV,kBACd,2BAA2B,GAC3BM,GAAW,EACXC,OAAqB,SAAS;IAE9B,MAAMX,iBAAiBU,KAAKC,MAAME,oBAAAA,kBAAkB,CAACQ,iBAAiB;AACxE;AAUO,SAASlB,wBAAwBY,KAAc;IACpD,IAAI,CAACO,CAAAA,GAAAA,eAAAA,eAAe,EAACP,QAAQ,OAAO;IAEpC,wEAAwE;IACxE,kBAAkB;IAClB,OAAOA,MAAMG,MAAM,CAACK,KAAK,CAAC,KAAKC,KAAK,CAAC,GAAG,CAAC,GAAGC,IAAI,CAAC;AACnD;AAEO,SAASvB,yBAAyBa,KAAoB;IAC3D,IAAI,CAACO,CAAAA,GAAAA,eAAAA,eAAe,EAACP,QAAQ;QAC3B,MAAM,OAAA,cAAiC,CAAjC,IAAIC,MAAM,yBAAV,qBAAA;mBAAA;wBAAA;0BAAA;QAAgC;IACxC;IAEA,OAAOD,MAAMG,MAAM,CAACK,KAAK,CAAC,KAAK,EAAE,CAAC,EAAE;AACtC;AAEO,SAAStB,+BAA+Bc,KAAoB;IACjE,IAAI,CAACO,CAAAA,GAAAA,eAAAA,eAAe,EAACP,QAAQ;QAC3B,MAAM,OAAA,cAAiC,CAAjC,IAAIC,MAAM,yBAAV,qBAAA;mBAAA;wBAAA;0BAAA;QAAgC;IACxC;IAEA,OAAOU,OAAOX,MAAMG,MAAM,CAACK,KAAK,CAAC,KAAKI,EAAE,CAAC,CAAC;AAC5C","ignoreList":[0]}},
    {"offset": {"line": 9804, "column": 0}, "map": {"version":3,"sources":["file:///D:/AconnectJP/node_modules/next/src/client/has-base-path.ts"],"sourcesContent":["import { pathHasPrefix } from '../shared/lib/router/utils/path-has-prefix'\n\nconst basePath = (process.env.__NEXT_ROUTER_BASEPATH as string) || ''\n\nexport function hasBasePath(path: string): boolean {\n  return pathHasPrefix(path, basePath)\n}\n"],"names":["hasBasePath","basePath","process","env","__NEXT_ROUTER_BASEPATH","path","pathHasPrefix"],"mappings":"AAEkBE,QAAQC,GAAG,CAACC,sBAAsB;;;;;+BAEpCJ,eAAAA;;;eAAAA;;;+BAJc;AAE9B,MAAMC,mDAA6D;AAE5D,SAASD,YAAYK,IAAY;IACtC,OAAOC,CAAAA,GAAAA,eAAAA,aAAa,EAACD,MAAMJ;AAC7B","ignoreList":[0]}},
    {"offset": {"line": 9831, "column": 0}, "map": {"version":3,"sources":["file:///D:/AconnectJP/node_modules/next/src/client/remove-base-path.ts"],"sourcesContent":["import { hasBasePath } from './has-base-path'\n\nconst basePath = (process.env.__NEXT_ROUTER_BASEPATH as string) || ''\n\nexport function removeBasePath(path: string): string {\n  if (process.env.__NEXT_MANUAL_CLIENT_BASE_PATH) {\n    if (!hasBasePath(path)) {\n      return path\n    }\n  }\n\n  // Can't trim the basePath if it has zero length!\n  if (basePath.length === 0) return path\n\n  path = path.slice(basePath.length)\n  if (!path.startsWith('/')) path = `/${path}`\n  return path\n}\n"],"names":["removeBasePath","basePath","process","env","__NEXT_ROUTER_BASEPATH","path","__NEXT_MANUAL_CLIENT_BASE_PATH","hasBasePath","length","slice","startsWith"],"mappings":"AAEkBE,QAAQC,GAAG,CAACC,sBAAsB;;;;;+BAEpCJ,kBAAAA;;;eAAAA;;;6BAJY;AAE5B,MAAMC,mDAA6D;AAE5D,SAASD,eAAeK,IAAY;IACzC,IAAIH,QAAQC,GAAG,CAACG,8BAA8B,EAAE;;IAMhD,iDAAiD;IACjD,IAAIL,SAASO,MAAM,KAAK,GAAG,OAAOH;IAElCA,OAAOA,KAAKI,KAAK,CAACR,SAASO,MAAM;IACjC,IAAI,CAACH,KAAKK,UAAU,CAAC,MAAML,OAAO,CAAC,CAAC,EAAEA,MAAM;IAC5C,OAAOA;AACT","ignoreList":[0]}},
    {"offset": {"line": 9864, "column": 0}, "map": {"version":3,"sources":["file:///D:/AconnectJP/node_modules/next/src/client/components/router-reducer/reducers/server-action-reducer.ts"],"sourcesContent":["import type {\n  ActionFlightResponse,\n  ActionResult,\n} from '../../../../shared/lib/app-router-types'\nimport { callServer } from '../../../app-call-server'\nimport { findSourceMapURL } from '../../../app-find-source-map-url'\nimport {\n  ACTION_HEADER,\n  NEXT_ACTION_NOT_FOUND_HEADER,\n  NEXT_IS_PRERENDER_HEADER,\n  NEXT_HTML_REQUEST_ID_HEADER,\n  NEXT_ROUTER_STATE_TREE_HEADER,\n  NEXT_URL,\n  RSC_CONTENT_TYPE_HEADER,\n  NEXT_REQUEST_ID_HEADER,\n} from '../../app-router-headers'\nimport { UnrecognizedActionError } from '../../unrecognized-action-error'\n\n// TODO: Explicitly import from client.browser\n// eslint-disable-next-line import/no-extraneous-dependencies\nimport {\n  createFromFetch as createFromFetchBrowser,\n  createTemporaryReferenceSet,\n  encodeReply,\n} from 'react-server-dom-webpack/client'\n\nimport type {\n  ReadonlyReducerState,\n  ReducerState,\n  ServerActionAction,\n} from '../router-reducer-types'\nimport { assignLocation } from '../../../assign-location'\nimport { createHrefFromUrl } from '../create-href-from-url'\nimport { hasInterceptionRouteInCurrentTree } from './has-interception-route-in-current-tree'\nimport {\n  normalizeFlightData,\n  prepareFlightRouterStateForRequest,\n  type NormalizedFlightData,\n} from '../../../flight-data-helpers'\nimport { getRedirectError } from '../../redirect'\nimport type { RedirectType } from '../../redirect-error'\nimport { removeBasePath } from '../../../remove-base-path'\nimport { hasBasePath } from '../../../has-base-path'\nimport {\n  extractInfoFromServerReferenceId,\n  omitUnusedArgs,\n} from '../../../../shared/lib/server-reference-info'\nimport { invalidateEntirePrefetchCache } from '../../segment-cache/cache'\nimport { startRevalidationCooldown } from '../../segment-cache/scheduler'\nimport { getDeploymentId } from '../../../../shared/lib/deployment-id'\nimport {\n  completeHardNavigation,\n  convertServerPatchToFullTree,\n  navigateToKnownRoute,\n  navigate,\n} from '../../segment-cache/navigation'\nimport { discoverKnownRoute } from '../../segment-cache/optimistic-routes'\nimport type { NormalizedSearch } from '../../segment-cache/cache-key'\nimport {\n  ActionDidNotRevalidate,\n  ActionDidRevalidateDynamicOnly,\n  ActionDidRevalidateStaticAndDynamic,\n  type ActionRevalidationKind,\n} from '../../../../shared/lib/action-revalidation-kind'\nimport { isExternalURL } from '../../app-router-utils'\nimport { FreshnessPolicy } from '../ppr-navigations'\nimport { invalidateBfCache } from '../../segment-cache/bfcache'\n\nconst createFromFetch =\n  createFromFetchBrowser as (typeof import('react-server-dom-webpack/client.browser'))['createFromFetch']\n\nlet createDebugChannel:\n  | typeof import('../../../dev/debug-channel').createDebugChannel\n  | undefined\n\nif (\n  process.env.NODE_ENV !== 'production' &&\n  process.env.__NEXT_REACT_DEBUG_CHANNEL\n) {\n  createDebugChannel = (\n    require('../../../dev/debug-channel') as typeof import('../../../dev/debug-channel')\n  ).createDebugChannel\n}\n\n// TODO: Refactor to be a discriminated union. Or just get rid of it;\n// fetchServerAction only has one caller, no reason this intermediate type has\n// to exist.\ntype FetchServerActionResult = {\n  redirectLocation: URL | undefined\n  redirectType: RedirectType | undefined\n  revalidationKind: ActionRevalidationKind\n  actionResult: ActionResult | undefined\n  actionFlightData: NormalizedFlightData[] | string | undefined\n  actionFlightDataRenderedSearch: NormalizedSearch | undefined\n  isPrerender: boolean\n  couldBeIntercepted: boolean\n}\n\nasync function fetchServerAction(\n  state: ReadonlyReducerState,\n  nextUrl: ReadonlyReducerState['nextUrl'],\n  { actionId, actionArgs }: ServerActionAction\n): Promise<FetchServerActionResult> {\n  const temporaryReferences = createTemporaryReferenceSet()\n  const info = extractInfoFromServerReferenceId(actionId)\n\n  // TODO: Currently, we're only omitting unused args for the experimental \"use\n  // cache\" functions. Once the server reference info byte feature is stable, we\n  // should apply this to server actions as well.\n  const usedArgs =\n    info.type === 'use-cache' ? omitUnusedArgs(actionArgs, info) : actionArgs\n\n  const body = await encodeReply(usedArgs, { temporaryReferences })\n\n  const headers: Record<string, string> = {\n    Accept: RSC_CONTENT_TYPE_HEADER,\n    [ACTION_HEADER]: actionId,\n    [NEXT_ROUTER_STATE_TREE_HEADER]: prepareFlightRouterStateForRequest(\n      state.tree\n    ),\n  }\n\n  const deploymentId = getDeploymentId()\n  if (deploymentId) {\n    headers['x-deployment-id'] = deploymentId\n  }\n\n  if (nextUrl) {\n    headers[NEXT_URL] = nextUrl\n  }\n\n  if (process.env.NODE_ENV !== 'production') {\n    if (self.__next_r) {\n      headers[NEXT_HTML_REQUEST_ID_HEADER] = self.__next_r\n    }\n\n    // Create a new request ID for the server action request. The server uses\n    // this to tag debug information sent via WebSocket to the client, which\n    // then routes those chunks to the debug channel associated with this ID.\n    headers[NEXT_REQUEST_ID_HEADER] = crypto\n      .getRandomValues(new Uint32Array(1))[0]\n      .toString(16)\n  }\n\n  const res = await fetch(state.canonicalUrl, { method: 'POST', headers, body })\n\n  // Handle server actions that the server didn't recognize.\n  const unrecognizedActionHeader = res.headers.get(NEXT_ACTION_NOT_FOUND_HEADER)\n  if (unrecognizedActionHeader === '1') {\n    throw new UnrecognizedActionError(\n      `Server Action \"${actionId}\" was not found on the server. \\nRead more: https://nextjs.org/docs/messages/failed-to-find-server-action`\n    )\n  }\n\n  const redirectHeader = res.headers.get('x-action-redirect')\n  const [location, _redirectType] = redirectHeader?.split(';') || []\n  let redirectType: RedirectType | undefined\n  switch (_redirectType) {\n    case 'push':\n      redirectType = 'push'\n      break\n    case 'replace':\n      redirectType = 'replace'\n      break\n    default:\n      redirectType = undefined\n  }\n\n  const isPrerender = !!res.headers.get(NEXT_IS_PRERENDER_HEADER)\n\n  let revalidationKind: ActionRevalidationKind = ActionDidNotRevalidate\n  try {\n    const revalidationHeader = res.headers.get('x-action-revalidated')\n    if (revalidationHeader) {\n      const parsedKind = JSON.parse(revalidationHeader)\n      if (\n        parsedKind === ActionDidRevalidateStaticAndDynamic ||\n        parsedKind === ActionDidRevalidateDynamicOnly\n      ) {\n        revalidationKind = parsedKind\n      }\n    }\n  } catch {}\n\n  const redirectLocation = location\n    ? assignLocation(\n        location,\n        new URL(state.canonicalUrl, window.location.href)\n      )\n    : undefined\n\n  const contentType = res.headers.get('content-type')\n  const isRscResponse = !!(\n    contentType && contentType.startsWith(RSC_CONTENT_TYPE_HEADER)\n  )\n\n  // Handle invalid server action responses.\n  // A valid response must have `content-type: text/x-component`, unless it's an external redirect.\n  // (external redirects have an 'x-action-redirect' header, but the body is an empty 'text/plain')\n  if (!isRscResponse && !redirectLocation) {\n    // The server can respond with a text/plain error message, but we'll fallback to something generic\n    // if there isn't one.\n    const message =\n      res.status >= 400 && contentType === 'text/plain'\n        ? await res.text()\n        : 'An unexpected response was received from the server.'\n\n    throw new Error(message)\n  }\n\n  let actionResult: FetchServerActionResult['actionResult']\n  let actionFlightData: FetchServerActionResult['actionFlightData']\n  let actionFlightDataRenderedSearch: FetchServerActionResult['actionFlightDataRenderedSearch']\n  let couldBeIntercepted: boolean = false\n\n  if (isRscResponse) {\n    const response: ActionFlightResponse = await createFromFetch(\n      Promise.resolve(res),\n      {\n        callServer,\n        findSourceMapURL,\n        temporaryReferences,\n        debugChannel: createDebugChannel && createDebugChannel(headers),\n      }\n    )\n\n    // An internal redirect can send an RSC response, but does not have a useful `actionResult`.\n    actionResult = redirectLocation ? undefined : response.a\n    couldBeIntercepted = response.i\n    const maybeFlightData = normalizeFlightData(response.f)\n    if (maybeFlightData !== '') {\n      actionFlightData = maybeFlightData\n      actionFlightDataRenderedSearch = response.q as NormalizedSearch\n    }\n  } else {\n    // An external redirect doesn't contain RSC data.\n    actionResult = undefined\n    actionFlightData = undefined\n    actionFlightDataRenderedSearch = undefined\n  }\n\n  return {\n    actionResult,\n    actionFlightData,\n    actionFlightDataRenderedSearch,\n    redirectLocation,\n    redirectType,\n    revalidationKind,\n    isPrerender,\n    couldBeIntercepted,\n  }\n}\n\n/*\n * This reducer is responsible for calling the server action and processing any side-effects from the server action.\n * It does not mutate the state by itself but rather delegates to other reducers to do the actual mutation.\n */\nexport function serverActionReducer(\n  state: ReadonlyReducerState,\n  action: ServerActionAction\n): ReducerState {\n  const { resolve, reject } = action\n\n  // only pass along the `nextUrl` param (used for interception routes) if the current route was intercepted.\n  // If the route has been intercepted, the action should be as well.\n  // Otherwise the server action might be intercepted with the wrong action id\n  // (ie, one that corresponds with the intercepted route)\n  const nextUrl =\n    // We always send the last next-url, not the current when\n    // performing a dynamic request. This is because we update\n    // the next-url after a navigation, but we want the same\n    // interception route to be matched that used the last\n    // next-url.\n    (state.previousNextUrl || state.nextUrl) &&\n    hasInterceptionRouteInCurrentTree(state.tree)\n      ? state.previousNextUrl || state.nextUrl\n      : null\n\n  return fetchServerAction(state, nextUrl, action).then(\n    async ({\n      revalidationKind,\n      actionResult,\n      actionFlightData: flightData,\n      actionFlightDataRenderedSearch: flightDataRenderedSearch,\n      redirectLocation,\n      redirectType,\n      isPrerender,\n      couldBeIntercepted,\n    }) => {\n      if (revalidationKind !== ActionDidNotRevalidate) {\n        // There was either a revalidation or a refresh, or maybe both.\n\n        // Evict the BFCache, which may contain dynamic data.\n        invalidateBfCache()\n\n        // Store whether this action triggered any revalidation\n        // The action queue will use this information to potentially\n        // trigger a refresh action if the action was discarded\n        // (ie, due to a navigation, before the action completed)\n        action.didRevalidate = true\n\n        // If there was a revalidation, evict the prefetch cache.\n        // TODO: Evict only segments with matching tags and/or paths.\n        // TODO: We should only invalidate the route cache if cookies were\n        // mutated, since route trees may vary based on cookies. For now we\n        // invalidate both caches until we have a way to detect cookie\n        // mutations on the client.\n        if (revalidationKind === ActionDidRevalidateStaticAndDynamic) {\n          invalidateEntirePrefetchCache(nextUrl, state.tree)\n        }\n\n        // Start a cooldown before re-prefetching to allow CDN cache\n        // propagation.\n        startRevalidationCooldown()\n      }\n\n      const navigateType = redirectType || 'push'\n\n      if (redirectLocation !== undefined) {\n        // If the action triggered a redirect, the action promise will be rejected with\n        // a redirect so that it's handled by RedirectBoundary as we won't have a valid\n        // action result to resolve the promise with. This will effectively reset the state of\n        // the component that called the action as the error boundary will remount the tree.\n        // The status code doesn't matter here as the action handler will have already sent\n        // a response with the correct status code.\n\n        if (isExternalURL(redirectLocation)) {\n          // External redirect. Triggers an MPA navigation.\n          const redirectHref = redirectLocation.href\n          const redirectError = createRedirectErrorForAction(\n            redirectHref,\n            navigateType\n          )\n          reject(redirectError)\n          return completeHardNavigation(state, redirectLocation, navigateType)\n        } else {\n          // Internal redirect. Triggers an SPA navigation.\n          const redirectWithBasepath = createHrefFromUrl(\n            redirectLocation,\n            false\n          )\n          const redirectHref = hasBasePath(redirectWithBasepath)\n            ? removeBasePath(redirectWithBasepath)\n            : redirectWithBasepath\n          const redirectError = createRedirectErrorForAction(\n            redirectHref,\n            navigateType\n          )\n          reject(redirectError)\n        }\n      } else {\n        // If there's no redirect, resolve the action with the result.\n        resolve(actionResult)\n      }\n\n      // Check if we can bail out without updating any state.\n      if (\n        // Did the action trigger a redirect?\n        redirectLocation === undefined &&\n        // Did the action revalidate any data?\n        revalidationKind === ActionDidNotRevalidate &&\n        // Did the server render new data?\n        flightData === undefined\n      ) {\n        // The action did not trigger any revalidations or redirects. No\n        // navigation is required.\n        return state\n      }\n\n      if (flightData === undefined && redirectLocation !== undefined) {\n        // The server redirected, but did not send any Flight data. This implies\n        // an external redirect.\n        // TODO: We should refactor the action response type to be more explicit\n        // about the various response types.\n        return completeHardNavigation(state, redirectLocation, navigateType)\n      }\n\n      if (typeof flightData === 'string') {\n        // If the flight data is just a string, something earlier in the\n        // response handling triggered an external redirect.\n        return completeHardNavigation(\n          state,\n          new URL(flightData, location.origin),\n          navigateType\n        )\n      }\n\n      // The action triggered a navigation  either a redirect, a revalidation,\n      // or both.\n\n      // If there was no redirect, then the target URL is the same as the\n      // current URL.\n      const currentUrl = new URL(state.canonicalUrl, location.origin)\n      const currentRenderedSearch = state.renderedSearch\n      const redirectUrl =\n        redirectLocation !== undefined ? redirectLocation : currentUrl\n      const currentFlightRouterState = state.tree\n      const shouldScroll = true\n\n      // If the action triggered a revalidation of the cache, we should also\n      // refresh all the dynamic data.\n      const freshnessPolicy =\n        revalidationKind === ActionDidNotRevalidate\n          ? FreshnessPolicy.Default\n          : FreshnessPolicy.RefreshAll\n\n      // The server may have sent back new data. If so, we will perform a\n      // \"seeded\" navigation that uses the data from the response.\n      // TODO: Currently the server always renders from the root in\n      // response to a Server Action. In the case of a normal redirect\n      // with no revalidation, it should skip over the shared layouts.\n      if (flightData !== undefined && flightDataRenderedSearch !== undefined) {\n        // The server sent back new route data as part of the response. We\n        // will use this to render the new page. If this happens to be only a\n        // subset of the data needed to render the new page, we'll initiate a\n        // new fetch, like we would for a normal navigation.\n        const redirectCanonicalUrl = createHrefFromUrl(redirectUrl)\n        const redirectSeed = convertServerPatchToFullTree(\n          currentFlightRouterState,\n          flightData,\n          flightDataRenderedSearch\n        )\n        const now = Date.now()\n\n        // Learn the route pattern so we can predict it for future navigations.\n        const metadataVaryPath = redirectSeed.metadataVaryPath\n        if (metadataVaryPath !== null) {\n          discoverKnownRoute(\n            now,\n            redirectUrl.pathname,\n            null, // No pending entry\n            redirectSeed.routeTree,\n            metadataVaryPath,\n            couldBeIntercepted,\n            redirectCanonicalUrl,\n            isPrerender,\n            false // hasDynamicRewrite\n          )\n        }\n\n        return navigateToKnownRoute(\n          now,\n          state,\n          redirectUrl,\n          redirectCanonicalUrl,\n          redirectSeed,\n          currentUrl,\n          currentRenderedSearch,\n          state.cache,\n          currentFlightRouterState,\n          freshnessPolicy,\n          nextUrl,\n          shouldScroll,\n          navigateType,\n          null,\n          // Server action redirects don't use route prediction - we already\n          // have the route tree from the server response. If a mismatch occurs\n          // during dynamic data fetch, the retry handler will traverse the\n          // known route tree to mark the entry as having a dynamic rewrite.\n          null\n        )\n      }\n\n      // The server did not send back new data. We'll perform a regular, non-\n      // seeded navigation  effectively the same as <Link> or router.push().\n      return navigate(\n        state,\n        redirectUrl,\n        currentUrl,\n        currentRenderedSearch,\n        state.cache,\n        currentFlightRouterState,\n        nextUrl,\n        freshnessPolicy,\n        shouldScroll,\n        navigateType\n      )\n    },\n    (e: any) => {\n      // When the server action is rejected we don't update the state and instead call the reject handler of the promise.\n      reject(e)\n\n      return state\n    }\n  )\n}\n\nfunction createRedirectErrorForAction(\n  redirectHref: string,\n  resolvedRedirectType: RedirectType\n) {\n  const redirectError = getRedirectError(redirectHref, resolvedRedirectType)\n  // We mark the error as handled because we don't want the redirect to be tried later by\n  // the RedirectBoundary, in case the user goes back and `Activity` triggers the redirect\n  // again, as it's run within an effect.\n  // We don't actually need the RedirectBoundary to do a router.push because we already\n  // have all the necessary RSC data to render the new page within a single roundtrip.\n  ;(redirectError as any).handled = true\n  return redirectError\n}\n"],"names":["serverActionReducer","createFromFetch","createFromFetchBrowser","createDebugChannel","process","env","NODE_ENV","__NEXT_REACT_DEBUG_CHANNEL","require","fetchServerAction","state","nextUrl","actionId","actionArgs","temporaryReferences","createTemporaryReferenceSet","info","extractInfoFromServerReferenceId","usedArgs","type","omitUnusedArgs","body","encodeReply","headers","Accept","RSC_CONTENT_TYPE_HEADER","ACTION_HEADER","NEXT_ROUTER_STATE_TREE_HEADER","prepareFlightRouterStateForRequest","tree","deploymentId","getDeploymentId","NEXT_URL","self","__next_r","NEXT_HTML_REQUEST_ID_HEADER","NEXT_REQUEST_ID_HEADER","crypto","getRandomValues","Uint32Array","toString","res","fetch","canonicalUrl","method","unrecognizedActionHeader","get","NEXT_ACTION_NOT_FOUND_HEADER","UnrecognizedActionError","redirectHeader","location","_redirectType","split","redirectType","undefined","isPrerender","NEXT_IS_PRERENDER_HEADER","revalidationKind","ActionDidNotRevalidate","revalidationHeader","parsedKind","JSON","parse","ActionDidRevalidateStaticAndDynamic","ActionDidRevalidateDynamicOnly","redirectLocation","assignLocation","URL","window","href","contentType","isRscResponse","startsWith","message","status","text","Error","actionResult","actionFlightData","actionFlightDataRenderedSearch","couldBeIntercepted","response","Promise","resolve","callServer","findSourceMapURL","debugChannel","a","i","maybeFlightData","normalizeFlightData","f","q","action","reject","previousNextUrl","hasInterceptionRouteInCurrentTree","then","flightData","flightDataRenderedSearch","invalidateBfCache","didRevalidate","invalidateEntirePrefetchCache","startRevalidationCooldown","navigateType","isExternalURL","redirectHref","redirectError","createRedirectErrorForAction","completeHardNavigation","redirectWithBasepath","createHrefFromUrl","hasBasePath","removeBasePath","origin","currentUrl","currentRenderedSearch","renderedSearch","redirectUrl","currentFlightRouterState","shouldScroll","freshnessPolicy","FreshnessPolicy","Default","RefreshAll","redirectCanonicalUrl","redirectSeed","convertServerPatchToFullTree","now","Date","metadataVaryPath","discoverKnownRoute","pathname","routeTree","navigateToKnownRoute","cache","navigate","e","resolvedRedirectType","getRedirectError","handled"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 10162, "column": 0}, "map": {"version":3,"sources":["file:///D:/AconnectJP/node_modules/next/src/client/components/router-reducer/router-reducer.ts"],"sourcesContent":["import {\n  ACTION_NAVIGATE,\n  ACTION_SERVER_PATCH,\n  ACTION_RESTORE,\n  ACTION_REFRESH,\n  ACTION_HMR_REFRESH,\n  ACTION_SERVER_ACTION,\n} from './router-reducer-types'\nimport type {\n  ReducerActions,\n  ReducerState,\n  ReadonlyReducerState,\n} from './router-reducer-types'\nimport { navigateReducer } from './reducers/navigate-reducer'\nimport { serverPatchReducer } from './reducers/server-patch-reducer'\nimport { restoreReducer } from './reducers/restore-reducer'\nimport { refreshReducer } from './reducers/refresh-reducer'\nimport { hmrRefreshReducer } from './reducers/hmr-refresh-reducer'\nimport { serverActionReducer } from './reducers/server-action-reducer'\n\n/**\n * Reducer that handles the app-router state updates.\n */\nfunction clientReducer(\n  state: ReadonlyReducerState,\n  action: ReducerActions\n): ReducerState {\n  switch (action.type) {\n    case ACTION_NAVIGATE: {\n      return navigateReducer(state, action)\n    }\n    case ACTION_SERVER_PATCH: {\n      return serverPatchReducer(state, action)\n    }\n    case ACTION_RESTORE: {\n      return restoreReducer(state, action)\n    }\n    case ACTION_REFRESH: {\n      return refreshReducer(state)\n    }\n    case ACTION_HMR_REFRESH: {\n      return hmrRefreshReducer(state)\n    }\n    case ACTION_SERVER_ACTION: {\n      return serverActionReducer(state, action)\n    }\n    // This case should never be hit as dispatch is strongly typed.\n    default:\n      throw new Error('Unknown action')\n  }\n}\n\nfunction serverReducer(\n  state: ReadonlyReducerState,\n  _action: ReducerActions\n): ReducerState {\n  return state\n}\n\n// we don't run the client reducer on the server, so we use a noop function for better tree shaking\nexport const reducer =\n  typeof window === 'undefined' ? serverReducer : clientReducer\n"],"names":["reducer","clientReducer","state","action","type","ACTION_NAVIGATE","navigateReducer","ACTION_SERVER_PATCH","serverPatchReducer","ACTION_RESTORE","restoreReducer","ACTION_REFRESH","refreshReducer","ACTION_HMR_REFRESH","hmrRefreshReducer","ACTION_SERVER_ACTION","serverActionReducer","Error","serverReducer","_action","window"],"mappings":";;;+BA4DaA,WAAAA;;;eAAAA;;;oCArDN;iCAMyB;oCACG;gCACJ;gCACA;mCACG;qCACE;AAEpC;;CAEC,GACD,SAASC,cACPC,KAA2B,EAC3BC,MAAsB;IAEtB,OAAQA,OAAOC,IAAI;QACjB,KAAKC,oBAAAA,eAAe;YAAE;gBACpB,OAAOC,CAAAA,GAAAA,iBAAAA,eAAe,EAACJ,OAAOC;YAChC;QACA,KAAKI,oBAAAA,mBAAmB;YAAE;gBACxB,OAAOC,CAAAA,GAAAA,oBAAAA,kBAAkB,EAACN,OAAOC;YACnC;QACA,KAAKM,oBAAAA,cAAc;YAAE;gBACnB,OAAOC,CAAAA,GAAAA,gBAAAA,cAAc,EAACR,OAAOC;YAC/B;QACA,KAAKQ,oBAAAA,cAAc;YAAE;gBACnB,OAAOC,CAAAA,GAAAA,gBAAAA,cAAc,EAACV;YACxB;QACA,KAAKW,oBAAAA,kBAAkB;YAAE;gBACvB,OAAOC,CAAAA,GAAAA,mBAAAA,iBAAiB,EAACZ;YAC3B;QACA,KAAKa,oBAAAA,oBAAoB;YAAE;gBACzB,OAAOC,CAAAA,GAAAA,qBAAAA,mBAAmB,EAACd,OAAOC;YACpC;QACA,+DAA+D;QAC/D;YACE,MAAM,OAAA,cAA2B,CAA3B,IAAIc,MAAM,mBAAV,qBAAA;uBAAA;4BAAA;8BAAA;YAA0B;IACpC;AACF;AAEA,SAASC,cACPhB,KAA2B,EAC3BiB,OAAuB;IAEvB,OAAOjB;AACT;AAGO,MAAMF,UACX,OAAOoB,WAAW,cAAcF,gBAAgBjB","ignoreList":[0]}},
    {"offset": {"line": 10230, "column": 0}, "map": {"version":3,"sources":["file:///D:/AconnectJP/node_modules/next/src/client/components/segment-cache/prefetch.ts"],"sourcesContent":["import type { FlightRouterState } from '../../../shared/lib/app-router-types'\nimport { createPrefetchURL } from '../app-router-utils'\nimport { createCacheKey } from './cache-key'\nimport { schedulePrefetchTask } from './scheduler'\nimport { PrefetchPriority, type PrefetchTaskFetchStrategy } from './types'\n\n/**\n * Entrypoint for prefetching a URL into the Segment Cache.\n * @param href - The URL to prefetch. Typically this will come from a <Link>,\n * or router.prefetch. It must be validated before we attempt to prefetch it.\n * @param nextUrl - A special header used by the server for interception routes.\n * Roughly corresponds to the current URL.\n * @param treeAtTimeOfPrefetch - The FlightRouterState at the time the prefetch\n * was requested. This is only used when PPR is disabled.\n * @param fetchStrategy - Whether to prefetch dynamic data, in addition to\n * static data. This is used by `<Link prefetch={true}>`.\n * @param onInvalidate - A callback that will be called when the prefetch cache\n * When called, it signals to the listener that the data associated with the\n * prefetch may have been invalidated from the cache. This is not a live\n * subscription  it's called at most once per `prefetch` call. The only\n * supported use case is to trigger a new prefetch inside the listener, if\n * desired. It also may be called even in cases where the associated data is\n * still cached. Prefetching is a poll-based (pull) operation, not an event-\n * based (push) one. Rather than subscribe to specific cache entries, you\n * occasionally poll the prefetch cache to check if anything is missing.\n */\nexport function prefetch(\n  href: string,\n  nextUrl: string | null,\n  treeAtTimeOfPrefetch: FlightRouterState,\n  fetchStrategy: PrefetchTaskFetchStrategy,\n  onInvalidate: null | (() => void)\n) {\n  const url = createPrefetchURL(href)\n  if (url === null) {\n    // This href should not be prefetched.\n    return\n  }\n  const cacheKey = createCacheKey(url.href, nextUrl)\n  schedulePrefetchTask(\n    cacheKey,\n    treeAtTimeOfPrefetch,\n    fetchStrategy,\n    PrefetchPriority.Default,\n    onInvalidate\n  )\n}\n"],"names":["prefetch","href","nextUrl","treeAtTimeOfPrefetch","fetchStrategy","onInvalidate","url","createPrefetchURL","cacheKey","createCacheKey","schedulePrefetchTask","PrefetchPriority","Default"],"mappings":";;;+BA0BgBA,YAAAA;;;eAAAA;;;gCAzBkB;0BACH;2BACM;uBAC4B;AAsB1D,SAASA,SACdC,IAAY,EACZC,OAAsB,EACtBC,oBAAuC,EACvCC,aAAwC,EACxCC,YAAiC;IAEjC,MAAMC,MAAMC,CAAAA,GAAAA,gBAAAA,iBAAiB,EAACN;IAC9B,IAAIK,QAAQ,MAAM;QAChB,sCAAsC;QACtC;IACF;IACA,MAAME,WAAWC,CAAAA,GAAAA,UAAAA,cAAc,EAACH,IAAIL,IAAI,EAAEC;IAC1CQ,CAAAA,GAAAA,WAAAA,oBAAoB,EAClBF,UACAL,sBACAC,eACAO,OAAAA,gBAAgB,CAACC,OAAO,EACxBP;AAEJ","ignoreList":[0]}},
    {"offset": {"line": 10263, "column": 0}, "map": {"version":3,"sources":["file:///D:/AconnectJP/node_modules/next/src/client/components/app-router-instance.ts"],"sourcesContent":["import {\n  type AppRouterState,\n  type ReducerActions,\n  type ReducerState,\n  ACTION_REFRESH,\n  ACTION_SERVER_ACTION,\n  ACTION_NAVIGATE,\n  ACTION_RESTORE,\n  type NavigateAction,\n  ACTION_HMR_REFRESH,\n  PrefetchKind,\n  type AppHistoryState,\n} from './router-reducer/router-reducer-types'\nimport { reducer } from './router-reducer/router-reducer'\nimport { startTransition } from 'react'\nimport { isThenable } from '../../shared/lib/is-thenable'\nimport {\n  FetchStrategy,\n  type PrefetchTaskFetchStrategy,\n} from './segment-cache/types'\nimport { prefetch as prefetchWithSegmentCache } from './segment-cache/prefetch'\nimport { navigate } from './segment-cache/navigation'\nimport {\n  dispatchAppRouterAction,\n  dispatchGestureState,\n} from './use-action-queue'\nimport { resetKnownRoutes } from './segment-cache/optimistic-routes'\nimport { FreshnessPolicy } from './router-reducer/ppr-navigations'\nimport { addBasePath } from '../add-base-path'\nimport { isExternalURL } from './app-router-utils'\nimport type {\n  AppRouterInstance,\n  NavigateOptions,\n  PrefetchOptions,\n} from '../../shared/lib/app-router-context.shared-runtime'\nimport { setLinkForCurrentNavigation, type LinkInstance } from './links'\nimport type { ClientInstrumentationHooks } from '../app-index'\nimport type { GlobalErrorComponent } from './builtin/global-error'\nimport { isJavaScriptURLString } from '../lib/javascript-url'\n\nexport type DispatchStatePromise = React.Dispatch<ReducerState>\n\nexport type AppRouterActionQueue = {\n  state: AppRouterState\n  dispatch: (payload: ReducerActions, setState: DispatchStatePromise) => void\n  action: (state: AppRouterState, action: ReducerActions) => ReducerState\n\n  onRouterTransitionStart:\n    | ((url: string, type: 'push' | 'replace' | 'traverse') => void)\n    | null\n\n  pending: ActionQueueNode | null\n  needsRefresh?: boolean\n  last: ActionQueueNode | null\n}\n\nexport type GlobalErrorState = [\n  GlobalError: GlobalErrorComponent,\n  styles: React.ReactNode,\n]\n\nexport type ActionQueueNode = {\n  payload: ReducerActions\n  next: ActionQueueNode | null\n  resolve: (value: ReducerState) => void\n  reject: (err: Error) => void\n  discarded?: boolean\n}\n\nfunction runRemainingActions(\n  actionQueue: AppRouterActionQueue,\n  setState: DispatchStatePromise\n) {\n  if (actionQueue.pending !== null) {\n    actionQueue.pending = actionQueue.pending.next\n    if (actionQueue.pending !== null) {\n      runAction({\n        actionQueue,\n        action: actionQueue.pending,\n        setState,\n      })\n    }\n  } else {\n    // Check for refresh when pending is already null\n    // This handles the case where a discarded server action completes\n    // after the navigation has already finished and the queue is empty\n    if (actionQueue.needsRefresh) {\n      actionQueue.needsRefresh = false\n      actionQueue.dispatch({ type: ACTION_REFRESH }, setState)\n    }\n  }\n}\n\nasync function runAction({\n  actionQueue,\n  action,\n  setState,\n}: {\n  actionQueue: AppRouterActionQueue\n  action: ActionQueueNode\n  setState: DispatchStatePromise\n}) {\n  const prevState = actionQueue.state\n\n  actionQueue.pending = action\n\n  const payload = action.payload\n  const actionResult = actionQueue.action(prevState, payload)\n\n  function handleResult(nextState: AppRouterState) {\n    // if we discarded this action, the state should also be discarded\n    if (action.discarded) {\n      // Check if the discarded server action revalidated data\n      if (\n        action.payload.type === ACTION_SERVER_ACTION &&\n        action.payload.didRevalidate\n      ) {\n        // The server action was discarded but it revalidated data,\n        // mark that we need to refresh after all actions complete\n        actionQueue.needsRefresh = true\n      }\n      // Still need to run remaining actions even for discarded actions\n      // to potentially trigger the refresh\n      runRemainingActions(actionQueue, setState)\n      return\n    }\n\n    actionQueue.state = nextState\n\n    runRemainingActions(actionQueue, setState)\n    action.resolve(nextState)\n  }\n\n  // if the action is a promise, set up a callback to resolve it\n  if (isThenable(actionResult)) {\n    actionResult.then(handleResult, (err) => {\n      runRemainingActions(actionQueue, setState)\n      action.reject(err)\n    })\n  } else {\n    handleResult(actionResult)\n  }\n}\n\nfunction dispatchAction(\n  actionQueue: AppRouterActionQueue,\n  payload: ReducerActions,\n  setState: DispatchStatePromise\n) {\n  let resolvers: {\n    resolve: (value: ReducerState) => void\n    reject: (reason: any) => void\n  } = { resolve: setState, reject: () => {} }\n\n  // most of the action types are async with the exception of restore\n  // it's important that restore is handled quickly since it's fired on the popstate event\n  // and we don't want to add any delay on a back/forward nav\n  // this only creates a promise for the async actions\n  if (payload.type !== ACTION_RESTORE) {\n    // Create the promise and assign the resolvers to the object.\n    const deferredPromise = new Promise<AppRouterState>((resolve, reject) => {\n      resolvers = { resolve, reject }\n    })\n\n    startTransition(() => {\n      // we immediately notify React of the pending promise -- the resolver is attached to the action node\n      // and will be called when the associated action promise resolves\n      setState(deferredPromise)\n    })\n  }\n\n  const newAction: ActionQueueNode = {\n    payload,\n    next: null,\n    resolve: resolvers.resolve,\n    reject: resolvers.reject,\n  }\n\n  // Check if the queue is empty\n  if (actionQueue.pending === null) {\n    // The queue is empty, so add the action and start it immediately\n    // Mark this action as the last in the queue\n    actionQueue.last = newAction\n\n    runAction({\n      actionQueue,\n      action: newAction,\n      setState,\n    })\n  } else if (\n    payload.type === ACTION_NAVIGATE ||\n    payload.type === ACTION_RESTORE\n  ) {\n    // Navigations (including back/forward) take priority over any pending actions.\n    // Mark the pending action as discarded (so the state is never applied) and start the navigation action immediately.\n    actionQueue.pending.discarded = true\n\n    // The rest of the current queue should still execute after this navigation.\n    // (Note that it can't contain any earlier navigations, because we always put those into `actionQueue.pending` by calling `runAction`)\n    newAction.next = actionQueue.pending.next\n\n    runAction({\n      actionQueue,\n      action: newAction,\n      setState,\n    })\n  } else {\n    // The queue is not empty, so add the action to the end of the queue\n    // It will be started by runRemainingActions after the previous action finishes\n    if (actionQueue.last !== null) {\n      actionQueue.last.next = newAction\n    }\n    actionQueue.last = newAction\n  }\n}\n\nlet globalActionQueue: AppRouterActionQueue | null = null\n\nexport function createMutableActionQueue(\n  initialState: AppRouterState,\n  instrumentationHooks: ClientInstrumentationHooks | null\n): AppRouterActionQueue {\n  const actionQueue: AppRouterActionQueue = {\n    state: initialState,\n    dispatch: (payload: ReducerActions, setState: DispatchStatePromise) =>\n      dispatchAction(actionQueue, payload, setState),\n    action: async (state: AppRouterState, action: ReducerActions) => {\n      const result = reducer(state, action)\n      return result\n    },\n    pending: null,\n    last: null,\n    onRouterTransitionStart:\n      instrumentationHooks !== null &&\n      typeof instrumentationHooks.onRouterTransitionStart === 'function'\n        ? // This profiling hook will be called at the start of every navigation.\n          instrumentationHooks.onRouterTransitionStart\n        : null,\n  }\n\n  if (typeof window !== 'undefined') {\n    // The action queue is lazily created on hydration, but after that point\n    // it doesn't change. So we can store it in a global rather than pass\n    // it around everywhere via props/context.\n    if (globalActionQueue !== null) {\n      throw new Error(\n        'Internal Next.js Error: createMutableActionQueue was called more ' +\n          'than once'\n      )\n    }\n    globalActionQueue = actionQueue\n  }\n\n  return actionQueue\n}\n\nexport function getCurrentAppRouterState(): AppRouterState | null {\n  return globalActionQueue !== null ? globalActionQueue.state : null\n}\n\nfunction getAppRouterActionQueue(): AppRouterActionQueue {\n  if (globalActionQueue === null) {\n    throw new Error(\n      'Internal Next.js error: Router action dispatched before initialization.'\n    )\n  }\n  return globalActionQueue\n}\n\nfunction getProfilingHookForOnNavigationStart() {\n  if (globalActionQueue !== null) {\n    return globalActionQueue.onRouterTransitionStart\n  }\n  return null\n}\n\nexport function dispatchNavigateAction(\n  href: string,\n  navigateType: NavigateAction['navigateType'],\n  shouldScroll: boolean,\n  linkInstanceRef: LinkInstance | null\n): void {\n  // TODO: This stuff could just go into the reducer. Leaving as-is for now\n  // since we're about to rewrite all the router reducer stuff anyway.\n  const url = new URL(addBasePath(href), location.href)\n  if (process.env.__NEXT_APP_NAV_FAIL_HANDLING) {\n    window.next.__pendingUrl = url\n  }\n\n  setLinkForCurrentNavigation(linkInstanceRef)\n\n  const onRouterTransitionStart = getProfilingHookForOnNavigationStart()\n  if (onRouterTransitionStart !== null) {\n    onRouterTransitionStart(href, navigateType)\n  }\n\n  dispatchAppRouterAction({\n    type: ACTION_NAVIGATE,\n    url,\n    isExternalUrl: isExternalURL(url),\n    locationSearch: location.search,\n    shouldScroll,\n    navigateType,\n  })\n}\n\nexport function dispatchTraverseAction(\n  href: string,\n  historyState: AppHistoryState | undefined\n) {\n  const onRouterTransitionStart = getProfilingHookForOnNavigationStart()\n  if (onRouterTransitionStart !== null) {\n    onRouterTransitionStart(href, 'traverse')\n  }\n  dispatchAppRouterAction({\n    type: ACTION_RESTORE,\n    url: new URL(href),\n    historyState,\n  })\n}\n\n/**\n * (Experimental) Perform a gesture navigation. This dispatches through React's\n * useOptimistic instead of the main action queue, allowing the state to be\n * shown during a gesture transition and discarded when the canonical navigation\n * completes.\n *\n * Only available when experimental.gestureTransition is enabled.\n */\nfunction gesturePush(href: string, options?: NavigateOptions): void {\n  if (process.env.__NEXT_GESTURE_TRANSITION) {\n    // TODO: Trigger a prefetch so the cache starts populating if there isn't\n    // already a prefetch for this route.\n    if (isJavaScriptURLString(href)) {\n      throw new Error(\n        'Next.js has blocked a javascript: URL as a security precaution.'\n      )\n    }\n\n    const state = getCurrentAppRouterState()\n    if (state === null) {\n      return\n    }\n    const url = new URL(addBasePath(href), location.href)\n    if (isExternalURL(url)) {\n      return\n    }\n\n    // Fork the router state for the duration of the gesture transition.\n    const currentUrl = new URL(state.canonicalUrl, location.href)\n    const shouldScroll = options?.scroll ?? true\n    // This is a special freshness policy that prevents dynamic requests from\n    // being spawned. During the gesture, we should only show the cached\n    // prefetched UI, not dynamic data.\n    // TODO: In the case of navigations to an unknown route, this will still\n    // end up performing a dynamic request. The plan is to do prefetch instead.\n    // There's a separate TODO for this.\n    const freshnessPolicy = FreshnessPolicy.Gesture\n    const forkedGestureState = navigate(\n      state,\n      url,\n      currentUrl,\n      state.renderedSearch,\n      state.cache,\n      state.tree,\n      state.nextUrl,\n      freshnessPolicy,\n      shouldScroll,\n      'push'\n    )\n    dispatchGestureState(forkedGestureState)\n  }\n}\n\n/**\n * The app router that is exposed through `useRouter`. These are public API\n * methods. Internal Next.js code should call the lower level methods directly\n * (although there's lots of existing code that doesn't do that).\n */\nexport const publicAppRouterInstance: AppRouterInstance = {\n  back: () => window.history.back(),\n  forward: () => window.history.forward(),\n  prefetch:\n    // Unlike the old implementation, the Segment Cache doesn't store its\n    // data in the router reducer state; it writes into a global mutable\n    // cache. So we don't need to dispatch an action.\n    (href: string, options?: PrefetchOptions) => {\n      if (isJavaScriptURLString(href)) {\n        throw new Error(\n          'Next.js has blocked a javascript: URL as a security precaution.'\n        )\n      }\n      const actionQueue = getAppRouterActionQueue()\n      const prefetchKind = options?.kind ?? PrefetchKind.AUTO\n\n      // We don't currently offer a way to issue a runtime prefetch via `router.prefetch()`.\n      // This will be possible when we update its API to not take a PrefetchKind.\n      let fetchStrategy: PrefetchTaskFetchStrategy\n      switch (prefetchKind) {\n        case PrefetchKind.AUTO: {\n          // We default to PPR. We'll discover whether or not the route supports it with the initial prefetch.\n          fetchStrategy = FetchStrategy.PPR\n          break\n        }\n        case PrefetchKind.FULL: {\n          fetchStrategy = FetchStrategy.Full\n          break\n        }\n        default: {\n          prefetchKind satisfies never\n          // Despite typescript thinking that this can't happen,\n          // we might get an unexpected value from user code.\n          // We don't know what they want, but we know they want a prefetch,\n          // so use the default.\n          fetchStrategy = FetchStrategy.PPR\n        }\n      }\n\n      prefetchWithSegmentCache(\n        href,\n        actionQueue.state.nextUrl,\n        actionQueue.state.tree,\n        fetchStrategy,\n        options?.onInvalidate ?? null\n      )\n    },\n  replace: (href: string, options?: NavigateOptions) => {\n    if (isJavaScriptURLString(href)) {\n      throw new Error(\n        'Next.js has blocked a javascript: URL as a security precaution.'\n      )\n    }\n    startTransition(() => {\n      dispatchNavigateAction(href, 'replace', options?.scroll ?? true, null)\n    })\n  },\n  push: (href: string, options?: NavigateOptions) => {\n    if (isJavaScriptURLString(href)) {\n      throw new Error(\n        'Next.js has blocked a javascript: URL as a security precaution.'\n      )\n    }\n    startTransition(() => {\n      dispatchNavigateAction(href, 'push', options?.scroll ?? true, null)\n    })\n  },\n  refresh: () => {\n    startTransition(() => {\n      dispatchAppRouterAction({\n        type: ACTION_REFRESH,\n      })\n    })\n  },\n  hmrRefresh: () => {\n    if (process.env.NODE_ENV !== 'development') {\n      throw new Error(\n        'hmrRefresh can only be used in development mode. Please use refresh instead.'\n      )\n    } else {\n      // Reset the known routes table so that route predictions are cleared\n      // when routes change during development.\n      resetKnownRoutes()\n      startTransition(() => {\n        dispatchAppRouterAction({\n          type: ACTION_HMR_REFRESH,\n        })\n      })\n    }\n  },\n}\n\n// Conditionally add experimental_gesturePush when gestureTransition is enabled\nif (process.env.__NEXT_GESTURE_TRANSITION) {\n  ;(publicAppRouterInstance as any).experimental_gesturePush = gesturePush\n}\n\n// Exists for debugging purposes. Don't use in application code.\nif (typeof window !== 'undefined' && window.next) {\n  window.next.router = publicAppRouterInstance\n}\n"],"names":["createMutableActionQueue","dispatchNavigateAction","dispatchTraverseAction","getCurrentAppRouterState","publicAppRouterInstance","runRemainingActions","actionQueue","setState","pending","next","runAction","action","needsRefresh","dispatch","type","ACTION_REFRESH","prevState","state","payload","actionResult","handleResult","nextState","discarded","ACTION_SERVER_ACTION","didRevalidate","resolve","isThenable","then","err","reject","dispatchAction","resolvers","ACTION_RESTORE","deferredPromise","Promise","startTransition","newAction","last","ACTION_NAVIGATE","globalActionQueue","initialState","instrumentationHooks","result","reducer","onRouterTransitionStart","window","Error","getAppRouterActionQueue","getProfilingHookForOnNavigationStart","href","navigateType","shouldScroll","linkInstanceRef","url","URL","addBasePath","location","process","env","__NEXT_APP_NAV_FAIL_HANDLING","__pendingUrl","setLinkForCurrentNavigation","dispatchAppRouterAction","isExternalUrl","isExternalURL","locationSearch","search","historyState","gesturePush","options","__NEXT_GESTURE_TRANSITION","isJavaScriptURLString","currentUrl","canonicalUrl","scroll","freshnessPolicy","FreshnessPolicy","Gesture","forkedGestureState","navigate","renderedSearch","cache","tree","nextUrl","dispatchGestureState","back","history","forward","prefetch","prefetchKind","kind","PrefetchKind","AUTO","fetchStrategy","FetchStrategy","PPR","FULL","Full","prefetchWithSegmentCache","onInvalidate","replace","push","refresh","hmrRefresh","NODE_ENV","resetKnownRoutes","ACTION_HMR_REFRESH","experimental_gesturePush","router"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 10622, "column": 0}, "map": {"version":3,"sources":["file:///D:/AconnectJP/node_modules/next/src/client/components/app-router-announcer.tsx"],"sourcesContent":["import { useEffect, useRef, useState } from 'react'\nimport { createPortal } from 'react-dom'\nimport type { FlightRouterState } from '../../shared/lib/app-router-types'\n\nconst ANNOUNCER_TYPE = 'next-route-announcer'\nconst ANNOUNCER_ID = '__next-route-announcer__'\n\nfunction getAnnouncerNode() {\n  const existingAnnouncer = document.getElementsByName(ANNOUNCER_TYPE)[0]\n  if (existingAnnouncer?.shadowRoot?.childNodes[0]) {\n    return existingAnnouncer.shadowRoot.childNodes[0] as HTMLElement\n  } else {\n    const container = document.createElement(ANNOUNCER_TYPE)\n    container.style.cssText = 'position:absolute'\n    const announcer = document.createElement('div')\n    announcer.ariaLive = 'assertive'\n    announcer.id = ANNOUNCER_ID\n    announcer.role = 'alert'\n    announcer.style.cssText =\n      'position:absolute;border:0;height:1px;margin:-1px;padding:0;width:1px;clip:rect(0 0 0 0);overflow:hidden;white-space:nowrap;word-wrap:normal'\n\n    // Use shadow DOM here to avoid any potential CSS bleed\n    const shadow = container.attachShadow({ mode: 'open' })\n    shadow.appendChild(announcer)\n    document.body.appendChild(container)\n    return announcer\n  }\n}\n\nexport function AppRouterAnnouncer({ tree }: { tree: FlightRouterState }) {\n  const [portalNode, setPortalNode] = useState<HTMLElement | null>(null)\n\n  useEffect(() => {\n    const announcer = getAnnouncerNode()\n    setPortalNode(announcer)\n    return () => {\n      const container = document.getElementsByTagName(ANNOUNCER_TYPE)[0]\n      if (container?.isConnected) {\n        document.body.removeChild(container)\n      }\n    }\n  }, [])\n\n  const [routeAnnouncement, setRouteAnnouncement] = useState('')\n  const previousTitle = useRef<string | undefined>(undefined)\n\n  useEffect(() => {\n    let currentTitle = ''\n    if (document.title) {\n      currentTitle = document.title\n    } else {\n      const pageHeader = document.querySelector('h1')\n      if (pageHeader) {\n        currentTitle = pageHeader.innerText || pageHeader.textContent || ''\n      }\n    }\n\n    // Only announce the title change, but not for the first load because screen\n    // readers do that automatically.\n    if (\n      previousTitle.current !== undefined &&\n      previousTitle.current !== currentTitle\n    ) {\n      setRouteAnnouncement(currentTitle)\n    }\n    previousTitle.current = currentTitle\n  }, [tree])\n\n  return portalNode ? createPortal(routeAnnouncement, portalNode) : null\n}\n"],"names":["AppRouterAnnouncer","ANNOUNCER_TYPE","ANNOUNCER_ID","getAnnouncerNode","existingAnnouncer","document","getElementsByName","shadowRoot","childNodes","container","createElement","style","cssText","announcer","ariaLive","id","role","shadow","attachShadow","mode","appendChild","body","tree","portalNode","setPortalNode","useState","useEffect","getElementsByTagName","isConnected","removeChild","routeAnnouncement","setRouteAnnouncement","previousTitle","useRef","undefined","currentTitle","title","pageHeader","querySelector","innerText","textContent","current","createPortal"],"mappings":";;;+BA6BgBA,sBAAAA;;;eAAAA;;;uBA7B4B;0BACf;AAG7B,MAAMC,iBAAiB;AACvB,MAAMC,eAAe;AAErB,SAASC;IACP,MAAMC,oBAAoBC,SAASC,iBAAiB,CAACL,eAAe,CAAC,EAAE;IACvE,IAAIG,mBAAmBG,YAAYC,UAAU,CAAC,EAAE,EAAE;QAChD,OAAOJ,kBAAkBG,UAAU,CAACC,UAAU,CAAC,EAAE;IACnD,OAAO;QACL,MAAMC,YAAYJ,SAASK,aAAa,CAACT;QACzCQ,UAAUE,KAAK,CAACC,OAAO,GAAG;QAC1B,MAAMC,YAAYR,SAASK,aAAa,CAAC;QACzCG,UAAUC,QAAQ,GAAG;QACrBD,UAAUE,EAAE,GAAGb;QACfW,UAAUG,IAAI,GAAG;QACjBH,UAAUF,KAAK,CAACC,OAAO,GACrB;QAEF,uDAAuD;QACvD,MAAMK,SAASR,UAAUS,YAAY,CAAC;YAAEC,MAAM;QAAO;QACrDF,OAAOG,WAAW,CAACP;QACnBR,SAASgB,IAAI,CAACD,WAAW,CAACX;QAC1B,OAAOI;IACT;AACF;AAEO,SAASb,mBAAmB,EAAEsB,IAAI,EAA+B;IACtE,MAAM,CAACC,YAAYC,cAAc,GAAGC,CAAAA,GAAAA,OAAAA,QAAQ,EAAqB;IAEjEC,CAAAA,GAAAA,OAAAA,SAAS,EAAC;QACR,MAAMb,YAAYV;QAClBqB,cAAcX;QACd,OAAO;YACL,MAAMJ,YAAYJ,SAASsB,oBAAoB,CAAC1B,eAAe,CAAC,EAAE;YAClE,IAAIQ,WAAWmB,aAAa;gBAC1BvB,SAASgB,IAAI,CAACQ,WAAW,CAACpB;YAC5B;QACF;IACF,GAAG,EAAE;IAEL,MAAM,CAACqB,mBAAmBC,qBAAqB,GAAGN,CAAAA,GAAAA,OAAAA,QAAQ,EAAC;IAC3D,MAAMO,gBAAgBC,CAAAA,GAAAA,OAAAA,MAAM,EAAqBC;IAEjDR,CAAAA,GAAAA,OAAAA,SAAS,EAAC;QACR,IAAIS,eAAe;QACnB,IAAI9B,SAAS+B,KAAK,EAAE;YAClBD,eAAe9B,SAAS+B,KAAK;QAC/B,OAAO;YACL,MAAMC,aAAahC,SAASiC,aAAa,CAAC;YAC1C,IAAID,YAAY;gBACdF,eAAeE,WAAWE,SAAS,IAAIF,WAAWG,WAAW,IAAI;YACnE;QACF;QAEA,4EAA4E;QAC5E,iCAAiC;QACjC,IACER,cAAcS,OAAO,KAAKP,aAC1BF,cAAcS,OAAO,KAAKN,cAC1B;YACAJ,qBAAqBI;QACvB;QACAH,cAAcS,OAAO,GAAGN;IAC1B,GAAG;QAACb;KAAK;IAET,OAAOC,aAAAA,WAAAA,GAAamB,CAAAA,GAAAA,UAAAA,YAAY,EAACZ,mBAAmBP,cAAc;AACpE","ignoreList":[0]}},
    {"offset": {"line": 10702, "column": 0}, "map": {"version":3,"sources":["file:///D:/AconnectJP/node_modules/next/src/client/components/forbidden.ts"],"sourcesContent":["import {\n  HTTP_ERROR_FALLBACK_ERROR_CODE,\n  type HTTPAccessFallbackError,\n} from './http-access-fallback/http-access-fallback'\n\n// TODO: Add `forbidden` docs\n/**\n * @experimental\n * This function allows you to render the [forbidden.js file](https://nextjs.org/docs/app/api-reference/file-conventions/forbidden)\n * within a route segment as well as inject a tag.\n *\n * `forbidden()` can be used in\n * [Server Components](https://nextjs.org/docs/app/building-your-application/rendering/server-components),\n * [Route Handlers](https://nextjs.org/docs/app/building-your-application/routing/route-handlers), and\n * [Server Actions](https://nextjs.org/docs/app/building-your-application/data-fetching/server-actions-and-mutations).\n *\n * Read more: [Next.js Docs: `forbidden`](https://nextjs.org/docs/app/api-reference/functions/forbidden)\n */\n\nconst DIGEST = `${HTTP_ERROR_FALLBACK_ERROR_CODE};403`\n\nexport function forbidden(): never {\n  if (!process.env.__NEXT_EXPERIMENTAL_AUTH_INTERRUPTS) {\n    throw new Error(\n      `\\`forbidden()\\` is experimental and only allowed to be enabled when \\`experimental.authInterrupts\\` is enabled.`\n    )\n  }\n\n  const error = new Error(DIGEST) as HTTPAccessFallbackError\n  ;(error as HTTPAccessFallbackError).digest = DIGEST\n  throw error\n}\n"],"names":["forbidden","DIGEST","HTTP_ERROR_FALLBACK_ERROR_CODE","process","env","__NEXT_EXPERIMENTAL_AUTH_INTERRUPTS","Error","error","digest"],"mappings":"AAsBOG,QAAQC,GAAG,CAACC,mCAAmC;;;;;+BADtCL,aAAAA;;;eAAAA;;;oCAlBT;AAEP,6BAA6B;AAC7B;;;;;;;;;;;CAWC,GAED,MAAMC,SAAS,GAAGC,oBAAAA,8BAA8B,CAAC,IAAI,CAAC;AAE/C,SAASF;IACd,IAAI,oCAAkD;QACpD,MAAM,OAAA,cAEL,CAFK,IAAIM,MACR,CAAC,+GAA+G,CAAC,GAD7G,qBAAA;mBAAA;wBAAA;0BAAA;QAEN;IACF;IAEA,MAAMC,QAAQ,OAAA,cAAiB,CAAjB,IAAID,MAAML,SAAV,qBAAA;eAAA;oBAAA;sBAAA;IAAgB;IAC5BM,MAAkCC,MAAM,GAAGP;IAC7C,MAAMM;AACR","ignoreList":[0]}},
    {"offset": {"line": 10754, "column": 0}, "map": {"version":3,"sources":["file:///D:/AconnectJP/node_modules/next/src/client/components/unauthorized.ts"],"sourcesContent":["import {\n  HTTP_ERROR_FALLBACK_ERROR_CODE,\n  type HTTPAccessFallbackError,\n} from './http-access-fallback/http-access-fallback'\n\n// TODO: Add `unauthorized` docs\n/**\n * @experimental\n * This function allows you to render the [unauthorized.js file](https://nextjs.org/docs/app/api-reference/file-conventions/unauthorized)\n * within a route segment as well as inject a tag.\n *\n * `unauthorized()` can be used in\n * [Server Components](https://nextjs.org/docs/app/building-your-application/rendering/server-components),\n * [Route Handlers](https://nextjs.org/docs/app/building-your-application/routing/route-handlers), and\n * [Server Actions](https://nextjs.org/docs/app/building-your-application/data-fetching/server-actions-and-mutations).\n *\n *\n * Read more: [Next.js Docs: `unauthorized`](https://nextjs.org/docs/app/api-reference/functions/unauthorized)\n */\n\nconst DIGEST = `${HTTP_ERROR_FALLBACK_ERROR_CODE};401`\n\nexport function unauthorized(): never {\n  if (!process.env.__NEXT_EXPERIMENTAL_AUTH_INTERRUPTS) {\n    throw new Error(\n      `\\`unauthorized()\\` is experimental and only allowed to be used when \\`experimental.authInterrupts\\` is enabled.`\n    )\n  }\n\n  const error = new Error(DIGEST) as HTTPAccessFallbackError\n  ;(error as HTTPAccessFallbackError).digest = DIGEST\n  throw error\n}\n"],"names":["unauthorized","DIGEST","HTTP_ERROR_FALLBACK_ERROR_CODE","process","env","__NEXT_EXPERIMENTAL_AUTH_INTERRUPTS","Error","error","digest"],"mappings":"AAuBOG,QAAQC,GAAG,CAACC,mCAAmC;;;;;+BADtCL,gBAAAA;;;eAAAA;;;oCAnBT;AAEP,gCAAgC;AAChC;;;;;;;;;;;;CAYC,GAED,MAAMC,SAAS,GAAGC,oBAAAA,8BAA8B,CAAC,IAAI,CAAC;AAE/C,SAASF;IACd,IAAI,oCAAkD;QACpD,MAAM,OAAA,cAEL,CAFK,IAAIM,MACR,CAAC,+GAA+G,CAAC,GAD7G,qBAAA;mBAAA;wBAAA;0BAAA;QAEN;IACF;IAEA,MAAMC,QAAQ,OAAA,cAAiB,CAAjB,IAAID,MAAML,SAAV,qBAAA;eAAA;oBAAA;sBAAA;IAAgB;IAC5BM,MAAkCC,MAAM,GAAGP;IAC7C,MAAMM;AACR","ignoreList":[0]}},
    {"offset": {"line": 10807, "column": 0}, "map": {"version":3,"sources":["file:///D:/AconnectJP/node_modules/next/src/client/components/unstable-rethrow.browser.ts"],"sourcesContent":["import { isBailoutToCSRError } from '../../shared/lib/lazy-dynamic/bailout-to-csr'\nimport { isNextRouterError } from './is-next-router-error'\n\nexport function unstable_rethrow(error: unknown): void {\n  if (isNextRouterError(error) || isBailoutToCSRError(error)) {\n    throw error\n  }\n\n  if (error instanceof Error && 'cause' in error) {\n    unstable_rethrow(error.cause)\n  }\n}\n"],"names":["unstable_rethrow","error","isNextRouterError","isBailoutToCSRError","Error","cause"],"mappings":";;;+BAGgBA,oBAAAA;;;eAAAA;;;8BAHoB;mCACF;AAE3B,SAASA,iBAAiBC,KAAc;IAC7C,IAAIC,CAAAA,GAAAA,mBAAAA,iBAAiB,EAACD,UAAUE,CAAAA,GAAAA,cAAAA,mBAAmB,EAACF,QAAQ;QAC1D,MAAMA;IACR;IAEA,IAAIA,iBAAiBG,SAAS,WAAWH,OAAO;QAC9CD,iBAAiBC,MAAMI,KAAK;IAC9B;AACF","ignoreList":[0]}},
    {"offset": {"line": 10837, "column": 0}, "map": {"version":3,"sources":["file:///D:/AconnectJP/node_modules/next/src/client/components/hooks-server-context.ts"],"sourcesContent":["const DYNAMIC_ERROR_CODE = 'DYNAMIC_SERVER_USAGE'\n\nexport class DynamicServerError extends Error {\n  digest: typeof DYNAMIC_ERROR_CODE = DYNAMIC_ERROR_CODE\n\n  constructor(public readonly description: string) {\n    super(`Dynamic server usage: ${description}`)\n  }\n}\n\nexport function isDynamicServerError(err: unknown): err is DynamicServerError {\n  if (\n    typeof err !== 'object' ||\n    err === null ||\n    !('digest' in err) ||\n    typeof err.digest !== 'string'\n  ) {\n    return false\n  }\n\n  return err.digest === DYNAMIC_ERROR_CODE\n}\n"],"names":["DynamicServerError","isDynamicServerError","DYNAMIC_ERROR_CODE","Error","constructor","description","digest","err"],"mappings":";;;;;;;;;;;;;;IAEaA,kBAAkB,EAAA;eAAlBA;;IAQGC,oBAAoB,EAAA;eAApBA;;;AAVhB,MAAMC,qBAAqB;AAEpB,MAAMF,2BAA2BG;IAGtCC,YAA4BC,WAAmB,CAAE;QAC/C,KAAK,CAAC,CAAC,sBAAsB,EAAEA,aAAa,GAAA,IAAA,CADlBA,WAAAA,GAAAA,aAAAA,IAAAA,CAF5BC,MAAAA,GAAoCJ;IAIpC;AACF;AAEO,SAASD,qBAAqBM,GAAY;IAC/C,IACE,OAAOA,QAAQ,YACfA,QAAQ,QACR,CAAE,CAAA,YAAYA,GAAE,KAChB,OAAOA,IAAID,MAAM,KAAK,UACtB;QACA,OAAO;IACT;IAEA,OAAOC,IAAID,MAAM,KAAKJ;AACxB","ignoreList":[0]}},
    {"offset": {"line": 10881, "column": 0}, "map": {"version":3,"sources":["file:///D:/AconnectJP/node_modules/next/src/client/components/static-generation-bailout.ts"],"sourcesContent":["const NEXT_STATIC_GEN_BAILOUT = 'NEXT_STATIC_GEN_BAILOUT'\n\nexport class StaticGenBailoutError extends Error {\n  public readonly code = NEXT_STATIC_GEN_BAILOUT\n}\n\nexport function isStaticGenBailoutError(\n  error: unknown\n): error is StaticGenBailoutError {\n  if (typeof error !== 'object' || error === null || !('code' in error)) {\n    return false\n  }\n\n  return error.code === NEXT_STATIC_GEN_BAILOUT\n}\n"],"names":["StaticGenBailoutError","isStaticGenBailoutError","NEXT_STATIC_GEN_BAILOUT","Error","code","error"],"mappings":";;;;;;;;;;;;;;IAEaA,qBAAqB,EAAA;eAArBA;;IAIGC,uBAAuB,EAAA;eAAvBA;;;AANhB,MAAMC,0BAA0B;AAEzB,MAAMF,8BAA8BG;;QAApC,KAAA,IAAA,OAAA,IAAA,CACWC,IAAAA,GAAOF;;AACzB;AAEO,SAASD,wBACdI,KAAc;IAEd,IAAI,OAAOA,UAAU,YAAYA,UAAU,QAAQ,CAAE,CAAA,UAAUA,KAAI,GAAI;QACrE,OAAO;IACT;IAEA,OAAOA,MAAMD,IAAI,KAAKF;AACxB","ignoreList":[0]}},
    {"offset": {"line": 10925, "column": 0}, "map": {"version":3,"sources":["file:///D:/AconnectJP/node_modules/next/src/client/components/unstable-rethrow.server.ts"],"sourcesContent":["import { isHangingPromiseRejectionError } from '../../server/dynamic-rendering-utils'\nimport { isPostpone } from '../../server/lib/router-utils/is-postpone'\nimport { isBailoutToCSRError } from '../../shared/lib/lazy-dynamic/bailout-to-csr'\nimport { isNextRouterError } from './is-next-router-error'\nimport {\n  isDynamicPostpone,\n  isPrerenderInterruptedError,\n} from '../../server/app-render/dynamic-rendering'\nimport { isDynamicServerError } from './hooks-server-context'\n\nexport function unstable_rethrow(error: unknown): void {\n  if (\n    isNextRouterError(error) ||\n    isBailoutToCSRError(error) ||\n    isDynamicServerError(error) ||\n    isDynamicPostpone(error) ||\n    isPostpone(error) ||\n    isHangingPromiseRejectionError(error) ||\n    isPrerenderInterruptedError(error)\n  ) {\n    throw error\n  }\n\n  if (error instanceof Error && 'cause' in error) {\n    unstable_rethrow(error.cause)\n  }\n}\n"],"names":["unstable_rethrow","error","isNextRouterError","isBailoutToCSRError","isDynamicServerError","isDynamicPostpone","isPostpone","isHangingPromiseRejectionError","isPrerenderInterruptedError","Error","cause"],"mappings":";;;+BAUgBA,oBAAAA;;;eAAAA;;;uCAV+B;4BACpB;8BACS;mCACF;kCAI3B;oCAC8B;AAE9B,SAASA,iBAAiBC,KAAc;IAC7C,IACEC,CAAAA,GAAAA,mBAAAA,iBAAiB,EAACD,UAClBE,CAAAA,GAAAA,cAAAA,mBAAmB,EAACF,UACpBG,CAAAA,GAAAA,oBAAAA,oBAAoB,EAACH,UACrBI,CAAAA,GAAAA,kBAAAA,iBAAiB,EAACJ,UAClBK,CAAAA,GAAAA,YAAAA,UAAU,EAACL,UACXM,CAAAA,GAAAA,uBAAAA,8BAA8B,EAACN,UAC/BO,CAAAA,GAAAA,kBAAAA,2BAA2B,EAACP,QAC5B;QACA,MAAMA;IACR;IAEA,IAAIA,iBAAiBQ,SAAS,WAAWR,OAAO;QAC9CD,iBAAiBC,MAAMS,KAAK;IAC9B;AACF","ignoreList":[0]}},
    {"offset": {"line": 10959, "column": 0}, "map": {"version":3,"sources":["file:///D:/AconnectJP/node_modules/next/src/client/components/unstable-rethrow.ts"],"sourcesContent":["/**\n * This function should be used to rethrow internal Next.js errors so that they can be handled by the framework.\n * When wrapping an API that uses errors to interrupt control flow, you should use this function before you do any error handling.\n * This function will rethrow the error if it is a Next.js error so it can be handled, otherwise it will do nothing.\n *\n * Read more: [Next.js Docs: `unstable_rethrow`](https://nextjs.org/docs/app/api-reference/functions/unstable_rethrow)\n */\nexport const unstable_rethrow =\n  typeof window === 'undefined'\n    ? (\n        require('./unstable-rethrow.server') as typeof import('./unstable-rethrow.server')\n      ).unstable_rethrow\n    : (\n        require('./unstable-rethrow.browser') as typeof import('./unstable-rethrow.browser')\n      ).unstable_rethrow\n"],"names":["unstable_rethrow","window","require"],"mappings":"AAAA;;;;;;CAMC;;;+BACYA,oBAAAA;;;eAAAA;;;AAAN,MAAMA,mBACX,OAAOC,WAAW,cAEZC,QAAQ,2HACRF,gBAAgB,GAEhBE,QAAQ,4HACRF,gBAAgB","ignoreList":[0]}},
    {"offset": {"line": 10986, "column": 0}, "map": {"version":3,"sources":["file:///D:/AconnectJP/node_modules/next/src/client/components/navigation.react-server.ts"],"sourcesContent":["import { ReadonlyURLSearchParams } from './readonly-url-search-params'\n\nexport function unstable_isUnrecognizedActionError(): boolean {\n  throw new Error(\n    '`unstable_isUnrecognizedActionError` can only be used on the client.'\n  )\n}\n\nexport { redirect, permanentRedirect } from './redirect'\nexport { notFound } from './not-found'\nexport { forbidden } from './forbidden'\nexport { unauthorized } from './unauthorized'\nexport { unstable_rethrow } from './unstable-rethrow'\nexport { ReadonlyURLSearchParams }\n\nexport const RedirectType = {\n  push: 'push',\n  replace: 'replace',\n} as const\n"],"names":["ReadonlyURLSearchParams","RedirectType","forbidden","notFound","permanentRedirect","redirect","unauthorized","unstable_isUnrecognizedActionError","unstable_rethrow","Error","push","replace"],"mappings":";;;;;;;;;;;;;;;;;;;;;IAaSA,uBAAuB,EAAA;eAAvBA,yBAAAA,uBAAuB;;IAEnBC,YAAY,EAAA;eAAZA;;IALJC,SAAS,EAAA;eAATA,WAAAA,SAAS;;IADTC,QAAQ,EAAA;eAARA,UAAAA,QAAQ;;IADEC,iBAAiB,EAAA;eAAjBA,UAAAA,iBAAiB;;IAA3BC,QAAQ,EAAA;eAARA,UAAAA,QAAQ;;IAGRC,YAAY,EAAA;eAAZA,cAAAA,YAAY;;IATLC,kCAAkC,EAAA;eAAlCA;;IAUPC,gBAAgB,EAAA;eAAhBA,iBAAAA,gBAAgB;;;yCAZe;0BAQI;0BACnB;2BACC;8BACG;iCACI;AAV1B,SAASD;IACd,MAAM,OAAA,cAEL,CAFK,IAAIE,MACR,yEADI,qBAAA;eAAA;oBAAA;sBAAA;IAEN;AACF;AASO,MAAMR,eAAe;IAC1BS,MAAM;IACNC,SAAS;AACX","ignoreList":[0]}},
    {"offset": {"line": 11063, "column": 0}, "map": {"version":3,"sources":["file:///D:/AconnectJP/node_modules/next/src/client/components/navigation.ts"],"sourcesContent":["import type { Params } from '../../server/request/params'\n\nimport React, { useContext, useMemo, use } from 'react'\nimport {\n  AppRouterContext,\n  LayoutRouterContext,\n  type AppRouterInstance,\n} from '../../shared/lib/app-router-context.shared-runtime'\nimport {\n  SearchParamsContext,\n  PathnameContext,\n  PathParamsContext,\n  NavigationPromisesContext,\n  ReadonlyURLSearchParams,\n} from '../../shared/lib/hooks-client-context.shared-runtime'\nimport {\n  computeSelectedLayoutSegment,\n  getSelectedLayoutSegmentPath,\n} from '../../shared/lib/segment'\n\nconst useDynamicRouteParams =\n  typeof window === 'undefined'\n    ? (\n        require('../../server/app-render/dynamic-rendering') as typeof import('../../server/app-render/dynamic-rendering')\n      ).useDynamicRouteParams\n    : undefined\n\nconst useDynamicSearchParams =\n  typeof window === 'undefined'\n    ? (\n        require('../../server/app-render/dynamic-rendering') as typeof import('../../server/app-render/dynamic-rendering')\n      ).useDynamicSearchParams\n    : undefined\n\n/**\n * A [Client Component](https://nextjs.org/docs/app/building-your-application/rendering/client-components) hook\n * that lets you *read* the current URL's search parameters.\n *\n * Learn more about [`URLSearchParams` on MDN](https://developer.mozilla.org/docs/Web/API/URLSearchParams)\n *\n * @example\n * ```ts\n * \"use client\"\n * import { useSearchParams } from 'next/navigation'\n *\n * export default function Page() {\n *   const searchParams = useSearchParams()\n *   searchParams.get('foo') // returns 'bar' when ?foo=bar\n *   // ...\n * }\n * ```\n *\n * Read more: [Next.js Docs: `useSearchParams`](https://nextjs.org/docs/app/api-reference/functions/use-search-params)\n */\n// Client components API\nexport function useSearchParams(): ReadonlyURLSearchParams {\n  useDynamicSearchParams?.('useSearchParams()')\n\n  const searchParams = useContext(SearchParamsContext)\n\n  // In the case where this is `null`, the compat types added in\n  // `next-env.d.ts` will add a new overload that changes the return type to\n  // include `null`.\n  const readonlySearchParams = useMemo((): ReadonlyURLSearchParams => {\n    if (!searchParams) {\n      // When the router is not ready in pages, we won't have the search params\n      // available.\n      return null!\n    }\n\n    return new ReadonlyURLSearchParams(searchParams)\n  }, [searchParams])\n\n  // Instrument with Suspense DevTools (dev-only)\n  if (process.env.NODE_ENV !== 'production' && 'use' in React) {\n    const navigationPromises = use(NavigationPromisesContext)\n    if (navigationPromises) {\n      return use(navigationPromises.searchParams)\n    }\n  }\n\n  return readonlySearchParams\n}\n\n/**\n * A [Client Component](https://nextjs.org/docs/app/building-your-application/rendering/client-components) hook\n * that lets you read the current URL's pathname.\n *\n * @example\n * ```ts\n * \"use client\"\n * import { usePathname } from 'next/navigation'\n *\n * export default function Page() {\n *  const pathname = usePathname() // returns \"/dashboard\" on /dashboard?foo=bar\n *  // ...\n * }\n * ```\n *\n * Read more: [Next.js Docs: `usePathname`](https://nextjs.org/docs/app/api-reference/functions/use-pathname)\n */\n// Client components API\nexport function usePathname(): string {\n  useDynamicRouteParams?.('usePathname()')\n\n  // In the case where this is `null`, the compat types added in `next-env.d.ts`\n  // will add a new overload that changes the return type to include `null`.\n  const pathname = useContext(PathnameContext) as string\n\n  // Instrument with Suspense DevTools (dev-only)\n  if (process.env.NODE_ENV !== 'production' && 'use' in React) {\n    const navigationPromises = use(NavigationPromisesContext)\n    if (navigationPromises) {\n      return use(navigationPromises.pathname)\n    }\n  }\n\n  return pathname\n}\n\n// Client components API\nexport {\n  ServerInsertedHTMLContext,\n  useServerInsertedHTML,\n} from '../../shared/lib/server-inserted-html.shared-runtime'\n\n/**\n *\n * This hook allows you to programmatically change routes inside [Client Component](https://nextjs.org/docs/app/building-your-application/rendering/client-components).\n *\n * @example\n * ```ts\n * \"use client\"\n * import { useRouter } from 'next/navigation'\n *\n * export default function Page() {\n *  const router = useRouter()\n *  // ...\n *  router.push('/dashboard') // Navigate to /dashboard\n * }\n * ```\n *\n * Read more: [Next.js Docs: `useRouter`](https://nextjs.org/docs/app/api-reference/functions/use-router)\n */\n// Client components API\nexport function useRouter(): AppRouterInstance {\n  const router = useContext(AppRouterContext)\n  if (router === null) {\n    throw new Error('invariant expected app router to be mounted')\n  }\n\n  return router\n}\n\n/**\n * A [Client Component](https://nextjs.org/docs/app/building-your-application/rendering/client-components) hook\n * that lets you read a route's dynamic params filled in by the current URL.\n *\n * @example\n * ```ts\n * \"use client\"\n * import { useParams } from 'next/navigation'\n *\n * export default function Page() {\n *   // on /dashboard/[team] where pathname is /dashboard/nextjs\n *   const { team } = useParams() // team === \"nextjs\"\n * }\n * ```\n *\n * Read more: [Next.js Docs: `useParams`](https://nextjs.org/docs/app/api-reference/functions/use-params)\n */\n// Client components API\nexport function useParams<T extends Params = Params>(): T {\n  useDynamicRouteParams?.('useParams()')\n\n  const params = useContext(PathParamsContext) as T\n\n  // Instrument with Suspense DevTools (dev-only)\n  if (process.env.NODE_ENV !== 'production' && 'use' in React) {\n    const navigationPromises = use(NavigationPromisesContext)\n    if (navigationPromises) {\n      return use(navigationPromises.params) as T\n    }\n  }\n\n  return params\n}\n\n/**\n * A [Client Component](https://nextjs.org/docs/app/building-your-application/rendering/client-components) hook\n * that lets you read the active route segments **below** the Layout it is called from.\n *\n * @example\n * ```ts\n * 'use client'\n *\n * import { useSelectedLayoutSegments } from 'next/navigation'\n *\n * export default function ExampleClientComponent() {\n *   const segments = useSelectedLayoutSegments()\n *\n *   return (\n *     <ul>\n *       {segments.map((segment, index) => (\n *         <li key={index}>{segment}</li>\n *       ))}\n *     </ul>\n *   )\n * }\n * ```\n *\n * Read more: [Next.js Docs: `useSelectedLayoutSegments`](https://nextjs.org/docs/app/api-reference/functions/use-selected-layout-segments)\n */\n// Client components API\nexport function useSelectedLayoutSegments(\n  parallelRouteKey: string = 'children'\n): string[] {\n  useDynamicRouteParams?.('useSelectedLayoutSegments()')\n\n  const context = useContext(LayoutRouterContext)\n  // @ts-expect-error This only happens in `pages`. Type is overwritten in navigation.d.ts\n  if (!context) return null\n\n  // Instrument with Suspense DevTools (dev-only)\n  if (process.env.NODE_ENV !== 'production' && 'use' in React) {\n    const navigationPromises = use(NavigationPromisesContext)\n    if (navigationPromises) {\n      const promise =\n        navigationPromises.selectedLayoutSegmentsPromises?.get(parallelRouteKey)\n      if (promise) {\n        // We should always have a promise here, but if we don't, it's not worth erroring over.\n        // We just won't be able to instrument it, but can still provide the value.\n        return use(promise)\n      }\n    }\n  }\n\n  return getSelectedLayoutSegmentPath(context.parentTree, parallelRouteKey)\n}\n\n/**\n * A [Client Component](https://nextjs.org/docs/app/building-your-application/rendering/client-components) hook\n * that lets you read the active route segment **one level below** the Layout it is called from.\n *\n * @example\n * ```ts\n * 'use client'\n * import { useSelectedLayoutSegment } from 'next/navigation'\n *\n * export default function ExampleClientComponent() {\n *   const segment = useSelectedLayoutSegment()\n *\n *   return <p>Active segment: {segment}</p>\n * }\n * ```\n *\n * Read more: [Next.js Docs: `useSelectedLayoutSegment`](https://nextjs.org/docs/app/api-reference/functions/use-selected-layout-segment)\n */\n// Client components API\nexport function useSelectedLayoutSegment(\n  parallelRouteKey: string = 'children'\n): string | null {\n  useDynamicRouteParams?.('useSelectedLayoutSegment()')\n  const navigationPromises = useContext(NavigationPromisesContext)\n  const selectedLayoutSegments = useSelectedLayoutSegments(parallelRouteKey)\n\n  // Instrument with Suspense DevTools (dev-only)\n  if (\n    process.env.NODE_ENV !== 'production' &&\n    navigationPromises &&\n    'use' in React\n  ) {\n    const promise =\n      navigationPromises.selectedLayoutSegmentPromises?.get(parallelRouteKey)\n    if (promise) {\n      // We should always have a promise here, but if we don't, it's not worth erroring over.\n      // We just won't be able to instrument it, but can still provide the value.\n      return use(promise)\n    }\n  }\n\n  return computeSelectedLayoutSegment(selectedLayoutSegments, parallelRouteKey)\n}\n\nexport { unstable_isUnrecognizedActionError } from './unrecognized-action-error'\n\n// Shared components APIs\nexport {\n  // We need the same class that was used to instantiate the context value\n  // Otherwise instanceof checks will fail in usercode\n  ReadonlyURLSearchParams,\n}\nexport {\n  notFound,\n  forbidden,\n  unauthorized,\n  redirect,\n  permanentRedirect,\n  RedirectType,\n  unstable_rethrow,\n} from './navigation.react-server'\n"],"names":["ReadonlyURLSearchParams","RedirectType","ServerInsertedHTMLContext","forbidden","notFound","permanentRedirect","redirect","unauthorized","unstable_isUnrecognizedActionError","unstable_rethrow","useParams","usePathname","useRouter","useSearchParams","useSelectedLayoutSegment","useSelectedLayoutSegments","useServerInsertedHTML","useDynamicRouteParams","window","require","undefined","useDynamicSearchParams","searchParams","useContext","SearchParamsContext","readonlySearchParams","useMemo","process","env","NODE_ENV","React","navigationPromises","use","NavigationPromisesContext","pathname","PathnameContext","router","AppRouterContext","Error","params","PathParamsContext","parallelRouteKey","context","LayoutRouterContext","promise","selectedLayoutSegmentsPromises","get","getSelectedLayoutSegmentPath","parentTree","selectedLayoutSegments","selectedLayoutSegmentPromises","computeSelectedLayoutSegment"],"mappings":"AA0EM2B,QAAQC,GAAG,CAACC,QAAQ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;IAsNxB,wEAAwE;IACxE,oDAAoD;IACpD7B,uBAAuB,EAAA;eAAvBA,iCAAAA,uBAAuB;;IAQvBC,YAAY,EAAA;eAAZA,uBAAAA,YAAY;;IAhLZC,yBAAyB,EAAA;eAAzBA,iCAAAA,yBAAyB;;IA4KzBC,SAAS,EAAA;eAATA,uBAAAA,SAAS;;IADTC,QAAQ,EAAA;eAARA,uBAAAA,QAAQ;;IAIRC,iBAAiB,EAAA;eAAjBA,uBAAAA,iBAAiB;;IADjBC,QAAQ,EAAA;eAARA,uBAAAA,QAAQ;;IADRC,YAAY,EAAA;eAAZA,uBAAAA,YAAY;;IAXLC,kCAAkC,EAAA;eAAlCA,yBAAAA,kCAAkC;;IAezCC,gBAAgB,EAAA;eAAhBA,uBAAAA,gBAAgB;;IA/HFC,SAAS,EAAA;eAATA;;IAtEAC,WAAW,EAAA;eAAXA;;IA2CAC,SAAS,EAAA;eAATA;;IA1FAC,eAAe,EAAA;eAAfA;;IA4MAC,wBAAwB,EAAA;eAAxBA;;IA7CAC,yBAAyB,EAAA;eAAzBA;;IA3FdC,qBAAqB,EAAA;eAArBA,iCAAAA,qBAAqB;;;;iEAzHyB;+CAKzC;iDAOA;yBAIA;iDA0GA;yCAgK4C;uCAgB5C;AAxRP,MAAMC,wBACJ,OAAOC,WAAW,cAEZC,QAAQ,qHACRF,qBAAqB,GACvBG;AAEN,MAAMC,yBACJ,OAAOH,WAAW,cAEZC,QAAQ,qHACRE,sBAAsB,GACxBD;AAuBC,SAASP;IACdQ,yBAAyB;IAEzB,MAAMC,eAAeC,CAAAA,GAAAA,OAAAA,UAAU,EAACC,iCAAAA,mBAAmB;IAEnD,8DAA8D;IAC9D,0EAA0E;IAC1E,kBAAkB;IAClB,MAAMC,uBAAuBC,CAAAA,GAAAA,OAAAA,OAAO,EAAC;QACnC,IAAI,CAACJ,cAAc;YACjB,yEAAyE;YACzE,aAAa;YACb,OAAO;QACT;QAEA,OAAO,IAAItB,iCAAAA,uBAAuB,CAACsB;IACrC,GAAG;QAACA;KAAa;IAEjB,+CAA+C;IAC/C,wDAA6B,gBAAgB,SAASQ,OAAAA,OAAK,EAAE;QAC3D,MAAMC,qBAAqBC,CAAAA,GAAAA,OAAAA,GAAG,EAACC,iCAAAA,yBAAyB;QACxD,IAAIF,oBAAoB;YACtB,OAAOC,CAAAA,GAAAA,OAAAA,GAAG,EAACD,mBAAmBT,YAAY;QAC5C;IACF;IAEA,OAAOG;AACT;AAoBO,SAASd;IACdM,wBAAwB;IAExB,8EAA8E;IAC9E,0EAA0E;IAC1E,MAAMiB,WAAWX,CAAAA,GAAAA,OAAAA,UAAU,EAACY,iCAAAA,eAAe;IAE3C,+CAA+C;IAC/C,IAAIR,QAAQC,GAAG,CAACC,QAAQ,gCAAK,gBAAgB,SAASC,OAAAA,OAAK,EAAE;QAC3D,MAAMC,qBAAqBC,CAAAA,GAAAA,OAAAA,GAAG,EAACC,iCAAAA,yBAAyB;QACxD,IAAIF,oBAAoB;YACtB,OAAOC,CAAAA,GAAAA,OAAAA,GAAG,EAACD,mBAAmBG,QAAQ;QACxC;IACF;IAEA,OAAOA;AACT;AA2BO,SAAStB;IACd,MAAMwB,SAASb,CAAAA,GAAAA,OAAAA,UAAU,EAACc,+BAAAA,gBAAgB;IAC1C,IAAID,WAAW,MAAM;QACnB,MAAM,OAAA,cAAwD,CAAxD,IAAIE,MAAM,gDAAV,qBAAA;mBAAA;wBAAA;0BAAA;QAAuD;IAC/D;IAEA,OAAOF;AACT;AAoBO,SAAS1B;IACdO,wBAAwB;IAExB,MAAMsB,SAAShB,CAAAA,GAAAA,OAAAA,UAAU,EAACiB,iCAAAA,iBAAiB;IAE3C,+CAA+C;IAC/C,IAAIb,QAAQC,GAAG,CAACC,QAAQ,gCAAK,gBAAgB,SAASC,OAAAA,OAAK,EAAE;QAC3D,MAAMC,qBAAqBC,CAAAA,GAAAA,OAAAA,GAAG,EAACC,iCAAAA,yBAAyB;QACxD,IAAIF,oBAAoB;YACtB,OAAOC,CAAAA,GAAAA,OAAAA,GAAG,EAACD,mBAAmBQ,MAAM;QACtC;IACF;IAEA,OAAOA;AACT;AA4BO,SAASxB,0BACd0B,mBAA2B,UAAU;IAErCxB,wBAAwB;IAExB,MAAMyB,UAAUnB,CAAAA,GAAAA,OAAAA,UAAU,EAACoB,+BAAAA,mBAAmB;IAC9C,wFAAwF;IACxF,IAAI,CAACD,SAAS,OAAO;IAErB,+CAA+C;IAC/C,IAAIf,QAAQC,GAAG,CAACC,QAAQ,gCAAK,gBAAgB,SAASC,OAAAA,OAAK,EAAE;QAC3D,MAAMC,qBAAqBC,CAAAA,GAAAA,OAAAA,GAAG,EAACC,iCAAAA,yBAAyB;QACxD,IAAIF,oBAAoB;YACtB,MAAMa,UACJb,mBAAmBc,8BAA8B,EAAEC,IAAIL;YACzD,IAAIG,SAAS;gBACX,uFAAuF;gBACvF,2EAA2E;gBAC3E,OAAOZ,CAAAA,GAAAA,OAAAA,GAAG,EAACY;YACb;QACF;IACF;IAEA,OAAOG,CAAAA,GAAAA,SAAAA,4BAA4B,EAACL,QAAQM,UAAU,EAAEP;AAC1D;AAqBO,SAAS3B,yBACd2B,mBAA2B,UAAU;IAErCxB,wBAAwB;IACxB,MAAMc,qBAAqBR,CAAAA,GAAAA,OAAAA,UAAU,EAACU,iCAAAA,yBAAyB;IAC/D,MAAMgB,yBAAyBlC,0BAA0B0B;IAEzD,+CAA+C;IAC/C,IACEd,QAAQC,GAAG,CAACC,QAAQ,gCAAK,gBACzBE,sBACA,SAASD,OAAAA,OAAK,EACd;QACA,MAAMc,UACJb,mBAAmBmB,6BAA6B,EAAEJ,IAAIL;QACxD,IAAIG,SAAS;YACX,uFAAuF;YACvF,2EAA2E;YAC3E,OAAOZ,CAAAA,GAAAA,OAAAA,GAAG,EAACY;QACb;IACF;IAEA,OAAOO,CAAAA,GAAAA,SAAAA,4BAA4B,EAACF,wBAAwBR;AAC9D","ignoreList":[0]}},
    {"offset": {"line": 11265, "column": 0}, "map": {"version":3,"sources":["file:///D:/AconnectJP/node_modules/next/src/client/components/redirect-boundary.tsx"],"sourcesContent":["'use client'\nimport React, { useEffect } from 'react'\nimport type { AppRouterInstance } from '../../shared/lib/app-router-context.shared-runtime'\nimport { useRouter } from './navigation'\nimport { getRedirectTypeFromError, getURLFromRedirectError } from './redirect'\nimport { type RedirectType, isRedirectError } from './redirect-error'\n\ninterface RedirectBoundaryProps {\n  router: AppRouterInstance\n  children: React.ReactNode\n}\n\nfunction HandleRedirect({\n  redirect,\n  reset,\n  redirectType,\n}: {\n  redirect: string\n  redirectType: RedirectType\n  reset: () => void\n}) {\n  const router = useRouter()\n\n  useEffect(() => {\n    React.startTransition(() => {\n      if (redirectType === 'push') {\n        router.push(redirect, {})\n      } else {\n        router.replace(redirect, {})\n      }\n      reset()\n    })\n  }, [redirect, redirectType, reset, router])\n\n  return null\n}\n\nexport class RedirectErrorBoundary extends React.Component<\n  RedirectBoundaryProps,\n  { redirect: string | null; redirectType: RedirectType | null }\n> {\n  constructor(props: RedirectBoundaryProps) {\n    super(props)\n    this.state = { redirect: null, redirectType: null }\n  }\n\n  static getDerivedStateFromError(error: any) {\n    if (isRedirectError(error)) {\n      const url = getURLFromRedirectError(error)\n      const redirectType = getRedirectTypeFromError(error)\n      if ('handled' in error) {\n        // The redirect was already handled. We'll still catch the redirect error\n        // so that we can remount the subtree, but we don't actually need to trigger the\n        // router.push.\n        return { redirect: null, redirectType: null }\n      }\n\n      return { redirect: url, redirectType }\n    }\n    // Re-throw if error is not for redirect\n    throw error\n  }\n\n  // Explicit type is needed to avoid the generated `.d.ts` having a wide return type that could be specific to the `@types/react` version.\n  render(): React.ReactNode {\n    const { redirect, redirectType } = this.state\n    if (redirect !== null && redirectType !== null) {\n      return (\n        <HandleRedirect\n          redirect={redirect}\n          redirectType={redirectType}\n          reset={() => this.setState({ redirect: null })}\n        />\n      )\n    }\n\n    return this.props.children\n  }\n}\n\nexport function RedirectBoundary({ children }: { children: React.ReactNode }) {\n  const router = useRouter()\n  return (\n    <RedirectErrorBoundary router={router}>{children}</RedirectErrorBoundary>\n  )\n}\n"],"names":["RedirectBoundary","RedirectErrorBoundary","HandleRedirect","redirect","reset","redirectType","router","useRouter","useEffect","React","startTransition","push","replace","Component","constructor","props","state","getDerivedStateFromError","error","isRedirectError","url","getURLFromRedirectError","getRedirectTypeFromError","render","setState","children"],"mappings":";;;;;;;;;;;;;;IAgFgBA,gBAAgB,EAAA;eAAhBA;;IA3CHC,qBAAqB,EAAA;eAArBA;;;;;iEApCoB;4BAEP;0BACwC;+BACf;AAOnD,SAASC,eAAe,EACtBC,QAAQ,EACRC,KAAK,EACLC,YAAY,EAKb;IACC,MAAMC,SAASC,CAAAA,GAAAA,YAAAA,SAAS;IAExBC,CAAAA,GAAAA,OAAAA,SAAS,EAAC;QACRC,OAAAA,OAAK,CAACC,eAAe,CAAC;YACpB,IAAIL,iBAAiB,QAAQ;gBAC3BC,OAAOK,IAAI,CAACR,UAAU,CAAC;YACzB,OAAO;gBACLG,OAAOM,OAAO,CAACT,UAAU,CAAC;YAC5B;YACAC;QACF;IACF,GAAG;QAACD;QAAUE;QAAcD;QAAOE;KAAO;IAE1C,OAAO;AACT;AAEO,MAAML,8BAA8BQ,OAAAA,OAAK,CAACI,SAAS;IAIxDC,YAAYC,KAA4B,CAAE;QACxC,KAAK,CAACA;QACN,IAAI,CAACC,KAAK,GAAG;YAAEb,UAAU;YAAME,cAAc;QAAK;IACpD;IAEA,OAAOY,yBAAyBC,KAAU,EAAE;QAC1C,IAAIC,CAAAA,GAAAA,eAAAA,eAAe,EAACD,QAAQ;YAC1B,MAAME,MAAMC,CAAAA,GAAAA,UAAAA,uBAAuB,EAACH;YACpC,MAAMb,eAAeiB,CAAAA,GAAAA,UAAAA,wBAAwB,EAACJ;YAC9C,IAAI,aAAaA,OAAO;gBACtB,yEAAyE;gBACzE,gFAAgF;gBAChF,eAAe;gBACf,OAAO;oBAAEf,UAAU;oBAAME,cAAc;gBAAK;YAC9C;YAEA,OAAO;gBAAEF,UAAUiB;gBAAKf;YAAa;QACvC;QACA,wCAAwC;QACxC,MAAMa;IACR;IAEA,yIAAyI;IACzIK,SAA0B;QACxB,MAAM,EAAEpB,QAAQ,EAAEE,YAAY,EAAE,GAAG,IAAI,CAACW,KAAK;QAC7C,IAAIb,aAAa,QAAQE,iBAAiB,MAAM;YAC9C,OAAA,WAAA,GACE,CAAA,GAAA,YAAA,GAAA,EAACH,gBAAAA;gBACCC,UAAUA;gBACVE,cAAcA;gBACdD,OAAO,IAAM,IAAI,CAACoB,QAAQ,CAAC;wBAAErB,UAAU;oBAAK;;QAGlD;QAEA,OAAO,IAAI,CAACY,KAAK,CAACU,QAAQ;IAC5B;AACF;AAEO,SAASzB,iBAAiB,EAAEyB,QAAQ,EAAiC;IAC1E,MAAMnB,SAASC,CAAAA,GAAAA,YAAAA,SAAS;IACxB,OAAA,WAAA,GACE,CAAA,GAAA,YAAA,GAAA,EAACN,uBAAAA;QAAsBK,QAAQA;kBAASmB;;AAE5C","ignoreList":[0]}},
    {"offset": {"line": 11373, "column": 0}, "map": {"version":3,"sources":["file:///D:/AconnectJP/node_modules/next/src/client/components/router-reducer/create-router-cache-key.ts"],"sourcesContent":["import type { Segment } from '../../../shared/lib/app-router-types'\nimport { PAGE_SEGMENT_KEY } from '../../../shared/lib/segment'\n\nexport function createRouterCacheKey(\n  segment: Segment,\n  withoutSearchParameters: boolean = false\n) {\n  // if the segment is an array, it means it's a dynamic segment\n  // for example, ['lang', 'en', 'd']. We need to convert it to a string to store it as a cache node key.\n  if (Array.isArray(segment)) {\n    return `${segment[0]}|${segment[1]}|${segment[2]}`\n  }\n\n  // Page segments might have search parameters, ie __PAGE__?foo=bar\n  // When `withoutSearchParameters` is true, we only want to return the page segment\n  if (withoutSearchParameters && segment.startsWith(PAGE_SEGMENT_KEY)) {\n    return PAGE_SEGMENT_KEY\n  }\n\n  return segment\n}\n"],"names":["createRouterCacheKey","segment","withoutSearchParameters","Array","isArray","startsWith","PAGE_SEGMENT_KEY"],"mappings":";;;+BAGgBA,wBAAAA;;;eAAAA;;;yBAFiB;AAE1B,SAASA,qBACdC,OAAgB,EAChBC,0BAAmC,KAAK;IAExC,8DAA8D;IAC9D,uGAAuG;IACvG,IAAIC,MAAMC,OAAO,CAACH,UAAU;QAC1B,OAAO,GAAGA,OAAO,CAAC,EAAE,CAAC,CAAC,EAAEA,OAAO,CAAC,EAAE,CAAC,CAAC,EAAEA,OAAO,CAAC,EAAE,EAAE;IACpD;IAEA,kEAAkE;IAClE,kFAAkF;IAClF,IAAIC,2BAA2BD,QAAQI,UAAU,CAACC,SAAAA,gBAAgB,GAAG;QACnE,OAAOA,SAAAA,gBAAgB;IACzB;IAEA,OAAOL;AACT","ignoreList":[0]}},
    {"offset": {"line": 11407, "column": 0}, "map": {"version":3,"sources":["file:///D:/AconnectJP/node_modules/next/src/client/components/router-reducer/reducers/find-head-in-cache.ts"],"sourcesContent":["import type {\n  FlightRouterState,\n  CacheNode,\n} from '../../../../shared/lib/app-router-types'\nimport { DEFAULT_SEGMENT_KEY } from '../../../../shared/lib/segment'\nimport { createRouterCacheKey } from '../create-router-cache-key'\n\nexport function findHeadInCache(\n  cache: CacheNode,\n  parallelRoutes: FlightRouterState[1]\n): [CacheNode, string, string] | null {\n  return findHeadInCacheImpl(cache, parallelRoutes, '', '')\n}\n\nfunction findHeadInCacheImpl(\n  cache: CacheNode,\n  parallelRoutes: FlightRouterState[1],\n  keyPrefix: string,\n  keyPrefixWithoutSearchParams: string\n): [CacheNode, string, string] | null {\n  const isLastItem = Object.keys(parallelRoutes).length === 0\n  if (isLastItem) {\n    // Returns the entire Cache Node of the segment whose head we will render.\n    return [cache, keyPrefix, keyPrefixWithoutSearchParams]\n  }\n\n  // First try the 'children' parallel route if it exists\n  // when starting from the \"root\", this corresponds with the main page component\n  const parallelRoutesKeys = Object.keys(parallelRoutes).filter(\n    (key) => key !== 'children'\n  )\n\n  // if we are at the root, we need to check the children slot first\n  if ('children' in parallelRoutes) {\n    parallelRoutesKeys.unshift('children')\n  }\n\n  const slots = cache.slots\n  if (slots !== null) {\n    for (const key of parallelRoutesKeys) {\n      const [segment, childParallelRoutes] = parallelRoutes[key]\n      // If the parallel is not matched and using the default segment,\n      // skip searching the head from it.\n      if (segment === DEFAULT_SEGMENT_KEY) {\n        continue\n      }\n\n      const childCacheNode = slots[key]\n      if (!childCacheNode) {\n        continue\n      }\n\n      const cacheKey = createRouterCacheKey(segment)\n      const cacheKeyWithoutSearchParams = createRouterCacheKey(segment, true)\n\n      const item = findHeadInCacheImpl(\n        childCacheNode,\n        childParallelRoutes,\n        keyPrefix + '/' + cacheKey,\n        keyPrefix + '/' + cacheKeyWithoutSearchParams\n      )\n\n      if (item) {\n        return item\n      }\n    }\n  }\n\n  return null\n}\n"],"names":["findHeadInCache","cache","parallelRoutes","findHeadInCacheImpl","keyPrefix","keyPrefixWithoutSearchParams","isLastItem","Object","keys","length","parallelRoutesKeys","filter","key","unshift","slots","segment","childParallelRoutes","DEFAULT_SEGMENT_KEY","childCacheNode","cacheKey","createRouterCacheKey","cacheKeyWithoutSearchParams","item"],"mappings":";;;+BAOgBA,mBAAAA;;;eAAAA;;;yBAHoB;sCACC;AAE9B,SAASA,gBACdC,KAAgB,EAChBC,cAAoC;IAEpC,OAAOC,oBAAoBF,OAAOC,gBAAgB,IAAI;AACxD;AAEA,SAASC,oBACPF,KAAgB,EAChBC,cAAoC,EACpCE,SAAiB,EACjBC,4BAAoC;IAEpC,MAAMC,aAAaC,OAAOC,IAAI,CAACN,gBAAgBO,MAAM,KAAK;IAC1D,IAAIH,YAAY;QACd,0EAA0E;QAC1E,OAAO;YAACL;YAAOG;YAAWC;SAA6B;IACzD;IAEA,uDAAuD;IACvD,+EAA+E;IAC/E,MAAMK,qBAAqBH,OAAOC,IAAI,CAACN,gBAAgBS,MAAM,CAC3D,CAACC,MAAQA,QAAQ;IAGnB,kEAAkE;IAClE,IAAI,cAAcV,gBAAgB;QAChCQ,mBAAmBG,OAAO,CAAC;IAC7B;IAEA,MAAMC,QAAQb,MAAMa,KAAK;IACzB,IAAIA,UAAU,MAAM;QAClB,KAAK,MAAMF,OAAOF,mBAAoB;YACpC,MAAM,CAACK,SAASC,oBAAoB,GAAGd,cAAc,CAACU,IAAI;YAC1D,gEAAgE;YAChE,mCAAmC;YACnC,IAAIG,YAAYE,SAAAA,mBAAmB,EAAE;gBACnC;YACF;YAEA,MAAMC,iBAAiBJ,KAAK,CAACF,IAAI;YACjC,IAAI,CAACM,gBAAgB;gBACnB;YACF;YAEA,MAAMC,WAAWC,CAAAA,GAAAA,sBAAAA,oBAAoB,EAACL;YACtC,MAAMM,8BAA8BD,CAAAA,GAAAA,sBAAAA,oBAAoB,EAACL,SAAS;YAElE,MAAMO,OAAOnB,oBACXe,gBACAF,qBACAZ,YAAY,MAAMe,UAClBf,YAAY,MAAMiB;YAGpB,IAAIC,MAAM;gBACR,OAAOA;YACT;QACF;IACF;IAEA,OAAO;AACT","ignoreList":[0]}},
    {"offset": {"line": 11472, "column": 0}, "map": {"version":3,"sources":["file:///D:/AconnectJP/node_modules/next/src/client/components/unresolved-thenable.ts"],"sourcesContent":["/**\n * Create a \"Thenable\" that does not resolve. This is used to suspend indefinitely when data is not available yet.\n */\nexport const unresolvedThenable = {\n  then: () => {},\n} as PromiseLike<void>\n"],"names":["unresolvedThenable","then"],"mappings":"AAAA;;CAEC;;;+BACYA,sBAAAA;;;eAAAA;;;AAAN,MAAMA,qBAAqB;IAChCC,MAAM,KAAO;AACf","ignoreList":[0]}},
    {"offset": {"line": 11497, "column": 0}, "map": {"version":3,"sources":["file:///D:/AconnectJP/node_modules/next/src/client/components/errors/graceful-degrade-boundary.tsx"],"sourcesContent":["'use client'\n\nimport { Component, createRef, type ReactNode } from 'react'\n\ninterface ErrorBoundaryProps {\n  children: ReactNode\n}\n\ninterface ErrorBoundaryState {\n  hasError: boolean\n}\n\nfunction getDomNodeAttributes(node: HTMLElement): Record<string, string> {\n  const result: Record<string, string> = {}\n  for (let i = 0; i < node.attributes.length; i++) {\n    const attr = node.attributes[i]\n    result[attr.name] = attr.value\n  }\n  return result\n}\n\nexport class GracefulDegradeBoundary extends Component<\n  ErrorBoundaryProps,\n  ErrorBoundaryState\n> {\n  private rootHtml: string\n  private htmlAttributes: Record<string, string>\n  private htmlRef: React.RefObject<HTMLHtmlElement | null>\n\n  constructor(props: ErrorBoundaryProps) {\n    super(props)\n    this.state = { hasError: false }\n    this.rootHtml = ''\n    this.htmlAttributes = {}\n    this.htmlRef = createRef<HTMLHtmlElement>()\n  }\n\n  static getDerivedStateFromError(_: unknown): ErrorBoundaryState {\n    return { hasError: true }\n  }\n\n  componentDidMount() {\n    const htmlNode = this.htmlRef.current\n    if (this.state.hasError && htmlNode) {\n      // Reapply the cached HTML attributes to the root element\n      Object.entries(this.htmlAttributes).forEach(([key, value]) => {\n        htmlNode.setAttribute(key, value)\n      })\n    }\n  }\n\n  render() {\n    const { hasError } = this.state\n    // Cache the root HTML content on the first render\n    if (typeof window !== 'undefined' && !this.rootHtml) {\n      this.rootHtml = document.documentElement.innerHTML\n      this.htmlAttributes = getDomNodeAttributes(document.documentElement)\n    }\n\n    if (hasError) {\n      // Render the current HTML content without hydration\n      return (\n        <html\n          ref={this.htmlRef}\n          suppressHydrationWarning\n          dangerouslySetInnerHTML={{\n            __html: this.rootHtml,\n          }}\n        />\n      )\n    }\n\n    return this.props.children\n  }\n}\n\nexport default GracefulDegradeBoundary\n"],"names":["GracefulDegradeBoundary","getDomNodeAttributes","node","result","i","attributes","length","attr","name","value","Component","constructor","props","state","hasError","rootHtml","htmlAttributes","htmlRef","createRef","getDerivedStateFromError","_","componentDidMount","htmlNode","current","Object","entries","forEach","key","setAttribute","render","window","document","documentElement","innerHTML","html","ref","suppressHydrationWarning","dangerouslySetInnerHTML","__html","children"],"mappings":";;;;;;;;;;;;;;IAqBaA,uBAAuB,EAAA;eAAvBA;;IAuDb,OAAsC,EAAA;eAAtC;;;;uBA1EqD;AAUrD,SAASC,qBAAqBC,IAAiB;IAC7C,MAAMC,SAAiC,CAAC;IACxC,IAAK,IAAIC,IAAI,GAAGA,IAAIF,KAAKG,UAAU,CAACC,MAAM,EAAEF,IAAK;QAC/C,MAAMG,OAAOL,KAAKG,UAAU,CAACD,EAAE;QAC/BD,MAAM,CAACI,KAAKC,IAAI,CAAC,GAAGD,KAAKE,KAAK;IAChC;IACA,OAAON;AACT;AAEO,MAAMH,gCAAgCU,OAAAA,SAAS;IAQpDC,YAAYC,KAAyB,CAAE;QACrC,KAAK,CAACA;QACN,IAAI,CAACC,KAAK,GAAG;YAAEC,UAAU;QAAM;QAC/B,IAAI,CAACC,QAAQ,GAAG;QAChB,IAAI,CAACC,cAAc,GAAG,CAAC;QACvB,IAAI,CAACC,OAAO,GAAA,WAAA,GAAGC,CAAAA,GAAAA,OAAAA,SAAS;IAC1B;IAEA,OAAOC,yBAAyBC,CAAU,EAAsB;QAC9D,OAAO;YAAEN,UAAU;QAAK;IAC1B;IAEAO,oBAAoB;QAClB,MAAMC,WAAW,IAAI,CAACL,OAAO,CAACM,OAAO;QACrC,IAAI,IAAI,CAACV,KAAK,CAACC,QAAQ,IAAIQ,UAAU;YACnC,yDAAyD;YACzDE,OAAOC,OAAO,CAAC,IAAI,CAACT,cAAc,EAAEU,OAAO,CAAC,CAAC,CAACC,KAAKlB,MAAM;gBACvDa,SAASM,YAAY,CAACD,KAAKlB;YAC7B;QACF;IACF;IAEAoB,SAAS;QACP,MAAM,EAAEf,QAAQ,EAAE,GAAG,IAAI,CAACD,KAAK;QAC/B,kDAAkD;QAClD,IAAI,OAAOiB,WAAW,eAAe,CAAC,IAAI,CAACf,QAAQ,EAAE;YACnD,IAAI,CAACA,QAAQ,GAAGgB,SAASC,eAAe,CAACC,SAAS;YAClD,IAAI,CAACjB,cAAc,GAAGf,qBAAqB8B,SAASC,eAAe;QACrE;QAEA,IAAIlB,UAAU;YACZ,oDAAoD;YACpD,OAAA,WAAA,GACE,CAAA,GAAA,YAAA,GAAA,EAACoB,QAAAA;gBACCC,KAAK,IAAI,CAAClB,OAAO;gBACjBmB,wBAAwB,EAAA;gBACxBC,yBAAyB;oBACvBC,QAAQ,IAAI,CAACvB,QAAQ;gBACvB;;QAGN;QAEA,OAAO,IAAI,CAACH,KAAK,CAAC2B,QAAQ;IAC5B;AACF;MAEA,WAAevC","ignoreList":[0]}},
    {"offset": {"line": 11584, "column": 0}, "map": {"version":3,"sources":["file:///D:/AconnectJP/node_modules/next/src/client/components/errors/root-error-boundary.tsx"],"sourcesContent":["'use client'\n\nimport React, { type JSX } from 'react'\nimport GracefulDegradeBoundary from './graceful-degrade-boundary'\nimport { ErrorBoundary, type ErrorBoundaryProps } from '../error-boundary'\nimport { isBot } from '../../../shared/lib/router/utils/is-bot'\n\nconst isBotUserAgent =\n  typeof window !== 'undefined' && isBot(window.navigator.userAgent)\n\nexport default function RootErrorBoundary({\n  children,\n  errorComponent,\n  errorStyles,\n  errorScripts,\n}: ErrorBoundaryProps & { children: React.ReactNode }): JSX.Element {\n  if (isBotUserAgent) {\n    // Preserve existing DOM/HTML for bots to avoid replacing content with an error UI\n    // and to keep the original SSR output intact.\n    return <GracefulDegradeBoundary>{children}</GracefulDegradeBoundary>\n  }\n\n  return (\n    <ErrorBoundary\n      errorComponent={errorComponent}\n      errorStyles={errorStyles}\n      errorScripts={errorScripts}\n    >\n      {children}\n    </ErrorBoundary>\n  )\n}\n"],"names":["RootErrorBoundary","isBotUserAgent","window","isBot","navigator","userAgent","children","errorComponent","errorStyles","errorScripts","GracefulDegradeBoundary","ErrorBoundary"],"mappings":";;;+BAUA,WAAA;;;eAAwBA;;;;;gEARQ;kFACI;+BACmB;uBACjC;AAEtB,MAAMC,iBACJ,OAAOC,WAAW,eAAeC,CAAAA,GAAAA,OAAAA,KAAK,EAACD,OAAOE,SAAS,CAACC,SAAS;AAEpD,SAASL,kBAAkB,EACxCM,QAAQ,EACRC,cAAc,EACdC,WAAW,EACXC,YAAY,EACuC;IACnD,IAAIR,gBAAgB;QAClB,kFAAkF;QAClF,8CAA8C;QAC9C,OAAA,WAAA,GAAO,CAAA,GAAA,YAAA,GAAA,EAACS,yBAAAA,OAAuB,EAAA;sBAAEJ;;IACnC;IAEA,OAAA,WAAA,GACE,CAAA,GAAA,YAAA,GAAA,EAACK,eAAAA,aAAa,EAAA;QACZJ,gBAAgBA;QAChBC,aAAaA;QACbC,cAAcA;kBAEbH;;AAGP","ignoreList":[0]}},
    {"offset": {"line": 11626, "column": 0}, "map": {"version":3,"sources":["file:///D:/AconnectJP/node_modules/next/src/client/components/navigation-devtools.ts"],"sourcesContent":["import type { FlightRouterState } from '../../shared/lib/app-router-types'\nimport type { Params } from '../../server/request/params'\nimport {\n  createDevToolsInstrumentedPromise,\n  ReadonlyURLSearchParams,\n  type InstrumentedPromise,\n  type NavigationPromises,\n} from '../../shared/lib/hooks-client-context.shared-runtime'\nimport {\n  computeSelectedLayoutSegment,\n  getSelectedLayoutSegmentPath,\n} from '../../shared/lib/segment'\n\n/**\n * Promises are cached by tree to ensure stability across suspense retries.\n */\ntype LayoutSegmentPromisesCache = {\n  selectedLayoutSegmentPromises: Map<string, InstrumentedPromise<string | null>>\n  selectedLayoutSegmentsPromises: Map<string, InstrumentedPromise<string[]>>\n}\n\nconst layoutSegmentPromisesCache = new WeakMap<\n  FlightRouterState,\n  LayoutSegmentPromisesCache\n>()\n\n/**\n * Creates instrumented promises for layout segment hooks at a given tree level.\n * This is dev-only code for React Suspense DevTools instrumentation.\n */\nfunction createLayoutSegmentPromises(\n  tree: FlightRouterState\n): LayoutSegmentPromisesCache | null {\n  if (process.env.NODE_ENV === 'production') {\n    return null\n  }\n\n  // Check if we already have cached promises for this tree\n  const cached = layoutSegmentPromisesCache.get(tree)\n  if (cached) {\n    return cached\n  }\n\n  // Create new promises and cache them\n  const segmentPromises = new Map<string, InstrumentedPromise<string | null>>()\n  const segmentsPromises = new Map<string, InstrumentedPromise<string[]>>()\n\n  const parallelRoutes = tree[1]\n  for (const parallelRouteKey of Object.keys(parallelRoutes)) {\n    const segments = getSelectedLayoutSegmentPath(tree, parallelRouteKey)\n\n    // Use the shared logic to compute the segment value\n    const segment = computeSelectedLayoutSegment(segments, parallelRouteKey)\n\n    segmentPromises.set(\n      parallelRouteKey,\n      createDevToolsInstrumentedPromise('useSelectedLayoutSegment', segment)\n    )\n    segmentsPromises.set(\n      parallelRouteKey,\n      createDevToolsInstrumentedPromise('useSelectedLayoutSegments', segments)\n    )\n  }\n\n  const result: LayoutSegmentPromisesCache = {\n    selectedLayoutSegmentPromises: segmentPromises,\n    selectedLayoutSegmentsPromises: segmentsPromises,\n  }\n\n  // Cache the result for future renders\n  layoutSegmentPromisesCache.set(tree, result)\n\n  return result\n}\n\nconst rootNavigationPromisesCache = new WeakMap<\n  FlightRouterState,\n  Map<string, NavigationPromises>\n>()\n\n/**\n * Creates instrumented navigation promises for the root app-router.\n */\nexport function createRootNavigationPromises(\n  tree: FlightRouterState,\n  pathname: string,\n  searchParams: URLSearchParams,\n  pathParams: Params\n): NavigationPromises | null {\n  if (process.env.NODE_ENV === 'production') {\n    return null\n  }\n\n  // Create stable cache keys from the values\n  const searchParamsString = searchParams.toString()\n  const pathParamsString = JSON.stringify(pathParams)\n  const cacheKey = `${pathname}:${searchParamsString}:${pathParamsString}`\n\n  // Get or create the cache for this tree\n  let treeCache = rootNavigationPromisesCache.get(tree)\n  if (!treeCache) {\n    treeCache = new Map<string, NavigationPromises>()\n    rootNavigationPromisesCache.set(tree, treeCache)\n  }\n\n  // Check if we have cached promises for this combination\n  const cached = treeCache.get(cacheKey)\n  if (cached) {\n    return cached\n  }\n\n  const readonlySearchParams = new ReadonlyURLSearchParams(searchParams)\n\n  const layoutSegmentPromises = createLayoutSegmentPromises(tree)\n\n  const promises: NavigationPromises = {\n    pathname: createDevToolsInstrumentedPromise('usePathname', pathname),\n    searchParams: createDevToolsInstrumentedPromise(\n      'useSearchParams',\n      readonlySearchParams\n    ),\n    params: createDevToolsInstrumentedPromise('useParams', pathParams),\n    ...layoutSegmentPromises,\n  }\n\n  treeCache.set(cacheKey, promises)\n\n  return promises\n}\n\nconst nestedLayoutPromisesCache = new WeakMap<\n  FlightRouterState,\n  Map<NavigationPromises | null, NavigationPromises>\n>()\n\n/**\n * Creates merged navigation promises for nested layouts.\n * Merges parent promises with layout-specific segment promises.\n */\nexport function createNestedLayoutNavigationPromises(\n  tree: FlightRouterState,\n  parentNavPromises: NavigationPromises | null\n): NavigationPromises | null {\n  if (process.env.NODE_ENV === 'production') {\n    return null\n  }\n\n  const parallelRoutes = tree[1]\n  const parallelRouteKeys = Object.keys(parallelRoutes)\n\n  // Only create promises if there are parallel routes at this level\n  if (parallelRouteKeys.length === 0) {\n    return null\n  }\n\n  // Get or create the cache for this tree\n  let treeCache = nestedLayoutPromisesCache.get(tree)\n  if (!treeCache) {\n    treeCache = new Map<NavigationPromises | null, NavigationPromises>()\n    nestedLayoutPromisesCache.set(tree, treeCache)\n  }\n\n  // Check if we have cached promises for this parent combination\n  const cached = treeCache.get(parentNavPromises)\n  if (cached) {\n    return cached\n  }\n\n  // Create merged promises\n  const layoutSegmentPromises = createLayoutSegmentPromises(tree)\n  const promises: NavigationPromises = {\n    ...parentNavPromises!,\n    ...layoutSegmentPromises,\n  }\n\n  treeCache.set(parentNavPromises, promises)\n\n  return promises\n}\n"],"names":["createNestedLayoutNavigationPromises","createRootNavigationPromises","layoutSegmentPromisesCache","WeakMap","createLayoutSegmentPromises","tree","process","env","NODE_ENV","cached","get","segmentPromises","Map","segmentsPromises","parallelRoutes","parallelRouteKey","Object","keys","segments","getSelectedLayoutSegmentPath","segment","computeSelectedLayoutSegment","set","createDevToolsInstrumentedPromise","result","selectedLayoutSegmentPromises","selectedLayoutSegmentsPromises","rootNavigationPromisesCache","pathname","searchParams","pathParams","searchParamsString","toString","pathParamsString","JSON","stringify","cacheKey","treeCache","readonlySearchParams","ReadonlyURLSearchParams","layoutSegmentPromises","promises","params","nestedLayoutPromisesCache","parentNavPromises","parallelRouteKeys","length"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 11753, "column": 0}, "map": {"version":3,"sources":["file:///D:/AconnectJP/node_modules/next/src/client/components/http-access-fallback/error-boundary.tsx"],"sourcesContent":["'use client'\n\n/**\n * HTTPAccessFallbackBoundary is a boundary that catches errors and renders a\n * fallback component for HTTP errors.\n *\n * It receives the status code, and determine if it should render fallbacks for few HTTP 4xx errors.\n *\n * e.g. 404\n * 404 represents not found, and the fallback component pair contains the component and its styles.\n *\n */\n\nimport React, { useContext } from 'react'\nimport { useUntrackedPathname } from '../navigation-untracked'\nimport {\n  HTTPAccessErrorStatus,\n  getAccessFallbackHTTPStatus,\n  getAccessFallbackErrorTypeByStatus,\n  isHTTPAccessFallbackError,\n} from './http-access-fallback'\nimport { warnOnce } from '../../../shared/lib/utils/warn-once'\nimport { MissingSlotContext } from '../../../shared/lib/app-router-context.shared-runtime'\n\ninterface HTTPAccessFallbackBoundaryProps {\n  notFound?: React.ReactNode\n  forbidden?: React.ReactNode\n  unauthorized?: React.ReactNode\n  // TODO: Make this required once `React.createElement` understands that positional args go into children\n  children?: React.ReactNode\n  missingSlots?: Set<string>\n}\n\ninterface HTTPAccessFallbackErrorBoundaryProps\n  extends HTTPAccessFallbackBoundaryProps {\n  pathname: string | null\n  missingSlots?: Set<string>\n}\n\ninterface HTTPAccessBoundaryState {\n  triggeredStatus: number | undefined\n  previousPathname: string | null\n}\n\nclass HTTPAccessFallbackErrorBoundary extends React.Component<\n  HTTPAccessFallbackErrorBoundaryProps,\n  HTTPAccessBoundaryState\n> {\n  constructor(props: HTTPAccessFallbackErrorBoundaryProps) {\n    super(props)\n    this.state = {\n      triggeredStatus: undefined,\n      previousPathname: props.pathname,\n    }\n  }\n\n  componentDidCatch(): void {\n    if (\n      process.env.NODE_ENV === 'development' &&\n      this.props.missingSlots &&\n      this.props.missingSlots.size > 0 &&\n      // A missing children slot is the typical not-found case, so no need to warn\n      !this.props.missingSlots.has('children')\n    ) {\n      let warningMessage =\n        'No default component was found for a parallel route rendered on this page. Falling back to nearest NotFound boundary.\\n' +\n        'Learn more: https://nextjs.org/docs/app/building-your-application/routing/parallel-routes#defaultjs\\n\\n'\n\n      const formattedSlots = Array.from(this.props.missingSlots)\n        .sort((a, b) => a.localeCompare(b))\n        .map((slot) => `@${slot}`)\n        .join(', ')\n\n      warningMessage += 'Missing slots: ' + formattedSlots\n\n      warnOnce(warningMessage)\n    }\n  }\n\n  static getDerivedStateFromError(error: any) {\n    if (isHTTPAccessFallbackError(error)) {\n      const httpStatus = getAccessFallbackHTTPStatus(error)\n      return {\n        triggeredStatus: httpStatus,\n      }\n    }\n    // Re-throw if error is not for 404\n    throw error\n  }\n\n  static getDerivedStateFromProps(\n    props: HTTPAccessFallbackErrorBoundaryProps,\n    state: HTTPAccessBoundaryState\n  ): HTTPAccessBoundaryState | null {\n    /**\n     * Handles reset of the error boundary when a navigation happens.\n     * Ensures the error boundary does not stay enabled when navigating to a new page.\n     * Approach of setState in render is safe as it checks the previous pathname and then overrides\n     * it as outlined in https://react.dev/reference/react/useState#storing-information-from-previous-renders\n     */\n    if (props.pathname !== state.previousPathname && state.triggeredStatus) {\n      return {\n        triggeredStatus: undefined,\n        previousPathname: props.pathname,\n      }\n    }\n    return {\n      triggeredStatus: state.triggeredStatus,\n      previousPathname: props.pathname,\n    }\n  }\n\n  render() {\n    const { notFound, forbidden, unauthorized, children } = this.props\n    const { triggeredStatus } = this.state\n    const errorComponents = {\n      [HTTPAccessErrorStatus.NOT_FOUND]: notFound,\n      [HTTPAccessErrorStatus.FORBIDDEN]: forbidden,\n      [HTTPAccessErrorStatus.UNAUTHORIZED]: unauthorized,\n    }\n\n    if (triggeredStatus) {\n      const isNotFound =\n        triggeredStatus === HTTPAccessErrorStatus.NOT_FOUND && notFound\n      const isForbidden =\n        triggeredStatus === HTTPAccessErrorStatus.FORBIDDEN && forbidden\n      const isUnauthorized =\n        triggeredStatus === HTTPAccessErrorStatus.UNAUTHORIZED && unauthorized\n\n      // If there's no matched boundary in this layer, keep throwing the error by rendering the children\n      if (!(isNotFound || isForbidden || isUnauthorized)) {\n        return children\n      }\n\n      return (\n        <>\n          <meta name=\"robots\" content=\"noindex\" />\n          {process.env.NODE_ENV === 'development' && (\n            <meta\n              name=\"boundary-next-error\"\n              content={getAccessFallbackErrorTypeByStatus(triggeredStatus)}\n            />\n          )}\n          {errorComponents[triggeredStatus]}\n        </>\n      )\n    }\n\n    return children\n  }\n}\n\nexport function HTTPAccessFallbackBoundary({\n  notFound,\n  forbidden,\n  unauthorized,\n  children,\n}: HTTPAccessFallbackBoundaryProps) {\n  // When we're rendering the missing params shell, this will return null. This\n  // is because we won't be rendering any not found boundaries or error\n  // boundaries for the missing params shell. When this runs on the client\n  // (where these error can occur), we will get the correct pathname.\n  const pathname = useUntrackedPathname()\n  const missingSlots = useContext(MissingSlotContext)\n  const hasErrorFallback = !!(notFound || forbidden || unauthorized)\n\n  if (hasErrorFallback) {\n    return (\n      <HTTPAccessFallbackErrorBoundary\n        pathname={pathname}\n        notFound={notFound}\n        forbidden={forbidden}\n        unauthorized={unauthorized}\n        missingSlots={missingSlots}\n      >\n        {children}\n      </HTTPAccessFallbackErrorBoundary>\n    )\n  }\n\n  return <>{children}</>\n}\n"],"names":["HTTPAccessFallbackBoundary","HTTPAccessFallbackErrorBoundary","React","Component","constructor","props","state","triggeredStatus","undefined","previousPathname","pathname","componentDidCatch","process","env","NODE_ENV","missingSlots","size","has","warningMessage","formattedSlots","Array","from","sort","a","b","localeCompare","map","slot","join","warnOnce","getDerivedStateFromError","error","isHTTPAccessFallbackError","httpStatus","getAccessFallbackHTTPStatus","getDerivedStateFromProps","render","notFound","forbidden","unauthorized","children","errorComponents","HTTPAccessErrorStatus","NOT_FOUND","FORBIDDEN","UNAUTHORIZED","isNotFound","isForbidden","isUnauthorized","meta","name","content","getAccessFallbackErrorTypeByStatus","useUntrackedPathname","useContext","MissingSlotContext","hasErrorFallback"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 11882, "column": 0}, "map": {"version":3,"sources":["file:///D:/AconnectJP/node_modules/next/src/client/components/dev-root-http-access-fallback-boundary.tsx"],"sourcesContent":["'use client'\n\nimport React from 'react'\nimport { HTTPAccessFallbackBoundary } from './http-access-fallback/error-boundary'\n\n// TODO: error on using forbidden and unauthorized in root layout\nexport function bailOnRootNotFound() {\n  throw new Error('notFound() is not allowed to use in root layout')\n}\n\nfunction NotAllowedRootHTTPFallbackError() {\n  bailOnRootNotFound()\n  return null\n}\n\nexport function DevRootHTTPAccessFallbackBoundary({\n  children,\n}: {\n  children: React.ReactNode\n}) {\n  return (\n    <HTTPAccessFallbackBoundary notFound={<NotAllowedRootHTTPFallbackError />}>\n      {children}\n    </HTTPAccessFallbackBoundary>\n  )\n}\n"],"names":["DevRootHTTPAccessFallbackBoundary","bailOnRootNotFound","Error","NotAllowedRootHTTPFallbackError","children","HTTPAccessFallbackBoundary","notFound"],"mappings":";;;;;;;;;;;;;;IAegBA,iCAAiC,EAAA;eAAjCA;;IATAC,kBAAkB,EAAA;eAAlBA;;;;;gEAJE;+BACyB;AAGpC,SAASA;IACd,MAAM,OAAA,cAA4D,CAA5D,IAAIC,MAAM,oDAAV,qBAAA;eAAA;oBAAA;sBAAA;IAA2D;AACnE;AAEA,SAASC;IACPF;IACA,OAAO;AACT;AAEO,SAASD,kCAAkC,EAChDI,QAAQ,EAGT;IACC,OAAA,WAAA,GACE,CAAA,GAAA,YAAA,GAAA,EAACC,eAAAA,0BAA0B,EAAA;QAACC,UAAAA,WAAAA,GAAU,CAAA,GAAA,YAAA,GAAA,EAACH,iCAAAA,CAAAA;kBACpCC;;AAGP","ignoreList":[0]}},
    {"offset": {"line": 11935, "column": 0}, "map": {"version":3,"sources":["file:///D:/AconnectJP/node_modules/next/src/client/dev/hot-reloader/shared.ts"],"sourcesContent":["import type { HmrMessageSentToBrowser } from '../../../server/dev/hot-reloader-types'\n\nexport const REACT_REFRESH_FULL_RELOAD =\n  '[Fast Refresh] performing full reload\\n\\n' +\n  \"Fast Refresh will perform a full reload when you edit a file that's imported by modules outside of the React rendering tree.\\n\" +\n  'You might have a file which exports a React component but also exports a value that is imported by a non-React component file.\\n' +\n  'Consider migrating the non-React component export to a separate file and importing it into both files.\\n\\n' +\n  'It is also possible the parent component of the component you edited is a class component, which disables Fast Refresh.\\n' +\n  'Fast Refresh requires at least one parent function component in your React tree.'\n\nexport const REACT_REFRESH_FULL_RELOAD_FROM_ERROR =\n  '[Fast Refresh] performing full reload because your application had an unrecoverable error'\n\nexport function reportInvalidHmrMessage(\n  message: HmrMessageSentToBrowser | MessageEvent<unknown>,\n  err: unknown\n) {\n  console.warn(\n    '[HMR] Invalid message: ' +\n      JSON.stringify(message) +\n      '\\n' +\n      ((err instanceof Error && err?.stack) || '')\n  )\n}\n"],"names":["REACT_REFRESH_FULL_RELOAD","REACT_REFRESH_FULL_RELOAD_FROM_ERROR","reportInvalidHmrMessage","message","err","console","warn","JSON","stringify","Error","stack"],"mappings":";;;;;;;;;;;;;;;IAEaA,yBAAyB,EAAA;eAAzBA;;IAQAC,oCAAoC,EAAA;eAApCA;;IAGGC,uBAAuB,EAAA;eAAvBA;;;AAXT,MAAMF,4BACX,8CACA,mIACA,qIACA,+GACA,8HACA;AAEK,MAAMC,uCACX;AAEK,SAASC,wBACdC,OAAwD,EACxDC,GAAY;IAEZC,QAAQC,IAAI,CACV,4BACEC,KAAKC,SAAS,CAACL,WACf,OACC,CAACC,eAAeK,SAASL,KAAKM,SAAU,EAAC;AAEhD","ignoreList":[0]}},
    {"offset": {"line": 11976, "column": 0}, "map": {"version":3,"sources":["file:///D:/AconnectJP/node_modules/next/src/client/dev/hot-reloader/get-socket-url.ts"],"sourcesContent":["import { normalizedAssetPrefix } from '../../../shared/lib/normalized-asset-prefix'\n\nfunction getSocketProtocol(assetPrefix: string): string {\n  let protocol = window.location.protocol\n\n  try {\n    // assetPrefix is a url\n    protocol = new URL(assetPrefix).protocol\n  } catch {}\n\n  return protocol === 'http:' ? 'ws:' : 'wss:'\n}\n\nexport function getSocketUrl(assetPrefix: string | undefined): string {\n  const prefix = normalizedAssetPrefix(assetPrefix)\n  const protocol = getSocketProtocol(assetPrefix || '')\n\n  if (URL.canParse(prefix)) {\n    // since normalized asset prefix is ensured to be a URL format,\n    // we can safely replace the protocol\n    return prefix.replace(/^http/, 'ws')\n  }\n\n  const { hostname, port } = window.location\n  return `${protocol}//${hostname}${port ? `:${port}` : ''}${prefix}`\n}\n"],"names":["getSocketUrl","getSocketProtocol","assetPrefix","protocol","window","location","URL","prefix","normalizedAssetPrefix","canParse","replace","hostname","port"],"mappings":";;;+BAagBA,gBAAAA;;;eAAAA;;;uCAbsB;AAEtC,SAASC,kBAAkBC,WAAmB;IAC5C,IAAIC,WAAWC,OAAOC,QAAQ,CAACF,QAAQ;IAEvC,IAAI;QACF,uBAAuB;QACvBA,WAAW,IAAIG,IAAIJ,aAAaC,QAAQ;IAC1C,EAAE,OAAM,CAAC;IAET,OAAOA,aAAa,UAAU,QAAQ;AACxC;AAEO,SAASH,aAAaE,WAA+B;IAC1D,MAAMK,SAASC,CAAAA,GAAAA,uBAAAA,qBAAqB,EAACN;IACrC,MAAMC,WAAWF,kBAAkBC,eAAe;IAElD,IAAII,IAAIG,QAAQ,CAACF,SAAS;QACxB,+DAA+D;QAC/D,qCAAqC;QACrC,OAAOA,OAAOG,OAAO,CAAC,SAAS;IACjC;IAEA,MAAM,EAAEC,QAAQ,EAAEC,IAAI,EAAE,GAAGR,OAAOC,QAAQ;IAC1C,OAAO,GAAGF,SAAS,EAAE,EAAEQ,WAAWC,OAAO,CAAC,CAAC,EAAEA,MAAM,GAAG,KAAKL,QAAQ;AACrE","ignoreList":[0]}},
    {"offset": {"line": 12016, "column": 0}, "map": {"version":3,"sources":["file:///D:/AconnectJP/node_modules/next/src/client/dev/hot-reloader/app/web-socket.ts"],"sourcesContent":["import { useContext, useEffect } from 'react'\nimport { GlobalLayoutRouterContext } from '../../../../shared/lib/app-router-context.shared-runtime'\nimport { getSocketUrl } from '../get-socket-url'\nimport {\n  HMR_MESSAGE_SENT_TO_BROWSER,\n  type HmrMessageSentToBrowser,\n  type TurbopackMessageSentToBrowser,\n} from '../../../../server/dev/hot-reloader-types'\nimport { reportInvalidHmrMessage } from '../shared'\nimport {\n  performFullReload,\n  processMessage,\n  type StaticIndicatorState,\n} from './hot-reloader-app'\nimport { logQueue } from '../../../../next-devtools/userspace/app/forward-logs'\nimport { InvariantError } from '../../../../shared/lib/invariant-error'\nimport { WEB_SOCKET_MAX_RECONNECTIONS } from '../../../../lib/constants'\n\nlet reconnections = 0\nlet reloading = false\nlet serverSessionId: number | null = null\nlet mostRecentCompilationHash: string | null = null\n\nexport function createWebSocket(\n  assetPrefix: string,\n  staticIndicatorState: StaticIndicatorState\n) {\n  if (!self.__next_r) {\n    throw new InvariantError(\n      `Expected a request ID to be defined for the document via self.__next_r.`\n    )\n  }\n\n  let webSocket: WebSocket\n  let timer: ReturnType<typeof setTimeout>\n\n  const sendMessage = (data: string) => {\n    if (webSocket && webSocket.readyState === webSocket.OPEN) {\n      webSocket.send(data)\n    }\n  }\n\n  const processTurbopackMessage = createProcessTurbopackMessage(sendMessage)\n\n  function init() {\n    if (webSocket) {\n      webSocket.close()\n    }\n\n    const newWebSocket = new window.WebSocket(\n      `${getSocketUrl(assetPrefix)}/_next/webpack-hmr?id=${self.__next_r}`\n    )\n\n    newWebSocket.binaryType = 'arraybuffer'\n\n    function handleOnline() {\n      logQueue.onSocketReady(newWebSocket)\n\n      reconnections = 0\n      window.console.log('[HMR] connected')\n    }\n\n    function handleMessage(event: MessageEvent) {\n      // While the page is reloading, don't respond to any more messages.\n      if (reloading) {\n        return\n      }\n\n      try {\n        const message: HmrMessageSentToBrowser =\n          event.data instanceof ArrayBuffer\n            ? parseBinaryMessage(event.data)\n            : JSON.parse(event.data)\n\n        // Check for server restart in Turbopack mode\n        if (message.type === HMR_MESSAGE_SENT_TO_BROWSER.TURBOPACK_CONNECTED) {\n          if (\n            serverSessionId !== null &&\n            serverSessionId !== message.data.sessionId\n          ) {\n            // Either the server's session id has changed and it's a new server, or\n            // it's been too long since we disconnected and we should reload the page.\n            window.location.reload()\n            reloading = true\n            return\n          }\n          serverSessionId = message.data.sessionId\n        }\n\n        // Track webpack compilation hash for server restart detection\n        if (\n          message.type === HMR_MESSAGE_SENT_TO_BROWSER.SYNC &&\n          'hash' in message\n        ) {\n          // If we had previously reconnected and the hash changed, the server may have restarted\n          if (\n            mostRecentCompilationHash !== null &&\n            mostRecentCompilationHash !== message.hash\n          ) {\n            window.location.reload()\n            reloading = true\n            return\n          }\n          mostRecentCompilationHash = message.hash\n        }\n\n        processMessage(\n          message,\n          sendMessage,\n          processTurbopackMessage,\n          staticIndicatorState\n        )\n      } catch (err: unknown) {\n        reportInvalidHmrMessage(event, err)\n      }\n    }\n\n    function handleDisconnect() {\n      newWebSocket.onerror = null\n      newWebSocket.onclose = null\n      newWebSocket.close()\n      reconnections++\n\n      // After 25 reconnects we'll want to reload the page as it indicates the dev server is no longer running.\n      if (reconnections > WEB_SOCKET_MAX_RECONNECTIONS) {\n        reloading = true\n        window.location.reload()\n        return\n      }\n\n      clearTimeout(timer)\n      // Try again after 5 seconds\n      timer = setTimeout(init, reconnections > 5 ? 5000 : 1000)\n    }\n\n    newWebSocket.onopen = handleOnline\n    newWebSocket.onerror = handleDisconnect\n    newWebSocket.onclose = handleDisconnect\n    newWebSocket.onmessage = handleMessage\n\n    webSocket = newWebSocket\n    return newWebSocket\n  }\n\n  return init()\n}\n\nexport function createProcessTurbopackMessage(\n  sendMessage: (data: string) => void\n): (msg: TurbopackMessageSentToBrowser) => void {\n  if (!process.env.TURBOPACK) {\n    return () => {}\n  }\n\n  let queue: TurbopackMessageSentToBrowser[] = []\n  let callback: ((msg: TurbopackMessageSentToBrowser) => void) | undefined\n\n  const processTurbopackMessage = (msg: TurbopackMessageSentToBrowser) => {\n    if (callback) {\n      callback(msg)\n    } else {\n      queue.push(msg)\n    }\n  }\n\n  import(\n    // @ts-expect-error requires \"moduleResolution\": \"node16\" in tsconfig.json and not .ts extension\n    '@vercel/turbopack-ecmascript-runtime/browser/dev/hmr-client/hmr-client.ts'\n  ).then(({ connect }) => {\n    connect({\n      addMessageListener(cb: (msg: TurbopackMessageSentToBrowser) => void) {\n        callback = cb\n\n        // Replay all Turbopack messages before we were able to establish the HMR client.\n        for (const msg of queue) {\n          cb(msg)\n        }\n        queue.length = 0\n      },\n      sendMessage,\n      onUpdateError: (err: unknown) => performFullReload(err, sendMessage),\n    })\n  })\n\n  return processTurbopackMessage\n}\n\nexport function useWebSocketPing(webSocket: WebSocket | undefined) {\n  const { tree } = useContext(GlobalLayoutRouterContext)\n\n  useEffect(() => {\n    if (!webSocket) {\n      throw new InvariantError('Expected webSocket to be defined in dev mode.')\n    }\n\n    // Never send pings when using Turbopack as it's not used.\n    // Pings were originally used to keep track of active routes in on-demand-entries with webpack.\n    if (process.env.TURBOPACK) {\n      return\n    }\n\n    // Taken from on-demand-entries-client.js\n    const interval = setInterval(() => {\n      if (webSocket.readyState === webSocket.OPEN) {\n        webSocket.send(\n          JSON.stringify({\n            event: 'ping',\n            tree,\n            appDirRoute: true,\n          })\n        )\n      }\n    }, 2500)\n    return () => clearInterval(interval)\n  }, [tree, webSocket])\n}\n\nconst textDecoder = new TextDecoder()\n\nfunction parseBinaryMessage(data: ArrayBuffer): HmrMessageSentToBrowser {\n  assertByteLength(data, 1)\n  const view = new DataView(data)\n  const messageType = view.getUint8(0)\n\n  switch (messageType) {\n    case HMR_MESSAGE_SENT_TO_BROWSER.ERRORS_TO_SHOW_IN_BROWSER: {\n      const serializedErrors = new Uint8Array(data, 1)\n\n      return {\n        type: HMR_MESSAGE_SENT_TO_BROWSER.ERRORS_TO_SHOW_IN_BROWSER,\n        serializedErrors,\n      }\n    }\n    case HMR_MESSAGE_SENT_TO_BROWSER.REACT_DEBUG_CHUNK: {\n      assertByteLength(data, 2)\n      const requestIdLength = view.getUint8(1)\n      assertByteLength(data, 2 + requestIdLength)\n\n      const requestId = textDecoder.decode(\n        new Uint8Array(data, 2, requestIdLength)\n      )\n\n      const chunk =\n        data.byteLength > 2 + requestIdLength\n          ? new Uint8Array(data, 2 + requestIdLength)\n          : null\n\n      return {\n        type: HMR_MESSAGE_SENT_TO_BROWSER.REACT_DEBUG_CHUNK,\n        requestId,\n        chunk,\n      }\n    }\n    default: {\n      throw new InvariantError(\n        `Invalid binary HMR message of type ${messageType}`\n      )\n    }\n  }\n}\n\nfunction assertByteLength(data: ArrayBuffer, expectedLength: number) {\n  if (data.byteLength < expectedLength) {\n    throw new InvariantError(\n      `Invalid binary HMR message: insufficient data (expected ${expectedLength} bytes, got ${data.byteLength})`\n    )\n  }\n}\n"],"names":["createProcessTurbopackMessage","createWebSocket","useWebSocketPing","reconnections","reloading","serverSessionId","mostRecentCompilationHash","assetPrefix","staticIndicatorState","self","__next_r","InvariantError","webSocket","timer","sendMessage","data","readyState","OPEN","send","processTurbopackMessage","init","close","newWebSocket","window","WebSocket","getSocketUrl","binaryType","handleOnline","logQueue","onSocketReady","console","log","handleMessage","event","message","ArrayBuffer","parseBinaryMessage","JSON","parse","type","HMR_MESSAGE_SENT_TO_BROWSER","TURBOPACK_CONNECTED","sessionId","location","reload","SYNC","hash","processMessage","err","reportInvalidHmrMessage","handleDisconnect","onerror","onclose","WEB_SOCKET_MAX_RECONNECTIONS","clearTimeout","setTimeout","onopen","onmessage","process","env","TURBOPACK","queue","callback","msg","push","then","connect","addMessageListener","cb","length","onUpdateError","performFullReload","tree","useContext","GlobalLayoutRouterContext","useEffect","interval","setInterval","stringify","appDirRoute","clearInterval","textDecoder","TextDecoder","assertByteLength","view","DataView","messageType","getUint8","ERRORS_TO_SHOW_IN_BROWSER","serializedErrors","Uint8Array","REACT_DEBUG_CHUNK","requestIdLength","requestId","decode","chunk","byteLength","expectedLength"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 12249, "column": 0}, "map": {"version":3,"sources":["file:///D:/AconnectJP/node_modules/next/src/client/dev/report-hmr-latency.ts"],"sourcesContent":["declare global {\n  interface Window {\n    __NEXT_HMR_LATENCY_CB: ((latencyMs: number) => void) | undefined\n  }\n}\n\n/**\n * Logs information about a completed HMR to the console, the server (via a\n * `client-hmr-latency` event), and to `self.__NEXT_HMR_LATENCY_CB` (a debugging\n * hook).\n *\n * @param hasUpdate Set this to `false` to avoid reporting the HMR event via a\n *   `client-hmr-latency` event or to `self.__NEXT_HMR_LATENCY_CB`. Used by\n *   turbopack when we must report a message to the browser console (because we\n *   already logged a \"rebuilding\" message), but it's not a real HMR, so we\n *   don't want to impact our telemetry.\n */\nexport default function reportHmrLatency(\n  sendMessage: (message: string) => void,\n  updatedModules: ReadonlyArray<string | number>,\n  startMsSinceEpoch: number,\n  endMsSinceEpoch: number,\n  hasUpdate: boolean = true\n) {\n  const latencyMs = endMsSinceEpoch - startMsSinceEpoch\n  console.log(`[Fast Refresh] done in ${latencyMs}ms`)\n  if (!hasUpdate) {\n    return\n  }\n  sendMessage(\n    JSON.stringify({\n      event: 'client-hmr-latency',\n      id: window.__nextDevClientId,\n      startTime: startMsSinceEpoch,\n      endTime: endMsSinceEpoch,\n      page: window.location.pathname,\n      updatedModules,\n      // Whether the page (tab) was hidden at the time the event occurred.\n      // This can impact the accuracy of the event's timing.\n      isPageHidden: document.visibilityState === 'hidden',\n    })\n  )\n  if (self.__NEXT_HMR_LATENCY_CB) {\n    self.__NEXT_HMR_LATENCY_CB(latencyMs)\n  }\n}\n"],"names":["reportHmrLatency","sendMessage","updatedModules","startMsSinceEpoch","endMsSinceEpoch","hasUpdate","latencyMs","console","log","JSON","stringify","event","id","window","__nextDevClientId","startTime","endTime","page","location","pathname","isPageHidden","document","visibilityState","self","__NEXT_HMR_LATENCY_CB"],"mappings":";;;+BAMA;;;;;;;;;;CAUC,GACD,WAAA;;;eAAwBA;;;AAAT,SAASA,iBACtBC,WAAsC,EACtCC,cAA8C,EAC9CC,iBAAyB,EACzBC,eAAuB,EACvBC,YAAqB,IAAI;IAEzB,MAAMC,YAAYF,kBAAkBD;IACpCI,QAAQC,GAAG,CAAC,CAAC,uBAAuB,EAAEF,UAAU,EAAE,CAAC;IACnD,IAAI,CAACD,WAAW;QACd;IACF;IACAJ,YACEQ,KAAKC,SAAS,CAAC;QACbC,OAAO;QACPC,IAAIC,OAAOC,iBAAiB;QAC5BC,WAAWZ;QACXa,SAASZ;QACTa,MAAMJ,OAAOK,QAAQ,CAACC,QAAQ;QAC9BjB;QACA,oEAAoE;QACpE,sDAAsD;QACtDkB,cAAcC,SAASC,eAAe,KAAK;IAC7C;IAEF,IAAIC,KAAKC,qBAAqB,EAAE;QAC9BD,KAAKC,qBAAqB,CAAClB;IAC7B;AACF","ignoreList":[0]}},
    {"offset": {"line": 12300, "column": 0}, "map": {"version":3,"sources":["file:///D:/AconnectJP/node_modules/next/src/client/dev/hot-reloader/turbopack-hot-reloader-common.ts"],"sourcesContent":["import type { TurbopackMessage } from '../../../server/dev/hot-reloader-types'\nimport type { Update as TurbopackUpdate } from '../../../build/swc/types'\n\ndeclare global {\n  interface Window {\n    __NEXT_HMR_TURBOPACK_REPORT_NOISY_NOOP_EVENTS: boolean | undefined\n  }\n}\n\n// How long to wait before reporting the HMR start, used to suppress irrelevant\n// `BUILDING` events. Does not impact reported latency.\nconst TURBOPACK_HMR_START_DELAY_MS = 100\n\ninterface HmrUpdate {\n  hasUpdates: boolean\n  updatedModules: Set<string>\n  startMsSinceEpoch: number\n  endMsSinceEpoch: number\n}\n\nexport class TurbopackHmr {\n  #updatedModules: Set<string>\n  #startMsSinceEpoch: number | undefined\n  #lastUpdateMsSinceEpoch: number | undefined\n  #deferredReportHmrStartId: ReturnType<typeof setTimeout> | undefined\n  #reportedHmrStart: boolean\n\n  constructor() {\n    this.#updatedModules = new Set()\n    this.#reportedHmrStart = false\n  }\n\n  // HACK: Turbopack tends to generate a lot of irrelevant \"BUILDING\" actions,\n  // as it reports *any* compilation, including fully no-op/cached compilations\n  // and those unrelated to HMR. Fixing this would require significant\n  // architectural changes.\n  //\n  // Work around this by deferring any \"rebuilding\" message by 100ms. If we get\n  // a BUILT event within that threshold and nothing has changed, just suppress\n  // the message entirely.\n  #runDeferredReportHmrStart() {\n    if (this.#deferredReportHmrStartId != null) {\n      console.log('[Fast Refresh] rebuilding')\n      this.#reportedHmrStart = true\n      this.#cancelDeferredReportHmrStart()\n    }\n  }\n\n  #cancelDeferredReportHmrStart() {\n    clearTimeout(this.#deferredReportHmrStartId)\n    this.#deferredReportHmrStartId = undefined\n  }\n\n  onBuilding() {\n    this.#lastUpdateMsSinceEpoch = undefined\n    this.#cancelDeferredReportHmrStart()\n    this.#startMsSinceEpoch = Date.now()\n\n    // report the HMR start after a short delay\n    this.#deferredReportHmrStartId = setTimeout(\n      () => this.#runDeferredReportHmrStart(),\n      // debugging feature: don't defer/suppress noisy no-op HMR update messages\n      self.__NEXT_HMR_TURBOPACK_REPORT_NOISY_NOOP_EVENTS\n        ? 0\n        : TURBOPACK_HMR_START_DELAY_MS\n    )\n  }\n\n  /** Helper for other `onEvent` methods. */\n  #onUpdate() {\n    this.#runDeferredReportHmrStart()\n    this.#lastUpdateMsSinceEpoch = Date.now()\n  }\n\n  onTurbopackMessage(msg: TurbopackMessage) {\n    this.#onUpdate()\n    const updatedModules = extractModulesFromTurbopackMessage(msg.data)\n    for (const module of updatedModules) {\n      this.#updatedModules.add(module)\n    }\n  }\n\n  onServerComponentChanges() {\n    this.#onUpdate()\n  }\n\n  onReloadPage() {\n    this.#onUpdate()\n  }\n\n  onPageAddRemove() {\n    this.#onUpdate()\n  }\n\n  /**\n   * @returns `null` if the caller should ignore the update entirely. Returns an\n   *   object with `hasUpdates: false` if the caller should report the end of\n   *   the HMR in the browser console, but the HMR was a no-op.\n   */\n  onBuilt(): HmrUpdate | null {\n    // Check that we got *any* `TurbopackMessage`, even if\n    // `updatedModules` is empty (not everything gets recorded there).\n    //\n    // There's also a case where `onBuilt` gets called before `onBuilding`,\n    // which can happen during initial page load. Ignore that too!\n    const hasUpdates =\n      this.#lastUpdateMsSinceEpoch != null && this.#startMsSinceEpoch != null\n    if (!hasUpdates && !this.#reportedHmrStart) {\n      // suppress the update entirely\n      this.#cancelDeferredReportHmrStart()\n      return null\n    }\n    this.#runDeferredReportHmrStart()\n\n    const result = {\n      hasUpdates,\n      updatedModules: this.#updatedModules,\n      startMsSinceEpoch: this.#startMsSinceEpoch!,\n      endMsSinceEpoch: this.#lastUpdateMsSinceEpoch ?? Date.now(),\n    }\n    this.#updatedModules = new Set()\n    this.#reportedHmrStart = false\n    return result\n  }\n}\n\nfunction extractModulesFromTurbopackMessage(\n  data: TurbopackUpdate | TurbopackUpdate[]\n): Set<string> {\n  const updatedModules: Set<string> = new Set()\n\n  const updates = Array.isArray(data) ? data : [data]\n  for (const update of updates) {\n    // TODO this won't capture changes to CSS since they don't result in a \"merged\" update\n    if (\n      update.type !== 'partial' ||\n      update.instruction.type !== 'ChunkListUpdate' ||\n      update.instruction.merged === undefined\n    ) {\n      continue\n    }\n\n    for (const mergedUpdate of update.instruction.merged) {\n      for (const name of Object.keys(mergedUpdate.entries)) {\n        const res = /(.*)\\s+[([].*/.exec(name)\n        if (res === null) {\n          continue\n        }\n\n        updatedModules.add(res[1])\n      }\n    }\n  }\n\n  return updatedModules\n}\n"],"names":["TurbopackHmr","TURBOPACK_HMR_START_DELAY_MS","constructor","Set","console","log","clearTimeout","undefined","onBuilding","Date","now","setTimeout","self","__NEXT_HMR_TURBOPACK_REPORT_NOISY_NOOP_EVENTS","onTurbopackMessage","msg","updatedModules","extractModulesFromTurbopackMessage","data","module","add","onServerComponentChanges","onReloadPage","onPageAddRemove","onBuilt","hasUpdates","result","startMsSinceEpoch","endMsSinceEpoch","updates","Array","isArray","update","type","instruction","merged","mergedUpdate","name","Object","keys","entries","res","exec"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 12429, "column": 0}, "map": {"version":3,"sources":["file:///D:/AconnectJP/node_modules/next/src/client/dev/debug-channel.ts"],"sourcesContent":["import { NEXT_REQUEST_ID_HEADER } from '../components/app-router-headers'\nimport { InvariantError } from '../../shared/lib/invariant-error'\n\nexport interface DebugChannelReadableWriterPair {\n  readonly readable: ReadableStream<Uint8Array>\n  readonly writer: WritableStreamDefaultWriter<Uint8Array>\n}\n\nconst pairs = new Map<string, DebugChannelReadableWriterPair>()\n\nexport function getOrCreateDebugChannelReadableWriterPair(\n  requestId: string\n): DebugChannelReadableWriterPair {\n  let pair = pairs.get(requestId)\n\n  if (!pair) {\n    const { readable, writable } = new TransformStream<Uint8Array, Uint8Array>()\n    pair = { readable, writer: writable.getWriter() }\n    pairs.set(requestId, pair)\n    pair.writer.closed.finally(() => pairs.delete(requestId))\n  }\n\n  return pair\n}\n\nexport function createDebugChannel(\n  requestHeaders: Record<string, string> | undefined\n): {\n  writable?: WritableStream\n  readable?: ReadableStream\n} {\n  let requestId: string | undefined\n\n  if (requestHeaders) {\n    requestId = requestHeaders[NEXT_REQUEST_ID_HEADER] ?? undefined\n\n    if (!requestId) {\n      throw new InvariantError(\n        `Expected a ${JSON.stringify(NEXT_REQUEST_ID_HEADER)} request header.`\n      )\n    }\n  } else {\n    requestId = self.__next_r\n\n    if (!requestId) {\n      throw new InvariantError(\n        `Expected a request ID to be defined for the document via self.__next_r.`\n      )\n    }\n  }\n\n  const { readable } = getOrCreateDebugChannelReadableWriterPair(requestId)\n\n  return { readable }\n}\n"],"names":["createDebugChannel","getOrCreateDebugChannelReadableWriterPair","pairs","Map","requestId","pair","get","readable","writable","TransformStream","writer","getWriter","set","closed","finally","delete","requestHeaders","NEXT_REQUEST_ID_HEADER","undefined","InvariantError","JSON","stringify","self","__next_r"],"mappings":";;;;;;;;;;;;;;IAyBgBA,kBAAkB,EAAA;eAAlBA;;IAfAC,yCAAyC,EAAA;eAAzCA;;;kCAVuB;gCACR;AAO/B,MAAMC,QAAQ,IAAIC;AAEX,SAASF,0CACdG,SAAiB;IAEjB,IAAIC,OAAOH,MAAMI,GAAG,CAACF;IAErB,IAAI,CAACC,MAAM;QACT,MAAM,EAAEE,QAAQ,EAAEC,QAAQ,EAAE,GAAG,IAAIC;QACnCJ,OAAO;YAAEE;YAAUG,QAAQF,SAASG,SAAS;QAAG;QAChDT,MAAMU,GAAG,CAACR,WAAWC;QACrBA,KAAKK,MAAM,CAACG,MAAM,CAACC,OAAO,CAAC,IAAMZ,MAAMa,MAAM,CAACX;IAChD;IAEA,OAAOC;AACT;AAEO,SAASL,mBACdgB,cAAkD;IAKlD,IAAIZ;IAEJ,IAAIY,gBAAgB;QAClBZ,YAAYY,cAAc,CAACC,kBAAAA,sBAAsB,CAAC,IAAIC;QAEtD,IAAI,CAACd,WAAW;YACd,MAAM,OAAA,cAEL,CAFK,IAAIe,gBAAAA,cAAc,CACtB,CAAC,WAAW,EAAEC,KAAKC,SAAS,CAACJ,kBAAAA,sBAAsB,EAAE,gBAAgB,CAAC,GADlE,qBAAA;uBAAA;4BAAA;8BAAA;YAEN;QACF;IACF,OAAO;QACLb,YAAYkB,KAAKC,QAAQ;QAEzB,IAAI,CAACnB,WAAW;YACd,MAAM,OAAA,cAEL,CAFK,IAAIe,gBAAAA,cAAc,CACtB,CAAC,uEAAuE,CAAC,GADrE,qBAAA;uBAAA;4BAAA;8BAAA;YAEN;QACF;IACF;IAEA,MAAM,EAAEZ,QAAQ,EAAE,GAAGN,0CAA0CG;IAE/D,OAAO;QAAEG;IAAS;AACpB","ignoreList":[0]}},
    {"offset": {"line": 12503, "column": 0}, "map": {"version":3,"sources":["file:///D:/AconnectJP/node_modules/next/src/client/dev/hot-reloader/app/hot-reloader-app.tsx"],"sourcesContent":["/// <reference types=\"webpack/module.d.ts\" />\n\nimport type { ReactNode } from 'react'\nimport { useEffect, startTransition } from 'react'\nimport stripAnsi from 'next/dist/compiled/strip-ansi'\nimport formatWebpackMessages from '../../../../shared/lib/format-webpack-messages'\nimport {\n  REACT_REFRESH_FULL_RELOAD,\n  REACT_REFRESH_FULL_RELOAD_FROM_ERROR,\n} from '../shared'\nimport {\n  dispatcher,\n  getSerializedOverlayState,\n  getSegmentTrieData,\n} from 'next/dist/compiled/next-devtools'\nimport { ReplaySsrOnlyErrors } from '../../../../next-devtools/userspace/app/errors/replay-ssr-only-errors'\nimport { AppDevOverlayErrorBoundary } from '../../../../next-devtools/userspace/app/app-dev-overlay-error-boundary'\nimport { useErrorHandler } from '../../../../next-devtools/userspace/app/errors/use-error-handler'\nimport { RuntimeErrorHandler } from '../../runtime-error-handler'\nimport { useWebSocketPing } from './web-socket'\nimport {\n  HMR_MESSAGE_SENT_TO_BROWSER,\n  HMR_MESSAGE_SENT_TO_SERVER,\n} from '../../../../server/dev/hot-reloader-types'\nimport type {\n  HmrMessageSentToBrowser,\n  TurbopackMessageSentToBrowser,\n} from '../../../../server/dev/hot-reloader-types'\nimport type { McpErrorStateResponse } from '../../../../shared/lib/mcp-error-types'\nimport type { McpPageMetadataResponse } from '../../../../shared/lib/mcp-page-metadata-types'\nimport { useUntrackedPathname } from '../../../components/navigation-untracked'\nimport reportHmrLatency from '../../report-hmr-latency'\nimport { TurbopackHmr } from '../turbopack-hot-reloader-common'\nimport { NEXT_HMR_REFRESH_HASH_COOKIE } from '../../../components/app-router-headers'\nimport {\n  publicAppRouterInstance,\n  type GlobalErrorState,\n} from '../../../components/app-router-instance'\nimport { InvariantError } from '../../../../shared/lib/invariant-error'\nimport { getOrCreateDebugChannelReadableWriterPair } from '../../debug-channel'\n// TODO: Explicitly import from client.browser (doesn't work with Webpack).\n// eslint-disable-next-line import/no-extraneous-dependencies\nimport { createFromReadableStream as createFromReadableStreamBrowser } from 'react-server-dom-webpack/client'\nimport { findSourceMapURL } from '../../../app-find-source-map-url'\n\nexport interface StaticIndicatorState {\n  pathname: string | null\n  appIsrManifest: Record<string, boolean> | null\n}\n\nconst createFromReadableStream =\n  createFromReadableStreamBrowser as (typeof import('react-server-dom-webpack/client.browser'))['createFromReadableStream']\n\nlet mostRecentCompilationHash: any = null\nlet __nextDevClientId = Math.round(Math.random() * 100 + Date.now())\nlet reloading = false\nlet webpackStartMsSinceEpoch: number | null = null\nconst turbopackHmr: TurbopackHmr | null = process.env.TURBOPACK\n  ? new TurbopackHmr()\n  : null\n\nlet pendingHotUpdateWebpack = Promise.resolve()\nlet resolvePendingHotUpdateWebpack: () => void = () => {}\nfunction setPendingHotUpdateWebpack() {\n  pendingHotUpdateWebpack = new Promise((resolve) => {\n    resolvePendingHotUpdateWebpack = () => {\n      resolve()\n    }\n  })\n}\n\nexport function waitForWebpackRuntimeHotUpdate() {\n  return pendingHotUpdateWebpack\n}\n\n// There is a newer version of the code available.\nfunction handleAvailableHash(hash: string) {\n  // Update last known compilation hash.\n  mostRecentCompilationHash = hash\n}\n\n/**\n * Is there a newer version of this code available?\n * For webpack: Check if the hash changed compared to __webpack_hash__\n * For Turbopack: Always true because it doesn't have __webpack_hash__\n */\nfunction isUpdateAvailable() {\n  if (process.env.TURBOPACK) {\n    return true\n  }\n\n  /* globals __webpack_hash__ */\n  // __webpack_hash__ is the hash of the current compilation.\n  // It's a global variable injected by Webpack.\n  return mostRecentCompilationHash !== __webpack_hash__\n}\n\n// Webpack disallows updates in other states.\nfunction canApplyUpdates() {\n  return module.hot.status() === 'idle'\n}\nfunction afterApplyUpdates(fn: any) {\n  if (canApplyUpdates()) {\n    fn()\n  } else {\n    function handler(status: any) {\n      if (status === 'idle') {\n        module.hot.removeStatusHandler(handler)\n        fn()\n      }\n    }\n    module.hot.addStatusHandler(handler)\n  }\n}\n\nexport function performFullReload(\n  err: any,\n  sendMessage: (data: string) => void\n) {\n  const stackTrace =\n    err &&\n    ((err.stack && err.stack.split('\\n').slice(0, 5).join('\\n')) ||\n      err.message ||\n      err + '')\n\n  sendMessage(\n    JSON.stringify({\n      event: 'client-full-reload',\n      stackTrace,\n      hadRuntimeError: !!RuntimeErrorHandler.hadRuntimeError,\n      dependencyChain: err ? err.dependencyChain : undefined,\n    })\n  )\n\n  if (reloading) return\n  reloading = true\n  window.location.reload()\n}\n\n// Attempt to update code on the fly, fall back to a hard reload.\nfunction tryApplyUpdatesWebpack(sendMessage: (message: string) => void) {\n  if (!isUpdateAvailable() || !canApplyUpdates()) {\n    resolvePendingHotUpdateWebpack()\n    dispatcher.onBuildOk()\n    reportHmrLatency(sendMessage, [], webpackStartMsSinceEpoch!, Date.now())\n    return\n  }\n\n  function handleApplyUpdates(\n    err: any,\n    updatedModules: (string | number)[] | null\n  ) {\n    if (err || RuntimeErrorHandler.hadRuntimeError || updatedModules == null) {\n      if (err) {\n        console.warn(REACT_REFRESH_FULL_RELOAD)\n      } else if (RuntimeErrorHandler.hadRuntimeError) {\n        console.warn(REACT_REFRESH_FULL_RELOAD_FROM_ERROR)\n      }\n      performFullReload(err, sendMessage)\n      return\n    }\n\n    dispatcher.onBuildOk()\n\n    if (isUpdateAvailable()) {\n      // While we were updating, there was a new update! Do it again.\n      tryApplyUpdatesWebpack(sendMessage)\n      return\n    }\n\n    dispatcher.onRefresh()\n    resolvePendingHotUpdateWebpack()\n    reportHmrLatency(\n      sendMessage,\n      updatedModules,\n      webpackStartMsSinceEpoch!,\n      Date.now()\n    )\n\n    if (process.env.__NEXT_TEST_MODE) {\n      afterApplyUpdates(() => {\n        if (self.__NEXT_HMR_CB) {\n          self.__NEXT_HMR_CB()\n          self.__NEXT_HMR_CB = null\n        }\n      })\n    }\n  }\n\n  // https://webpack.js.org/api/hot-module-replacement/#check\n  module.hot\n    .check(/* autoApply */ false)\n    .then((updatedModules: (string | number)[] | null) => {\n      if (updatedModules == null) {\n        return null\n      }\n\n      // We should always handle an update, even if updatedModules is empty (but\n      // non-null) for any reason. That's what webpack would normally do:\n      // https://github.com/webpack/webpack/blob/3aa6b6bc3a64/lib/hmr/HotModuleReplacement.runtime.js#L296-L298\n      dispatcher.onBeforeRefresh()\n      // https://webpack.js.org/api/hot-module-replacement/#apply\n      return module.hot.apply()\n    })\n    .then(\n      (updatedModules: (string | number)[] | null) => {\n        handleApplyUpdates(null, updatedModules)\n      },\n      (err: any) => {\n        handleApplyUpdates(err, null)\n      }\n    )\n}\n\n/** Handles messages from the server for the App Router. */\nexport function processMessage(\n  message: HmrMessageSentToBrowser,\n  sendMessage: (message: string) => void,\n  processTurbopackMessage: (msg: TurbopackMessageSentToBrowser) => void,\n  staticIndicatorState: StaticIndicatorState\n) {\n  function handleErrors(errors: ReadonlyArray<unknown>) {\n    // \"Massage\" webpack messages.\n    const formatted = formatWebpackMessages({\n      errors: errors,\n      warnings: [],\n    })\n\n    // Only show the first error.\n    dispatcher.onBuildError(formatted.errors[0])\n\n    // Also log them to the console.\n    for (let i = 0; i < formatted.errors.length; i++) {\n      console.error(stripAnsi(formatted.errors[i]))\n    }\n\n    // Do not attempt to reload now.\n    // We will reload on next success instead.\n    if (process.env.__NEXT_TEST_MODE) {\n      if (self.__NEXT_HMR_CB) {\n        self.__NEXT_HMR_CB(formatted.errors[0])\n        self.__NEXT_HMR_CB = null\n      }\n    }\n  }\n\n  function handleHotUpdate() {\n    if (process.env.TURBOPACK) {\n      const hmrUpdate = turbopackHmr!.onBuilt()\n      if (hmrUpdate != null) {\n        reportHmrLatency(\n          sendMessage,\n          [...hmrUpdate.updatedModules],\n          hmrUpdate.startMsSinceEpoch,\n          hmrUpdate.endMsSinceEpoch,\n          // suppress the `client-hmr-latency` event if the update was a no-op:\n          hmrUpdate.hasUpdates\n        )\n      }\n      dispatcher.onBuildOk()\n    } else {\n      tryApplyUpdatesWebpack(sendMessage)\n    }\n  }\n\n  switch (message.type) {\n    case HMR_MESSAGE_SENT_TO_BROWSER.ISR_MANIFEST: {\n      if (process.env.__NEXT_DEV_INDICATOR) {\n        staticIndicatorState.appIsrManifest = message.data\n\n        // Handle the initial static indicator status on receiving the ISR\n        // manifest. Navigation is handled in an effect inside HotReload for\n        // pathname changes as we'll receive the updated manifest before\n        // usePathname triggers for a new value.\n\n        const isStatic = staticIndicatorState.pathname\n          ? message.data[staticIndicatorState.pathname]\n          : undefined\n\n        dispatcher.onStaticIndicator(\n          isStatic === undefined ? 'pending' : isStatic ? 'static' : 'dynamic'\n        )\n      }\n      break\n    }\n    case HMR_MESSAGE_SENT_TO_BROWSER.BUILDING: {\n      dispatcher.buildingIndicatorShow()\n\n      if (process.env.TURBOPACK) {\n        turbopackHmr!.onBuilding()\n      } else {\n        webpackStartMsSinceEpoch = Date.now()\n        setPendingHotUpdateWebpack()\n        console.log('[Fast Refresh] rebuilding')\n      }\n      break\n    }\n    case HMR_MESSAGE_SENT_TO_BROWSER.BUILT:\n    case HMR_MESSAGE_SENT_TO_BROWSER.SYNC: {\n      dispatcher.buildingIndicatorHide()\n\n      if (message.hash) {\n        handleAvailableHash(message.hash)\n      }\n\n      const { errors, warnings } = message\n\n      // Is undefined when it's a 'built' event\n      if ('versionInfo' in message)\n        dispatcher.onVersionInfo(message.versionInfo)\n      if ('debug' in message && message.debug)\n        dispatcher.onDebugInfo(message.debug)\n      if ('devIndicator' in message)\n        dispatcher.onDevIndicator(message.devIndicator)\n      if ('devToolsConfig' in message)\n        dispatcher.onDevToolsConfig(message.devToolsConfig)\n\n      const hasErrors = Boolean(errors && errors.length)\n      // Compilation with errors (e.g. syntax error or missing modules).\n      if (hasErrors) {\n        sendMessage(\n          JSON.stringify({\n            event: 'client-error',\n            errorCount: errors.length,\n            clientId: __nextDevClientId,\n          })\n        )\n\n        handleErrors(errors)\n        return\n      }\n\n      const hasWarnings = Boolean(warnings && warnings.length)\n      if (hasWarnings) {\n        sendMessage(\n          JSON.stringify({\n            event: 'client-warning',\n            warningCount: warnings.length,\n            clientId: __nextDevClientId,\n          })\n        )\n\n        // Print warnings to the console.\n        const formattedMessages = formatWebpackMessages({\n          warnings: warnings,\n          errors: [],\n        })\n\n        for (let i = 0; i < formattedMessages.warnings.length; i++) {\n          if (i === 5) {\n            console.warn(\n              'There were more warnings in other files.\\n' +\n                'You can find a complete log in the terminal.'\n            )\n            break\n          }\n          console.warn(stripAnsi(formattedMessages.warnings[i]))\n        }\n\n        // No early return here as we need to apply modules in the same way between warnings only and compiles without warnings\n      }\n\n      sendMessage(\n        JSON.stringify({\n          event: 'client-success',\n          clientId: __nextDevClientId,\n        })\n      )\n\n      if (message.type === HMR_MESSAGE_SENT_TO_BROWSER.BUILT) {\n        handleHotUpdate()\n      }\n      return\n    }\n    case HMR_MESSAGE_SENT_TO_BROWSER.TURBOPACK_CONNECTED: {\n      processTurbopackMessage({\n        type: HMR_MESSAGE_SENT_TO_BROWSER.TURBOPACK_CONNECTED,\n        data: {\n          sessionId: message.data.sessionId,\n        },\n      })\n      break\n    }\n    case HMR_MESSAGE_SENT_TO_BROWSER.TURBOPACK_MESSAGE: {\n      turbopackHmr!.onTurbopackMessage(message)\n      dispatcher.onBeforeRefresh()\n      processTurbopackMessage({\n        type: HMR_MESSAGE_SENT_TO_BROWSER.TURBOPACK_MESSAGE,\n        data: message.data,\n      })\n      if (RuntimeErrorHandler.hadRuntimeError) {\n        console.warn(REACT_REFRESH_FULL_RELOAD_FROM_ERROR)\n        performFullReload(null, sendMessage)\n      }\n      dispatcher.onRefresh()\n      break\n    }\n    // TODO-APP: make server component change more granular\n    case HMR_MESSAGE_SENT_TO_BROWSER.SERVER_COMPONENT_CHANGES: {\n      turbopackHmr?.onServerComponentChanges()\n      sendMessage(\n        JSON.stringify({\n          event: 'server-component-reload-page',\n          clientId: __nextDevClientId,\n          hash: message.hash,\n        })\n      )\n\n      // Store the latest hash in a session cookie so that it's sent back to the\n      // server with any subsequent requests.\n      document.cookie = `${NEXT_HMR_REFRESH_HASH_COOKIE}=${message.hash};path=/`\n\n      if (\n        RuntimeErrorHandler.hadRuntimeError ||\n        document.documentElement.id === '__next_error__'\n      ) {\n        if (reloading) return\n        reloading = true\n        return window.location.reload()\n      }\n\n      startTransition(() => {\n        publicAppRouterInstance.hmrRefresh()\n        dispatcher.onRefresh()\n      })\n\n      if (process.env.__NEXT_TEST_MODE) {\n        if (self.__NEXT_HMR_CB) {\n          self.__NEXT_HMR_CB()\n          self.__NEXT_HMR_CB = null\n        }\n      }\n\n      return\n    }\n    case HMR_MESSAGE_SENT_TO_BROWSER.RELOAD_PAGE: {\n      turbopackHmr?.onReloadPage()\n      sendMessage(\n        JSON.stringify({\n          event: 'client-reload-page',\n          clientId: __nextDevClientId,\n        })\n      )\n      if (reloading) return\n      reloading = true\n      return window.location.reload()\n    }\n    case HMR_MESSAGE_SENT_TO_BROWSER.ADDED_PAGE:\n    case HMR_MESSAGE_SENT_TO_BROWSER.REMOVED_PAGE: {\n      turbopackHmr?.onPageAddRemove()\n      // TODO-APP: potentially only refresh if the currently viewed page was added/removed.\n      return publicAppRouterInstance.hmrRefresh()\n    }\n    case HMR_MESSAGE_SENT_TO_BROWSER.SERVER_ERROR: {\n      const { errorJSON } = message\n      if (errorJSON) {\n        const errorObject = JSON.parse(errorJSON)\n        const error = new Error(errorObject.message)\n        error.stack = errorObject.stack\n        handleErrors([error])\n      }\n      return\n    }\n    case HMR_MESSAGE_SENT_TO_BROWSER.DEV_PAGES_MANIFEST_UPDATE: {\n      return\n    }\n    case HMR_MESSAGE_SENT_TO_BROWSER.DEVTOOLS_CONFIG: {\n      dispatcher.onDevToolsConfig(message.data)\n      return\n    }\n    case HMR_MESSAGE_SENT_TO_BROWSER.REACT_DEBUG_CHUNK: {\n      const { requestId, chunk } = message\n      const { writer } = getOrCreateDebugChannelReadableWriterPair(requestId)\n\n      if (chunk) {\n        writer.ready.then(() => writer.write(chunk)).catch(console.error)\n      } else {\n        // A null chunk signals that no more chunks will be sent, which allows\n        // us to close the writer.\n        // TODO: Revisit this cleanup logic when we integrate the return channel\n        // that keeps the connection open to be able to lazily retrieve debug\n        // objects.\n        writer.ready.then(() => writer.close()).catch(console.error)\n      }\n\n      return\n    }\n    case HMR_MESSAGE_SENT_TO_BROWSER.REQUEST_CURRENT_ERROR_STATE: {\n      const errorState = getSerializedOverlayState()\n      const response: McpErrorStateResponse = {\n        event: HMR_MESSAGE_SENT_TO_SERVER.MCP_ERROR_STATE_RESPONSE,\n        requestId: message.requestId,\n        errorState,\n        url: window.location.href,\n      }\n      sendMessage(JSON.stringify(response))\n      return\n    }\n    case HMR_MESSAGE_SENT_TO_BROWSER.REQUEST_PAGE_METADATA: {\n      const segmentTrieData = getSegmentTrieData()\n      const response: McpPageMetadataResponse = {\n        event: HMR_MESSAGE_SENT_TO_SERVER.MCP_PAGE_METADATA_RESPONSE,\n        requestId: message.requestId,\n        segmentTrieData,\n        url: window.location.href,\n      }\n      sendMessage(JSON.stringify(response))\n      return\n    }\n    case HMR_MESSAGE_SENT_TO_BROWSER.CACHE_INDICATOR: {\n      dispatcher.onCacheIndicator(message.state)\n      return\n    }\n    case HMR_MESSAGE_SENT_TO_BROWSER.ERRORS_TO_SHOW_IN_BROWSER: {\n      createFromReadableStream<Error[]>(\n        new ReadableStream({\n          start(controller) {\n            controller.enqueue(message.serializedErrors)\n            controller.close()\n          },\n        }),\n        { findSourceMapURL }\n      ).then(\n        (errors) => {\n          for (const error of errors) {\n            console.error(error)\n          }\n        },\n        (err) => {\n          console.error(\n            new Error('Failed to deserialize errors.', { cause: err })\n          )\n        }\n      )\n      return\n    }\n    case HMR_MESSAGE_SENT_TO_BROWSER.MIDDLEWARE_CHANGES:\n    case HMR_MESSAGE_SENT_TO_BROWSER.CLIENT_CHANGES:\n    case HMR_MESSAGE_SENT_TO_BROWSER.SERVER_ONLY_CHANGES:\n      // These action types are handled in src/client/page-bootstrap.ts\n      break\n    default: {\n      message satisfies never\n    }\n  }\n}\n\nexport default function HotReload({\n  children,\n  globalError,\n  webSocket,\n  staticIndicatorState,\n}: {\n  children: ReactNode\n  globalError: GlobalErrorState\n  webSocket: WebSocket | undefined\n  staticIndicatorState: StaticIndicatorState | undefined\n}) {\n  useErrorHandler(dispatcher.onUnhandledError, dispatcher.onUnhandledRejection)\n  useWebSocketPing(webSocket)\n\n  // We don't want access of the pathname for the dev tools to trigger a dynamic\n  // access (as the dev overlay will never be present in production).\n  const pathname = useUntrackedPathname()\n\n  if (process.env.__NEXT_DEV_INDICATOR) {\n    // this conditional is only for dead-code elimination which\n    // isn't a runtime conditional only build-time so ignore hooks rule\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    useEffect(() => {\n      if (!staticIndicatorState) {\n        throw new InvariantError(\n          'Expected staticIndicatorState to be defined in dev mode.'\n        )\n      }\n\n      staticIndicatorState.pathname = pathname\n\n      if (staticIndicatorState.appIsrManifest) {\n        const isStatic = pathname\n          ? staticIndicatorState.appIsrManifest[pathname]\n          : undefined\n\n        dispatcher.onStaticIndicator(\n          isStatic === undefined ? 'pending' : isStatic ? 'static' : 'dynamic'\n        )\n      }\n    }, [pathname, staticIndicatorState])\n  }\n\n  return (\n    <AppDevOverlayErrorBoundary globalError={globalError}>\n      <ReplaySsrOnlyErrors onBlockingError={dispatcher.openErrorOverlay} />\n      {children}\n    </AppDevOverlayErrorBoundary>\n  )\n}\n"],"names":["HotReload","performFullReload","processMessage","waitForWebpackRuntimeHotUpdate","createFromReadableStream","createFromReadableStreamBrowser","mostRecentCompilationHash","__nextDevClientId","Math","round","random","Date","now","reloading","webpackStartMsSinceEpoch","turbopackHmr","process","env","TURBOPACK","TurbopackHmr","pendingHotUpdateWebpack","Promise","resolve","resolvePendingHotUpdateWebpack","setPendingHotUpdateWebpack","handleAvailableHash","hash","isUpdateAvailable","__webpack_hash__","canApplyUpdates","module","hot","status","afterApplyUpdates","fn","handler","removeStatusHandler","addStatusHandler","err","sendMessage","stackTrace","stack","split","slice","join","message","JSON","stringify","event","hadRuntimeError","RuntimeErrorHandler","dependencyChain","undefined","window","location","reload","tryApplyUpdatesWebpack","dispatcher","onBuildOk","reportHmrLatency","handleApplyUpdates","updatedModules","console","warn","REACT_REFRESH_FULL_RELOAD","REACT_REFRESH_FULL_RELOAD_FROM_ERROR","onRefresh","__NEXT_TEST_MODE","self","__NEXT_HMR_CB","check","then","onBeforeRefresh","apply","processTurbopackMessage","staticIndicatorState","handleErrors","errors","formatted","formatWebpackMessages","warnings","onBuildError","i","length","error","stripAnsi","handleHotUpdate","hmrUpdate","onBuilt","startMsSinceEpoch","endMsSinceEpoch","hasUpdates","type","HMR_MESSAGE_SENT_TO_BROWSER","ISR_MANIFEST","__NEXT_DEV_INDICATOR","appIsrManifest","data","isStatic","pathname","onStaticIndicator","BUILDING","buildingIndicatorShow","onBuilding","log","BUILT","SYNC","buildingIndicatorHide","onVersionInfo","versionInfo","debug","onDebugInfo","onDevIndicator","devIndicator","onDevToolsConfig","devToolsConfig","hasErrors","Boolean","errorCount","clientId","hasWarnings","warningCount","formattedMessages","TURBOPACK_CONNECTED","sessionId","TURBOPACK_MESSAGE","onTurbopackMessage","SERVER_COMPONENT_CHANGES","onServerComponentChanges","document","cookie","NEXT_HMR_REFRESH_HASH_COOKIE","documentElement","id","startTransition","publicAppRouterInstance","hmrRefresh","RELOAD_PAGE","onReloadPage","ADDED_PAGE","REMOVED_PAGE","onPageAddRemove","SERVER_ERROR","errorJSON","errorObject","parse","Error","DEV_PAGES_MANIFEST_UPDATE","DEVTOOLS_CONFIG","REACT_DEBUG_CHUNK","requestId","chunk","writer","getOrCreateDebugChannelReadableWriterPair","ready","write","catch","close","REQUEST_CURRENT_ERROR_STATE","errorState","getSerializedOverlayState","response","HMR_MESSAGE_SENT_TO_SERVER","MCP_ERROR_STATE_RESPONSE","url","href","REQUEST_PAGE_METADATA","segmentTrieData","getSegmentTrieData","MCP_PAGE_METADATA_RESPONSE","CACHE_INDICATOR","onCacheIndicator","state","ERRORS_TO_SHOW_IN_BROWSER","ReadableStream","start","controller","enqueue","serializedErrors","findSourceMapURL","cause","MIDDLEWARE_CHANGES","CLIENT_CHANGES","SERVER_ONLY_CHANGES","children","globalError","webSocket","useErrorHandler","onUnhandledError","onUnhandledRejection","useWebSocketPing","useUntrackedPathname","useEffect","InvariantError","AppDevOverlayErrorBoundary","ReplaySsrOnlyErrors","onBlockingError","openErrorOverlay"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 12996, "column": 0}, "map": {"version":3,"sources":["file:///D:/AconnectJP/node_modules/next/src/client/components/app-router.tsx"],"sourcesContent":["import React, {\n  useEffect,\n  useMemo,\n  startTransition,\n  useInsertionEffect,\n  useDeferredValue,\n} from 'react'\nimport {\n  AppRouterContext,\n  LayoutRouterContext,\n  GlobalLayoutRouterContext,\n} from '../../shared/lib/app-router-context.shared-runtime'\nimport type { CacheNode } from '../../shared/lib/app-router-types'\nimport { ACTION_RESTORE } from './router-reducer/router-reducer-types'\nimport type {\n  AppHistoryState,\n  AppRouterState,\n} from './router-reducer/router-reducer-types'\nimport { createHrefFromUrl } from './router-reducer/create-href-from-url'\nimport {\n  SearchParamsContext,\n  PathnameContext,\n  PathParamsContext,\n  NavigationPromisesContext,\n  type NavigationPromises,\n} from '../../shared/lib/hooks-client-context.shared-runtime'\nimport { dispatchAppRouterAction, useActionQueue } from './use-action-queue'\nimport { AppRouterAnnouncer } from './app-router-announcer'\nimport { RedirectBoundary } from './redirect-boundary'\nimport { findHeadInCache } from './router-reducer/reducers/find-head-in-cache'\nimport { unresolvedThenable } from './unresolved-thenable'\nimport { removeBasePath } from '../remove-base-path'\nimport { hasBasePath } from '../has-base-path'\nimport { getSelectedParams } from './router-reducer/compute-changed-path'\nimport { useNavFailureHandler } from './nav-failure-handler'\nimport {\n  dispatchTraverseAction,\n  publicAppRouterInstance,\n  type AppRouterActionQueue,\n  type GlobalErrorState,\n} from './app-router-instance'\nimport { getRedirectTypeFromError, getURLFromRedirectError } from './redirect'\nimport { isRedirectError } from './redirect-error'\nimport { pingVisibleLinks } from './links'\nimport RootErrorBoundary from './errors/root-error-boundary'\nimport DefaultGlobalError from './builtin/global-error'\nimport { RootLayoutBoundary } from '../../lib/framework/boundary-components'\nimport type { StaticIndicatorState } from '../dev/hot-reloader/app/hot-reloader-app'\nimport { getDeploymentIdQueryOrEmptyString } from '../../shared/lib/deployment-id'\n\nconst globalMutable: {\n  pendingMpaPath?: string\n} = {}\n\nfunction HistoryUpdater({\n  appRouterState,\n}: {\n  appRouterState: AppRouterState\n}) {\n  useInsertionEffect(() => {\n    if (process.env.__NEXT_APP_NAV_FAIL_HANDLING) {\n      // clear pending URL as navigation is no longer\n      // in flight\n      window.next.__pendingUrl = undefined\n    }\n\n    const { tree, pushRef, canonicalUrl, renderedSearch } = appRouterState\n\n    const appHistoryState: AppHistoryState = {\n      tree,\n      renderedSearch,\n    }\n\n    // TODO: Use Navigation API if available\n    const historyState = {\n      ...(pushRef.preserveCustomHistoryState ? window.history.state : {}),\n      // Identifier is shortened intentionally.\n      // __NA is used to identify if the history entry can be handled by the app-router.\n      // __N is used to identify if the history entry can be handled by the old router.\n      __NA: true,\n      __PRIVATE_NEXTJS_INTERNALS_TREE: appHistoryState,\n    }\n    if (\n      pushRef.pendingPush &&\n      // Skip pushing an additional history entry if the canonicalUrl is the same as the current url.\n      // This mirrors the browser behavior for normal navigation.\n      createHrefFromUrl(new URL(window.location.href)) !== canonicalUrl\n    ) {\n      // This intentionally mutates React state, pushRef is overwritten to ensure additional push/replace calls do not trigger an additional history entry.\n      pushRef.pendingPush = false\n      window.history.pushState(historyState, '', canonicalUrl)\n    } else {\n      window.history.replaceState(historyState, '', canonicalUrl)\n    }\n  }, [appRouterState])\n\n  useEffect(() => {\n    // The Next-Url and the base tree may affect the result of a prefetch\n    // task. Re-prefetch all visible links with the updated values. In most\n    // cases, this will not result in any new network requests, only if\n    // the prefetch result actually varies on one of these inputs.\n    pingVisibleLinks(appRouterState.nextUrl, appRouterState.tree)\n  }, [appRouterState.nextUrl, appRouterState.tree])\n\n  return null\n}\n\nfunction copyNextJsInternalHistoryState(data: any) {\n  if (data == null) data = {}\n  const currentState = window.history.state\n  const __NA = currentState?.__NA\n  if (__NA) {\n    data.__NA = __NA\n  }\n  const __PRIVATE_NEXTJS_INTERNALS_TREE =\n    currentState?.__PRIVATE_NEXTJS_INTERNALS_TREE\n  if (__PRIVATE_NEXTJS_INTERNALS_TREE) {\n    data.__PRIVATE_NEXTJS_INTERNALS_TREE = __PRIVATE_NEXTJS_INTERNALS_TREE\n  }\n\n  return data\n}\n\nfunction Head({\n  headCacheNode,\n}: {\n  headCacheNode: CacheNode | null\n}): React.ReactNode {\n  // If this segment has a `prefetchHead`, it's the statically prefetched data.\n  // We should use that on initial render instead of `head`. Then we'll switch\n  // to `head` when the dynamic response streams in.\n  const head = headCacheNode !== null ? headCacheNode.head : null\n  const prefetchHead =\n    headCacheNode !== null ? headCacheNode.prefetchHead : null\n\n  // If no prefetch data is available, then we go straight to rendering `head`.\n  const resolvedPrefetchRsc = prefetchHead !== null ? prefetchHead : head\n\n  // We use `useDeferredValue` to handle switching between the prefetched and\n  // final values. The second argument is returned on initial render, then it\n  // re-renders with the first argument.\n  return useDeferredValue(head, resolvedPrefetchRsc)\n}\n\n/**\n * The global router that wraps the application components.\n */\nfunction Router({\n  actionQueue,\n  globalError,\n  webSocket,\n  staticIndicatorState,\n}: {\n  actionQueue: AppRouterActionQueue\n  globalError: GlobalErrorState\n  webSocket: WebSocket | undefined\n  staticIndicatorState: StaticIndicatorState | undefined\n}) {\n  const state = useActionQueue(actionQueue)\n  const { canonicalUrl } = state\n  // Add memoized pathname/query for useSearchParams and usePathname.\n  const { searchParams, pathname } = useMemo(() => {\n    const url = new URL(\n      canonicalUrl,\n      typeof window === 'undefined' ? 'http://n' : window.location.href\n    )\n\n    return {\n      // This is turned into a readonly class in `useSearchParams`\n      searchParams: url.searchParams,\n      pathname: hasBasePath(url.pathname)\n        ? removeBasePath(url.pathname)\n        : url.pathname,\n    }\n  }, [canonicalUrl])\n\n  if (process.env.NODE_ENV !== 'production') {\n    const { cache, tree } = state\n\n    // This hook is in a conditional but that is ok because `process.env.NODE_ENV` never changes\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    useEffect(() => {\n      // Add `window.nd` for debugging purposes.\n      // This is not meant for use in applications as concurrent rendering will affect the cache/tree/router.\n      // @ts-ignore this is for debugging\n      window.nd = {\n        router: publicAppRouterInstance,\n        cache,\n        tree,\n      }\n    }, [cache, tree])\n  }\n\n  useEffect(() => {\n    // If the app is restored from bfcache, it's possible that\n    // pushRef.mpaNavigation is true, which would mean that any re-render of this component\n    // would trigger the mpa navigation logic again from the lines below.\n    // This will restore the router to the initial state in the event that the app is restored from bfcache.\n    function handlePageShow(event: PageTransitionEvent) {\n      if (\n        !event.persisted ||\n        !window.history.state?.__PRIVATE_NEXTJS_INTERNALS_TREE\n      ) {\n        return\n      }\n\n      // Clear the pendingMpaPath value so that a subsequent MPA navigation to the same URL can be triggered.\n      // This is necessary because if the browser restored from bfcache, the pendingMpaPath would still be set to the value\n      // of the last MPA navigation.\n      globalMutable.pendingMpaPath = undefined\n\n      dispatchAppRouterAction({\n        type: ACTION_RESTORE,\n        url: new URL(window.location.href),\n        historyState: window.history.state.__PRIVATE_NEXTJS_INTERNALS_TREE,\n      })\n    }\n\n    window.addEventListener('pageshow', handlePageShow)\n\n    return () => {\n      window.removeEventListener('pageshow', handlePageShow)\n    }\n  }, [])\n\n  useEffect(() => {\n    // Ensure that any redirect errors that bubble up outside of the RedirectBoundary\n    // are caught and handled by the router.\n    function handleUnhandledRedirect(\n      event: ErrorEvent | PromiseRejectionEvent\n    ) {\n      const error = 'reason' in event ? event.reason : event.error\n      if (isRedirectError(error)) {\n        event.preventDefault()\n        const url = getURLFromRedirectError(error)\n        const redirectType = getRedirectTypeFromError(error)\n        // TODO: This should access the router methods directly, rather than\n        // go through the public interface.\n        if (redirectType === 'push') {\n          publicAppRouterInstance.push(url, {})\n        } else {\n          publicAppRouterInstance.replace(url, {})\n        }\n      }\n    }\n    window.addEventListener('error', handleUnhandledRedirect)\n    window.addEventListener('unhandledrejection', handleUnhandledRedirect)\n\n    return () => {\n      window.removeEventListener('error', handleUnhandledRedirect)\n      window.removeEventListener('unhandledrejection', handleUnhandledRedirect)\n    }\n  }, [])\n\n  // When mpaNavigation flag is set do a hard navigation to the new url.\n  // Infinitely suspend because we don't actually want to rerender any child\n  // components with the new URL and any entangled state updates shouldn't\n  // commit either (eg: useTransition isPending should stay true until the page\n  // unloads).\n  //\n  // This is a side effect in render. Don't try this at home, kids. It's\n  // probably safe because we know this is a singleton component and it's never\n  // in <Offscreen>. At least I hope so. (It will run twice in dev strict mode,\n  // but that's... fine?)\n  const { pushRef } = state\n  if (pushRef.mpaNavigation) {\n    // if there's a re-render, we don't want to trigger another redirect if one is already in flight to the same URL\n    if (globalMutable.pendingMpaPath !== canonicalUrl) {\n      const location = window.location\n      if (pushRef.pendingPush) {\n        location.assign(canonicalUrl)\n      } else {\n        location.replace(canonicalUrl)\n      }\n\n      globalMutable.pendingMpaPath = canonicalUrl\n    }\n    // TODO-APP: Should we listen to navigateerror here to catch failed\n    // navigations somehow? And should we call window.stop() if a SPA navigation\n    // should interrupt an MPA one?\n    // NOTE: This is intentionally using `throw` instead of `use` because we're\n    // inside an externally mutable condition (pushRef.mpaNavigation), which\n    // violates the rules of hooks.\n    throw unresolvedThenable\n  }\n\n  useEffect(() => {\n    const originalPushState = window.history.pushState.bind(window.history)\n    const originalReplaceState = window.history.replaceState.bind(\n      window.history\n    )\n\n    // Ensure the canonical URL in the Next.js Router is updated when the URL is changed so that `usePathname` and `useSearchParams` hold the pushed values.\n    const applyUrlFromHistoryPushReplace = (\n      url: string | URL | null | undefined\n    ) => {\n      const href = window.location.href\n      const appHistoryState: AppHistoryState | undefined =\n        window.history.state?.__PRIVATE_NEXTJS_INTERNALS_TREE\n\n      startTransition(() => {\n        dispatchAppRouterAction({\n          type: ACTION_RESTORE,\n          url: new URL(url ?? href, href),\n          historyState: appHistoryState,\n        })\n      })\n    }\n\n    /**\n     * Patch pushState to ensure external changes to the history are reflected in the Next.js Router.\n     * Ensures Next.js internal history state is copied to the new history entry.\n     * Ensures usePathname and useSearchParams hold the newly provided url.\n     */\n    window.history.pushState = function pushState(\n      data: any,\n      _unused: string,\n      url?: string | URL | null\n    ): void {\n      // TODO: Warn when Navigation API is available (navigation.navigate() should be used)\n      // Avoid a loop when Next.js internals trigger pushState/replaceState\n      if (data?.__NA || data?._N) {\n        return originalPushState(data, _unused, url)\n      }\n\n      data = copyNextJsInternalHistoryState(data)\n\n      if (url) {\n        applyUrlFromHistoryPushReplace(url)\n      }\n\n      return originalPushState(data, _unused, url)\n    }\n\n    /**\n     * Patch replaceState to ensure external changes to the history are reflected in the Next.js Router.\n     * Ensures Next.js internal history state is copied to the new history entry.\n     * Ensures usePathname and useSearchParams hold the newly provided url.\n     */\n    window.history.replaceState = function replaceState(\n      data: any,\n      _unused: string,\n      url?: string | URL | null\n    ): void {\n      // TODO: Warn when Navigation API is available (navigation.navigate() should be used)\n      // Avoid a loop when Next.js internals trigger pushState/replaceState\n      if (data?.__NA || data?._N) {\n        return originalReplaceState(data, _unused, url)\n      }\n      data = copyNextJsInternalHistoryState(data)\n\n      if (url) {\n        applyUrlFromHistoryPushReplace(url)\n      }\n      return originalReplaceState(data, _unused, url)\n    }\n\n    /**\n     * Handle popstate event, this is used to handle back/forward in the browser.\n     * By default dispatches ACTION_RESTORE, however if the history entry was not pushed/replaced by app-router it will reload the page.\n     * That case can happen when the old router injected the history entry.\n     */\n    const onPopState = (event: PopStateEvent) => {\n      if (!event.state) {\n        // TODO-APP: this case only happens when pushState/replaceState was called outside of Next.js. It should probably reload the page in this case.\n        return\n      }\n\n      // This case happens when the history entry was pushed by the `pages` router.\n      if (!event.state.__NA) {\n        window.location.reload()\n        return\n      }\n\n      // TODO-APP: Ideally the back button should not use startTransition as it should apply the updates synchronously\n      // Without startTransition works if the cache is there for this path\n      startTransition(() => {\n        dispatchTraverseAction(\n          window.location.href,\n          event.state.__PRIVATE_NEXTJS_INTERNALS_TREE\n        )\n      })\n    }\n\n    // Register popstate event to call onPopstate.\n    window.addEventListener('popstate', onPopState)\n    return () => {\n      window.history.pushState = originalPushState\n      window.history.replaceState = originalReplaceState\n      window.removeEventListener('popstate', onPopState)\n    }\n  }, [])\n\n  const { cache, tree, nextUrl, focusAndScrollRef, previousNextUrl } = state\n\n  const matchingHead = useMemo(() => {\n    return findHeadInCache(cache, tree[1])\n  }, [cache, tree])\n\n  // Add memoized pathParams for useParams.\n  const pathParams = useMemo(() => {\n    return getSelectedParams(tree)\n  }, [tree])\n\n  // Create instrumented promises for navigation hooks (dev-only)\n  // These are specially instrumented promises to show in the Suspense DevTools\n  // Promises are cached outside of render to survive suspense retries.\n  let instrumentedNavigationPromises: NavigationPromises | null = null\n  if (process.env.NODE_ENV !== 'production') {\n    const { createRootNavigationPromises } =\n      require('./navigation-devtools') as typeof import('./navigation-devtools')\n\n    instrumentedNavigationPromises = createRootNavigationPromises(\n      tree,\n      pathname,\n      searchParams,\n      pathParams\n    )\n  }\n\n  const layoutRouterContext = useMemo(() => {\n    return {\n      parentTree: tree,\n      parentCacheNode: cache,\n      parentSegmentPath: null,\n      parentParams: {},\n      parentLoadingData: null,\n      // This is the <Activity> \"name\" that shows up in the Suspense DevTools.\n      // It represents the root of the app.\n      debugNameContext: '/',\n      // Root node always has `url`\n      // Provided in AppTreeContext to ensure it can be overwritten in layout-router\n      url: canonicalUrl,\n      // Root segment is always active\n      isActive: true,\n    }\n  }, [tree, cache, canonicalUrl])\n\n  const globalLayoutRouterContext = useMemo(() => {\n    return {\n      tree,\n      focusAndScrollRef,\n      nextUrl,\n      previousNextUrl,\n    }\n  }, [tree, focusAndScrollRef, nextUrl, previousNextUrl])\n\n  let head\n  if (matchingHead !== null) {\n    // The head is wrapped in an extra component so we can use\n    // `useDeferredValue` to swap between the prefetched and final versions of\n    // the head. (This is what LayoutRouter does for segment data, too.)\n    //\n    // The `key` is used to remount the component whenever the head moves to\n    // a different segment.\n    const [headCacheNode, headKey, headKeyWithoutSearchParams] = matchingHead\n\n    head = (\n      <Head\n        key={\n          // Necessary for PPR: omit search params from the key to match prerendered keys\n          typeof window === 'undefined' ? headKeyWithoutSearchParams : headKey\n        }\n        headCacheNode={headCacheNode}\n      />\n    )\n  } else {\n    head = null\n  }\n\n  let content = (\n    <RedirectBoundary>\n      {head}\n      {/* RootLayoutBoundary enables detection of Suspense boundaries around the root layout.\n          When users wrap their layout in <Suspense>, this creates the component stack pattern\n          \"Suspense -> RootLayoutBoundary\" which dynamic-rendering.ts uses to allow dynamic rendering. */}\n      <RootLayoutBoundary>{cache.rsc}</RootLayoutBoundary>\n      <AppRouterAnnouncer tree={tree} />\n    </RedirectBoundary>\n  )\n\n  if (process.env.NODE_ENV !== 'production') {\n    // In development, we apply few error boundaries and hot-reloader:\n    // - DevRootHTTPAccessFallbackBoundary: avoid using navigation API like notFound() in root layout\n    // - HotReloader:\n    //  - hot-reload the app when the code changes\n    //  - render dev overlay\n    //  - catch runtime errors and display global-error when necessary\n    if (typeof window !== 'undefined') {\n      const { DevRootHTTPAccessFallbackBoundary } =\n        require('./dev-root-http-access-fallback-boundary') as typeof import('./dev-root-http-access-fallback-boundary')\n      content = (\n        <DevRootHTTPAccessFallbackBoundary>\n          {content}\n        </DevRootHTTPAccessFallbackBoundary>\n      )\n    }\n    const HotReloader: typeof import('../dev/hot-reloader/app/hot-reloader-app').default =\n      (\n        require('../dev/hot-reloader/app/hot-reloader-app') as typeof import('../dev/hot-reloader/app/hot-reloader-app')\n      ).default\n\n    content = (\n      <HotReloader\n        globalError={globalError}\n        webSocket={webSocket}\n        staticIndicatorState={staticIndicatorState}\n      >\n        {content}\n      </HotReloader>\n    )\n  } else {\n    content = (\n      <RootErrorBoundary\n        errorComponent={globalError[0]}\n        errorStyles={globalError[1]}\n      >\n        {content}\n      </RootErrorBoundary>\n    )\n  }\n\n  return (\n    <>\n      <HistoryUpdater appRouterState={state} />\n      <RuntimeStyles />\n      <NavigationPromisesContext.Provider\n        value={instrumentedNavigationPromises}\n      >\n        <PathParamsContext.Provider value={pathParams}>\n          <PathnameContext.Provider value={pathname}>\n            <SearchParamsContext.Provider value={searchParams}>\n              <GlobalLayoutRouterContext.Provider\n                value={globalLayoutRouterContext}\n              >\n                {/* TODO: We should be able to remove this context. useRouter\n                    should import from app-router-instance instead. It's only\n                    necessary because useRouter is shared between Pages and\n                    App Router. We should fork that module, then remove this\n                    context provider. */}\n                <AppRouterContext.Provider value={publicAppRouterInstance}>\n                  <LayoutRouterContext.Provider value={layoutRouterContext}>\n                    {content}\n                  </LayoutRouterContext.Provider>\n                </AppRouterContext.Provider>\n              </GlobalLayoutRouterContext.Provider>\n            </SearchParamsContext.Provider>\n          </PathnameContext.Provider>\n        </PathParamsContext.Provider>\n      </NavigationPromisesContext.Provider>\n    </>\n  )\n}\n\nexport default function AppRouter({\n  actionQueue,\n  globalErrorState,\n  webSocket,\n  staticIndicatorState,\n}: {\n  actionQueue: AppRouterActionQueue\n  globalErrorState: GlobalErrorState\n  webSocket?: WebSocket\n  staticIndicatorState?: StaticIndicatorState\n}) {\n  useNavFailureHandler()\n\n  const router = (\n    <Router\n      actionQueue={actionQueue}\n      globalError={globalErrorState}\n      webSocket={webSocket}\n      staticIndicatorState={staticIndicatorState}\n    />\n  )\n\n  // At the very top level, use the default GlobalError component as the final fallback.\n  // When the app router itself fails, which means the framework itself fails, we show the default error.\n  return (\n    <RootErrorBoundary errorComponent={DefaultGlobalError}>\n      {router}\n    </RootErrorBoundary>\n  )\n}\n\nconst runtimeStyles = new Set<string>()\nlet runtimeStyleChanged = new Set<() => void>()\n\nglobalThis._N_E_STYLE_LOAD = function (href: string) {\n  let len = runtimeStyles.size\n  runtimeStyles.add(href)\n  if (runtimeStyles.size !== len) {\n    runtimeStyleChanged.forEach((cb) => cb())\n  }\n  // TODO figure out how to get a promise here\n  // But maybe it's not necessary as react would block rendering until it's loaded\n  return Promise.resolve()\n}\n\nfunction RuntimeStyles() {\n  const [, forceUpdate] = React.useState(0)\n  const renderedStylesSize = runtimeStyles.size\n  useEffect(() => {\n    const changed = () => forceUpdate((c) => c + 1)\n    runtimeStyleChanged.add(changed)\n    if (renderedStylesSize !== runtimeStyles.size) {\n      changed()\n    }\n    return () => {\n      runtimeStyleChanged.delete(changed)\n    }\n  }, [renderedStylesSize, forceUpdate])\n\n  const dplId = getDeploymentIdQueryOrEmptyString()\n  return [...runtimeStyles].map((href, i) => (\n    <link\n      key={i}\n      rel=\"stylesheet\"\n      href={`${href}${dplId}`}\n      // @ts-ignore\n      precedence=\"next\"\n      // TODO figure out crossOrigin and nonce\n      // crossOrigin={TODO}\n      // nonce={TODO}\n    />\n  ))\n}\n"],"names":["AppRouter","globalMutable","HistoryUpdater","appRouterState","useInsertionEffect","process","env","__NEXT_APP_NAV_FAIL_HANDLING","window","next","__pendingUrl","undefined","tree","pushRef","canonicalUrl","renderedSearch","appHistoryState","historyState","preserveCustomHistoryState","history","state","__NA","__PRIVATE_NEXTJS_INTERNALS_TREE","pendingPush","createHrefFromUrl","URL","location","href","pushState","replaceState","useEffect","pingVisibleLinks","nextUrl","copyNextJsInternalHistoryState","data","currentState","Head","headCacheNode","head","prefetchHead","resolvedPrefetchRsc","useDeferredValue","Router","actionQueue","globalError","webSocket","staticIndicatorState","useActionQueue","searchParams","pathname","useMemo","url","hasBasePath","removeBasePath","NODE_ENV","cache","nd","router","publicAppRouterInstance","handlePageShow","event","persisted","pendingMpaPath","dispatchAppRouterAction","type","ACTION_RESTORE","addEventListener","removeEventListener","handleUnhandledRedirect","error","reason","isRedirectError","preventDefault","getURLFromRedirectError","redirectType","getRedirectTypeFromError","push","replace","mpaNavigation","assign","unresolvedThenable","originalPushState","bind","originalReplaceState","applyUrlFromHistoryPushReplace","startTransition","_unused","_N","onPopState","reload","dispatchTraverseAction","focusAndScrollRef","previousNextUrl","matchingHead","findHeadInCache","pathParams","getSelectedParams","instrumentedNavigationPromises","createRootNavigationPromises","require","layoutRouterContext","parentTree","parentCacheNode","parentSegmentPath","parentParams","parentLoadingData","debugNameContext","isActive","globalLayoutRouterContext","headKey","headKeyWithoutSearchParams","content","RedirectBoundary","RootLayoutBoundary","rsc","AppRouterAnnouncer","DevRootHTTPAccessFallbackBoundary","HotReloader","default","RootErrorBoundary","errorComponent","errorStyles","RuntimeStyles","NavigationPromisesContext","Provider","value","PathParamsContext","PathnameContext","SearchParamsContext","GlobalLayoutRouterContext","AppRouterContext","LayoutRouterContext","globalErrorState","useNavFailureHandler","DefaultGlobalError","runtimeStyles","Set","runtimeStyleChanged","globalThis","_N_E_STYLE_LOAD","len","size","add","forEach","cb","Promise","resolve","forceUpdate","React","useState","renderedStylesSize","changed","c","delete","dplId","getDeploymentIdQueryOrEmptyString","map","i","link","rel","precedence"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 13487, "column": 0}, "map": {"version":3,"sources":["file:///D:/AconnectJP/node_modules/next/src/client/components/router-reducer/create-initial-router-state.ts"],"sourcesContent":["import type { FlightDataPath } from '../../../shared/lib/app-router-types'\n\nimport { createHrefFromUrl } from './create-href-from-url'\nimport { extractPathFromFlightRouterState } from './compute-changed-path'\n\nimport type { AppRouterState } from './router-reducer-types'\nimport { getFlightDataPartsFromPath } from '../../flight-data-helpers'\nimport { createInitialCacheNodeForHydration } from './ppr-navigations'\nimport { convertRootFlightRouterStateToRouteTree } from '../segment-cache/cache'\nimport { discoverKnownRoute } from '../segment-cache/optimistic-routes'\nimport type { NormalizedSearch } from '../segment-cache/cache-key'\n\nexport interface InitialRouterStateParameters {\n  navigatedAt: number\n  initialCanonicalUrlParts: string[]\n  initialRenderedSearch: string\n  initialFlightData: FlightDataPath[]\n  initialCouldBeIntercepted: boolean\n  initialPrerendered: boolean\n  location: Location | null\n}\n\nexport function createInitialRouterState({\n  navigatedAt,\n  initialFlightData,\n  initialCanonicalUrlParts,\n  initialRenderedSearch,\n  initialCouldBeIntercepted,\n  initialPrerendered,\n  location,\n}: InitialRouterStateParameters): AppRouterState {\n  // When initialized on the server, the canonical URL is provided as an array of parts.\n  // This is to ensure that when the RSC payload streamed to the client, crawlers don't interpret it\n  // as a URL that should be crawled.\n  const initialCanonicalUrl = initialCanonicalUrlParts.join('/')\n\n  const normalizedFlightData = getFlightDataPartsFromPath(initialFlightData[0])\n  const {\n    tree: initialTree,\n    seedData: initialSeedData,\n    head: initialHead,\n  } = normalizedFlightData\n  // For the SSR render, seed data should always be available (we only send back a `null` response\n  // in the case of a `loading` segment, pre-PPR.)\n\n  const canonicalUrl =\n    // location.href is read as the initial value for canonicalUrl in the browser\n    // This is safe to do as canonicalUrl can't be rendered, it's only used to control the history updates in the useEffect further down in this file.\n    location\n      ? // window.location does not have the same type as URL but has all the fields createHrefFromUrl needs.\n        createHrefFromUrl(location)\n      : initialCanonicalUrl\n\n  // Conver the initial FlightRouterState into the RouteTree type.\n  // NOTE: The metadataVaryPath isn't used for anything currently because the\n  // head is embedded into the CacheNode tree, but eventually we'll lift it out\n  // and store it on the top-level state object.\n  const acc = { metadataVaryPath: null }\n  const initialRouteTree = convertRootFlightRouterStateToRouteTree(\n    initialTree,\n    initialRenderedSearch as NormalizedSearch,\n    acc\n  )\n  const metadataVaryPath = acc.metadataVaryPath\n  const initialTask = createInitialCacheNodeForHydration(\n    navigatedAt,\n    initialRouteTree,\n    initialSeedData,\n    initialHead\n  )\n\n  // Learn the route pattern so we can predict it for future navigations.\n  // Only do this in the browser (location !== null) since route learning\n  // state doesn't persist from SSR to client.\n  if (location !== null && metadataVaryPath !== null) {\n    discoverKnownRoute(\n      Date.now(),\n      location.pathname,\n      null, // No pending entry\n      initialRouteTree,\n      metadataVaryPath,\n      initialCouldBeIntercepted,\n      canonicalUrl,\n      initialPrerendered,\n      false // hasDynamicRewrite\n    )\n  }\n\n  // NOTE: We intentionally don't check if any data needs to be fetched from the\n  // server. We assume the initial hydration payload is sufficient to render\n  // the page.\n  //\n  // The completeness of the initial data is an important property that we rely\n  // on as a last-ditch mechanism for recovering the app; we must always be able\n  // to reload a fresh HTML document to get to a consistent state.\n  //\n  // In the future, there may be cases where the server intentionally sends\n  // partial data and expects the client to fill in the rest, in which case this\n  // logic may change. (There already is a similar case where the server sends\n  // _no_ hydration data in the HTML document at all, and the client fetches it\n  // separately, but that's different because we still end up hydrating with a\n  // complete tree.)\n\n  const initialState = {\n    tree: initialTask.route,\n    cache: initialTask.node,\n    pushRef: {\n      pendingPush: false,\n      mpaNavigation: false,\n      // First render needs to preserve the previous window.history.state\n      // to avoid it being overwritten on navigation back/forward with MPA Navigation.\n      preserveCustomHistoryState: true,\n    },\n    focusAndScrollRef: {\n      apply: false,\n      onlyHashChange: false,\n      hashFragment: null,\n      segmentPaths: [],\n    },\n    canonicalUrl,\n    renderedSearch: initialRenderedSearch,\n    // the || operator is intentional, the pathname can be an empty string\n    nextUrl:\n      (extractPathFromFlightRouterState(initialTree) || location?.pathname) ??\n      null,\n    previousNextUrl: null,\n    debugInfo: null,\n  }\n\n  return initialState\n}\n"],"names":["createInitialRouterState","navigatedAt","initialFlightData","initialCanonicalUrlParts","initialRenderedSearch","initialCouldBeIntercepted","initialPrerendered","location","initialCanonicalUrl","join","normalizedFlightData","getFlightDataPartsFromPath","tree","initialTree","seedData","initialSeedData","head","initialHead","canonicalUrl","createHrefFromUrl","acc","metadataVaryPath","initialRouteTree","convertRootFlightRouterStateToRouteTree","initialTask","createInitialCacheNodeForHydration","discoverKnownRoute","Date","now","pathname","initialState","route","cache","node","pushRef","pendingPush","mpaNavigation","preserveCustomHistoryState","focusAndScrollRef","apply","onlyHashChange","hashFragment","segmentPaths","renderedSearch","nextUrl","extractPathFromFlightRouterState","previousNextUrl","debugInfo"],"mappings":";;;+BAsBgBA,4BAAAA;;;eAAAA;;;mCApBkB;oCACe;mCAGN;gCACQ;uBACK;kCACrB;AAa5B,SAASA,yBAAyB,EACvCC,WAAW,EACXC,iBAAiB,EACjBC,wBAAwB,EACxBC,qBAAqB,EACrBC,yBAAyB,EACzBC,kBAAkB,EAClBC,QAAQ,EACqB;IAC7B,sFAAsF;IACtF,kGAAkG;IAClG,mCAAmC;IACnC,MAAMC,sBAAsBL,yBAAyBM,IAAI,CAAC;IAE1D,MAAMC,uBAAuBC,CAAAA,GAAAA,mBAAAA,0BAA0B,EAACT,iBAAiB,CAAC,EAAE;IAC5E,MAAM,EACJU,MAAMC,WAAW,EACjBC,UAAUC,eAAe,EACzBC,MAAMC,WAAW,EAClB,GAAGP;IACJ,gGAAgG;IAChG,gDAAgD;IAEhD,MAAMQ,eACJ,AACA,6EAD6E,qEACqE;IAClJX,WAEIY,CAAAA,GAAAA,mBAAAA,iBAAiB,EAACZ,YAClBC;IAEN,gEAAgE;IAChE,2EAA2E;IAC3E,6EAA6E;IAC7E,8CAA8C;IAC9C,MAAMY,MAAM;QAAEC,kBAAkB;IAAK;IACrC,MAAMC,mBAAmBC,CAAAA,GAAAA,OAAAA,uCAAuC,EAC9DV,aACAT,uBACAgB;IAEF,MAAMC,mBAAmBD,IAAIC,gBAAgB;IAC7C,MAAMG,cAAcC,CAAAA,GAAAA,gBAAAA,kCAAkC,EACpDxB,aACAqB,kBACAP,iBACAE;IAGF,uEAAuE;IACvE,uEAAuE;IACvE,4CAA4C;IAC5C,IAAIV,aAAa,QAAQc,qBAAqB,MAAM;QAClDK,CAAAA,GAAAA,kBAAAA,kBAAkB,EAChBC,KAAKC,GAAG,IACRrB,SAASsB,QAAQ,EACjB,MACAP,kBACAD,kBACAhB,2BACAa,cACAZ,oBACA,MAAM,oBAAoB;;IAE9B;IAEA,8EAA8E;IAC9E,0EAA0E;IAC1E,YAAY;IACZ,EAAE;IACF,6EAA6E;IAC7E,8EAA8E;IAC9E,gEAAgE;IAChE,EAAE;IACF,yEAAyE;IACzE,8EAA8E;IAC9E,4EAA4E;IAC5E,6EAA6E;IAC7E,4EAA4E;IAC5E,kBAAkB;IAElB,MAAMwB,eAAe;QACnBlB,MAAMY,YAAYO,KAAK;QACvBC,OAAOR,YAAYS,IAAI;QACvBC,SAAS;YACPC,aAAa;YACbC,eAAe;YACf,mEAAmE;YACnE,gFAAgF;YAChFC,4BAA4B;QAC9B;QACAC,mBAAmB;YACjBC,OAAO;YACPC,gBAAgB;YAChBC,cAAc;YACdC,cAAc,EAAE;QAClB;QACAxB;QACAyB,gBAAgBvC;QAChB,sEAAsE;QACtEwC,SACGC,CAAAA,CAAAA,GAAAA,oBAAAA,gCAAgC,EAAChC,gBAAgBN,UAAUsB,QAAO,KACnE;QACFiB,iBAAiB;QACjBC,WAAW;IACb;IAEA,OAAOjB;AACT","ignoreList":[0]}},
    {"offset": {"line": 13580, "column": 0}, "map": {"version":3,"sources":["file:///D:/AconnectJP/node_modules/next/src/client/app-link-gc.ts"],"sourcesContent":["export function linkGc() {\n  // TODO-APP: Remove this logic when Float has GC built-in in development.\n  if (process.env.NODE_ENV !== 'production') {\n    const callback = (mutationList: MutationRecord[]) => {\n      for (const mutation of mutationList) {\n        if (mutation.type === 'childList') {\n          for (const node of mutation.addedNodes) {\n            if (\n              'tagName' in node &&\n              (node as HTMLLinkElement).tagName === 'LINK'\n            ) {\n              const link = node as HTMLLinkElement\n              if (link.dataset.precedence?.startsWith('next')) {\n                const href = link.getAttribute('href')\n                if (href) {\n                  const [resource, version] = href.split('?v=', 2)\n                  if (version) {\n                    const currentOrigin = window.location.origin\n                    const allLinks = [\n                      ...document.querySelectorAll(\n                        'link[href^=\"' + resource + '\"]'\n                      ),\n                      // It's possible that the resource is a full URL or only pathname,\n                      // so we need to remove the alternative href as well.\n                      ...document.querySelectorAll(\n                        'link[href^=\"' +\n                          (resource.startsWith(currentOrigin)\n                            ? resource.slice(currentOrigin.length)\n                            : currentOrigin + resource) +\n                          '\"]'\n                      ),\n                    ] as HTMLLinkElement[]\n\n                    for (const otherLink of allLinks) {\n                      if (otherLink.dataset.precedence?.startsWith('next')) {\n                        const otherHref = otherLink.getAttribute('href')\n                        if (otherHref) {\n                          const [, otherVersion] = otherHref.split('?v=', 2)\n                          if (!otherVersion || +otherVersion < +version) {\n                            // Delay the removal of the stylesheet to avoid FOUC\n                            // caused by `@font-face` rules, as they seem to be\n                            // a couple of ticks delayed between the old and new\n                            // styles being swapped even if the font is cached.\n                            setTimeout(() => {\n                              otherLink.remove()\n                            }, 5)\n                            const preloadLink = document.querySelector(\n                              `link[rel=\"preload\"][as=\"style\"][href=\"${otherHref}\"]`\n                            )\n                            if (preloadLink) {\n                              preloadLink.remove()\n                            }\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n\n    // Create an observer instance linked to the callback function\n    const observer = new MutationObserver(callback)\n    observer.observe(document.head, {\n      childList: true,\n    })\n  }\n}\n"],"names":["linkGc","process","env","NODE_ENV","callback","mutationList","mutation","type","node","addedNodes","tagName","link","dataset","precedence","startsWith","href","getAttribute","resource","version","split","currentOrigin","window","location","origin","allLinks","document","querySelectorAll","slice","length","otherLink","otherHref","otherVersion","setTimeout","remove","preloadLink","querySelector","observer","MutationObserver","observe","head","childList"],"mappings":"AAEMC,QAAQC,GAAG,CAACC,QAAQ,KAAK;;;;;+BAFfH,UAAAA;;;eAAAA;;;AAAT,SAASA;IACd,yEAAyE;IACzE,wCAA2C;QACzC,MAAMI,WAAW,CAACC;YAChB,KAAK,MAAMC,YAAYD,aAAc;gBACnC,IAAIC,SAASC,IAAI,KAAK,aAAa;oBACjC,KAAK,MAAMC,QAAQF,SAASG,UAAU,CAAE;wBACtC,IACE,aAAaD,QACZA,KAAyBE,OAAO,KAAK,QACtC;4BACA,MAAMC,OAAOH;4BACb,IAAIG,KAAKC,OAAO,CAACC,UAAU,EAAEC,WAAW,SAAS;gCAC/C,MAAMC,OAAOJ,KAAKK,YAAY,CAAC;gCAC/B,IAAID,MAAM;oCACR,MAAM,CAACE,UAAUC,QAAQ,GAAGH,KAAKI,KAAK,CAAC,OAAO;oCAC9C,IAAID,SAAS;wCACX,MAAME,gBAAgBC,OAAOC,QAAQ,CAACC,MAAM;wCAC5C,MAAMC,WAAW;+CACZC,SAASC,gBAAgB,CAC1B,iBAAiBT,WAAW;4CAE9B,kEAAkE;4CAClE,qDAAqD;+CAClDQ,SAASC,gBAAgB,CAC1B,iBACGT,CAAAA,SAASH,UAAU,CAACM,iBACjBH,SAASU,KAAK,CAACP,cAAcQ,MAAM,IACnCR,gBAAgBH,QAAO,IAC3B;yCAEL;wCAED,KAAK,MAAMY,aAAaL,SAAU;4CAChC,IAAIK,UAAUjB,OAAO,CAACC,UAAU,EAAEC,WAAW,SAAS;gDACpD,MAAMgB,YAAYD,UAAUb,YAAY,CAAC;gDACzC,IAAIc,WAAW;oDACb,MAAM,GAAGC,aAAa,GAAGD,UAAUX,KAAK,CAAC,OAAO;oDAChD,IAAI,CAACY,gBAAgB,CAACA,eAAe,CAACb,SAAS;wDAC7C,oDAAoD;wDACpD,mDAAmD;wDACnD,oDAAoD;wDACpD,mDAAmD;wDACnDc,WAAW;4DACTH,UAAUI,MAAM;wDAClB,GAAG;wDACH,MAAMC,cAAcT,SAASU,aAAa,CACxC,CAAC,sCAAsC,EAAEL,UAAU,EAAE,CAAC;wDAExD,IAAII,aAAa;4DACfA,YAAYD,MAAM;wDACpB;oDACF;gDACF;4CACF;wCACF;oCACF;gCACF;4BACF;wBACF;oBACF;gBACF;YACF;QACF;QAEA,8DAA8D;QAC9D,MAAMG,WAAW,IAAIC,iBAAiBjC;QACtCgC,SAASE,OAAO,CAACb,SAASc,IAAI,EAAE;YAC9BC,WAAW;QACb;IACF;AACF","ignoreList":[0]}},
    {"offset": {"line": 13659, "column": 0}, "map": {"version":3,"sources":["file:///D:/AconnectJP/node_modules/next/src/client/app-index.tsx"],"sourcesContent":["import './app-globals'\nimport ReactDOMClient from 'react-dom/client'\nimport React from 'react'\n// TODO: Explicitly import from client.browser\n// eslint-disable-next-line import/no-extraneous-dependencies\nimport {\n  createFromReadableStream as createFromReadableStreamBrowser,\n  createFromFetch as createFromFetchBrowser,\n} from 'react-server-dom-webpack/client'\nimport { HeadManagerContext } from '../shared/lib/head-manager-context.shared-runtime'\nimport { onRecoverableError } from './react-client-callbacks/on-recoverable-error'\nimport {\n  onCaughtError,\n  onUncaughtError,\n} from './react-client-callbacks/error-boundary-callbacks'\nimport { callServer } from './app-call-server'\nimport { findSourceMapURL } from './app-find-source-map-url'\nimport {\n  type AppRouterActionQueue,\n  createMutableActionQueue,\n} from './components/app-router-instance'\nimport AppRouter from './components/app-router'\nimport type { InitialRSCPayload } from '../shared/lib/app-router-types'\nimport { createInitialRouterState } from './components/router-reducer/create-initial-router-state'\nimport { MissingSlotContext } from '../shared/lib/app-router-context.shared-runtime'\nimport { setAppBuildId } from './app-build-id'\nimport type { StaticIndicatorState } from './dev/hot-reloader/app/hot-reloader-app'\nimport { createInitialRSCPayloadFromFallbackPrerender } from './flight-data-helpers'\n\n/// <reference types=\"react-dom/experimental\" />\n\nconst createFromReadableStream =\n  createFromReadableStreamBrowser as (typeof import('react-server-dom-webpack/client.browser'))['createFromReadableStream']\nconst createFromFetch =\n  createFromFetchBrowser as (typeof import('react-server-dom-webpack/client.browser'))['createFromFetch']\n\nconst appElement: HTMLElement | Document = document\n\nconst encoder = new TextEncoder()\n\nlet initialServerDataBuffer: (string | Uint8Array)[] | undefined = undefined\nlet initialServerDataWriter: ReadableStreamDefaultController | undefined =\n  undefined\nlet initialServerDataLoaded = false\nlet initialServerDataFlushed = false\n\nlet initialFormStateData: null | any = null\n\ntype FlightSegment =\n  | [isBootStrap: 0]\n  | [isNotBootstrap: 1, responsePartial: string]\n  | [isFormState: 2, formState: any]\n  | [isBinary: 3, responseBase64Partial: string]\n\ntype NextFlight = Omit<Array<FlightSegment>, 'push'> & {\n  push: (seg: FlightSegment) => void\n}\n\ndeclare global {\n  // If you're working in a browser environment\n  interface Window {\n    /**\n     * request ID, dev-only\n     */\n    __next_r?: string\n    __next_f: NextFlight\n  }\n}\n\nfunction nextServerDataCallback(seg: FlightSegment): void {\n  if (seg[0] === 0) {\n    initialServerDataBuffer = []\n  } else if (seg[0] === 1) {\n    if (!initialServerDataBuffer)\n      throw new Error('Unexpected server data: missing bootstrap script.')\n\n    if (initialServerDataWriter) {\n      initialServerDataWriter.enqueue(encoder.encode(seg[1]))\n    } else {\n      initialServerDataBuffer.push(seg[1])\n    }\n  } else if (seg[0] === 2) {\n    initialFormStateData = seg[1]\n  } else if (seg[0] === 3) {\n    if (!initialServerDataBuffer)\n      throw new Error('Unexpected server data: missing bootstrap script.')\n\n    // Decode the base64 string back to binary data.\n    const binaryString = atob(seg[1])\n    const decodedChunk = new Uint8Array(binaryString.length)\n    for (var i = 0; i < binaryString.length; i++) {\n      decodedChunk[i] = binaryString.charCodeAt(i)\n    }\n\n    if (initialServerDataWriter) {\n      initialServerDataWriter.enqueue(decodedChunk)\n    } else {\n      initialServerDataBuffer.push(decodedChunk)\n    }\n  }\n}\n\nfunction isStreamErrorOrUnfinished(ctr: ReadableStreamDefaultController) {\n  // If `desiredSize` is null, it means the stream is closed or errored. If it is lower than 0, the stream is still unfinished.\n  return ctr.desiredSize === null || ctr.desiredSize < 0\n}\n\n// There might be race conditions between `nextServerDataRegisterWriter` and\n// `DOMContentLoaded`. The former will be called when React starts to hydrate\n// the root, the latter will be called when the DOM is fully loaded.\n// For streaming, the former is called first due to partial hydration.\n// For non-streaming, the latter can be called first.\n// Hence, we use two variables `initialServerDataLoaded` and\n// `initialServerDataFlushed` to make sure the writer will be closed and\n// `initialServerDataBuffer` will be cleared in the right time.\nfunction nextServerDataRegisterWriter(ctr: ReadableStreamDefaultController) {\n  if (initialServerDataBuffer) {\n    initialServerDataBuffer.forEach((val) => {\n      ctr.enqueue(typeof val === 'string' ? encoder.encode(val) : val)\n    })\n    if (initialServerDataLoaded && !initialServerDataFlushed) {\n      if (isStreamErrorOrUnfinished(ctr)) {\n        ctr.error(\n          new Error(\n            'The connection to the page was unexpectedly closed, possibly due to the stop button being clicked, loss of Wi-Fi, or an unstable internet connection.'\n          )\n        )\n      } else {\n        ctr.close()\n      }\n      initialServerDataFlushed = true\n      initialServerDataBuffer = undefined\n    }\n  }\n\n  initialServerDataWriter = ctr\n}\n\n// When `DOMContentLoaded`, we can close all pending writers to finish hydration.\nconst DOMContentLoaded = function () {\n  if (initialServerDataWriter && !initialServerDataFlushed) {\n    initialServerDataWriter.close()\n    initialServerDataFlushed = true\n    initialServerDataBuffer = undefined\n  }\n  initialServerDataLoaded = true\n}\n\n// It's possible that the DOM is already loaded.\nif (document.readyState === 'loading') {\n  document.addEventListener('DOMContentLoaded', DOMContentLoaded, false)\n} else {\n  // Delayed in marco task to ensure it's executed later than hydration\n  setTimeout(DOMContentLoaded)\n}\n\nconst nextServerDataLoadingGlobal = (self.__next_f = self.__next_f || [])\n\n// Consume all buffered chunks and clear the global data array right after to release memory.\n// Otherwise it will be retained indefinitely.\nnextServerDataLoadingGlobal.forEach(nextServerDataCallback)\nnextServerDataLoadingGlobal.length = 0\n\n// Patch its push method so subsequent chunks are handled (but not actually pushed to the array).\nnextServerDataLoadingGlobal.push = nextServerDataCallback\n\nconst readable = new ReadableStream({\n  start(controller) {\n    nextServerDataRegisterWriter(controller)\n  },\n})\nif (process.env.NODE_ENV !== 'production') {\n  // @ts-expect-error\n  readable.name = 'hydration'\n}\n\nlet debugChannel:\n  | { readable?: ReadableStream; writable?: WritableStream }\n  | undefined\n\nif (\n  process.env.NODE_ENV !== 'production' &&\n  process.env.__NEXT_REACT_DEBUG_CHANNEL &&\n  typeof window !== 'undefined'\n) {\n  const { createDebugChannel } =\n    require('./dev/debug-channel') as typeof import('./dev/debug-channel')\n\n  debugChannel = createDebugChannel(undefined)\n}\n\nconst clientResumeFetch: Promise<Response> | undefined =\n  // @ts-expect-error\n  window.__NEXT_CLIENT_RESUME\n\nlet initialServerResponse: Promise<InitialRSCPayload>\nif (clientResumeFetch) {\n  initialServerResponse = Promise.resolve(\n    createFromFetch<InitialRSCPayload>(clientResumeFetch, {\n      callServer,\n      findSourceMapURL,\n      debugChannel,\n    })\n  ).then(async (fallbackInitialRSCPayload) =>\n    createInitialRSCPayloadFromFallbackPrerender(\n      await clientResumeFetch,\n      fallbackInitialRSCPayload\n    )\n  )\n} else {\n  initialServerResponse = createFromReadableStream<InitialRSCPayload>(\n    readable,\n    {\n      callServer,\n      findSourceMapURL,\n      debugChannel,\n      startTime: 0,\n    }\n  )\n}\n\nfunction ServerRoot({\n  initialRSCPayload,\n  actionQueue,\n  webSocket,\n  staticIndicatorState,\n}: {\n  initialRSCPayload: InitialRSCPayload\n  actionQueue: AppRouterActionQueue\n  webSocket: WebSocket | undefined\n  staticIndicatorState: StaticIndicatorState | undefined\n}): React.ReactNode {\n  const router = (\n    <AppRouter\n      actionQueue={actionQueue}\n      globalErrorState={initialRSCPayload.G}\n      webSocket={webSocket}\n      staticIndicatorState={staticIndicatorState}\n    />\n  )\n\n  if (process.env.NODE_ENV === 'development' && initialRSCPayload.m) {\n    // We provide missing slot information in a context provider only during development\n    // as we log some additional information about the missing slots in the console.\n    return (\n      <MissingSlotContext value={initialRSCPayload.m}>\n        {router}\n      </MissingSlotContext>\n    )\n  }\n\n  return router\n}\n\nconst StrictModeIfEnabled = process.env.__NEXT_STRICT_MODE_APP\n  ? React.StrictMode\n  : React.Fragment\n\nfunction Root({ children }: React.PropsWithChildren<{}>) {\n  if (process.env.__NEXT_TEST_MODE) {\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    React.useEffect(() => {\n      window.__NEXT_HYDRATED = true\n      window.__NEXT_HYDRATED_AT = performance.now()\n      window.__NEXT_HYDRATED_CB?.()\n    }, [])\n  }\n\n  return children\n}\n\nconst enableTransitionIndicator = process.env.__NEXT_TRANSITION_INDICATOR\n\nfunction noDefaultTransitionIndicator() {\n  return () => {}\n}\n\nconst reactRootOptions: ReactDOMClient.RootOptions = {\n  onDefaultTransitionIndicator: enableTransitionIndicator\n    ? // TODO: Compose default with user-configureable (e.g. nprogress)\n      undefined\n    : noDefaultTransitionIndicator,\n  onRecoverableError,\n  onCaughtError,\n  onUncaughtError,\n}\n\nexport type ClientInstrumentationHooks = {\n  onRouterTransitionStart?: (\n    url: string,\n    navigationType: 'push' | 'replace' | 'traverse'\n  ) => void\n}\n\nexport async function hydrate(\n  instrumentationHooks: ClientInstrumentationHooks | null,\n  assetPrefix: string\n) {\n  let staticIndicatorState: StaticIndicatorState | undefined\n  let webSocket: WebSocket | undefined\n\n  if (process.env.NODE_ENV !== 'production') {\n    const { createWebSocket } =\n      require('./dev/hot-reloader/app/web-socket') as typeof import('./dev/hot-reloader/app/web-socket')\n\n    staticIndicatorState = { pathname: null, appIsrManifest: null }\n    webSocket = createWebSocket(assetPrefix, staticIndicatorState)\n  }\n  const initialRSCPayload = await initialServerResponse\n  // setAppBuildId should be called only once, during JS initialization\n  // and before any components have hydrated.\n  setAppBuildId(initialRSCPayload.b)\n\n  const initialTimestamp = Date.now()\n  const actionQueue: AppRouterActionQueue = createMutableActionQueue(\n    createInitialRouterState({\n      navigatedAt: initialTimestamp,\n      initialFlightData: initialRSCPayload.f,\n      initialCanonicalUrlParts: initialRSCPayload.c,\n      initialRenderedSearch: initialRSCPayload.q,\n      initialCouldBeIntercepted: initialRSCPayload.i,\n      initialPrerendered: initialRSCPayload.S,\n      location: window.location,\n    }),\n    instrumentationHooks\n  )\n\n  const reactEl = (\n    <StrictModeIfEnabled>\n      <HeadManagerContext.Provider value={{ appDir: true }}>\n        <Root>\n          <ServerRoot\n            initialRSCPayload={initialRSCPayload}\n            actionQueue={actionQueue}\n            webSocket={webSocket}\n            staticIndicatorState={staticIndicatorState}\n          />\n        </Root>\n      </HeadManagerContext.Provider>\n    </StrictModeIfEnabled>\n  )\n\n  if (document.documentElement.id === '__next_error__') {\n    let element = reactEl\n    // Server rendering failed, fall back to client-side rendering\n    if (process.env.NODE_ENV !== 'production') {\n      const { RootLevelDevOverlayElement } =\n        require('../next-devtools/userspace/app/client-entry') as typeof import('../next-devtools/userspace/app/client-entry')\n\n      // Note this won't cause hydration mismatch because we are doing CSR w/o hydration\n      element = (\n        <RootLevelDevOverlayElement>{element}</RootLevelDevOverlayElement>\n      )\n    }\n\n    ReactDOMClient.createRoot(appElement, reactRootOptions).render(element)\n  } else {\n    React.startTransition(() => {\n      ReactDOMClient.hydrateRoot(appElement, reactEl, {\n        ...reactRootOptions,\n        formState: initialFormStateData,\n      })\n    })\n  }\n\n  // TODO-APP: Remove this logic when Float has GC built-in in development.\n  if (process.env.NODE_ENV !== 'production') {\n    const { linkGc } =\n      require('./app-link-gc') as typeof import('./app-link-gc')\n    linkGc()\n  }\n}\n"],"names":["hydrate","createFromReadableStream","createFromReadableStreamBrowser","createFromFetch","createFromFetchBrowser","appElement","document","encoder","TextEncoder","initialServerDataBuffer","undefined","initialServerDataWriter","initialServerDataLoaded","initialServerDataFlushed","initialFormStateData","nextServerDataCallback","seg","Error","enqueue","encode","push","binaryString","atob","decodedChunk","Uint8Array","length","i","charCodeAt","isStreamErrorOrUnfinished","ctr","desiredSize","nextServerDataRegisterWriter","forEach","val","error","close","DOMContentLoaded","readyState","addEventListener","setTimeout","nextServerDataLoadingGlobal","self","__next_f","readable","ReadableStream","start","controller","process","env","NODE_ENV","name","debugChannel","__NEXT_REACT_DEBUG_CHANNEL","window","createDebugChannel","require","clientResumeFetch","__NEXT_CLIENT_RESUME","initialServerResponse","Promise","resolve","callServer","findSourceMapURL","then","fallbackInitialRSCPayload","createInitialRSCPayloadFromFallbackPrerender","startTime","ServerRoot","initialRSCPayload","actionQueue","webSocket","staticIndicatorState","router","AppRouter","globalErrorState","G","m","MissingSlotContext","value","StrictModeIfEnabled","__NEXT_STRICT_MODE_APP","React","StrictMode","Fragment","Root","children","__NEXT_TEST_MODE","useEffect","__NEXT_HYDRATED","__NEXT_HYDRATED_AT","performance","now","__NEXT_HYDRATED_CB","enableTransitionIndicator","__NEXT_TRANSITION_INDICATOR","noDefaultTransitionIndicator","reactRootOptions","onDefaultTransitionIndicator","onRecoverableError","onCaughtError","onUncaughtError","instrumentationHooks","assetPrefix","createWebSocket","pathname","appIsrManifest","setAppBuildId","b","initialTimestamp","Date","createMutableActionQueue","createInitialRouterState","navigatedAt","initialFlightData","f","initialCanonicalUrlParts","c","initialRenderedSearch","q","initialCouldBeIntercepted","initialPrerendered","S","location","reactEl","HeadManagerContext","Provider","appDir","documentElement","id","element","RootLevelDevOverlayElement","ReactDOMClient","createRoot","render","startTransition","hydrateRoot","formState","linkGc"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 13925, "column": 0}, "map": {"version":3,"sources":["file:///D:/AconnectJP/node_modules/next/src/client/app-next-turbopack.ts"],"sourcesContent":["import './register-deployment-id-global'\nimport { appBootstrap } from './app-bootstrap'\nimport { isRecoverableError } from './react-client-callbacks/on-recoverable-error'\n\nwindow.next.turbopack = true\n;(self as any).__webpack_hash__ = ''\n\n// eslint-disable-next-line @next/internal/typechecked-require\nconst instrumentationHooks = require('../lib/require-instrumentation-client')\n\nappBootstrap((assetPrefix) => {\n  const { hydrate } = require('./app-index') as typeof import('./app-index')\n  try {\n    hydrate(instrumentationHooks, assetPrefix)\n  } finally {\n    if (process.env.NODE_ENV !== 'production') {\n      const enableCacheIndicator = process.env.__NEXT_CACHE_COMPONENTS\n      const { getOwnerStack } =\n        require('../next-devtools/userspace/app/errors/stitched-error') as typeof import('../next-devtools/userspace/app/errors/stitched-error')\n      const { renderAppDevOverlay } =\n        require('next/dist/compiled/next-devtools') as typeof import('next/dist/compiled/next-devtools')\n      renderAppDevOverlay(\n        getOwnerStack,\n        isRecoverableError,\n        enableCacheIndicator\n      )\n    }\n  }\n})\n"],"names":["window","next","turbopack","self","__webpack_hash__","instrumentationHooks","require","appBootstrap","assetPrefix","hydrate","process","env","NODE_ENV","enableCacheIndicator","__NEXT_CACHE_COMPONENTS","getOwnerStack","renderAppDevOverlay","isRecoverableError"],"mappings":"AAeQU,QAAQC,GAAG,CAACC,QAAQ,KAAK;;;;;;8BAdJ;oCACM;AAEnCZ,OAAOC,IAAI,CAACC,SAAS,GAAG;AACtBC,KAAaC,gBAAgB,GAAG;AAElC,8DAA8D;AAC9D,MAAMC,uBAAuBC,QAAQ;AAErCC,CAAAA,GAAAA,cAAAA,YAAY,EAAC,CAACC;IACZ,MAAM,EAAEC,OAAO,EAAE,GAAGH,QAAQ;IAC5B,IAAI;QACFG,QAAQJ,sBAAsBG;IAChC,SAAU;QACR,wCAA2C;YACzC,MAAMK,uBAAuBH,QAAQC,GAAG,CAACG,uBAAuB;YAChE,MAAM,EAAEC,aAAa,EAAE,GACrBT,QAAQ;YACV,MAAM,EAAEU,mBAAmB,EAAE,GAC3BV,QAAQ;YACVU,oBACED,eACAE,oBAAAA,kBAAkB,EAClBJ;QAEJ;IACF;AACF","ignoreList":[0]}}]
}