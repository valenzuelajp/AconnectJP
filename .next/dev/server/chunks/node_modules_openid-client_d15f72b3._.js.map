{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 3, "column": 0}, "map": {"version":3,"sources":["file:///D:/AconnectJP/node_modules/openid-client/lib/errors.js"],"sourcesContent":["const { format } = require('util');\n\nclass OPError extends Error {\n  constructor({ error_description, error, error_uri, session_state, state, scope }, response) {\n    super(!error_description ? error : `${error} (${error_description})`);\n\n    Object.assign(\n      this,\n      { error },\n      error_description && { error_description },\n      error_uri && { error_uri },\n      state && { state },\n      scope && { scope },\n      session_state && { session_state },\n    );\n\n    if (response) {\n      Object.defineProperty(this, 'response', {\n        value: response,\n      });\n    }\n\n    this.name = this.constructor.name;\n    Error.captureStackTrace(this, this.constructor);\n  }\n}\n\nclass RPError extends Error {\n  constructor(...args) {\n    if (typeof args[0] === 'string') {\n      super(format(...args));\n    } else {\n      const { message, printf, response, ...rest } = args[0];\n      if (printf) {\n        super(format(...printf));\n      } else {\n        super(message);\n      }\n      Object.assign(this, rest);\n      if (response) {\n        Object.defineProperty(this, 'response', {\n          value: response,\n        });\n      }\n    }\n\n    this.name = this.constructor.name;\n    Error.captureStackTrace(this, this.constructor);\n  }\n}\n\nmodule.exports = {\n  OPError,\n  RPError,\n};\n"],"names":["format","OPError","Error","error_description","error","error_uri","session_state","state","scope","response","Object","assign","defineProperty","value","name","captureStackTrace","RPError","args","message","printf","rest","module","exports"],"mappings":"AAAA,MAAM,EAAEA,MAAM,EAAE;AAEhB,MAAMC,gBAAgBC;IACpBD,YAAY,EAAEE,iBAAiB,EAAEC,KAAK,EAAEC,SAAS,EAAEC,aAAa,EAAEC,KAAK,EAAEC,KAAK,EAAE,EAAEC,QAAQ,CAAE;QAC1F,KAAK,CAAC,CAACN,oBAAoBC,QAAQ,GAAGA,MAAM,EAAE,EAAED,kBAAkB,CAAC,CAAC;QAEpEO,OAAOC,MAAM,CACX,IAAI,EACJ;YAAEP;QAAM,GACRD,qBAAqB;YAAEA;QAAkB,GACzCE,aAAa;YAAEA;QAAU,GACzBE,SAAS;YAAEA;QAAM,GACjBC,SAAS;YAAEA;QAAM,GACjBF,iBAAiB;YAAEA;QAAc;QAGnC,IAAIG,UAAU;YACZC,OAAOE,cAAc,CAAC,IAAI,EAAE,YAAY;gBACtCC,OAAOJ;YACT;QACF;QAEA,IAAI,CAACK,IAAI,GAAG,IAAI,CAACb,WAAW,CAACa,IAAI;QACjCZ,MAAMa,iBAAiB,CAAC,IAAI,EAAE,IAAI,CAACd,WAAW;IAChD;AACF;AAEA,MAAMe,gBAAgBd;IACpBc,YAAY,GAAGC,IAAI,CAAE;QACnB,IAAI,OAAOA,IAAI,CAAC,EAAE,KAAK,UAAU;YAC/B,KAAK,CAACjB,UAAUiB;QAClB,OAAO;YACL,MAAM,EAAEC,OAAO,EAAEC,MAAM,EAAEV,QAAQ,EAAE,GAAGW,MAAM,GAAGH,IAAI,CAAC,EAAE;YACtD,IAAIE,QAAQ;gBACV,KAAK,CAACnB,UAAUmB;YAClB,OAAO;gBACL,KAAK,CAACD;YACR;YACAR,OAAOC,MAAM,CAAC,IAAI,EAAES;YACpB,IAAIX,UAAU;gBACZC,OAAOE,cAAc,CAAC,IAAI,EAAE,YAAY;oBACtCC,OAAOJ;gBACT;YACF;QACF;QAEA,IAAI,CAACK,IAAI,GAAG,IAAI,CAACE,WAAW,CAACF,IAAI;QACjCZ,MAAMa,iBAAiB,CAAC,IAAI,EAAE,IAAI,CAACC,WAAW;IAChD;AACF;AAEAK,OAAOC,OAAO,GAAG;IACfrB;IACAe;AACF","ignoreList":[0]}},
    {"offset": {"line": 58, "column": 0}, "map": {"version":3,"sources":["file:///D:/AconnectJP/node_modules/openid-client/lib/helpers/is_key_object.js"],"sourcesContent":["const util = require('util');\nconst crypto = require('crypto');\n\nmodule.exports = util.types.isKeyObject || ((obj) => obj && obj instanceof crypto.KeyObject);\n"],"names":["util","crypto","module","exports","types","isKeyObject","obj","KeyObject"],"mappings":"AAAA,MAAMA;AACN,MAAMC;AAENC,OAAOC,OAAO,GAAGH,KAAKI,KAAK,CAACC,WAAW,IAAI,CAAC,CAACC,MAAQA,OAAOA,eAAeL,OAAOM,SAAS","ignoreList":[0]}},
    {"offset": {"line": 64, "column": 0}, "map": {"version":3,"sources":["file:///D:/AconnectJP/node_modules/openid-client/lib/helpers/base64url.js"],"sourcesContent":["let encode;\nif (Buffer.isEncoding('base64url')) {\n  encode = (input, encoding = 'utf8') => Buffer.from(input, encoding).toString('base64url');\n} else {\n  const fromBase64 = (base64) => base64.replace(/=/g, '').replace(/\\+/g, '-').replace(/\\//g, '_');\n  encode = (input, encoding = 'utf8') =>\n    fromBase64(Buffer.from(input, encoding).toString('base64'));\n}\n\nconst decode = (input) => Buffer.from(input, 'base64');\n\nmodule.exports.decode = decode;\nmodule.exports.encode = encode;\n"],"names":["encode","Buffer","isEncoding","input","encoding","from","toString","fromBase64","base64","replace","decode","module","exports"],"mappings":"AAAA,IAAIA;AACJ,IAAIC,OAAOC,UAAU,CAAC,cAAc;IAClCF,SAAS,CAACG,OAAOC,WAAW,MAAM,GAAKH,OAAOI,IAAI,CAACF,OAAOC,UAAUE,QAAQ,CAAC;AAC/E,OAAO;IACL,MAAMC,aAAa,CAACC,SAAWA,OAAOC,OAAO,CAAC,MAAM,IAAIA,OAAO,CAAC,OAAO,KAAKA,OAAO,CAAC,OAAO;IAC3FT,SAAS,CAACG,OAAOC,WAAW,MAAM,GAChCG,WAAWN,OAAOI,IAAI,CAACF,OAAOC,UAAUE,QAAQ,CAAC;AACrD;AAEA,MAAMI,SAAS,CAACP,QAAUF,OAAOI,IAAI,CAACF,OAAO;AAE7CQ,OAAOC,OAAO,CAACF,MAAM,GAAGA;AACxBC,OAAOC,OAAO,CAACZ,MAAM,GAAGA","ignoreList":[0]}},
    {"offset": {"line": 77, "column": 0}, "map": {"version":3,"sources":["file:///D:/AconnectJP/node_modules/openid-client/lib/helpers/decode_jwt.js"],"sourcesContent":["const base64url = require('./base64url');\n\nmodule.exports = (token) => {\n  if (typeof token !== 'string' || !token) {\n    throw new TypeError('JWT must be a string');\n  }\n\n  const { 0: header, 1: payload, 2: signature, length } = token.split('.');\n\n  if (length === 5) {\n    throw new TypeError('encrypted JWTs cannot be decoded');\n  }\n\n  if (length !== 3) {\n    throw new Error('JWTs must have three components');\n  }\n\n  try {\n    return {\n      header: JSON.parse(base64url.decode(header)),\n      payload: JSON.parse(base64url.decode(payload)),\n      signature,\n    };\n  } catch (err) {\n    throw new Error('JWT is malformed');\n  }\n};\n"],"names":["base64url","module","exports","token","TypeError","header","payload","signature","length","split","Error","JSON","parse","decode","err"],"mappings":"AAAA,MAAMA;AAENC,OAAOC,OAAO,GAAG,CAACC;IAChB,IAAI,OAAOA,UAAU,YAAY,CAACA,OAAO;QACvC,MAAM,IAAIC,UAAU;IACtB;IAEA,MAAM,EAAE,GAAGC,MAAM,EAAE,GAAGC,OAAO,EAAE,GAAGC,SAAS,EAAEC,MAAM,EAAE,GAAGL,MAAMM,KAAK,CAAC;IAEpE,IAAID,WAAW,GAAG;QAChB,MAAM,IAAIJ,UAAU;IACtB;IAEA,IAAII,WAAW,GAAG;QAChB,MAAM,IAAIE,MAAM;IAClB;IAEA,IAAI;QACF,OAAO;YACLL,QAAQM,KAAKC,KAAK,CAACZ,UAAUa,MAAM,CAACR;YACpCC,SAASK,KAAKC,KAAK,CAACZ,UAAUa,MAAM,CAACP;YACrCC;QACF;IACF,EAAE,OAAOO,KAAK;QACZ,MAAM,IAAIJ,MAAM;IAClB;AACF","ignoreList":[0]}},
    {"offset": {"line": 102, "column": 0}, "map": {"version":3,"sources":["file:///D:/AconnectJP/node_modules/openid-client/lib/helpers/is_plain_object.js"],"sourcesContent":["module.exports = (a) => !!a && a.constructor === Object;\n"],"names":["module","exports","a","Object"],"mappings":"AAAAA,OAAOC,OAAO,GAAG,CAACC,IAAM,CAAC,CAACA,KAAKA,EAAE,WAAW,KAAKC","ignoreList":[0]}},
    {"offset": {"line": 106, "column": 0}, "map": {"version":3,"sources":["file:///D:/AconnectJP/node_modules/openid-client/lib/helpers/defaults.js"],"sourcesContent":["const isPlainObject = require('./is_plain_object');\n\nfunction defaults(deep, target, ...sources) {\n  for (const source of sources) {\n    if (!isPlainObject(source)) {\n      continue;\n    }\n    for (const [key, value] of Object.entries(source)) {\n      /* istanbul ignore if */\n      if (key === '__proto__' || key === 'constructor') {\n        continue;\n      }\n      if (typeof target[key] === 'undefined' && typeof value !== 'undefined') {\n        target[key] = value;\n      }\n\n      if (deep && isPlainObject(target[key]) && isPlainObject(value)) {\n        defaults(true, target[key], value);\n      }\n    }\n  }\n\n  return target;\n}\n\nmodule.exports = defaults.bind(undefined, false);\nmodule.exports.deep = defaults.bind(undefined, true);\n"],"names":["isPlainObject","defaults","deep","target","sources","source","key","value","Object","entries","module","exports","bind","undefined"],"mappings":"AAAA,MAAMA;AAEN,SAASC,SAASC,IAAI,EAAEC,MAAM,EAAE,GAAGC,OAAO;IACxC,KAAK,MAAMC,UAAUD,QAAS;QAC5B,IAAI,CAACJ,cAAcK,SAAS;YAC1B;QACF;QACA,KAAK,MAAM,CAACC,KAAKC,MAAM,IAAIC,OAAOC,OAAO,CAACJ,QAAS;YACjD,sBAAsB,GACtB,IAAIC,QAAQ,eAAeA,QAAQ,eAAe;gBAChD;YACF;YACA,IAAI,OAAOH,MAAM,CAACG,IAAI,KAAK,eAAe,OAAOC,UAAU,aAAa;gBACtEJ,MAAM,CAACG,IAAI,GAAGC;YAChB;YAEA,IAAIL,QAAQF,cAAcG,MAAM,CAACG,IAAI,KAAKN,cAAcO,QAAQ;gBAC9DN,SAAS,MAAME,MAAM,CAACG,IAAI,EAAEC;YAC9B;QACF;IACF;IAEA,OAAOJ;AACT;AAEAO,OAAOC,OAAO,GAAGV,SAASW,IAAI,CAACC,WAAW;AAC1CH,OAAOC,OAAO,CAACT,IAAI,GAAGD,SAASW,IAAI,CAACC,WAAW","ignoreList":[0]}},
    {"offset": {"line": 131, "column": 0}, "map": {"version":3,"sources":["file:///D:/AconnectJP/node_modules/openid-client/lib/helpers/www_authenticate_parser.js"],"sourcesContent":["const REGEXP = /(\\w+)=(\"[^\"]*\")/g;\n\nmodule.exports = (wwwAuthenticate) => {\n  const params = {};\n  try {\n    while (REGEXP.exec(wwwAuthenticate) !== null) {\n      if (RegExp.$1 && RegExp.$2) {\n        params[RegExp.$1] = RegExp.$2.slice(1, -1);\n      }\n    }\n  } catch (err) {}\n\n  return params;\n};\n"],"names":["REGEXP","module","exports","wwwAuthenticate","params","exec","RegExp","$1","$2","slice","err"],"mappings":"AAAA,MAAMA,SAAS;AAEfC,OAAOC,OAAO,GAAG,CAACC;IAChB,MAAMC,SAAS,CAAC;IAChB,IAAI;QACF,MAAOJ,OAAOK,IAAI,CAACF,qBAAqB,KAAM;YAC5C,IAAIG,OAAOC,EAAE,IAAID,OAAOE,EAAE,EAAE;gBAC1BJ,MAAM,CAACE,OAAOC,EAAE,CAAC,GAAGD,OAAOE,EAAE,CAACC,KAAK,CAAC,GAAG,CAAC;YAC1C;QACF;IACF,EAAE,OAAOC,KAAK,CAAC;IAEf,OAAON;AACT","ignoreList":[0]}},
    {"offset": {"line": 146, "column": 0}, "map": {"version":3,"sources":["file:///D:/AconnectJP/node_modules/openid-client/lib/helpers/assert.js"],"sourcesContent":["function assertSigningAlgValuesSupport(endpoint, issuer, properties) {\n  if (!issuer[`${endpoint}_endpoint`]) return;\n\n  const eam = `${endpoint}_endpoint_auth_method`;\n  const easa = `${endpoint}_endpoint_auth_signing_alg`;\n  const easavs = `${endpoint}_endpoint_auth_signing_alg_values_supported`;\n\n  if (properties[eam] && properties[eam].endsWith('_jwt') && !properties[easa] && !issuer[easavs]) {\n    throw new TypeError(\n      `${easavs} must be configured on the issuer if ${easa} is not defined on a client`,\n    );\n  }\n}\n\nfunction assertIssuerConfiguration(issuer, endpoint) {\n  if (!issuer[endpoint]) {\n    throw new TypeError(`${endpoint} must be configured on the issuer`);\n  }\n}\n\nmodule.exports = {\n  assertSigningAlgValuesSupport,\n  assertIssuerConfiguration,\n};\n"],"names":["assertSigningAlgValuesSupport","endpoint","issuer","properties","eam","easa","easavs","endsWith","TypeError","assertIssuerConfiguration","module","exports"],"mappings":"AAAA,SAASA,8BAA8BC,QAAQ,EAAEC,MAAM,EAAEC,UAAU;IACjE,IAAI,CAACD,MAAM,CAAC,GAAGD,SAAS,SAAS,CAAC,CAAC,EAAE;IAErC,MAAMG,MAAM,GAAGH,SAAS,qBAAqB,CAAC;IAC9C,MAAMI,OAAO,GAAGJ,SAAS,0BAA0B,CAAC;IACpD,MAAMK,SAAS,GAAGL,SAAS,2CAA2C,CAAC;IAEvE,IAAIE,UAAU,CAACC,IAAI,IAAID,UAAU,CAACC,IAAI,CAACG,QAAQ,CAAC,WAAW,CAACJ,UAAU,CAACE,KAAK,IAAI,CAACH,MAAM,CAACI,OAAO,EAAE;QAC/F,MAAM,IAAIE,UACR,GAAGF,OAAO,qCAAqC,EAAED,KAAK,2BAA2B,CAAC;IAEtF;AACF;AAEA,SAASI,0BAA0BP,MAAM,EAAED,QAAQ;IACjD,IAAI,CAACC,MAAM,CAACD,SAAS,EAAE;QACrB,MAAM,IAAIO,UAAU,GAAGP,SAAS,iCAAiC,CAAC;IACpE;AACF;AAEAS,OAAOC,OAAO,GAAG;IACfX;IACAS;AACF","ignoreList":[0]}},
    {"offset": {"line": 167, "column": 0}, "map": {"version":3,"sources":["file:///D:/AconnectJP/node_modules/openid-client/lib/helpers/pick.js"],"sourcesContent":["module.exports = function pick(object, ...paths) {\n  const obj = {};\n  for (const path of paths) {\n    if (object[path] !== undefined) {\n      obj[path] = object[path];\n    }\n  }\n  return obj;\n};\n"],"names":["module","exports","pick","object","paths","obj","path","undefined"],"mappings":"AAAAA,OAAOC,OAAO,GAAG,SAASC,KAAKC,MAAM,EAAE,GAAGC,KAAK;IAC7C,MAAMC,MAAM,CAAC;IACb,KAAK,MAAMC,QAAQF,MAAO;QACxB,IAAID,MAAM,CAACG,KAAK,KAAKC,WAAW;YAC9BF,GAAG,CAACC,KAAK,GAAGH,MAAM,CAACG,KAAK;QAC1B;IACF;IACA,OAAOD;AACT","ignoreList":[0]}},
    {"offset": {"line": 179, "column": 0}, "map": {"version":3,"sources":["file:///D:/AconnectJP/node_modules/openid-client/lib/helpers/process_response.js"],"sourcesContent":["const { STATUS_CODES } = require('http');\nconst { format } = require('util');\n\nconst { OPError } = require('../errors');\nconst parseWwwAuthenticate = require('./www_authenticate_parser');\n\nconst throwAuthenticateErrors = (response) => {\n  const params = parseWwwAuthenticate(response.headers['www-authenticate']);\n\n  if (params.error) {\n    throw new OPError(params, response);\n  }\n};\n\nconst isStandardBodyError = (response) => {\n  let result = false;\n  try {\n    let jsonbody;\n    if (typeof response.body !== 'object' || Buffer.isBuffer(response.body)) {\n      jsonbody = JSON.parse(response.body);\n    } else {\n      jsonbody = response.body;\n    }\n    result = typeof jsonbody.error === 'string' && jsonbody.error.length;\n    if (result) Object.defineProperty(response, 'body', { value: jsonbody, configurable: true });\n  } catch (err) {}\n\n  return result;\n};\n\nfunction processResponse(response, { statusCode = 200, body = true, bearer = false } = {}) {\n  if (response.statusCode !== statusCode) {\n    if (bearer) {\n      throwAuthenticateErrors(response);\n    }\n\n    if (isStandardBodyError(response)) {\n      throw new OPError(response.body, response);\n    }\n\n    throw new OPError(\n      {\n        error: format(\n          'expected %i %s, got: %i %s',\n          statusCode,\n          STATUS_CODES[statusCode],\n          response.statusCode,\n          STATUS_CODES[response.statusCode],\n        ),\n      },\n      response,\n    );\n  }\n\n  if (body && !response.body) {\n    throw new OPError(\n      {\n        error: format(\n          'expected %i %s with body but no body was returned',\n          statusCode,\n          STATUS_CODES[statusCode],\n        ),\n      },\n      response,\n    );\n  }\n\n  return response.body;\n}\n\nmodule.exports = processResponse;\n"],"names":["STATUS_CODES","format","OPError","parseWwwAuthenticate","throwAuthenticateErrors","response","params","headers","error","isStandardBodyError","result","jsonbody","body","Buffer","isBuffer","JSON","parse","length","Object","defineProperty","value","configurable","err","processResponse","statusCode","bearer","module","exports"],"mappings":"AAAA,MAAM,EAAEA,YAAY,EAAE;AACtB,MAAM,EAAEC,MAAM,EAAE;AAEhB,MAAM,EAAEC,OAAO,EAAE;AACjB,MAAMC;AAEN,MAAMC,0BAA0B,CAACC;IAC/B,MAAMC,SAASH,qBAAqBE,SAASE,OAAO,CAAC,mBAAmB;IAExE,IAAID,OAAOE,KAAK,EAAE;QAChB,MAAM,IAAIN,QAAQI,QAAQD;IAC5B;AACF;AAEA,MAAMI,sBAAsB,CAACJ;IAC3B,IAAIK,SAAS;IACb,IAAI;QACF,IAAIC;QACJ,IAAI,OAAON,SAASO,IAAI,KAAK,YAAYC,OAAOC,QAAQ,CAACT,SAASO,IAAI,GAAG;YACvED,WAAWI,KAAKC,KAAK,CAACX,SAASO,IAAI;QACrC,OAAO;YACLD,WAAWN,SAASO,IAAI;QAC1B;QACAF,SAAS,OAAOC,SAASH,KAAK,KAAK,YAAYG,SAASH,KAAK,CAACS,MAAM;QACpE,IAAIP,QAAQQ,OAAOC,cAAc,CAACd,UAAU,QAAQ;YAAEe,OAAOT;YAAUU,cAAc;QAAK;IAC5F,EAAE,OAAOC,KAAK,CAAC;IAEf,OAAOZ;AACT;AAEA,SAASa,gBAAgBlB,QAAQ,EAAE,EAAEmB,aAAa,GAAG,EAAEZ,OAAO,IAAI,EAAEa,SAAS,KAAK,EAAE,GAAG,CAAC,CAAC;IACvF,IAAIpB,SAASmB,UAAU,KAAKA,YAAY;QACtC,IAAIC,QAAQ;YACVrB,wBAAwBC;QAC1B;QAEA,IAAII,oBAAoBJ,WAAW;YACjC,MAAM,IAAIH,QAAQG,SAASO,IAAI,EAAEP;QACnC;QAEA,MAAM,IAAIH,QACR;YACEM,OAAOP,OACL,8BACAuB,YACAxB,YAAY,CAACwB,WAAW,EACxBnB,SAASmB,UAAU,EACnBxB,YAAY,CAACK,SAASmB,UAAU,CAAC;QAErC,GACAnB;IAEJ;IAEA,IAAIO,QAAQ,CAACP,SAASO,IAAI,EAAE;QAC1B,MAAM,IAAIV,QACR;YACEM,OAAOP,OACL,qDACAuB,YACAxB,YAAY,CAACwB,WAAW;QAE5B,GACAnB;IAEJ;IAEA,OAAOA,SAASO,IAAI;AACtB;AAEAc,OAAOC,OAAO,GAAGJ","ignoreList":[0]}},
    {"offset": {"line": 229, "column": 0}, "map": {"version":3,"sources":["file:///D:/AconnectJP/node_modules/openid-client/lib/helpers/unix_timestamp.js"],"sourcesContent":["module.exports = () => Math.floor(Date.now() / 1000);\n"],"names":["module","exports","Math","floor","Date","now"],"mappings":"AAAAA,OAAOC,OAAO,GAAG,IAAMC,KAAKC,KAAK,CAACC,KAAKC,GAAG,KAAK","ignoreList":[0]}},
    {"offset": {"line": 233, "column": 0}, "map": {"version":3,"sources":["file:///D:/AconnectJP/node_modules/openid-client/lib/token_set.js"],"sourcesContent":["const base64url = require('./helpers/base64url');\nconst now = require('./helpers/unix_timestamp');\n\nclass TokenSet {\n  constructor(values) {\n    Object.assign(this, values);\n    const { constructor, ...properties } = Object.getOwnPropertyDescriptors(\n      this.constructor.prototype,\n    );\n\n    Object.defineProperties(this, properties);\n  }\n\n  set expires_in(value) {\n    this.expires_at = now() + Number(value);\n  }\n\n  get expires_in() {\n    return Math.max.apply(null, [this.expires_at - now(), 0]);\n  }\n\n  expired() {\n    return this.expires_in === 0;\n  }\n\n  claims() {\n    if (!this.id_token) {\n      throw new TypeError('id_token not present in TokenSet');\n    }\n\n    return JSON.parse(base64url.decode(this.id_token.split('.')[1]));\n  }\n}\n\nmodule.exports = TokenSet;\n"],"names":["base64url","now","TokenSet","values","Object","assign","constructor","properties","getOwnPropertyDescriptors","prototype","defineProperties","expires_in","value","expires_at","Number","Math","max","apply","expired","claims","id_token","TypeError","JSON","parse","decode","split","module","exports"],"mappings":"AAAA,MAAMA;AACN,MAAMC;AAEN,MAAMC;IACJA,YAAYC,MAAM,CAAE;QAClBC,OAAOC,MAAM,CAAC,IAAI,EAAEF;QACpB,MAAM,EAAEG,WAAW,EAAE,GAAGC,YAAY,GAAGH,OAAOI,yBAAyB,CACrE,IAAI,CAACN,WAAW,CAACO,SAAS;QAG5BL,OAAOM,gBAAgB,CAAC,IAAI,EAAEH;IAChC;IAEA,IAAII,WAAWC,KAAK,EAAE;QACpB,IAAI,CAACC,UAAU,GAAGZ,QAAQa,OAAOF;IACnC;IAEA,IAAID,aAAa;QACf,OAAOI,KAAKC,GAAG,CAACC,KAAK,CAAC,MAAM;YAAC,IAAI,CAACJ,UAAU,GAAGZ;YAAO;SAAE;IAC1D;IAEAiB,UAAU;QACR,OAAO,IAAI,CAACP,UAAU,KAAK;IAC7B;IAEAQ,SAAS;QACP,IAAI,CAAC,IAAI,CAACC,QAAQ,EAAE;YAClB,MAAM,IAAIC,UAAU;QACtB;QAEA,OAAOC,KAAKC,KAAK,CAACvB,UAAUwB,MAAM,CAAC,IAAI,CAACJ,QAAQ,CAACK,KAAK,CAAC,IAAI,CAAC,EAAE;IAChE;AACF;AAEAC,OAAOC,OAAO,GAAGzB","ignoreList":[0]}},
    {"offset": {"line": 264, "column": 0}, "map": {"version":3,"sources":["file:///D:/AconnectJP/node_modules/openid-client/lib/helpers/generators.js"],"sourcesContent":["const { createHash, randomBytes } = require('crypto');\n\nconst base64url = require('./base64url');\n\nconst random = (bytes = 32) => base64url.encode(randomBytes(bytes));\n\nmodule.exports = {\n  random,\n  state: random,\n  nonce: random,\n  codeVerifier: random,\n  codeChallenge: (codeVerifier) =>\n    base64url.encode(createHash('sha256').update(codeVerifier).digest()),\n};\n"],"names":["createHash","randomBytes","base64url","random","bytes","encode","module","exports","state","nonce","codeVerifier","codeChallenge","update","digest"],"mappings":"AAAA,MAAM,EAAEA,UAAU,EAAEC,WAAW,EAAE;AAEjC,MAAMC;AAEN,MAAMC,SAAS,CAACC,QAAQ,EAAE,GAAKF,UAAUG,MAAM,CAACJ,YAAYG;AAE5DE,OAAOC,OAAO,GAAG;IACfJ;IACAK,OAAOL;IACPM,OAAON;IACPO,cAAcP;IACdQ,eAAe,CAACD,eACdR,UAAUG,MAAM,CAACL,WAAW,UAAUY,MAAM,CAACF,cAAcG,MAAM;AACrE","ignoreList":[0]}},
    {"offset": {"line": 277, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/node_modules/openid-client/package.json"],"sourcesContent":["{\"name\":\"openid-client\",\"version\":\"5.7.1\",\"description\":\"OpenID Connect Relying Party (RP, Client) implementation for Node.js runtime, supports passportjs\",\"keywords\":[\"auth\",\"authentication\",\"basic\",\"certified\",\"client\",\"connect\",\"dynamic\",\"electron\",\"hybrid\",\"identity\",\"implicit\",\"oauth\",\"oauth2\",\"oidc\",\"openid\",\"passport\",\"relying party\",\"strategy\"],\"homepage\":\"https://github.com/panva/openid-client\",\"repository\":\"panva/openid-client\",\"funding\":{\"url\":\"https://github.com/sponsors/panva\"},\"license\":\"MIT\",\"author\":\"Filip Skokan <panva.ip@gmail.com>\",\"exports\":{\"types\":\"./types/index.d.ts\",\"import\":\"./lib/index.mjs\",\"require\":\"./lib/index.js\"},\"main\":\"./lib/index.js\",\"types\":\"./types/index.d.ts\",\"files\":[\"lib\",\"types/index.d.ts\"],\"scripts\":{\"format\":\"npx prettier --loglevel silent --write ./lib ./test ./certification ./types\",\"test\":\"mocha test/**/*.test.js\"},\"dependencies\":{\"jose\":\"^4.15.9\",\"lru-cache\":\"^6.0.0\",\"object-hash\":\"^2.2.0\",\"oidc-token-hash\":\"^5.0.3\"},\"devDependencies\":{\"@types/node\":\"^16.18.106\",\"@types/passport\":\"^1.0.16\",\"base64url\":\"^3.0.1\",\"chai\":\"^4.5.0\",\"mocha\":\"^10.7.3\",\"nock\":\"^13.5.5\",\"prettier\":\"^2.8.8\",\"readable-mock-req\":\"^0.2.2\",\"sinon\":\"^9.2.4\",\"timekeeper\":\"^2.3.1\"},\"standard-version\":{\"scripts\":{\"postchangelog\":\"sed -i '' -e 's/### \\\\[/## [/g' CHANGELOG.md\"},\"types\":[{\"type\":\"feat\",\"section\":\"Features\"},{\"type\":\"fix\",\"section\":\"Fixes\"},{\"type\":\"chore\",\"hidden\":true},{\"type\":\"docs\",\"hidden\":true},{\"type\":\"style\",\"hidden\":true},{\"type\":\"refactor\",\"section\":\"Refactor\",\"hidden\":false},{\"type\":\"perf\",\"section\":\"Performance\",\"hidden\":false},{\"type\":\"test\",\"hidden\":true}]}}"],"names":[],"mappings":"AAAA"}},
    {"offset": {"line": 277, "column": 1647}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 280, "column": 0}, "map": {"version":3,"sources":["file:///D:/AconnectJP/node_modules/openid-client/lib/helpers/consts.js"],"sourcesContent":["const HTTP_OPTIONS = Symbol();\nconst CLOCK_TOLERANCE = Symbol();\n\nmodule.exports = {\n  CLOCK_TOLERANCE,\n  HTTP_OPTIONS,\n};\n"],"names":["HTTP_OPTIONS","Symbol","CLOCK_TOLERANCE","module","exports"],"mappings":"AAAA,MAAMA,eAAeC;AACrB,MAAMC,kBAAkBD;AAExBE,OAAOC,OAAO,GAAG;IACfF;IACAF;AACF","ignoreList":[0]}},
    {"offset": {"line": 289, "column": 0}, "map": {"version":3,"sources":["file:///D:/AconnectJP/node_modules/openid-client/lib/helpers/request.js"],"sourcesContent":["const assert = require('assert');\nconst querystring = require('querystring');\nconst http = require('http');\nconst https = require('https');\nconst { once } = require('events');\nconst { URL } = require('url');\n\nconst LRU = require('lru-cache');\n\nconst pkg = require('../../package.json');\nconst { RPError } = require('../errors');\n\nconst pick = require('./pick');\nconst { deep: defaultsDeep } = require('./defaults');\nconst { HTTP_OPTIONS } = require('./consts');\n\nlet DEFAULT_HTTP_OPTIONS;\nconst NQCHAR = /^[\\x21\\x23-\\x5B\\x5D-\\x7E]+$/;\n\nconst allowed = [\n  'agent',\n  'ca',\n  'cert',\n  'crl',\n  'headers',\n  'key',\n  'lookup',\n  'passphrase',\n  'pfx',\n  'timeout',\n];\n\nconst setDefaults = (props, options) => {\n  DEFAULT_HTTP_OPTIONS = defaultsDeep(\n    {},\n    props.length ? pick(options, ...props) : options,\n    DEFAULT_HTTP_OPTIONS,\n  );\n};\n\nsetDefaults([], {\n  headers: {\n    'User-Agent': `${pkg.name}/${pkg.version} (${pkg.homepage})`,\n    'Accept-Encoding': 'identity',\n  },\n  timeout: 3500,\n});\n\nfunction send(req, body, contentType) {\n  if (contentType) {\n    req.removeHeader('content-type');\n    req.setHeader('content-type', contentType);\n  }\n  if (body) {\n    req.removeHeader('content-length');\n    req.setHeader('content-length', Buffer.byteLength(body));\n    req.write(body);\n  }\n  req.end();\n}\n\nconst nonces = new LRU({ max: 100 });\n\nmodule.exports = async function request(options, { accessToken, mTLS = false, DPoP } = {}) {\n  let url;\n  try {\n    url = new URL(options.url);\n    delete options.url;\n    assert(/^(https?:)$/.test(url.protocol));\n  } catch (err) {\n    throw new TypeError('only valid absolute URLs can be requested');\n  }\n  const optsFn = this[HTTP_OPTIONS];\n  let opts = options;\n\n  const nonceKey = `${url.origin}${url.pathname}`;\n  if (DPoP && 'dpopProof' in this) {\n    opts.headers = opts.headers || {};\n    opts.headers.DPoP = await this.dpopProof(\n      {\n        htu: `${url.origin}${url.pathname}`,\n        htm: options.method || 'GET',\n        nonce: nonces.get(nonceKey),\n      },\n      DPoP,\n      accessToken,\n    );\n  }\n\n  let userOptions;\n  if (optsFn) {\n    userOptions = pick(\n      optsFn.call(this, url, defaultsDeep({}, opts, DEFAULT_HTTP_OPTIONS)),\n      ...allowed,\n    );\n  }\n  opts = defaultsDeep({}, userOptions, opts, DEFAULT_HTTP_OPTIONS);\n\n  if (mTLS && !opts.pfx && !(opts.key && opts.cert)) {\n    throw new TypeError('mutual-TLS certificate and key not set');\n  }\n\n  if (opts.searchParams) {\n    for (const [key, value] of Object.entries(opts.searchParams)) {\n      url.searchParams.delete(key);\n      url.searchParams.set(key, value);\n    }\n  }\n\n  let responseType;\n  let form;\n  let json;\n  let body;\n  ({ form, responseType, json, body, ...opts } = opts);\n\n  for (const [key, value] of Object.entries(opts.headers || {})) {\n    if (value === undefined) {\n      delete opts.headers[key];\n    }\n  }\n\n  let response;\n  const req = (url.protocol === 'https:' ? https.request : http.request)(url.href, opts);\n  return (async () => {\n    if (json) {\n      send(req, JSON.stringify(json), 'application/json');\n    } else if (form) {\n      send(req, querystring.stringify(form), 'application/x-www-form-urlencoded');\n    } else if (body) {\n      send(req, body);\n    } else {\n      send(req);\n    }\n\n    [response] = await Promise.race([once(req, 'response'), once(req, 'timeout')]);\n\n    // timeout reached\n    if (!response) {\n      req.destroy();\n      throw new RPError(`outgoing request timed out after ${opts.timeout}ms`);\n    }\n\n    const parts = [];\n\n    for await (const part of response) {\n      parts.push(part);\n    }\n\n    if (parts.length) {\n      switch (responseType) {\n        case 'json': {\n          Object.defineProperty(response, 'body', {\n            get() {\n              let value = Buffer.concat(parts);\n              try {\n                value = JSON.parse(value);\n              } catch (err) {\n                Object.defineProperty(err, 'response', { value: response });\n                throw err;\n              } finally {\n                Object.defineProperty(response, 'body', { value, configurable: true });\n              }\n              return value;\n            },\n            configurable: true,\n          });\n          break;\n        }\n        case undefined:\n        case 'buffer': {\n          Object.defineProperty(response, 'body', {\n            get() {\n              const value = Buffer.concat(parts);\n              Object.defineProperty(response, 'body', { value, configurable: true });\n              return value;\n            },\n            configurable: true,\n          });\n          break;\n        }\n        default:\n          throw new TypeError('unsupported responseType request option');\n      }\n    }\n\n    return response;\n  })()\n    .catch((err) => {\n      if (response) Object.defineProperty(err, 'response', { value: response });\n      throw err;\n    })\n    .finally(() => {\n      const dpopNonce = response && response.headers['dpop-nonce'];\n      if (dpopNonce && NQCHAR.test(dpopNonce)) {\n        nonces.set(nonceKey, dpopNonce);\n      }\n    });\n};\n\nmodule.exports.setDefaults = setDefaults.bind(undefined, allowed);\n"],"names":["assert","querystring","http","https","once","URL","LRU","pkg","RPError","pick","deep","defaultsDeep","HTTP_OPTIONS","DEFAULT_HTTP_OPTIONS","NQCHAR","allowed","setDefaults","props","options","length","headers","name","version","homepage","timeout","send","req","body","contentType","removeHeader","setHeader","Buffer","byteLength","write","end","nonces","max","module","exports","request","accessToken","mTLS","DPoP","url","test","protocol","err","TypeError","optsFn","opts","nonceKey","origin","pathname","dpopProof","htu","htm","method","nonce","get","userOptions","call","pfx","key","cert","searchParams","value","Object","entries","delete","set","responseType","form","json","undefined","response","href","JSON","stringify","Promise","race","destroy","parts","part","push","defineProperty","concat","parse","configurable","catch","finally","dpopNonce","bind"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 472, "column": 0}, "map": {"version":3,"sources":["file:///D:/AconnectJP/node_modules/openid-client/lib/helpers/weak_cache.js"],"sourcesContent":["module.exports.keystores = new WeakMap();\n"],"names":["module","exports","keystores","WeakMap"],"mappings":"AAAAA,OAAOC,OAAO,CAACC,SAAS,GAAG,IAAIC","ignoreList":[0]}},
    {"offset": {"line": 476, "column": 0}, "map": {"version":3,"sources":["file:///D:/AconnectJP/node_modules/openid-client/lib/helpers/deep_clone.js"],"sourcesContent":["module.exports = globalThis.structuredClone || ((obj) => JSON.parse(JSON.stringify(obj)));\n"],"names":["module","exports","globalThis","structuredClone","obj","JSON","parse","stringify"],"mappings":"AAAAA,OAAOC,OAAO,GAAGC,WAAWC,eAAe,IAAI,CAAC,CAACC,MAAQC,KAAKC,KAAK,CAACD,KAAKE,SAAS,CAACH,KAAK","ignoreList":[0]}},
    {"offset": {"line": 480, "column": 0}, "map": {"version":3,"sources":["file:///D:/AconnectJP/node_modules/openid-client/lib/helpers/keystore.js"],"sourcesContent":["const jose = require('jose');\n\nconst clone = require('./deep_clone');\nconst isPlainObject = require('./is_plain_object');\n\nconst internal = Symbol();\n\nconst keyscore = (key, { alg, use }) => {\n  let score = 0;\n\n  if (alg && key.alg) {\n    score++;\n  }\n\n  if (use && key.use) {\n    score++;\n  }\n\n  return score;\n};\n\nfunction getKtyFromAlg(alg) {\n  switch (typeof alg === 'string' && alg.slice(0, 2)) {\n    case 'RS':\n    case 'PS':\n      return 'RSA';\n    case 'ES':\n      return 'EC';\n    case 'Ed':\n      return 'OKP';\n    default:\n      return undefined;\n  }\n}\n\nfunction getAlgorithms(use, alg, kty, crv) {\n  // Ed25519, Ed448, and secp256k1 always have \"alg\"\n  // OKP always has \"use\"\n  if (alg) {\n    return new Set([alg]);\n  }\n\n  switch (kty) {\n    case 'EC': {\n      let algs = [];\n\n      if (use === 'enc' || use === undefined) {\n        algs = algs.concat(['ECDH-ES', 'ECDH-ES+A128KW', 'ECDH-ES+A192KW', 'ECDH-ES+A256KW']);\n      }\n\n      if (use === 'sig' || use === undefined) {\n        switch (crv) {\n          case 'P-256':\n          case 'P-384':\n            algs = algs.concat([`ES${crv.slice(-3)}`]);\n            break;\n          case 'P-521':\n            algs = algs.concat(['ES512']);\n            break;\n          case 'secp256k1':\n            if (jose.cryptoRuntime === 'node:crypto') {\n              algs = algs.concat(['ES256K']);\n            }\n            break;\n        }\n      }\n\n      return new Set(algs);\n    }\n    case 'OKP': {\n      return new Set(['ECDH-ES', 'ECDH-ES+A128KW', 'ECDH-ES+A192KW', 'ECDH-ES+A256KW']);\n    }\n    case 'RSA': {\n      let algs = [];\n\n      if (use === 'enc' || use === undefined) {\n        algs = algs.concat(['RSA-OAEP', 'RSA-OAEP-256', 'RSA-OAEP-384', 'RSA-OAEP-512']);\n        if (jose.cryptoRuntime === 'node:crypto') {\n          algs = algs.concat(['RSA1_5']);\n        }\n      }\n\n      if (use === 'sig' || use === undefined) {\n        algs = algs.concat(['PS256', 'PS384', 'PS512', 'RS256', 'RS384', 'RS512']);\n      }\n\n      return new Set(algs);\n    }\n    default:\n      throw new Error('unreachable');\n  }\n}\n\nmodule.exports = class KeyStore {\n  #keys;\n\n  constructor(i, keys) {\n    if (i !== internal) throw new Error('invalid constructor call');\n    this.#keys = keys;\n  }\n\n  toJWKS() {\n    return {\n      keys: this.map(({ jwk: { d, p, q, dp, dq, qi, ...jwk } }) => jwk),\n    };\n  }\n\n  all({ alg, kid, use } = {}) {\n    if (!use || !alg) {\n      throw new Error();\n    }\n\n    const kty = getKtyFromAlg(alg);\n\n    const search = { alg, use };\n    return this.filter((key) => {\n      let candidate = true;\n\n      if (candidate && kty !== undefined && key.jwk.kty !== kty) {\n        candidate = false;\n      }\n\n      if (candidate && kid !== undefined && key.jwk.kid !== kid) {\n        candidate = false;\n      }\n\n      if (candidate && use !== undefined && key.jwk.use !== undefined && key.jwk.use !== use) {\n        candidate = false;\n      }\n\n      if (candidate && key.jwk.alg && key.jwk.alg !== alg) {\n        candidate = false;\n      } else if (!key.algorithms.has(alg)) {\n        candidate = false;\n      }\n\n      return candidate;\n    }).sort((first, second) => keyscore(second, search) - keyscore(first, search));\n  }\n\n  get(...args) {\n    return this.all(...args)[0];\n  }\n\n  static async fromJWKS(jwks, { onlyPublic = false, onlyPrivate = false } = {}) {\n    if (\n      !isPlainObject(jwks) ||\n      !Array.isArray(jwks.keys) ||\n      jwks.keys.some((k) => !isPlainObject(k) || !('kty' in k))\n    ) {\n      throw new TypeError('jwks must be a JSON Web Key Set formatted object');\n    }\n\n    const keys = [];\n\n    for (let jwk of jwks.keys) {\n      jwk = clone(jwk);\n      const { kty, kid, crv } = jwk;\n\n      let { alg, use } = jwk;\n\n      if (typeof kty !== 'string' || !kty) {\n        continue;\n      }\n\n      if (use !== undefined && use !== 'sig' && use !== 'enc') {\n        continue;\n      }\n\n      if (typeof alg !== 'string' && alg !== undefined) {\n        continue;\n      }\n\n      if (typeof kid !== 'string' && kid !== undefined) {\n        continue;\n      }\n\n      if (kty === 'EC' && use === 'sig') {\n        switch (crv) {\n          case 'P-256':\n            alg = 'ES256';\n            break;\n          case 'P-384':\n            alg = 'ES384';\n            break;\n          case 'P-521':\n            alg = 'ES512';\n            break;\n          default:\n            break;\n        }\n      }\n\n      if (crv === 'secp256k1') {\n        use = 'sig';\n        alg = 'ES256K';\n      }\n\n      if (kty === 'OKP') {\n        switch (crv) {\n          case 'Ed25519':\n          case 'Ed448':\n            use = 'sig';\n            alg = 'EdDSA';\n            break;\n          case 'X25519':\n          case 'X448':\n            use = 'enc';\n            break;\n          default:\n            break;\n        }\n      }\n\n      if (alg && !use) {\n        switch (true) {\n          case alg.startsWith('ECDH'):\n            use = 'enc';\n            break;\n          case alg.startsWith('RSA'):\n            use = 'enc';\n            break;\n          default:\n            break;\n        }\n      }\n\n      if (onlyPrivate && (jwk.kty === 'oct' || !jwk.d)) {\n        throw new Error('jwks must only contain private keys');\n      }\n\n      if (onlyPublic && (jwk.d || jwk.k)) {\n        continue;\n      }\n\n      keys.push({\n        jwk: { ...jwk, alg, use },\n        async keyObject(alg) {\n          if (this[alg]) {\n            return this[alg];\n          }\n\n          const keyObject = await jose.importJWK(this.jwk, alg);\n          this[alg] = keyObject;\n          return keyObject;\n        },\n        get algorithms() {\n          Object.defineProperty(this, 'algorithms', {\n            value: getAlgorithms(this.jwk.use, this.jwk.alg, this.jwk.kty, this.jwk.crv),\n            enumerable: true,\n            configurable: false,\n          });\n          return this.algorithms;\n        },\n      });\n    }\n\n    return new this(internal, keys);\n  }\n\n  filter(...args) {\n    return this.#keys.filter(...args);\n  }\n\n  find(...args) {\n    return this.#keys.find(...args);\n  }\n\n  every(...args) {\n    return this.#keys.every(...args);\n  }\n\n  some(...args) {\n    return this.#keys.some(...args);\n  }\n\n  map(...args) {\n    return this.#keys.map(...args);\n  }\n\n  forEach(...args) {\n    return this.#keys.forEach(...args);\n  }\n\n  reduce(...args) {\n    return this.#keys.reduce(...args);\n  }\n\n  sort(...args) {\n    return this.#keys.sort(...args);\n  }\n\n  *[Symbol.iterator]() {\n    for (const key of this.#keys) {\n      yield key;\n    }\n  }\n};\n"],"names":["jose","clone","isPlainObject","internal","Symbol","keyscore","key","alg","use","score","getKtyFromAlg","slice","undefined","getAlgorithms","kty","crv","Set","algs","concat","cryptoRuntime","Error","module","exports","KeyStore","i","keys","toJWKS","map","jwk","d","p","q","dp","dq","qi","all","kid","search","filter","candidate","algorithms","has","sort","first","second","get","args","fromJWKS","jwks","onlyPublic","onlyPrivate","Array","isArray","some","k","TypeError","startsWith","push","keyObject","importJWK","Object","defineProperty","value","enumerable","configurable","find","every","forEach","reduce","iterator"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 766, "column": 0}, "map": {"version":3,"sources":["file:///D:/AconnectJP/node_modules/openid-client/lib/helpers/merge.js"],"sourcesContent":["const isPlainObject = require('./is_plain_object');\n\nfunction merge(target, ...sources) {\n  for (const source of sources) {\n    if (!isPlainObject(source)) {\n      continue;\n    }\n    for (const [key, value] of Object.entries(source)) {\n      /* istanbul ignore if */\n      if (key === '__proto__' || key === 'constructor') {\n        continue;\n      }\n      if (isPlainObject(target[key]) && isPlainObject(value)) {\n        target[key] = merge(target[key], value);\n      } else if (typeof value !== 'undefined') {\n        target[key] = value;\n      }\n    }\n  }\n\n  return target;\n}\n\nmodule.exports = merge;\n"],"names":["isPlainObject","merge","target","sources","source","key","value","Object","entries","module","exports"],"mappings":"AAAA,MAAMA;AAEN,SAASC,MAAMC,MAAM,EAAE,GAAGC,OAAO;IAC/B,KAAK,MAAMC,UAAUD,QAAS;QAC5B,IAAI,CAACH,cAAcI,SAAS;YAC1B;QACF;QACA,KAAK,MAAM,CAACC,KAAKC,MAAM,IAAIC,OAAOC,OAAO,CAACJ,QAAS;YACjD,sBAAsB,GACtB,IAAIC,QAAQ,eAAeA,QAAQ,eAAe;gBAChD;YACF;YACA,IAAIL,cAAcE,MAAM,CAACG,IAAI,KAAKL,cAAcM,QAAQ;gBACtDJ,MAAM,CAACG,IAAI,GAAGJ,MAAMC,MAAM,CAACG,IAAI,EAAEC;YACnC,OAAO,IAAI,OAAOA,UAAU,aAAa;gBACvCJ,MAAM,CAACG,IAAI,GAAGC;YAChB;QACF;IACF;IAEA,OAAOJ;AACT;AAEAO,OAAOC,OAAO,GAAGT","ignoreList":[0]}},
    {"offset": {"line": 789, "column": 0}, "map": {"version":3,"sources":["file:///D:/AconnectJP/node_modules/openid-client/lib/helpers/client.js"],"sourcesContent":["const jose = require('jose');\n\nconst { RPError } = require('../errors');\n\nconst { assertIssuerConfiguration } = require('./assert');\nconst { random } = require('./generators');\nconst now = require('./unix_timestamp');\nconst request = require('./request');\nconst { keystores } = require('./weak_cache');\nconst merge = require('./merge');\n\n// TODO: in v6.x additionally encode the `- _ . ! ~ * ' ( )` characters\n// https://github.com/panva/node-openid-client/commit/5a2ea80ef5e59ec0c03dbd97d82f551e24a9d348\nconst formUrlEncode = (value) => encodeURIComponent(value).replace(/%20/g, '+');\n\nasync function clientAssertion(endpoint, payload) {\n  let alg = this[`${endpoint}_endpoint_auth_signing_alg`];\n  if (!alg) {\n    assertIssuerConfiguration(\n      this.issuer,\n      `${endpoint}_endpoint_auth_signing_alg_values_supported`,\n    );\n  }\n\n  if (this[`${endpoint}_endpoint_auth_method`] === 'client_secret_jwt') {\n    if (!alg) {\n      const supported = this.issuer[`${endpoint}_endpoint_auth_signing_alg_values_supported`];\n      alg =\n        Array.isArray(supported) && supported.find((signAlg) => /^HS(?:256|384|512)/.test(signAlg));\n    }\n\n    if (!alg) {\n      throw new RPError(\n        `failed to determine a JWS Algorithm to use for ${\n          this[`${endpoint}_endpoint_auth_method`]\n        } Client Assertion`,\n      );\n    }\n\n    return new jose.CompactSign(Buffer.from(JSON.stringify(payload)))\n      .setProtectedHeader({ alg })\n      .sign(this.secretForAlg(alg));\n  }\n\n  const keystore = await keystores.get(this);\n\n  if (!keystore) {\n    throw new TypeError('no client jwks provided for signing a client assertion with');\n  }\n\n  if (!alg) {\n    const supported = this.issuer[`${endpoint}_endpoint_auth_signing_alg_values_supported`];\n    alg =\n      Array.isArray(supported) &&\n      supported.find((signAlg) => keystore.get({ alg: signAlg, use: 'sig' }));\n  }\n\n  if (!alg) {\n    throw new RPError(\n      `failed to determine a JWS Algorithm to use for ${\n        this[`${endpoint}_endpoint_auth_method`]\n      } Client Assertion`,\n    );\n  }\n\n  const key = keystore.get({ alg, use: 'sig' });\n  if (!key) {\n    throw new RPError(\n      `no key found in client jwks to sign a client assertion with using alg ${alg}`,\n    );\n  }\n\n  return new jose.CompactSign(Buffer.from(JSON.stringify(payload)))\n    .setProtectedHeader({ alg, kid: key.jwk && key.jwk.kid })\n    .sign(await key.keyObject(alg));\n}\n\nasync function authFor(endpoint, { clientAssertionPayload } = {}) {\n  const authMethod = this[`${endpoint}_endpoint_auth_method`];\n  switch (authMethod) {\n    case 'self_signed_tls_client_auth':\n    case 'tls_client_auth':\n    case 'none':\n      return { form: { client_id: this.client_id } };\n    case 'client_secret_post':\n      if (typeof this.client_secret !== 'string') {\n        throw new TypeError(\n          'client_secret_post client authentication method requires a client_secret',\n        );\n      }\n      return { form: { client_id: this.client_id, client_secret: this.client_secret } };\n    case 'private_key_jwt':\n    case 'client_secret_jwt': {\n      const timestamp = now();\n\n      const assertion = await clientAssertion.call(this, endpoint, {\n        iat: timestamp,\n        exp: timestamp + 60,\n        jti: random(),\n        iss: this.client_id,\n        sub: this.client_id,\n        aud: this.issuer.issuer,\n        ...clientAssertionPayload,\n      });\n\n      return {\n        form: {\n          client_id: this.client_id,\n          client_assertion: assertion,\n          client_assertion_type: 'urn:ietf:params:oauth:client-assertion-type:jwt-bearer',\n        },\n      };\n    }\n    case 'client_secret_basic': {\n      // This is correct behaviour, see https://tools.ietf.org/html/rfc6749#section-2.3.1 and the\n      // related appendix. (also https://github.com/panva/node-openid-client/pull/91)\n      // > The client identifier is encoded using the\n      // > \"application/x-www-form-urlencoded\" encoding algorithm per\n      // > Appendix B, and the encoded value is used as the username; the client\n      // > password is encoded using the same algorithm and used as the\n      // > password.\n      if (typeof this.client_secret !== 'string') {\n        throw new TypeError(\n          'client_secret_basic client authentication method requires a client_secret',\n        );\n      }\n      const encoded = `${formUrlEncode(this.client_id)}:${formUrlEncode(this.client_secret)}`;\n      const value = Buffer.from(encoded).toString('base64');\n      return { headers: { Authorization: `Basic ${value}` } };\n    }\n    default: {\n      throw new TypeError(`missing, or unsupported, ${endpoint}_endpoint_auth_method`);\n    }\n  }\n}\n\nfunction resolveResponseType() {\n  const { length, 0: value } = this.response_types;\n\n  if (length === 1) {\n    return value;\n  }\n\n  return undefined;\n}\n\nfunction resolveRedirectUri() {\n  const { length, 0: value } = this.redirect_uris || [];\n\n  if (length === 1) {\n    return value;\n  }\n\n  return undefined;\n}\n\nasync function authenticatedPost(\n  endpoint,\n  opts,\n  { clientAssertionPayload, endpointAuthMethod = endpoint, DPoP } = {},\n) {\n  const auth = await authFor.call(this, endpointAuthMethod, { clientAssertionPayload });\n  const requestOpts = merge(opts, auth);\n\n  const mTLS =\n    this[`${endpointAuthMethod}_endpoint_auth_method`].includes('tls_client_auth') ||\n    (endpoint === 'token' && this.tls_client_certificate_bound_access_tokens);\n\n  let targetUrl;\n  if (mTLS && this.issuer.mtls_endpoint_aliases) {\n    targetUrl = this.issuer.mtls_endpoint_aliases[`${endpoint}_endpoint`];\n  }\n\n  targetUrl = targetUrl || this.issuer[`${endpoint}_endpoint`];\n\n  if ('form' in requestOpts) {\n    for (const [key, value] of Object.entries(requestOpts.form)) {\n      if (typeof value === 'undefined') {\n        delete requestOpts.form[key];\n      }\n    }\n  }\n\n  return request.call(\n    this,\n    {\n      ...requestOpts,\n      method: 'POST',\n      url: targetUrl,\n      headers: {\n        ...(endpoint !== 'revocation'\n          ? {\n              Accept: 'application/json',\n            }\n          : undefined),\n        ...requestOpts.headers,\n      },\n    },\n    { mTLS, DPoP },\n  );\n}\n\nmodule.exports = {\n  resolveResponseType,\n  resolveRedirectUri,\n  authFor,\n  authenticatedPost,\n};\n"],"names":["jose","RPError","assertIssuerConfiguration","random","now","request","keystores","merge","formUrlEncode","value","encodeURIComponent","replace","clientAssertion","endpoint","payload","alg","issuer","supported","Array","isArray","find","signAlg","test","CompactSign","Buffer","from","JSON","stringify","setProtectedHeader","sign","secretForAlg","keystore","get","TypeError","use","key","kid","jwk","keyObject","authFor","clientAssertionPayload","authMethod","form","client_id","client_secret","timestamp","assertion","call","iat","exp","jti","iss","sub","aud","client_assertion","client_assertion_type","encoded","toString","headers","Authorization","resolveResponseType","length","response_types","undefined","resolveRedirectUri","redirect_uris","authenticatedPost","opts","endpointAuthMethod","DPoP","auth","requestOpts","mTLS","includes","tls_client_certificate_bound_access_tokens","targetUrl","mtls_endpoint_aliases","Object","entries","method","url","Accept","module","exports"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 967, "column": 0}, "map": {"version":3,"sources":["file:///D:/AconnectJP/node_modules/openid-client/lib/helpers/issuer.js"],"sourcesContent":["const objectHash = require('object-hash');\nconst LRU = require('lru-cache');\n\nconst { RPError } = require('../errors');\n\nconst { assertIssuerConfiguration } = require('./assert');\nconst KeyStore = require('./keystore');\nconst { keystores } = require('./weak_cache');\nconst processResponse = require('./process_response');\nconst request = require('./request');\n\nconst inFlight = new WeakMap();\nconst caches = new WeakMap();\nconst lrus = (ctx) => {\n  if (!caches.has(ctx)) {\n    caches.set(ctx, new LRU({ max: 100 }));\n  }\n  return caches.get(ctx);\n};\n\nasync function getKeyStore(reload = false) {\n  assertIssuerConfiguration(this, 'jwks_uri');\n\n  const keystore = keystores.get(this);\n  const cache = lrus(this);\n\n  if (reload || !keystore) {\n    if (inFlight.has(this)) {\n      return inFlight.get(this);\n    }\n    cache.reset();\n    inFlight.set(\n      this,\n      (async () => {\n        const response = await request\n          .call(this, {\n            method: 'GET',\n            responseType: 'json',\n            url: this.jwks_uri,\n            headers: {\n              Accept: 'application/json, application/jwk-set+json',\n            },\n          })\n          .finally(() => {\n            inFlight.delete(this);\n          });\n        const jwks = processResponse(response);\n\n        const joseKeyStore = KeyStore.fromJWKS(jwks, { onlyPublic: true });\n        cache.set('throttle', true, 60 * 1000);\n        keystores.set(this, joseKeyStore);\n\n        return joseKeyStore;\n      })(),\n    );\n\n    return inFlight.get(this);\n  }\n\n  return keystore;\n}\n\nasync function queryKeyStore({ kid, kty, alg, use }, { allowMulti = false } = {}) {\n  const cache = lrus(this);\n\n  const def = {\n    kid,\n    kty,\n    alg,\n    use,\n  };\n\n  const defHash = objectHash(def, {\n    algorithm: 'sha256',\n    ignoreUnknown: true,\n    unorderedArrays: true,\n    unorderedSets: true,\n    respectType: false,\n  });\n\n  // refresh keystore on every unknown key but also only upto once every minute\n  const freshJwksUri = cache.get(defHash) || cache.get('throttle');\n\n  const keystore = await getKeyStore.call(this, !freshJwksUri);\n  const keys = keystore.all(def);\n\n  delete def.use;\n  if (keys.length === 0) {\n    throw new RPError({\n      printf: [\"no valid key found in issuer's jwks_uri for key parameters %j\", def],\n      jwks: keystore,\n    });\n  }\n\n  if (!allowMulti && keys.length > 1 && !kid) {\n    throw new RPError({\n      printf: [\n        \"multiple matching keys found in issuer's jwks_uri for key parameters %j, kid must be provided in this case\",\n        def,\n      ],\n      jwks: keystore,\n    });\n  }\n\n  cache.set(defHash, true);\n\n  return keys;\n}\n\nmodule.exports.queryKeyStore = queryKeyStore;\nmodule.exports.keystore = getKeyStore;\n"],"names":["objectHash","LRU","RPError","assertIssuerConfiguration","KeyStore","keystores","processResponse","request","inFlight","WeakMap","caches","lrus","ctx","has","set","max","get","getKeyStore","reload","keystore","cache","reset","response","call","method","responseType","url","jwks_uri","headers","Accept","finally","delete","jwks","joseKeyStore","fromJWKS","onlyPublic","queryKeyStore","kid","kty","alg","use","allowMulti","def","defHash","algorithm","ignoreUnknown","unorderedArrays","unorderedSets","respectType","freshJwksUri","keys","all","length","printf","module","exports"],"mappings":"AAAA,MAAMA;AACN,MAAMC;AAEN,MAAM,EAAEC,OAAO,EAAE;AAEjB,MAAM,EAAEC,yBAAyB,EAAE;AACnC,MAAMC;AACN,MAAM,EAAEC,SAAS,EAAE;AACnB,MAAMC;AACN,MAAMC;AAEN,MAAMC,WAAW,IAAIC;AACrB,MAAMC,SAAS,IAAID;AACnB,MAAME,OAAO,CAACC;IACZ,IAAI,CAACF,OAAOG,GAAG,CAACD,MAAM;QACpBF,OAAOI,GAAG,CAACF,KAAK,IAAIX,IAAI;YAAEc,KAAK;QAAI;IACrC;IACA,OAAOL,OAAOM,GAAG,CAACJ;AACpB;AAEA,eAAeK,YAAYC,SAAS,KAAK;IACvCf,0BAA0B,IAAI,EAAE;IAEhC,MAAMgB,WAAWd,UAAUW,GAAG,CAAC,IAAI;IACnC,MAAMI,QAAQT,KAAK,IAAI;IAEvB,IAAIO,UAAU,CAACC,UAAU;QACvB,IAAIX,SAASK,GAAG,CAAC,IAAI,GAAG;YACtB,OAAOL,SAASQ,GAAG,CAAC,IAAI;QAC1B;QACAI,MAAMC,KAAK;QACXb,SAASM,GAAG,CACV,IAAI,EACJ,CAAC;YACC,MAAMQ,WAAW,MAAMf,QACpBgB,IAAI,CAAC,IAAI,EAAE;gBACVC,QAAQ;gBACRC,cAAc;gBACdC,KAAK,IAAI,CAACC,QAAQ;gBAClBC,SAAS;oBACPC,QAAQ;gBACV;YACF,GACCC,OAAO,CAAC;gBACPtB,SAASuB,MAAM,CAAC,IAAI;YACtB;YACF,MAAMC,OAAO1B,gBAAgBgB;YAE7B,MAAMW,eAAe7B,SAAS8B,QAAQ,CAACF,MAAM;gBAAEG,YAAY;YAAK;YAChEf,MAAMN,GAAG,CAAC,YAAY,MAAM,KAAK;YACjCT,UAAUS,GAAG,CAAC,IAAI,EAAEmB;YAEpB,OAAOA;QACT,CAAC;QAGH,OAAOzB,SAASQ,GAAG,CAAC,IAAI;IAC1B;IAEA,OAAOG;AACT;AAEA,eAAeiB,cAAc,EAAEC,GAAG,EAAEC,GAAG,EAAEC,GAAG,EAAEC,GAAG,EAAE,EAAE,EAAEC,aAAa,KAAK,EAAE,GAAG,CAAC,CAAC;IAC9E,MAAMrB,QAAQT,KAAK,IAAI;IAEvB,MAAM+B,MAAM;QACVL;QACAC;QACAC;QACAC;IACF;IAEA,MAAMG,UAAU3C,WAAW0C,KAAK;QAC9BE,WAAW;QACXC,eAAe;QACfC,iBAAiB;QACjBC,eAAe;QACfC,aAAa;IACf;IAEA,6EAA6E;IAC7E,MAAMC,eAAe7B,MAAMJ,GAAG,CAAC2B,YAAYvB,MAAMJ,GAAG,CAAC;IAErD,MAAMG,WAAW,MAAMF,YAAYM,IAAI,CAAC,IAAI,EAAE,CAAC0B;IAC/C,MAAMC,OAAO/B,SAASgC,GAAG,CAACT;IAE1B,OAAOA,IAAIF,GAAG;IACd,IAAIU,KAAKE,MAAM,KAAK,GAAG;QACrB,MAAM,IAAIlD,QAAQ;YAChBmD,QAAQ;gBAAC;gBAAiEX;aAAI;YAC9EV,MAAMb;QACR;IACF;IAEA,IAAI,CAACsB,cAAcS,KAAKE,MAAM,GAAG,KAAK,CAACf,KAAK;QAC1C,MAAM,IAAInC,QAAQ;YAChBmD,QAAQ;gBACN;gBACAX;aACD;YACDV,MAAMb;QACR;IACF;IAEAC,MAAMN,GAAG,CAAC6B,SAAS;IAEnB,OAAOO;AACT;AAEAI,OAAOC,OAAO,CAACnB,aAAa,GAAGA;AAC/BkB,OAAOC,OAAO,CAACpC,QAAQ,GAAGF","ignoreList":[0]}},
    {"offset": {"line": 1063, "column": 0}, "map": {"version":3,"sources":["file:///D:/AconnectJP/node_modules/openid-client/lib/device_flow_handle.js"],"sourcesContent":["const { inspect } = require('util');\n\nconst { RPError, OPError } = require('./errors');\nconst now = require('./helpers/unix_timestamp');\n\nclass DeviceFlowHandle {\n  #aborted;\n  #client;\n  #clientAssertionPayload;\n  #DPoP;\n  #exchangeBody;\n  #expires_at;\n  #interval;\n  #maxAge;\n  #response;\n  constructor({ client, exchangeBody, clientAssertionPayload, response, maxAge, DPoP }) {\n    ['verification_uri', 'user_code', 'device_code'].forEach((prop) => {\n      if (typeof response[prop] !== 'string' || !response[prop]) {\n        throw new RPError(\n          `expected ${prop} string to be returned by Device Authorization Response, got %j`,\n          response[prop],\n        );\n      }\n    });\n\n    if (!Number.isSafeInteger(response.expires_in)) {\n      throw new RPError(\n        'expected expires_in number to be returned by Device Authorization Response, got %j',\n        response.expires_in,\n      );\n    }\n\n    this.#expires_at = now() + response.expires_in;\n    this.#client = client;\n    this.#DPoP = DPoP;\n    this.#maxAge = maxAge;\n    this.#exchangeBody = exchangeBody;\n    this.#clientAssertionPayload = clientAssertionPayload;\n    this.#response = response;\n    this.#interval = response.interval * 1000 || 5000;\n  }\n\n  abort() {\n    this.#aborted = true;\n  }\n\n  async poll({ signal } = {}) {\n    if ((signal && signal.aborted) || this.#aborted) {\n      throw new RPError('polling aborted');\n    }\n\n    if (this.expired()) {\n      throw new RPError(\n        'the device code %j has expired and the device authorization session has concluded',\n        this.device_code,\n      );\n    }\n\n    await new Promise((resolve) => setTimeout(resolve, this.#interval));\n\n    let tokenset;\n    try {\n      tokenset = await this.#client.grant(\n        {\n          ...this.#exchangeBody,\n          grant_type: 'urn:ietf:params:oauth:grant-type:device_code',\n          device_code: this.device_code,\n        },\n        { clientAssertionPayload: this.#clientAssertionPayload, DPoP: this.#DPoP },\n      );\n    } catch (err) {\n      switch (err instanceof OPError && err.error) {\n        case 'slow_down':\n          this.#interval += 5000;\n        case 'authorization_pending':\n          return this.poll({ signal });\n        default:\n          throw err;\n      }\n    }\n\n    if ('id_token' in tokenset) {\n      await this.#client.decryptIdToken(tokenset);\n      await this.#client.validateIdToken(tokenset, undefined, 'token', this.#maxAge);\n    }\n\n    return tokenset;\n  }\n\n  get device_code() {\n    return this.#response.device_code;\n  }\n\n  get user_code() {\n    return this.#response.user_code;\n  }\n\n  get verification_uri() {\n    return this.#response.verification_uri;\n  }\n\n  get verification_uri_complete() {\n    return this.#response.verification_uri_complete;\n  }\n\n  get expires_in() {\n    return Math.max.apply(null, [this.#expires_at - now(), 0]);\n  }\n\n  expired() {\n    return this.expires_in === 0;\n  }\n\n  /* istanbul ignore next */\n  [inspect.custom]() {\n    return `${this.constructor.name} ${inspect(this.#response, {\n      depth: Infinity,\n      colors: process.stdout.isTTY,\n      compact: false,\n      sorted: true,\n    })}`;\n  }\n}\n\nmodule.exports = DeviceFlowHandle;\n"],"names":["inspect","RPError","OPError","now","DeviceFlowHandle","client","exchangeBody","clientAssertionPayload","response","maxAge","DPoP","forEach","prop","Number","isSafeInteger","expires_in","interval","abort","poll","signal","aborted","expired","device_code","Promise","resolve","setTimeout","tokenset","grant","grant_type","err","error","decryptIdToken","validateIdToken","undefined","user_code","verification_uri","verification_uri_complete","Math","max","apply","custom","name","depth","Infinity","colors","process","stdout","isTTY","compact","sorted","module","exports"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 1171, "column": 0}, "map": {"version":3,"sources":["file:///D:/AconnectJP/node_modules/openid-client/lib/client.js"],"sourcesContent":["const { inspect } = require('util');\nconst stdhttp = require('http');\nconst crypto = require('crypto');\nconst { strict: assert } = require('assert');\nconst querystring = require('querystring');\nconst url = require('url');\nconst { URL, URLSearchParams } = require('url');\n\nconst jose = require('jose');\nconst tokenHash = require('oidc-token-hash');\n\nconst isKeyObject = require('./helpers/is_key_object');\nconst decodeJWT = require('./helpers/decode_jwt');\nconst base64url = require('./helpers/base64url');\nconst defaults = require('./helpers/defaults');\nconst parseWwwAuthenticate = require('./helpers/www_authenticate_parser');\nconst { assertSigningAlgValuesSupport, assertIssuerConfiguration } = require('./helpers/assert');\nconst pick = require('./helpers/pick');\nconst isPlainObject = require('./helpers/is_plain_object');\nconst processResponse = require('./helpers/process_response');\nconst TokenSet = require('./token_set');\nconst { OPError, RPError } = require('./errors');\nconst now = require('./helpers/unix_timestamp');\nconst { random } = require('./helpers/generators');\nconst request = require('./helpers/request');\nconst { CLOCK_TOLERANCE } = require('./helpers/consts');\nconst { keystores } = require('./helpers/weak_cache');\nconst KeyStore = require('./helpers/keystore');\nconst clone = require('./helpers/deep_clone');\nconst { authenticatedPost, resolveResponseType, resolveRedirectUri } = require('./helpers/client');\nconst { queryKeyStore } = require('./helpers/issuer');\nconst DeviceFlowHandle = require('./device_flow_handle');\n\nconst [major, minor] = process.version\n  .slice(1)\n  .split('.')\n  .map((str) => parseInt(str, 10));\n\nconst rsaPssParams = major >= 17 || (major === 16 && minor >= 9);\nconst retryAttempt = Symbol();\nconst skipNonceCheck = Symbol();\nconst skipMaxAgeCheck = Symbol();\n\nfunction pickCb(input) {\n  return pick(\n    input,\n    'access_token', // OAuth 2.0\n    'code', // OAuth 2.0\n    'error_description', // OAuth 2.0\n    'error_uri', // OAuth 2.0\n    'error', // OAuth 2.0\n    'expires_in', // OAuth 2.0\n    'id_token', // OIDC Core 1.0\n    'iss', // draft-ietf-oauth-iss-auth-resp\n    'response', // FAPI JARM\n    'session_state', // OIDC Session Management\n    'state', // OAuth 2.0\n    'token_type', // OAuth 2.0\n  );\n}\n\nfunction authorizationHeaderValue(token, tokenType = 'Bearer') {\n  return `${tokenType} ${token}`;\n}\n\nfunction getSearchParams(input) {\n  const parsed = url.parse(input);\n  if (!parsed.search) return {};\n  return querystring.parse(parsed.search.substring(1));\n}\n\nfunction verifyPresence(payload, jwt, prop) {\n  if (payload[prop] === undefined) {\n    throw new RPError({\n      message: `missing required JWT property ${prop}`,\n      jwt,\n    });\n  }\n}\n\nfunction authorizationParams(params) {\n  const authParams = {\n    client_id: this.client_id,\n    scope: 'openid',\n    response_type: resolveResponseType.call(this),\n    redirect_uri: resolveRedirectUri.call(this),\n    ...params,\n  };\n\n  Object.entries(authParams).forEach(([key, value]) => {\n    if (value === null || value === undefined) {\n      delete authParams[key];\n    } else if (key === 'claims' && typeof value === 'object') {\n      authParams[key] = JSON.stringify(value);\n    } else if (key === 'resource' && Array.isArray(value)) {\n      authParams[key] = value;\n    } else if (typeof value !== 'string') {\n      authParams[key] = String(value);\n    }\n  });\n\n  return authParams;\n}\n\nfunction getKeystore(jwks) {\n  if (\n    !isPlainObject(jwks) ||\n    !Array.isArray(jwks.keys) ||\n    jwks.keys.some((k) => !isPlainObject(k) || !('kty' in k))\n  ) {\n    throw new TypeError('jwks must be a JSON Web Key Set formatted object');\n  }\n\n  return KeyStore.fromJWKS(jwks, { onlyPrivate: true });\n}\n\n// if an OP doesnt support client_secret_basic but supports client_secret_post, use it instead\n// this is in place to take care of most common pitfalls when first using discovered Issuers without\n// the support for default values defined by Discovery 1.0\nfunction checkBasicSupport(client, properties) {\n  try {\n    const supported = client.issuer.token_endpoint_auth_methods_supported;\n    if (!supported.includes(properties.token_endpoint_auth_method)) {\n      if (supported.includes('client_secret_post')) {\n        properties.token_endpoint_auth_method = 'client_secret_post';\n      }\n    }\n  } catch (err) {}\n}\n\nfunction handleCommonMistakes(client, metadata, properties) {\n  if (!metadata.token_endpoint_auth_method) {\n    // if no explicit value was provided\n    checkBasicSupport(client, properties);\n  }\n\n  // :fp: c'mon people... RTFM\n  if (metadata.redirect_uri) {\n    if (metadata.redirect_uris) {\n      throw new TypeError('provide a redirect_uri or redirect_uris, not both');\n    }\n    properties.redirect_uris = [metadata.redirect_uri];\n    delete properties.redirect_uri;\n  }\n\n  if (metadata.response_type) {\n    if (metadata.response_types) {\n      throw new TypeError('provide a response_type or response_types, not both');\n    }\n    properties.response_types = [metadata.response_type];\n    delete properties.response_type;\n  }\n}\n\nfunction getDefaultsForEndpoint(endpoint, issuer, properties) {\n  if (!issuer[`${endpoint}_endpoint`]) return;\n\n  const tokenEndpointAuthMethod = properties.token_endpoint_auth_method;\n  const tokenEndpointAuthSigningAlg = properties.token_endpoint_auth_signing_alg;\n\n  const eam = `${endpoint}_endpoint_auth_method`;\n  const easa = `${endpoint}_endpoint_auth_signing_alg`;\n\n  if (properties[eam] === undefined && properties[easa] === undefined) {\n    if (tokenEndpointAuthMethod !== undefined) {\n      properties[eam] = tokenEndpointAuthMethod;\n    }\n    if (tokenEndpointAuthSigningAlg !== undefined) {\n      properties[easa] = tokenEndpointAuthSigningAlg;\n    }\n  }\n}\n\nclass BaseClient {\n  #metadata;\n  #issuer;\n  #aadIssValidation;\n  #additionalAuthorizedParties;\n  constructor(issuer, aadIssValidation, metadata = {}, jwks, options) {\n    this.#metadata = new Map();\n    this.#issuer = issuer;\n    this.#aadIssValidation = aadIssValidation;\n\n    if (typeof metadata.client_id !== 'string' || !metadata.client_id) {\n      throw new TypeError('client_id is required');\n    }\n\n    const properties = {\n      grant_types: ['authorization_code'],\n      id_token_signed_response_alg: 'RS256',\n      authorization_signed_response_alg: 'RS256',\n      response_types: ['code'],\n      token_endpoint_auth_method: 'client_secret_basic',\n      ...(this.fapi1()\n        ? {\n            grant_types: ['authorization_code', 'implicit'],\n            id_token_signed_response_alg: 'PS256',\n            authorization_signed_response_alg: 'PS256',\n            response_types: ['code id_token'],\n            tls_client_certificate_bound_access_tokens: true,\n            token_endpoint_auth_method: undefined,\n          }\n        : undefined),\n      ...(this.fapi2()\n        ? {\n            id_token_signed_response_alg: 'PS256',\n            authorization_signed_response_alg: 'PS256',\n            token_endpoint_auth_method: undefined,\n          }\n        : undefined),\n      ...metadata,\n    };\n\n    if (this.fapi()) {\n      switch (properties.token_endpoint_auth_method) {\n        case 'self_signed_tls_client_auth':\n        case 'tls_client_auth':\n          break;\n        case 'private_key_jwt':\n          if (!jwks) {\n            throw new TypeError('jwks is required');\n          }\n          break;\n        case undefined:\n          throw new TypeError('token_endpoint_auth_method is required');\n        default:\n          throw new TypeError('invalid or unsupported token_endpoint_auth_method');\n      }\n    }\n\n    if (this.fapi2()) {\n      if (\n        properties.tls_client_certificate_bound_access_tokens &&\n        properties.dpop_bound_access_tokens\n      ) {\n        throw new TypeError(\n          'either tls_client_certificate_bound_access_tokens or dpop_bound_access_tokens must be set to true',\n        );\n      }\n\n      if (\n        !properties.tls_client_certificate_bound_access_tokens &&\n        !properties.dpop_bound_access_tokens\n      ) {\n        throw new TypeError(\n          'either tls_client_certificate_bound_access_tokens or dpop_bound_access_tokens must be set to true',\n        );\n      }\n    }\n\n    handleCommonMistakes(this, metadata, properties);\n\n    assertSigningAlgValuesSupport('token', this.issuer, properties);\n    ['introspection', 'revocation'].forEach((endpoint) => {\n      getDefaultsForEndpoint(endpoint, this.issuer, properties);\n      assertSigningAlgValuesSupport(endpoint, this.issuer, properties);\n    });\n\n    Object.entries(properties).forEach(([key, value]) => {\n      this.#metadata.set(key, value);\n      if (!this[key]) {\n        Object.defineProperty(this, key, {\n          get() {\n            return this.#metadata.get(key);\n          },\n          enumerable: true,\n        });\n      }\n    });\n\n    if (jwks !== undefined) {\n      const keystore = getKeystore.call(this, jwks);\n      keystores.set(this, keystore);\n    }\n\n    if (options != null && options.additionalAuthorizedParties) {\n      this.#additionalAuthorizedParties = clone(options.additionalAuthorizedParties);\n    }\n\n    this[CLOCK_TOLERANCE] = 0;\n  }\n\n  authorizationUrl(params = {}) {\n    if (!isPlainObject(params)) {\n      throw new TypeError('params must be a plain object');\n    }\n    assertIssuerConfiguration(this.issuer, 'authorization_endpoint');\n    const target = new URL(this.issuer.authorization_endpoint);\n\n    for (const [name, value] of Object.entries(authorizationParams.call(this, params))) {\n      if (Array.isArray(value)) {\n        target.searchParams.delete(name);\n        for (const member of value) {\n          target.searchParams.append(name, member);\n        }\n      } else {\n        target.searchParams.set(name, value);\n      }\n    }\n\n    // TODO: is the replace needed?\n    return target.href.replace(/\\+/g, '%20');\n  }\n\n  authorizationPost(params = {}) {\n    if (!isPlainObject(params)) {\n      throw new TypeError('params must be a plain object');\n    }\n    const inputs = authorizationParams.call(this, params);\n    const formInputs = Object.keys(inputs)\n      .map((name) => `<input type=\"hidden\" name=\"${name}\" value=\"${inputs[name]}\"/>`)\n      .join('\\n');\n\n    return `<!DOCTYPE html>\n<head>\n<title>Requesting Authorization</title>\n</head>\n<body onload=\"javascript:document.forms[0].submit()\">\n<form method=\"post\" action=\"${this.issuer.authorization_endpoint}\">\n  ${formInputs}\n</form>\n</body>\n</html>`;\n  }\n\n  endSessionUrl(params = {}) {\n    assertIssuerConfiguration(this.issuer, 'end_session_endpoint');\n\n    const { 0: postLogout, length } = this.post_logout_redirect_uris || [];\n\n    const { post_logout_redirect_uri = length === 1 ? postLogout : undefined } = params;\n\n    let id_token_hint;\n    ({ id_token_hint, ...params } = params);\n    if (id_token_hint instanceof TokenSet) {\n      if (!id_token_hint.id_token) {\n        throw new TypeError('id_token not present in TokenSet');\n      }\n      id_token_hint = id_token_hint.id_token;\n    }\n\n    const target = url.parse(this.issuer.end_session_endpoint);\n    const query = defaults(\n      getSearchParams(this.issuer.end_session_endpoint),\n      params,\n      {\n        post_logout_redirect_uri,\n        client_id: this.client_id,\n      },\n      { id_token_hint },\n    );\n\n    Object.entries(query).forEach(([key, value]) => {\n      if (value === null || value === undefined) {\n        delete query[key];\n      }\n    });\n\n    target.search = null;\n    target.query = query;\n\n    return url.format(target);\n  }\n\n  callbackParams(input) {\n    const isIncomingMessage =\n      input instanceof stdhttp.IncomingMessage || (input && input.method && input.url);\n    const isString = typeof input === 'string';\n\n    if (!isString && !isIncomingMessage) {\n      throw new TypeError(\n        '#callbackParams only accepts string urls, http.IncomingMessage or a lookalike',\n      );\n    }\n    if (isIncomingMessage) {\n      switch (input.method) {\n        case 'GET':\n          return pickCb(getSearchParams(input.url));\n        case 'POST':\n          if (input.body === undefined) {\n            throw new TypeError(\n              'incoming message body missing, include a body parser prior to this method call',\n            );\n          }\n          switch (typeof input.body) {\n            case 'object':\n            case 'string':\n              if (Buffer.isBuffer(input.body)) {\n                return pickCb(querystring.parse(input.body.toString('utf-8')));\n              }\n              if (typeof input.body === 'string') {\n                return pickCb(querystring.parse(input.body));\n              }\n\n              return pickCb(input.body);\n            default:\n              throw new TypeError('invalid IncomingMessage body object');\n          }\n        default:\n          throw new TypeError('invalid IncomingMessage method');\n      }\n    } else {\n      return pickCb(getSearchParams(input));\n    }\n  }\n\n  async callback(\n    redirectUri,\n    parameters,\n    checks = {},\n    { exchangeBody, clientAssertionPayload, DPoP } = {},\n  ) {\n    let params = pickCb(parameters);\n\n    if (checks.jarm && !('response' in parameters)) {\n      throw new RPError({\n        message: 'expected a JARM response',\n        checks,\n        params,\n      });\n    } else if ('response' in parameters) {\n      const decrypted = await this.decryptJARM(params.response);\n      params = await this.validateJARM(decrypted);\n    }\n\n    if (this.default_max_age && !checks.max_age) {\n      checks.max_age = this.default_max_age;\n    }\n\n    if (params.state && !checks.state) {\n      throw new TypeError('checks.state argument is missing');\n    }\n\n    if (!params.state && checks.state) {\n      throw new RPError({\n        message: 'state missing from the response',\n        checks,\n        params,\n      });\n    }\n\n    if (checks.state !== params.state) {\n      throw new RPError({\n        printf: ['state mismatch, expected %s, got: %s', checks.state, params.state],\n        checks,\n        params,\n      });\n    }\n\n    if ('iss' in params) {\n      assertIssuerConfiguration(this.issuer, 'issuer');\n      if (params.iss !== this.issuer.issuer) {\n        throw new RPError({\n          printf: ['iss mismatch, expected %s, got: %s', this.issuer.issuer, params.iss],\n          params,\n        });\n      }\n    } else if (\n      this.issuer.authorization_response_iss_parameter_supported &&\n      !('id_token' in params) &&\n      !('response' in parameters)\n    ) {\n      throw new RPError({\n        message: 'iss missing from the response',\n        params,\n      });\n    }\n\n    if (params.error) {\n      throw new OPError(params);\n    }\n\n    const RESPONSE_TYPE_REQUIRED_PARAMS = {\n      code: ['code'],\n      id_token: ['id_token'],\n      token: ['access_token', 'token_type'],\n    };\n\n    if (checks.response_type) {\n      for (const type of checks.response_type.split(' ')) {\n        if (type === 'none') {\n          if (params.code || params.id_token || params.access_token) {\n            throw new RPError({\n              message: 'unexpected params encountered for \"none\" response',\n              checks,\n              params,\n            });\n          }\n        } else {\n          for (const param of RESPONSE_TYPE_REQUIRED_PARAMS[type]) {\n            if (!params[param]) {\n              throw new RPError({\n                message: `${param} missing from response`,\n                checks,\n                params,\n              });\n            }\n          }\n        }\n      }\n    }\n\n    if (params.id_token) {\n      const tokenset = new TokenSet(params);\n      await this.decryptIdToken(tokenset);\n      await this.validateIdToken(\n        tokenset,\n        checks.nonce,\n        'authorization',\n        checks.max_age,\n        checks.state,\n      );\n\n      if (!params.code) {\n        return tokenset;\n      }\n    }\n\n    if (params.code) {\n      const tokenset = await this.grant(\n        {\n          ...exchangeBody,\n          grant_type: 'authorization_code',\n          code: params.code,\n          redirect_uri: redirectUri,\n          code_verifier: checks.code_verifier,\n        },\n        { clientAssertionPayload, DPoP },\n      );\n\n      await this.decryptIdToken(tokenset);\n      await this.validateIdToken(tokenset, checks.nonce, 'token', checks.max_age);\n\n      if (params.session_state) {\n        tokenset.session_state = params.session_state;\n      }\n\n      return tokenset;\n    }\n\n    return new TokenSet(params);\n  }\n\n  async oauthCallback(\n    redirectUri,\n    parameters,\n    checks = {},\n    { exchangeBody, clientAssertionPayload, DPoP } = {},\n  ) {\n    let params = pickCb(parameters);\n\n    if (checks.jarm && !('response' in parameters)) {\n      throw new RPError({\n        message: 'expected a JARM response',\n        checks,\n        params,\n      });\n    } else if ('response' in parameters) {\n      const decrypted = await this.decryptJARM(params.response);\n      params = await this.validateJARM(decrypted);\n    }\n\n    if (params.state && !checks.state) {\n      throw new TypeError('checks.state argument is missing');\n    }\n\n    if (!params.state && checks.state) {\n      throw new RPError({\n        message: 'state missing from the response',\n        checks,\n        params,\n      });\n    }\n\n    if (checks.state !== params.state) {\n      throw new RPError({\n        printf: ['state mismatch, expected %s, got: %s', checks.state, params.state],\n        checks,\n        params,\n      });\n    }\n\n    if ('iss' in params) {\n      assertIssuerConfiguration(this.issuer, 'issuer');\n      if (params.iss !== this.issuer.issuer) {\n        throw new RPError({\n          printf: ['iss mismatch, expected %s, got: %s', this.issuer.issuer, params.iss],\n          params,\n        });\n      }\n    } else if (\n      this.issuer.authorization_response_iss_parameter_supported &&\n      !('id_token' in params) &&\n      !('response' in parameters)\n    ) {\n      throw new RPError({\n        message: 'iss missing from the response',\n        params,\n      });\n    }\n\n    if (params.error) {\n      throw new OPError(params);\n    }\n\n    if (typeof params.id_token === 'string' && params.id_token.length) {\n      throw new RPError({\n        message:\n          'id_token detected in the response, you must use client.callback() instead of client.oauthCallback()',\n        params,\n      });\n    }\n    delete params.id_token;\n\n    const RESPONSE_TYPE_REQUIRED_PARAMS = {\n      code: ['code'],\n      token: ['access_token', 'token_type'],\n    };\n\n    if (checks.response_type) {\n      for (const type of checks.response_type.split(' ')) {\n        if (type === 'none') {\n          if (params.code || params.id_token || params.access_token) {\n            throw new RPError({\n              message: 'unexpected params encountered for \"none\" response',\n              checks,\n              params,\n            });\n          }\n        }\n\n        if (RESPONSE_TYPE_REQUIRED_PARAMS[type]) {\n          for (const param of RESPONSE_TYPE_REQUIRED_PARAMS[type]) {\n            if (!params[param]) {\n              throw new RPError({\n                message: `${param} missing from response`,\n                checks,\n                params,\n              });\n            }\n          }\n        }\n      }\n    }\n\n    if (params.code) {\n      const tokenset = await this.grant(\n        {\n          ...exchangeBody,\n          grant_type: 'authorization_code',\n          code: params.code,\n          redirect_uri: redirectUri,\n          code_verifier: checks.code_verifier,\n        },\n        { clientAssertionPayload, DPoP },\n      );\n\n      if (typeof tokenset.id_token === 'string' && tokenset.id_token.length) {\n        throw new RPError({\n          message:\n            'id_token detected in the response, you must use client.callback() instead of client.oauthCallback()',\n          params,\n        });\n      }\n      delete tokenset.id_token;\n\n      return tokenset;\n    }\n\n    return new TokenSet(params);\n  }\n\n  async decryptIdToken(token) {\n    if (!this.id_token_encrypted_response_alg) {\n      return token;\n    }\n\n    let idToken = token;\n\n    if (idToken instanceof TokenSet) {\n      if (!idToken.id_token) {\n        throw new TypeError('id_token not present in TokenSet');\n      }\n      idToken = idToken.id_token;\n    }\n\n    const expectedAlg = this.id_token_encrypted_response_alg;\n    const expectedEnc = this.id_token_encrypted_response_enc;\n\n    const result = await this.decryptJWE(idToken, expectedAlg, expectedEnc);\n\n    if (token instanceof TokenSet) {\n      token.id_token = result;\n      return token;\n    }\n\n    return result;\n  }\n\n  async validateJWTUserinfo(body) {\n    const expectedAlg = this.userinfo_signed_response_alg;\n\n    return this.validateJWT(body, expectedAlg, []);\n  }\n\n  async decryptJARM(response) {\n    if (!this.authorization_encrypted_response_alg) {\n      return response;\n    }\n\n    const expectedAlg = this.authorization_encrypted_response_alg;\n    const expectedEnc = this.authorization_encrypted_response_enc;\n\n    return this.decryptJWE(response, expectedAlg, expectedEnc);\n  }\n\n  async decryptJWTUserinfo(body) {\n    if (!this.userinfo_encrypted_response_alg) {\n      return body;\n    }\n\n    const expectedAlg = this.userinfo_encrypted_response_alg;\n    const expectedEnc = this.userinfo_encrypted_response_enc;\n\n    return this.decryptJWE(body, expectedAlg, expectedEnc);\n  }\n\n  async decryptJWE(jwe, expectedAlg, expectedEnc = 'A128CBC-HS256') {\n    const header = JSON.parse(base64url.decode(jwe.split('.')[0]));\n\n    if (header.alg !== expectedAlg) {\n      throw new RPError({\n        printf: ['unexpected JWE alg received, expected %s, got: %s', expectedAlg, header.alg],\n        jwt: jwe,\n      });\n    }\n\n    if (header.enc !== expectedEnc) {\n      throw new RPError({\n        printf: ['unexpected JWE enc received, expected %s, got: %s', expectedEnc, header.enc],\n        jwt: jwe,\n      });\n    }\n\n    const getPlaintext = (result) => new TextDecoder().decode(result.plaintext);\n    let plaintext;\n    if (expectedAlg.match(/^(?:RSA|ECDH)/)) {\n      const keystore = await keystores.get(this);\n\n      const protectedHeader = jose.decodeProtectedHeader(jwe);\n\n      for (const key of keystore.all({\n        ...protectedHeader,\n        use: 'enc',\n      })) {\n        plaintext = await jose\n          .compactDecrypt(jwe, await key.keyObject(protectedHeader.alg))\n          .then(getPlaintext, () => {});\n        if (plaintext) break;\n      }\n    } else {\n      plaintext = await jose\n        .compactDecrypt(jwe, this.secretForAlg(expectedAlg === 'dir' ? expectedEnc : expectedAlg))\n        .then(getPlaintext, () => {});\n    }\n\n    if (!plaintext) {\n      throw new RPError({\n        message: 'failed to decrypt JWE',\n        jwt: jwe,\n      });\n    }\n    return plaintext;\n  }\n\n  async validateIdToken(tokenSet, nonce, returnedBy, maxAge, state) {\n    let idToken = tokenSet;\n\n    const expectedAlg = this.id_token_signed_response_alg;\n\n    const isTokenSet = idToken instanceof TokenSet;\n\n    if (isTokenSet) {\n      if (!idToken.id_token) {\n        throw new TypeError('id_token not present in TokenSet');\n      }\n      idToken = idToken.id_token;\n    }\n\n    idToken = String(idToken);\n\n    const timestamp = now();\n    const { protected: header, payload, key } = await this.validateJWT(idToken, expectedAlg);\n\n    if (typeof maxAge === 'number' || (maxAge !== skipMaxAgeCheck && this.require_auth_time)) {\n      if (!payload.auth_time) {\n        throw new RPError({\n          message: 'missing required JWT property auth_time',\n          jwt: idToken,\n        });\n      }\n      if (typeof payload.auth_time !== 'number') {\n        throw new RPError({\n          message: 'JWT auth_time claim must be a JSON numeric value',\n          jwt: idToken,\n        });\n      }\n    }\n\n    if (\n      typeof maxAge === 'number' &&\n      payload.auth_time + maxAge < timestamp - this[CLOCK_TOLERANCE]\n    ) {\n      throw new RPError({\n        printf: [\n          'too much time has elapsed since the last End-User authentication, max_age %i, auth_time: %i, now %i',\n          maxAge,\n          payload.auth_time,\n          timestamp - this[CLOCK_TOLERANCE],\n        ],\n        now: timestamp,\n        tolerance: this[CLOCK_TOLERANCE],\n        auth_time: payload.auth_time,\n        jwt: idToken,\n      });\n    }\n\n    if (\n      nonce !== skipNonceCheck &&\n      (payload.nonce || nonce !== undefined) &&\n      payload.nonce !== nonce\n    ) {\n      throw new RPError({\n        printf: ['nonce mismatch, expected %s, got: %s', nonce, payload.nonce],\n        jwt: idToken,\n      });\n    }\n\n    if (returnedBy === 'authorization') {\n      if (!payload.at_hash && tokenSet.access_token) {\n        throw new RPError({\n          message: 'missing required property at_hash',\n          jwt: idToken,\n        });\n      }\n\n      if (!payload.c_hash && tokenSet.code) {\n        throw new RPError({\n          message: 'missing required property c_hash',\n          jwt: idToken,\n        });\n      }\n\n      if (this.fapi1()) {\n        if (!payload.s_hash && (tokenSet.state || state)) {\n          throw new RPError({\n            message: 'missing required property s_hash',\n            jwt: idToken,\n          });\n        }\n      }\n\n      if (payload.s_hash) {\n        if (!state) {\n          throw new TypeError('cannot verify s_hash, \"checks.state\" property not provided');\n        }\n\n        try {\n          tokenHash.validate(\n            { claim: 's_hash', source: 'state' },\n            payload.s_hash,\n            state,\n            header.alg,\n            key.jwk && key.jwk.crv,\n          );\n        } catch (err) {\n          throw new RPError({ message: err.message, jwt: idToken });\n        }\n      }\n    }\n\n    if (this.fapi() && payload.iat < timestamp - 3600) {\n      throw new RPError({\n        printf: ['JWT issued too far in the past, now %i, iat %i', timestamp, payload.iat],\n        now: timestamp,\n        tolerance: this[CLOCK_TOLERANCE],\n        iat: payload.iat,\n        jwt: idToken,\n      });\n    }\n\n    if (tokenSet.access_token && payload.at_hash !== undefined) {\n      try {\n        tokenHash.validate(\n          { claim: 'at_hash', source: 'access_token' },\n          payload.at_hash,\n          tokenSet.access_token,\n          header.alg,\n          key.jwk && key.jwk.crv,\n        );\n      } catch (err) {\n        throw new RPError({ message: err.message, jwt: idToken });\n      }\n    }\n\n    if (tokenSet.code && payload.c_hash !== undefined) {\n      try {\n        tokenHash.validate(\n          { claim: 'c_hash', source: 'code' },\n          payload.c_hash,\n          tokenSet.code,\n          header.alg,\n          key.jwk && key.jwk.crv,\n        );\n      } catch (err) {\n        throw new RPError({ message: err.message, jwt: idToken });\n      }\n    }\n\n    return tokenSet;\n  }\n\n  async validateJWT(jwt, expectedAlg, required = ['iss', 'sub', 'aud', 'exp', 'iat']) {\n    const isSelfIssued = this.issuer.issuer === 'https://self-issued.me';\n    const timestamp = now();\n    let header;\n    let payload;\n    try {\n      ({ header, payload } = decodeJWT(jwt, { complete: true }));\n    } catch (err) {\n      throw new RPError({\n        printf: ['failed to decode JWT (%s: %s)', err.name, err.message],\n        jwt,\n      });\n    }\n\n    if (header.alg !== expectedAlg) {\n      throw new RPError({\n        printf: ['unexpected JWT alg received, expected %s, got: %s', expectedAlg, header.alg],\n        jwt,\n      });\n    }\n\n    if (isSelfIssued) {\n      required = [...required, 'sub_jwk'];\n    }\n\n    required.forEach(verifyPresence.bind(undefined, payload, jwt));\n\n    if (payload.iss !== undefined) {\n      let expectedIss = this.issuer.issuer;\n\n      if (this.#aadIssValidation) {\n        expectedIss = this.issuer.issuer.replace('{tenantid}', payload.tid);\n      }\n\n      if (payload.iss !== expectedIss) {\n        throw new RPError({\n          printf: ['unexpected iss value, expected %s, got: %s', expectedIss, payload.iss],\n          jwt,\n        });\n      }\n    }\n\n    if (payload.iat !== undefined) {\n      if (typeof payload.iat !== 'number') {\n        throw new RPError({\n          message: 'JWT iat claim must be a JSON numeric value',\n          jwt,\n        });\n      }\n    }\n\n    if (payload.nbf !== undefined) {\n      if (typeof payload.nbf !== 'number') {\n        throw new RPError({\n          message: 'JWT nbf claim must be a JSON numeric value',\n          jwt,\n        });\n      }\n      if (payload.nbf > timestamp + this[CLOCK_TOLERANCE]) {\n        throw new RPError({\n          printf: [\n            'JWT not active yet, now %i, nbf %i',\n            timestamp + this[CLOCK_TOLERANCE],\n            payload.nbf,\n          ],\n          now: timestamp,\n          tolerance: this[CLOCK_TOLERANCE],\n          nbf: payload.nbf,\n          jwt,\n        });\n      }\n    }\n\n    if (payload.exp !== undefined) {\n      if (typeof payload.exp !== 'number') {\n        throw new RPError({\n          message: 'JWT exp claim must be a JSON numeric value',\n          jwt,\n        });\n      }\n      if (timestamp - this[CLOCK_TOLERANCE] >= payload.exp) {\n        throw new RPError({\n          printf: ['JWT expired, now %i, exp %i', timestamp - this[CLOCK_TOLERANCE], payload.exp],\n          now: timestamp,\n          tolerance: this[CLOCK_TOLERANCE],\n          exp: payload.exp,\n          jwt,\n        });\n      }\n    }\n\n    if (payload.aud !== undefined) {\n      if (Array.isArray(payload.aud)) {\n        if (payload.aud.length > 1 && !payload.azp) {\n          throw new RPError({\n            message: 'missing required JWT property azp',\n            jwt,\n          });\n        }\n\n        if (!payload.aud.includes(this.client_id)) {\n          throw new RPError({\n            printf: [\n              'aud is missing the client_id, expected %s to be included in %j',\n              this.client_id,\n              payload.aud,\n            ],\n            jwt,\n          });\n        }\n      } else if (payload.aud !== this.client_id) {\n        throw new RPError({\n          printf: ['aud mismatch, expected %s, got: %s', this.client_id, payload.aud],\n          jwt,\n        });\n      }\n    }\n\n    if (payload.azp !== undefined) {\n      let additionalAuthorizedParties = this.#additionalAuthorizedParties;\n\n      if (typeof additionalAuthorizedParties === 'string') {\n        additionalAuthorizedParties = [this.client_id, additionalAuthorizedParties];\n      } else if (Array.isArray(additionalAuthorizedParties)) {\n        additionalAuthorizedParties = [this.client_id, ...additionalAuthorizedParties];\n      } else {\n        additionalAuthorizedParties = [this.client_id];\n      }\n\n      if (!additionalAuthorizedParties.includes(payload.azp)) {\n        throw new RPError({\n          printf: ['azp mismatch, got: %s', payload.azp],\n          jwt,\n        });\n      }\n    }\n\n    let keys;\n\n    if (isSelfIssued) {\n      try {\n        assert(isPlainObject(payload.sub_jwk));\n        const key = await jose.importJWK(payload.sub_jwk, header.alg);\n        assert.equal(key.type, 'public');\n        keys = [\n          {\n            keyObject() {\n              return key;\n            },\n          },\n        ];\n      } catch (err) {\n        throw new RPError({\n          message: 'failed to use sub_jwk claim as an asymmetric JSON Web Key',\n          jwt,\n        });\n      }\n      if ((await jose.calculateJwkThumbprint(payload.sub_jwk)) !== payload.sub) {\n        throw new RPError({\n          message: 'failed to match the subject with sub_jwk',\n          jwt,\n        });\n      }\n    } else if (header.alg.startsWith('HS')) {\n      keys = [this.secretForAlg(header.alg)];\n    } else if (header.alg !== 'none') {\n      keys = await queryKeyStore.call(this.issuer, { ...header, use: 'sig' });\n    }\n\n    if (!keys && header.alg === 'none') {\n      return { protected: header, payload };\n    }\n\n    for (const key of keys) {\n      const verified = await jose\n        .compactVerify(jwt, key instanceof Uint8Array ? key : await key.keyObject(header.alg))\n        .catch(() => {});\n      if (verified) {\n        return {\n          payload,\n          protected: verified.protectedHeader,\n          key,\n        };\n      }\n    }\n\n    throw new RPError({\n      message: 'failed to validate JWT signature',\n      jwt,\n    });\n  }\n\n  async refresh(refreshToken, { exchangeBody, clientAssertionPayload, DPoP } = {}) {\n    let token = refreshToken;\n\n    if (token instanceof TokenSet) {\n      if (!token.refresh_token) {\n        throw new TypeError('refresh_token not present in TokenSet');\n      }\n      token = token.refresh_token;\n    }\n\n    const tokenset = await this.grant(\n      {\n        ...exchangeBody,\n        grant_type: 'refresh_token',\n        refresh_token: String(token),\n      },\n      { clientAssertionPayload, DPoP },\n    );\n\n    if (tokenset.id_token) {\n      await this.decryptIdToken(tokenset);\n      await this.validateIdToken(tokenset, skipNonceCheck, 'token', skipMaxAgeCheck);\n\n      if (refreshToken instanceof TokenSet && refreshToken.id_token) {\n        const expectedSub = refreshToken.claims().sub;\n        const actualSub = tokenset.claims().sub;\n        if (actualSub !== expectedSub) {\n          throw new RPError({\n            printf: ['sub mismatch, expected %s, got: %s', expectedSub, actualSub],\n            jwt: tokenset.id_token,\n          });\n        }\n      }\n    }\n\n    return tokenset;\n  }\n\n  async requestResource(\n    resourceUrl,\n    accessToken,\n    {\n      method,\n      headers,\n      body,\n      DPoP,\n      tokenType = DPoP\n        ? 'DPoP'\n        : accessToken instanceof TokenSet\n        ? accessToken.token_type\n        : 'Bearer',\n    } = {},\n    retry,\n  ) {\n    if (accessToken instanceof TokenSet) {\n      if (!accessToken.access_token) {\n        throw new TypeError('access_token not present in TokenSet');\n      }\n      accessToken = accessToken.access_token;\n    }\n\n    if (!accessToken) {\n      throw new TypeError('no access token provided');\n    } else if (typeof accessToken !== 'string') {\n      throw new TypeError('invalid access token provided');\n    }\n\n    const requestOpts = {\n      headers: {\n        Authorization: authorizationHeaderValue(accessToken, tokenType),\n        ...headers,\n      },\n      body,\n    };\n\n    const mTLS = !!this.tls_client_certificate_bound_access_tokens;\n\n    const response = await request.call(\n      this,\n      {\n        ...requestOpts,\n        responseType: 'buffer',\n        method,\n        url: resourceUrl,\n      },\n      { accessToken, mTLS, DPoP },\n    );\n\n    const wwwAuthenticate = response.headers['www-authenticate'];\n    if (\n      retry !== retryAttempt &&\n      wwwAuthenticate &&\n      wwwAuthenticate.toLowerCase().startsWith('dpop ') &&\n      parseWwwAuthenticate(wwwAuthenticate).error === 'use_dpop_nonce'\n    ) {\n      return this.requestResource(resourceUrl, accessToken, {\n        method,\n        headers,\n        body,\n        DPoP,\n        tokenType,\n      });\n    }\n\n    return response;\n  }\n\n  async userinfo(accessToken, { method = 'GET', via = 'header', tokenType, params, DPoP } = {}) {\n    assertIssuerConfiguration(this.issuer, 'userinfo_endpoint');\n    const options = {\n      tokenType,\n      method: String(method).toUpperCase(),\n      DPoP,\n    };\n\n    if (options.method !== 'GET' && options.method !== 'POST') {\n      throw new TypeError('#userinfo() method can only be POST or a GET');\n    }\n\n    if (via === 'body' && options.method !== 'POST') {\n      throw new TypeError('can only send body on POST');\n    }\n\n    const jwt = !!(this.userinfo_signed_response_alg || this.userinfo_encrypted_response_alg);\n\n    if (jwt) {\n      options.headers = { Accept: 'application/jwt' };\n    } else {\n      options.headers = { Accept: 'application/json' };\n    }\n    const mTLS = !!this.tls_client_certificate_bound_access_tokens;\n\n    let targetUrl;\n    if (mTLS && this.issuer.mtls_endpoint_aliases) {\n      targetUrl = this.issuer.mtls_endpoint_aliases.userinfo_endpoint;\n    }\n\n    targetUrl = new URL(targetUrl || this.issuer.userinfo_endpoint);\n\n    if (via === 'body') {\n      options.headers.Authorization = undefined;\n      options.headers['Content-Type'] = 'application/x-www-form-urlencoded';\n      options.body = new URLSearchParams();\n      options.body.append(\n        'access_token',\n        accessToken instanceof TokenSet ? accessToken.access_token : accessToken,\n      );\n    }\n\n    // handle additional parameters, GET via querystring, POST via urlencoded body\n    if (params) {\n      if (options.method === 'GET') {\n        Object.entries(params).forEach(([key, value]) => {\n          targetUrl.searchParams.append(key, value);\n        });\n      } else if (options.body) {\n        // POST && via body\n        Object.entries(params).forEach(([key, value]) => {\n          options.body.append(key, value);\n        });\n      } else {\n        // POST && via header\n        options.body = new URLSearchParams();\n        options.headers['Content-Type'] = 'application/x-www-form-urlencoded';\n        Object.entries(params).forEach(([key, value]) => {\n          options.body.append(key, value);\n        });\n      }\n    }\n\n    if (options.body) {\n      options.body = options.body.toString();\n    }\n\n    const response = await this.requestResource(targetUrl, accessToken, options);\n\n    let parsed = processResponse(response, { bearer: true });\n\n    if (jwt) {\n      if (!/^application\\/jwt/.test(response.headers['content-type'])) {\n        throw new RPError({\n          message: 'expected application/jwt response from the userinfo_endpoint',\n          response,\n        });\n      }\n\n      const body = response.body.toString();\n      const userinfo = await this.decryptJWTUserinfo(body);\n      if (!this.userinfo_signed_response_alg) {\n        try {\n          parsed = JSON.parse(userinfo);\n          assert(isPlainObject(parsed));\n        } catch (err) {\n          throw new RPError({\n            message: 'failed to parse userinfo JWE payload as JSON',\n            jwt: userinfo,\n          });\n        }\n      } else {\n        ({ payload: parsed } = await this.validateJWTUserinfo(userinfo));\n      }\n    } else {\n      try {\n        parsed = JSON.parse(response.body);\n      } catch (err) {\n        Object.defineProperty(err, 'response', { value: response });\n        throw err;\n      }\n    }\n\n    if (accessToken instanceof TokenSet && accessToken.id_token) {\n      const expectedSub = accessToken.claims().sub;\n      if (parsed.sub !== expectedSub) {\n        throw new RPError({\n          printf: ['userinfo sub mismatch, expected %s, got: %s', expectedSub, parsed.sub],\n          body: parsed,\n          jwt: accessToken.id_token,\n        });\n      }\n    }\n\n    return parsed;\n  }\n\n  encryptionSecret(len) {\n    const hash = len <= 256 ? 'sha256' : len <= 384 ? 'sha384' : len <= 512 ? 'sha512' : false;\n    if (!hash) {\n      throw new Error('unsupported symmetric encryption key derivation');\n    }\n\n    return crypto\n      .createHash(hash)\n      .update(this.client_secret)\n      .digest()\n      .slice(0, len / 8);\n  }\n\n  secretForAlg(alg) {\n    if (!this.client_secret) {\n      throw new TypeError('client_secret is required');\n    }\n\n    if (/^A(\\d{3})(?:GCM)?KW$/.test(alg)) {\n      return this.encryptionSecret(parseInt(RegExp.$1, 10));\n    }\n\n    if (/^A(\\d{3})(?:GCM|CBC-HS(\\d{3}))$/.test(alg)) {\n      return this.encryptionSecret(parseInt(RegExp.$2 || RegExp.$1, 10));\n    }\n\n    return new TextEncoder().encode(this.client_secret);\n  }\n\n  async grant(body, { clientAssertionPayload, DPoP } = {}, retry) {\n    assertIssuerConfiguration(this.issuer, 'token_endpoint');\n    const response = await authenticatedPost.call(\n      this,\n      'token',\n      {\n        form: body,\n        responseType: 'json',\n      },\n      { clientAssertionPayload, DPoP },\n    );\n    let responseBody;\n    try {\n      responseBody = processResponse(response);\n    } catch (err) {\n      if (retry !== retryAttempt && err instanceof OPError && err.error === 'use_dpop_nonce') {\n        return this.grant(body, { clientAssertionPayload, DPoP }, retryAttempt);\n      }\n      throw err;\n    }\n\n    return new TokenSet(responseBody);\n  }\n\n  async deviceAuthorization(params = {}, { exchangeBody, clientAssertionPayload, DPoP } = {}) {\n    assertIssuerConfiguration(this.issuer, 'device_authorization_endpoint');\n    assertIssuerConfiguration(this.issuer, 'token_endpoint');\n\n    const body = authorizationParams.call(this, {\n      client_id: this.client_id,\n      redirect_uri: null,\n      response_type: null,\n      ...params,\n    });\n\n    const response = await authenticatedPost.call(\n      this,\n      'device_authorization',\n      {\n        responseType: 'json',\n        form: body,\n      },\n      { clientAssertionPayload, endpointAuthMethod: 'token' },\n    );\n    const responseBody = processResponse(response);\n\n    return new DeviceFlowHandle({\n      client: this,\n      exchangeBody,\n      clientAssertionPayload,\n      response: responseBody,\n      maxAge: params.max_age,\n      DPoP,\n    });\n  }\n\n  async revoke(token, hint, { revokeBody, clientAssertionPayload } = {}) {\n    assertIssuerConfiguration(this.issuer, 'revocation_endpoint');\n    if (hint !== undefined && typeof hint !== 'string') {\n      throw new TypeError('hint must be a string');\n    }\n\n    const form = { ...revokeBody, token };\n\n    if (hint) {\n      form.token_type_hint = hint;\n    }\n\n    const response = await authenticatedPost.call(\n      this,\n      'revocation',\n      {\n        form,\n      },\n      { clientAssertionPayload },\n    );\n    processResponse(response, { body: false });\n  }\n\n  async introspect(token, hint, { introspectBody, clientAssertionPayload } = {}) {\n    assertIssuerConfiguration(this.issuer, 'introspection_endpoint');\n    if (hint !== undefined && typeof hint !== 'string') {\n      throw new TypeError('hint must be a string');\n    }\n\n    const form = { ...introspectBody, token };\n    if (hint) {\n      form.token_type_hint = hint;\n    }\n\n    const response = await authenticatedPost.call(\n      this,\n      'introspection',\n      { form, responseType: 'json' },\n      { clientAssertionPayload },\n    );\n\n    const responseBody = processResponse(response);\n\n    return responseBody;\n  }\n\n  static async register(metadata, options = {}) {\n    const { initialAccessToken, jwks, ...clientOptions } = options;\n\n    assertIssuerConfiguration(this.issuer, 'registration_endpoint');\n\n    if (jwks !== undefined && !(metadata.jwks || metadata.jwks_uri)) {\n      const keystore = await getKeystore.call(this, jwks);\n      metadata.jwks = keystore.toJWKS();\n    }\n\n    const response = await request.call(this, {\n      headers: {\n        Accept: 'application/json',\n        ...(initialAccessToken\n          ? {\n              Authorization: authorizationHeaderValue(initialAccessToken),\n            }\n          : undefined),\n      },\n      responseType: 'json',\n      json: metadata,\n      url: this.issuer.registration_endpoint,\n      method: 'POST',\n    });\n    const responseBody = processResponse(response, { statusCode: 201, bearer: true });\n\n    return new this(responseBody, jwks, clientOptions);\n  }\n\n  get metadata() {\n    return clone(Object.fromEntries(this.#metadata.entries()));\n  }\n\n  static async fromUri(registrationClientUri, registrationAccessToken, jwks, clientOptions) {\n    const response = await request.call(this, {\n      method: 'GET',\n      url: registrationClientUri,\n      responseType: 'json',\n      headers: {\n        Authorization: authorizationHeaderValue(registrationAccessToken),\n        Accept: 'application/json',\n      },\n    });\n    const responseBody = processResponse(response, { bearer: true });\n\n    return new this(responseBody, jwks, clientOptions);\n  }\n\n  async requestObject(\n    requestObject = {},\n    {\n      sign: signingAlgorithm = this.request_object_signing_alg || 'none',\n      encrypt: {\n        alg: eKeyManagement = this.request_object_encryption_alg,\n        enc: eContentEncryption = this.request_object_encryption_enc || 'A128CBC-HS256',\n      } = {},\n    } = {},\n  ) {\n    if (!isPlainObject(requestObject)) {\n      throw new TypeError('requestObject must be a plain object');\n    }\n\n    let signed;\n    let key;\n    const unix = now();\n    const header = { alg: signingAlgorithm, typ: 'oauth-authz-req+jwt' };\n    const payload = JSON.stringify(\n      defaults({}, requestObject, {\n        iss: this.client_id,\n        aud: this.issuer.issuer,\n        client_id: this.client_id,\n        jti: random(),\n        iat: unix,\n        exp: unix + 300,\n        ...(this.fapi() ? { nbf: unix } : undefined),\n      }),\n    );\n    if (signingAlgorithm === 'none') {\n      signed = [base64url.encode(JSON.stringify(header)), base64url.encode(payload), ''].join('.');\n    } else {\n      const symmetric = signingAlgorithm.startsWith('HS');\n      if (symmetric) {\n        key = this.secretForAlg(signingAlgorithm);\n      } else {\n        const keystore = await keystores.get(this);\n\n        if (!keystore) {\n          throw new TypeError(\n            `no keystore present for client, cannot sign using alg ${signingAlgorithm}`,\n          );\n        }\n        key = keystore.get({ alg: signingAlgorithm, use: 'sig' });\n        if (!key) {\n          throw new TypeError(`no key to sign with found for alg ${signingAlgorithm}`);\n        }\n      }\n\n      signed = await new jose.CompactSign(new TextEncoder().encode(payload))\n        .setProtectedHeader({\n          ...header,\n          kid: symmetric ? undefined : key.jwk.kid,\n        })\n        .sign(symmetric ? key : await key.keyObject(signingAlgorithm));\n    }\n\n    if (!eKeyManagement) {\n      return signed;\n    }\n\n    const fields = { alg: eKeyManagement, enc: eContentEncryption, cty: 'oauth-authz-req+jwt' };\n\n    if (fields.alg.match(/^(RSA|ECDH)/)) {\n      [key] = await queryKeyStore.call(\n        this.issuer,\n        { alg: fields.alg, use: 'enc' },\n        { allowMulti: true },\n      );\n    } else {\n      key = this.secretForAlg(fields.alg === 'dir' ? fields.enc : fields.alg);\n    }\n\n    return new jose.CompactEncrypt(new TextEncoder().encode(signed))\n      .setProtectedHeader({\n        ...fields,\n        kid: key instanceof Uint8Array ? undefined : key.jwk.kid,\n      })\n      .encrypt(key instanceof Uint8Array ? key : await key.keyObject(fields.alg));\n  }\n\n  async pushedAuthorizationRequest(params = {}, { clientAssertionPayload } = {}) {\n    assertIssuerConfiguration(this.issuer, 'pushed_authorization_request_endpoint');\n\n    const body = {\n      ...('request' in params ? params : authorizationParams.call(this, params)),\n      client_id: this.client_id,\n    };\n\n    const response = await authenticatedPost.call(\n      this,\n      'pushed_authorization_request',\n      {\n        responseType: 'json',\n        form: body,\n      },\n      { clientAssertionPayload, endpointAuthMethod: 'token' },\n    );\n    const responseBody = processResponse(response, { statusCode: 201 });\n\n    if (!('expires_in' in responseBody)) {\n      throw new RPError({\n        message: 'expected expires_in in Pushed Authorization Successful Response',\n        response,\n      });\n    }\n    if (typeof responseBody.expires_in !== 'number') {\n      throw new RPError({\n        message: 'invalid expires_in value in Pushed Authorization Successful Response',\n        response,\n      });\n    }\n    if (!('request_uri' in responseBody)) {\n      throw new RPError({\n        message: 'expected request_uri in Pushed Authorization Successful Response',\n        response,\n      });\n    }\n    if (typeof responseBody.request_uri !== 'string') {\n      throw new RPError({\n        message: 'invalid request_uri value in Pushed Authorization Successful Response',\n        response,\n      });\n    }\n\n    return responseBody;\n  }\n\n  get issuer() {\n    return this.#issuer;\n  }\n\n  /* istanbul ignore next */\n  [inspect.custom]() {\n    return `${this.constructor.name} ${inspect(this.metadata, {\n      depth: Infinity,\n      colors: process.stdout.isTTY,\n      compact: false,\n      sorted: true,\n    })}`;\n  }\n\n  fapi() {\n    return this.fapi1() || this.fapi2();\n  }\n\n  fapi1() {\n    return this.constructor.name === 'FAPI1Client';\n  }\n\n  fapi2() {\n    return this.constructor.name === 'FAPI2Client';\n  }\n\n  async validateJARM(response) {\n    const expectedAlg = this.authorization_signed_response_alg;\n    const { payload } = await this.validateJWT(response, expectedAlg, ['iss', 'exp', 'aud']);\n    return pickCb(payload);\n  }\n\n  /**\n   * @name dpopProof\n   * @api private\n   */\n  async dpopProof(payload, privateKeyInput, accessToken) {\n    if (!isPlainObject(payload)) {\n      throw new TypeError('payload must be a plain object');\n    }\n\n    let privateKey;\n    if (isKeyObject(privateKeyInput)) {\n      privateKey = privateKeyInput;\n    } else if (privateKeyInput[Symbol.toStringTag] === 'CryptoKey') {\n      privateKey = privateKeyInput;\n    } else if (jose.cryptoRuntime === 'node:crypto') {\n      privateKey = crypto.createPrivateKey(privateKeyInput);\n    } else {\n      throw new TypeError('unrecognized crypto runtime');\n    }\n\n    if (privateKey.type !== 'private') {\n      throw new TypeError('\"DPoP\" option must be a private key');\n    }\n    let alg = determineDPoPAlgorithm.call(this, privateKey, privateKeyInput);\n\n    if (!alg) {\n      throw new TypeError('could not determine DPoP JWS Algorithm');\n    }\n\n    return new jose.SignJWT({\n      ath: accessToken\n        ? base64url.encode(crypto.createHash('sha256').update(accessToken).digest())\n        : undefined,\n      ...payload,\n    })\n      .setProtectedHeader({\n        alg,\n        typ: 'dpop+jwt',\n        jwk: await getJwk(privateKey, privateKeyInput),\n      })\n      .setIssuedAt()\n      .setJti(random())\n      .sign(privateKey);\n  }\n}\n\nfunction determineDPoPAlgorithmFromCryptoKey(cryptoKey) {\n  switch (cryptoKey.algorithm.name) {\n    case 'Ed25519':\n    case 'Ed448':\n      return 'EdDSA';\n    case 'ECDSA': {\n      switch (cryptoKey.algorithm.namedCurve) {\n        case 'P-256':\n          return 'ES256';\n        case 'P-384':\n          return 'ES384';\n        case 'P-521':\n          return 'ES512';\n        default:\n          break;\n      }\n      break;\n    }\n    case 'RSASSA-PKCS1-v1_5':\n      return `RS${cryptoKey.algorithm.hash.name.slice(4)}`;\n    case 'RSA-PSS':\n      return `PS${cryptoKey.algorithm.hash.name.slice(4)}`;\n    default:\n      throw new TypeError('unsupported DPoP private key');\n  }\n}\n\nlet determineDPoPAlgorithm;\nif (jose.cryptoRuntime === 'node:crypto') {\n  determineDPoPAlgorithm = function (privateKey, privateKeyInput) {\n    if (privateKeyInput[Symbol.toStringTag] === 'CryptoKey') {\n      return determineDPoPAlgorithmFromCryptoKey(privateKey);\n    }\n\n    switch (privateKey.asymmetricKeyType) {\n      case 'ed25519':\n      case 'ed448':\n        return 'EdDSA';\n      case 'ec':\n        return determineEcAlgorithm(privateKey, privateKeyInput);\n      case 'rsa':\n      case rsaPssParams && 'rsa-pss':\n        return determineRsaAlgorithm(\n          privateKey,\n          privateKeyInput,\n          this.issuer.dpop_signing_alg_values_supported,\n        );\n      default:\n        throw new TypeError('unsupported DPoP private key');\n    }\n  };\n\n  const RSPS = /^(?:RS|PS)(?:256|384|512)$/;\n  function determineRsaAlgorithm(privateKey, privateKeyInput, valuesSupported) {\n    if (\n      typeof privateKeyInput === 'object' &&\n      privateKeyInput.format === 'jwk' &&\n      privateKeyInput.key &&\n      privateKeyInput.key.alg\n    ) {\n      return privateKeyInput.key.alg;\n    }\n\n    if (Array.isArray(valuesSupported)) {\n      let candidates = valuesSupported.filter(RegExp.prototype.test.bind(RSPS));\n      if (privateKey.asymmetricKeyType === 'rsa-pss') {\n        candidates = candidates.filter((value) => value.startsWith('PS'));\n      }\n      return ['PS256', 'PS384', 'PS512', 'RS256', 'RS384', 'RS384'].find((preferred) =>\n        candidates.includes(preferred),\n      );\n    }\n\n    return 'PS256';\n  }\n\n  const p256 = Buffer.from([42, 134, 72, 206, 61, 3, 1, 7]);\n  const p384 = Buffer.from([43, 129, 4, 0, 34]);\n  const p521 = Buffer.from([43, 129, 4, 0, 35]);\n  const secp256k1 = Buffer.from([43, 129, 4, 0, 10]);\n\n  function determineEcAlgorithm(privateKey, privateKeyInput) {\n    // If input was a JWK\n    switch (\n      typeof privateKeyInput === 'object' &&\n      typeof privateKeyInput.key === 'object' &&\n      privateKeyInput.key.crv\n    ) {\n      case 'P-256':\n        return 'ES256';\n      case 'secp256k1':\n        return 'ES256K';\n      case 'P-384':\n        return 'ES384';\n      case 'P-512':\n        return 'ES512';\n      default:\n        break;\n    }\n\n    const buf = privateKey.export({ format: 'der', type: 'pkcs8' });\n    const i = buf[1] < 128 ? 17 : 18;\n    const len = buf[i];\n    const curveOid = buf.slice(i + 1, i + 1 + len);\n    if (curveOid.equals(p256)) {\n      return 'ES256';\n    }\n\n    if (curveOid.equals(p384)) {\n      return 'ES384';\n    }\n    if (curveOid.equals(p521)) {\n      return 'ES512';\n    }\n\n    if (curveOid.equals(secp256k1)) {\n      return 'ES256K';\n    }\n\n    throw new TypeError('unsupported DPoP private key curve');\n  }\n} else {\n  determineDPoPAlgorithm = determineDPoPAlgorithmFromCryptoKey;\n}\n\nconst jwkCache = new WeakMap();\nasync function getJwk(keyObject, privateKeyInput) {\n  if (\n    jose.cryptoRuntime === 'node:crypto' &&\n    typeof privateKeyInput === 'object' &&\n    typeof privateKeyInput.key === 'object' &&\n    privateKeyInput.format === 'jwk'\n  ) {\n    return pick(privateKeyInput.key, 'kty', 'crv', 'x', 'y', 'e', 'n');\n  }\n\n  if (jwkCache.has(privateKeyInput)) {\n    return jwkCache.get(privateKeyInput);\n  }\n\n  const jwk = pick(await jose.exportJWK(keyObject), 'kty', 'crv', 'x', 'y', 'e', 'n');\n\n  if (isKeyObject(privateKeyInput) || jose.cryptoRuntime === 'WebCryptoAPI') {\n    jwkCache.set(privateKeyInput, jwk);\n  }\n\n  return jwk;\n}\n\nmodule.exports = (issuer, aadIssValidation = false) =>\n  class Client extends BaseClient {\n    constructor(...args) {\n      super(issuer, aadIssValidation, ...args);\n    }\n\n    static get issuer() {\n      return issuer;\n    }\n  };\n\nmodule.exports.BaseClient = BaseClient;\n"],"names":["inspect","stdhttp","crypto","strict","assert","querystring","url","URL","URLSearchParams","jose","tokenHash","isKeyObject","decodeJWT","base64url","defaults","parseWwwAuthenticate","assertSigningAlgValuesSupport","assertIssuerConfiguration","pick","isPlainObject","processResponse","TokenSet","OPError","RPError","now","random","request","CLOCK_TOLERANCE","keystores","KeyStore","clone","authenticatedPost","resolveResponseType","resolveRedirectUri","queryKeyStore","DeviceFlowHandle","major","minor","process","version","slice","split","map","str","parseInt","rsaPssParams","retryAttempt","Symbol","skipNonceCheck","skipMaxAgeCheck","pickCb","input","authorizationHeaderValue","token","tokenType","getSearchParams","parsed","parse","search","substring","verifyPresence","payload","jwt","prop","undefined","message","authorizationParams","params","authParams","client_id","scope","response_type","call","redirect_uri","Object","entries","forEach","key","value","JSON","stringify","Array","isArray","String","getKeystore","jwks","keys","some","k","TypeError","fromJWKS","onlyPrivate","checkBasicSupport","client","properties","supported","issuer","token_endpoint_auth_methods_supported","includes","token_endpoint_auth_method","err","handleCommonMistakes","metadata","redirect_uris","response_types","getDefaultsForEndpoint","endpoint","tokenEndpointAuthMethod","tokenEndpointAuthSigningAlg","token_endpoint_auth_signing_alg","eam","easa","BaseClient","aadIssValidation","options","Map","grant_types","id_token_signed_response_alg","authorization_signed_response_alg","fapi1","tls_client_certificate_bound_access_tokens","fapi2","fapi","dpop_bound_access_tokens","set","defineProperty","get","enumerable","keystore","additionalAuthorizedParties","authorizationUrl","target","authorization_endpoint","name","searchParams","delete","member","append","href","replace","authorizationPost","inputs","formInputs","join","endSessionUrl","postLogout","length","post_logout_redirect_uris","post_logout_redirect_uri","id_token_hint","id_token","end_session_endpoint","query","format","callbackParams","isIncomingMessage","IncomingMessage","method","isString","body","Buffer","isBuffer","toString","callback","redirectUri","parameters","checks","exchangeBody","clientAssertionPayload","DPoP","jarm","decrypted","decryptJARM","response","validateJARM","default_max_age","max_age","state","printf","iss","authorization_response_iss_parameter_supported","error","RESPONSE_TYPE_REQUIRED_PARAMS","code","type","access_token","param","tokenset","decryptIdToken","validateIdToken","nonce","grant","grant_type","code_verifier","session_state","oauthCallback","id_token_encrypted_response_alg","idToken","expectedAlg","expectedEnc","id_token_encrypted_response_enc","result","decryptJWE","validateJWTUserinfo","userinfo_signed_response_alg","validateJWT","authorization_encrypted_response_alg","authorization_encrypted_response_enc","decryptJWTUserinfo","userinfo_encrypted_response_alg","userinfo_encrypted_response_enc","jwe","header","decode","alg","enc","getPlaintext","TextDecoder","plaintext","match","protectedHeader","decodeProtectedHeader","all","use","compactDecrypt","keyObject","then","secretForAlg","tokenSet","returnedBy","maxAge","isTokenSet","timestamp","protected","require_auth_time","auth_time","tolerance","at_hash","c_hash","s_hash","validate","claim","source","jwk","crv","iat","required","isSelfIssued","complete","bind","expectedIss","tid","nbf","exp","aud","azp","sub_jwk","importJWK","equal","calculateJwkThumbprint","sub","startsWith","verified","compactVerify","Uint8Array","catch","refresh","refreshToken","refresh_token","expectedSub","claims","actualSub","requestResource","resourceUrl","accessToken","headers","token_type","retry","requestOpts","Authorization","mTLS","responseType","wwwAuthenticate","toLowerCase","userinfo","via","toUpperCase","Accept","targetUrl","mtls_endpoint_aliases","userinfo_endpoint","bearer","test","encryptionSecret","len","hash","Error","createHash","update","client_secret","digest","RegExp","$1","$2","TextEncoder","encode","form","responseBody","deviceAuthorization","endpointAuthMethod","revoke","hint","revokeBody","token_type_hint","introspect","introspectBody","register","initialAccessToken","clientOptions","jwks_uri","toJWKS","json","registration_endpoint","statusCode","fromEntries","fromUri","registrationClientUri","registrationAccessToken","requestObject","sign","signingAlgorithm","request_object_signing_alg","encrypt","eKeyManagement","request_object_encryption_alg","eContentEncryption","request_object_encryption_enc","signed","unix","typ","jti","symmetric","CompactSign","setProtectedHeader","kid","fields","cty","allowMulti","CompactEncrypt","pushedAuthorizationRequest","expires_in","request_uri","custom","depth","Infinity","colors","stdout","isTTY","compact","sorted","dpopProof","privateKeyInput","privateKey","toStringTag","cryptoRuntime","createPrivateKey","determineDPoPAlgorithm","SignJWT","ath","getJwk","setIssuedAt","setJti","determineDPoPAlgorithmFromCryptoKey","cryptoKey","algorithm","namedCurve","asymmetricKeyType","determineEcAlgorithm","determineRsaAlgorithm","dpop_signing_alg_values_supported","RSPS","valuesSupported","candidates","filter","prototype","find","preferred","p256","from","p384","p521","secp256k1","buf","export","i","curveOid","equals","jwkCache","WeakMap","has","exportJWK","module","exports","Client","args"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 2852, "column": 0}, "map": {"version":3,"sources":["file:///D:/AconnectJP/node_modules/openid-client/lib/issuer_registry.js"],"sourcesContent":["const LRU = require('lru-cache');\n\nmodule.exports = new LRU({ max: 100 });\n"],"names":["LRU","module","exports","max"],"mappings":"AAAA,MAAMA;AAENC,OAAOC,OAAO,GAAG,IAAIF,IAAI;IAAEG,KAAK;AAAI","ignoreList":[0]}},
    {"offset": {"line": 2859, "column": 0}, "map": {"version":3,"sources":["file:///D:/AconnectJP/node_modules/openid-client/lib/helpers/webfinger_normalize.js"],"sourcesContent":["// Credit: https://github.com/rohe/pyoidc/blob/master/src/oic/utils/webfinger.py\n\n// -- Normalization --\n// A string of any other type is interpreted as a URI either the form of scheme\n// \"://\" authority path-abempty [ \"?\" query ] [ \"#\" fragment ] or authority\n// path-abempty [ \"?\" query ] [ \"#\" fragment ] per RFC 3986 [RFC3986] and is\n// normalized according to the following rules:\n//\n// If the user input Identifier does not have an RFC 3986 [RFC3986] scheme\n// portion, the string is interpreted as [userinfo \"@\"] host [\":\" port]\n// path-abempty [ \"?\" query ] [ \"#\" fragment ] per RFC 3986 [RFC3986].\n// If the userinfo component is present and all of the path component, query\n// component, and port component are empty, the acct scheme is assumed. In this\n// case, the normalized URI is formed by prefixing acct: to the string as the\n// scheme. Per the 'acct' URI Scheme [ID.ietfappsawgaccturi], if there is an\n// at-sign character ('@') in the userinfo component, it needs to be\n// percent-encoded as described in RFC 3986 [RFC3986].\n// For all other inputs without a scheme portion, the https scheme is assumed,\n// and the normalized URI is formed by prefixing https:// to the string as the\n// scheme.\n// If the resulting URI contains a fragment portion, it MUST be stripped off\n// together with the fragment delimiter character \"#\".\n// The WebFinger [ID.ietfappsawgwebfinger] Resource in this case is the\n// resulting URI, and the WebFinger Host is the authority component.\n//\n// Note: Since the definition of authority in RFC 3986 [RFC3986] is\n// [ userinfo \"@\" ] host [ \":\" port ], it is legal to have a user input\n// identifier like userinfo@host:port, e.g., alice@example.com:8080.\n\nconst PORT = /^\\d+$/;\n\nfunction hasScheme(input) {\n  if (input.includes('://')) return true;\n\n  const authority = input.replace(/(\\/|\\?)/g, '#').split('#')[0];\n  if (authority.includes(':')) {\n    const index = authority.indexOf(':');\n    const hostOrPort = authority.slice(index + 1);\n    if (!PORT.test(hostOrPort)) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction acctSchemeAssumed(input) {\n  if (!input.includes('@')) return false;\n  const parts = input.split('@');\n  const host = parts[parts.length - 1];\n  return !(host.includes(':') || host.includes('/') || host.includes('?'));\n}\n\nfunction normalize(input) {\n  if (typeof input !== 'string') {\n    throw new TypeError('input must be a string');\n  }\n\n  let output;\n  if (hasScheme(input)) {\n    output = input;\n  } else if (acctSchemeAssumed(input)) {\n    output = `acct:${input}`;\n  } else {\n    output = `https://${input}`;\n  }\n\n  return output.split('#')[0];\n}\n\nmodule.exports = normalize;\n"],"names":["PORT","hasScheme","input","includes","authority","replace","split","index","indexOf","hostOrPort","slice","test","acctSchemeAssumed","parts","host","length","normalize","TypeError","output","module","exports"],"mappings":"AAAA,gFAAgF;AAEhF,sBAAsB;AACtB,+EAA+E;AAC/E,2EAA2E;AAC3E,4EAA4E;AAC5E,+CAA+C;AAC/C,EAAE;AACF,0EAA0E;AAC1E,uEAAuE;AACvE,sEAAsE;AACtE,4EAA4E;AAC5E,+EAA+E;AAC/E,6EAA6E;AAC7E,gFAAgF;AAChF,oEAAoE;AACpE,sDAAsD;AACtD,8EAA8E;AAC9E,8EAA8E;AAC9E,UAAU;AACV,4EAA4E;AAC5E,sDAAsD;AACtD,0EAA0E;AAC1E,oEAAoE;AACpE,EAAE;AACF,mEAAmE;AACnE,uEAAuE;AACvE,oEAAoE;AAEpE,MAAMA,OAAO;AAEb,SAASC,UAAUC,KAAK;IACtB,IAAIA,MAAMC,QAAQ,CAAC,QAAQ,OAAO;IAElC,MAAMC,YAAYF,MAAMG,OAAO,CAAC,YAAY,KAAKC,KAAK,CAAC,IAAI,CAAC,EAAE;IAC9D,IAAIF,UAAUD,QAAQ,CAAC,MAAM;QAC3B,MAAMI,QAAQH,UAAUI,OAAO,CAAC;QAChC,MAAMC,aAAaL,UAAUM,KAAK,CAACH,QAAQ;QAC3C,IAAI,CAACP,KAAKW,IAAI,CAACF,aAAa;YAC1B,OAAO;QACT;IACF;IAEA,OAAO;AACT;AAEA,SAASG,kBAAkBV,KAAK;IAC9B,IAAI,CAACA,MAAMC,QAAQ,CAAC,MAAM,OAAO;IACjC,MAAMU,QAAQX,MAAMI,KAAK,CAAC;IAC1B,MAAMQ,OAAOD,KAAK,CAACA,MAAME,MAAM,GAAG,EAAE;IACpC,OAAO,CAAC,CAACD,KAAKX,QAAQ,CAAC,QAAQW,KAAKX,QAAQ,CAAC,QAAQW,KAAKX,QAAQ,CAAC,IAAI;AACzE;AAEA,SAASa,UAAUd,KAAK;IACtB,IAAI,OAAOA,UAAU,UAAU;QAC7B,MAAM,IAAIe,UAAU;IACtB;IAEA,IAAIC;IACJ,IAAIjB,UAAUC,QAAQ;QACpBgB,SAAShB;IACX,OAAO,IAAIU,kBAAkBV,QAAQ;QACnCgB,SAAS,CAAC,KAAK,EAAEhB,OAAO;IAC1B,OAAO;QACLgB,SAAS,CAAC,QAAQ,EAAEhB,OAAO;IAC7B;IAEA,OAAOgB,OAAOZ,KAAK,CAAC,IAAI,CAAC,EAAE;AAC7B;AAEAa,OAAOC,OAAO,GAAGJ","ignoreList":[0]}},
    {"offset": {"line": 2923, "column": 0}, "map": {"version":3,"sources":["file:///D:/AconnectJP/node_modules/openid-client/lib/issuer.js"],"sourcesContent":["const { inspect } = require('util');\nconst url = require('url');\n\nconst { RPError } = require('./errors');\nconst getClient = require('./client');\nconst registry = require('./issuer_registry');\nconst processResponse = require('./helpers/process_response');\nconst webfingerNormalize = require('./helpers/webfinger_normalize');\nconst request = require('./helpers/request');\nconst clone = require('./helpers/deep_clone');\nconst { keystore } = require('./helpers/issuer');\n\nconst AAD_MULTITENANT_DISCOVERY = [\n  'https://login.microsoftonline.com/common/.well-known/openid-configuration',\n  'https://login.microsoftonline.com/common/v2.0/.well-known/openid-configuration',\n  'https://login.microsoftonline.com/organizations/v2.0/.well-known/openid-configuration',\n  'https://login.microsoftonline.com/consumers/v2.0/.well-known/openid-configuration',\n];\nconst AAD_MULTITENANT = Symbol();\nconst ISSUER_DEFAULTS = {\n  claim_types_supported: ['normal'],\n  claims_parameter_supported: false,\n  grant_types_supported: ['authorization_code', 'implicit'],\n  request_parameter_supported: false,\n  request_uri_parameter_supported: true,\n  require_request_uri_registration: false,\n  response_modes_supported: ['query', 'fragment'],\n  token_endpoint_auth_methods_supported: ['client_secret_basic'],\n};\n\nclass Issuer {\n  #metadata;\n  constructor(meta = {}) {\n    const aadIssValidation = meta[AAD_MULTITENANT];\n    delete meta[AAD_MULTITENANT];\n    ['introspection', 'revocation'].forEach((endpoint) => {\n      // if intro/revocation endpoint auth specific meta is missing use the token ones if they\n      // are defined\n      if (\n        meta[`${endpoint}_endpoint`] &&\n        meta[`${endpoint}_endpoint_auth_methods_supported`] === undefined &&\n        meta[`${endpoint}_endpoint_auth_signing_alg_values_supported`] === undefined\n      ) {\n        if (meta.token_endpoint_auth_methods_supported) {\n          meta[`${endpoint}_endpoint_auth_methods_supported`] =\n            meta.token_endpoint_auth_methods_supported;\n        }\n        if (meta.token_endpoint_auth_signing_alg_values_supported) {\n          meta[`${endpoint}_endpoint_auth_signing_alg_values_supported`] =\n            meta.token_endpoint_auth_signing_alg_values_supported;\n        }\n      }\n    });\n\n    this.#metadata = new Map();\n\n    Object.entries(meta).forEach(([key, value]) => {\n      this.#metadata.set(key, value);\n      if (!this[key]) {\n        Object.defineProperty(this, key, {\n          get() {\n            return this.#metadata.get(key);\n          },\n          enumerable: true,\n        });\n      }\n    });\n\n    registry.set(this.issuer, this);\n\n    const Client = getClient(this, aadIssValidation);\n\n    Object.defineProperties(this, {\n      Client: { value: Client, enumerable: true },\n      FAPI1Client: { value: class FAPI1Client extends Client {}, enumerable: true },\n      FAPI2Client: { value: class FAPI2Client extends Client {}, enumerable: true },\n    });\n  }\n\n  get metadata() {\n    return clone(Object.fromEntries(this.#metadata.entries()));\n  }\n\n  static async webfinger(input) {\n    const resource = webfingerNormalize(input);\n    const { host } = url.parse(resource);\n    const webfingerUrl = `https://${host}/.well-known/webfinger`;\n\n    const response = await request.call(this, {\n      method: 'GET',\n      url: webfingerUrl,\n      responseType: 'json',\n      searchParams: { resource, rel: 'http://openid.net/specs/connect/1.0/issuer' },\n      headers: {\n        Accept: 'application/json',\n      },\n    });\n    const body = processResponse(response);\n\n    const location =\n      Array.isArray(body.links) &&\n      body.links.find(\n        (link) =>\n          typeof link === 'object' &&\n          link.rel === 'http://openid.net/specs/connect/1.0/issuer' &&\n          link.href,\n      );\n\n    if (!location) {\n      throw new RPError({\n        message: 'no issuer found in webfinger response',\n        body,\n      });\n    }\n\n    if (typeof location.href !== 'string' || !location.href.startsWith('https://')) {\n      throw new RPError({\n        printf: ['invalid issuer location %s', location.href],\n        body,\n      });\n    }\n\n    const expectedIssuer = location.href;\n    if (registry.has(expectedIssuer)) {\n      return registry.get(expectedIssuer);\n    }\n\n    const issuer = await this.discover(expectedIssuer);\n\n    if (issuer.issuer !== expectedIssuer) {\n      registry.del(issuer.issuer);\n      throw new RPError(\n        'discovered issuer mismatch, expected %s, got: %s',\n        expectedIssuer,\n        issuer.issuer,\n      );\n    }\n    return issuer;\n  }\n\n  static async discover(uri) {\n    const wellKnownUri = resolveWellKnownUri(uri);\n\n    const response = await request.call(this, {\n      method: 'GET',\n      responseType: 'json',\n      url: wellKnownUri,\n      headers: {\n        Accept: 'application/json',\n      },\n    });\n    const body = processResponse(response);\n    return new Issuer({\n      ...ISSUER_DEFAULTS,\n      ...body,\n      [AAD_MULTITENANT]: !!AAD_MULTITENANT_DISCOVERY.find((discoveryURL) =>\n        wellKnownUri.startsWith(discoveryURL),\n      ),\n    });\n  }\n\n  async reloadJwksUri() {\n    await keystore.call(this, true);\n  }\n\n  /* istanbul ignore next */\n  [inspect.custom]() {\n    return `${this.constructor.name} ${inspect(this.metadata, {\n      depth: Infinity,\n      colors: process.stdout.isTTY,\n      compact: false,\n      sorted: true,\n    })}`;\n  }\n}\n\nfunction resolveWellKnownUri(uri) {\n  const parsed = url.parse(uri);\n  if (parsed.pathname.includes('/.well-known/')) {\n    return uri;\n  } else {\n    let pathname;\n    if (parsed.pathname.endsWith('/')) {\n      pathname = `${parsed.pathname}.well-known/openid-configuration`;\n    } else {\n      pathname = `${parsed.pathname}/.well-known/openid-configuration`;\n    }\n    return url.format({ ...parsed, pathname });\n  }\n}\n\nmodule.exports = Issuer;\n"],"names":["inspect","url","RPError","getClient","registry","processResponse","webfingerNormalize","request","clone","keystore","AAD_MULTITENANT_DISCOVERY","AAD_MULTITENANT","Symbol","ISSUER_DEFAULTS","claim_types_supported","claims_parameter_supported","grant_types_supported","request_parameter_supported","request_uri_parameter_supported","require_request_uri_registration","response_modes_supported","token_endpoint_auth_methods_supported","Issuer","meta","aadIssValidation","forEach","endpoint","undefined","token_endpoint_auth_signing_alg_values_supported","Map","Object","entries","key","value","set","defineProperty","get","enumerable","issuer","Client","defineProperties","FAPI1Client","FAPI2Client","metadata","fromEntries","webfinger","input","resource","host","parse","webfingerUrl","response","call","method","responseType","searchParams","rel","headers","Accept","body","location","Array","isArray","links","find","link","href","message","startsWith","printf","expectedIssuer","has","discover","del","uri","wellKnownUri","resolveWellKnownUri","discoveryURL","reloadJwksUri","custom","name","depth","Infinity","colors","process","stdout","isTTY","compact","sorted","parsed","pathname","includes","endsWith","format","module","exports"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 3108, "column": 0}, "map": {"version":3,"sources":["file:///D:/AconnectJP/node_modules/openid-client/lib/passport_strategy.js"],"sourcesContent":["const url = require('url');\nconst { format } = require('util');\n\nconst cloneDeep = require('./helpers/deep_clone');\nconst { RPError, OPError } = require('./errors');\nconst { BaseClient } = require('./client');\nconst { random, codeChallenge } = require('./helpers/generators');\nconst pick = require('./helpers/pick');\nconst { resolveResponseType, resolveRedirectUri } = require('./helpers/client');\n\nfunction verified(err, user, info = {}) {\n  if (err) {\n    this.error(err);\n  } else if (!user) {\n    this.fail(info);\n  } else {\n    this.success(user, info);\n  }\n}\n\nfunction OpenIDConnectStrategy(\n  { client, params = {}, passReqToCallback = false, sessionKey, usePKCE = true, extras = {} } = {},\n  verify,\n) {\n  if (!(client instanceof BaseClient)) {\n    throw new TypeError('client must be an instance of openid-client Client');\n  }\n\n  if (typeof verify !== 'function') {\n    throw new TypeError('verify callback must be a function');\n  }\n\n  if (!client.issuer || !client.issuer.issuer) {\n    throw new TypeError('client must have an issuer with an identifier');\n  }\n\n  this._client = client;\n  this._issuer = client.issuer;\n  this._verify = verify;\n  this._passReqToCallback = passReqToCallback;\n  this._usePKCE = usePKCE;\n  this._key = sessionKey || `oidc:${url.parse(this._issuer.issuer).hostname}`;\n  this._params = cloneDeep(params);\n\n  // state and nonce are handled in authenticate()\n  delete this._params.state;\n  delete this._params.nonce;\n\n  this._extras = cloneDeep(extras);\n\n  if (!this._params.response_type) this._params.response_type = resolveResponseType.call(client);\n  if (!this._params.redirect_uri) this._params.redirect_uri = resolveRedirectUri.call(client);\n  if (!this._params.scope) this._params.scope = 'openid';\n\n  if (this._usePKCE === true) {\n    const supportedMethods = Array.isArray(this._issuer.code_challenge_methods_supported)\n      ? this._issuer.code_challenge_methods_supported\n      : false;\n\n    if (supportedMethods && supportedMethods.includes('S256')) {\n      this._usePKCE = 'S256';\n    } else if (supportedMethods && supportedMethods.includes('plain')) {\n      this._usePKCE = 'plain';\n    } else if (supportedMethods) {\n      throw new TypeError(\n        'neither code_challenge_method supported by the client is supported by the issuer',\n      );\n    } else {\n      this._usePKCE = 'S256';\n    }\n  } else if (typeof this._usePKCE === 'string' && !['plain', 'S256'].includes(this._usePKCE)) {\n    throw new TypeError(`${this._usePKCE} is not valid/implemented PKCE code_challenge_method`);\n  }\n\n  this.name = url.parse(client.issuer.issuer).hostname;\n}\n\nOpenIDConnectStrategy.prototype.authenticate = function authenticate(req, options) {\n  (async () => {\n    const client = this._client;\n    if (!req.session) {\n      throw new TypeError('authentication requires session support');\n    }\n    const reqParams = client.callbackParams(req);\n    const sessionKey = this._key;\n\n    const { 0: parameter, length } = Object.keys(reqParams);\n\n    /**\n     * Start authentication request if this has no authorization response parameters or\n     * this might a login initiated from a third party as per\n     * https://openid.net/specs/openid-connect-core-1_0.html#ThirdPartyInitiatedLogin.\n     */\n    if (length === 0 || (length === 1 && parameter === 'iss')) {\n      // provide options object with extra authentication parameters\n      const params = {\n        state: random(),\n        ...this._params,\n        ...options,\n      };\n\n      if (!params.nonce && params.response_type.includes('id_token')) {\n        params.nonce = random();\n      }\n\n      req.session[sessionKey] = pick(params, 'nonce', 'state', 'max_age', 'response_type');\n\n      if (this._usePKCE && params.response_type.includes('code')) {\n        const verifier = random();\n        req.session[sessionKey].code_verifier = verifier;\n\n        switch (this._usePKCE) {\n          case 'S256':\n            params.code_challenge = codeChallenge(verifier);\n            params.code_challenge_method = 'S256';\n            break;\n          case 'plain':\n            params.code_challenge = verifier;\n            break;\n        }\n      }\n\n      this.redirect(client.authorizationUrl(params));\n      return;\n    }\n    /* end authentication request */\n\n    /* start authentication response */\n\n    const session = req.session[sessionKey];\n    if (Object.keys(session || {}).length === 0) {\n      throw new Error(\n        format(\n          'did not find expected authorization request details in session, req.session[\"%s\"] is %j',\n          sessionKey,\n          session,\n        ),\n      );\n    }\n\n    const {\n      state,\n      nonce,\n      max_age: maxAge,\n      code_verifier: codeVerifier,\n      response_type: responseType,\n    } = session;\n\n    try {\n      delete req.session[sessionKey];\n    } catch (err) {}\n\n    const opts = {\n      redirect_uri: this._params.redirect_uri,\n      ...options,\n    };\n\n    const checks = {\n      state,\n      nonce,\n      max_age: maxAge,\n      code_verifier: codeVerifier,\n      response_type: responseType,\n    };\n\n    const tokenset = await client.callback(opts.redirect_uri, reqParams, checks, this._extras);\n\n    const passReq = this._passReqToCallback;\n    const loadUserinfo = this._verify.length > (passReq ? 3 : 2) && client.issuer.userinfo_endpoint;\n\n    const args = [tokenset, verified.bind(this)];\n\n    if (loadUserinfo) {\n      if (!tokenset.access_token) {\n        throw new RPError({\n          message:\n            'expected access_token to be returned when asking for userinfo in verify callback',\n          tokenset,\n        });\n      }\n      const userinfo = await client.userinfo(tokenset);\n      args.splice(1, 0, userinfo);\n    }\n\n    if (passReq) {\n      args.unshift(req);\n    }\n\n    this._verify(...args);\n    /* end authentication response */\n  })().catch((error) => {\n    if (\n      (error instanceof OPError &&\n        error.error !== 'server_error' &&\n        !error.error.startsWith('invalid')) ||\n      error instanceof RPError\n    ) {\n      this.fail(error);\n    } else {\n      this.error(error);\n    }\n  });\n};\n\nmodule.exports = OpenIDConnectStrategy;\n"],"names":["url","format","cloneDeep","RPError","OPError","BaseClient","random","codeChallenge","pick","resolveResponseType","resolveRedirectUri","verified","err","user","info","error","fail","success","OpenIDConnectStrategy","client","params","passReqToCallback","sessionKey","usePKCE","extras","verify","TypeError","issuer","_client","_issuer","_verify","_passReqToCallback","_usePKCE","_key","parse","hostname","_params","state","nonce","_extras","response_type","call","redirect_uri","scope","supportedMethods","Array","isArray","code_challenge_methods_supported","includes","name","prototype","authenticate","req","options","session","reqParams","callbackParams","parameter","length","Object","keys","verifier","code_verifier","code_challenge","code_challenge_method","redirect","authorizationUrl","Error","max_age","maxAge","codeVerifier","responseType","opts","checks","tokenset","callback","passReq","loadUserinfo","userinfo_endpoint","args","bind","access_token","message","userinfo","splice","unshift","catch","startsWith","module","exports"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 3260, "column": 0}, "map": {"version":3,"sources":["file:///D:/AconnectJP/node_modules/openid-client/lib/index.js"],"sourcesContent":["const Issuer = require('./issuer');\nconst { OPError, RPError } = require('./errors');\nconst Strategy = require('./passport_strategy');\nconst TokenSet = require('./token_set');\nconst { CLOCK_TOLERANCE, HTTP_OPTIONS } = require('./helpers/consts');\nconst generators = require('./helpers/generators');\nconst { setDefaults } = require('./helpers/request');\n\nmodule.exports = {\n  Issuer,\n  Strategy,\n  TokenSet,\n  errors: {\n    OPError,\n    RPError,\n  },\n  custom: {\n    setHttpOptionsDefaults: setDefaults,\n    http_options: HTTP_OPTIONS,\n    clock_tolerance: CLOCK_TOLERANCE,\n  },\n  generators,\n};\n"],"names":["Issuer","OPError","RPError","Strategy","TokenSet","CLOCK_TOLERANCE","HTTP_OPTIONS","generators","setDefaults","module","exports","errors","custom","setHttpOptionsDefaults","http_options","clock_tolerance"],"mappings":"AAAA,MAAMA;AACN,MAAM,EAAEC,OAAO,EAAEC,OAAO,EAAE;AAC1B,MAAMC;AACN,MAAMC;AACN,MAAM,EAAEC,eAAe,EAAEC,YAAY,EAAE;AACvC,MAAMC;AACN,MAAM,EAAEC,WAAW,EAAE;AAErBC,OAAOC,OAAO,GAAG;IACfV;IACAG;IACAC;IACAO,QAAQ;QACNV;QACAC;IACF;IACAU,QAAQ;QACNC,wBAAwBL;QACxBM,cAAcR;QACdS,iBAAiBV;IACnB;IACAE;AACF","ignoreList":[0]}}]
}