{"version":3,"sources":["../../../../src/server/mcp/tools/get-routes.ts"],"sourcesContent":["/**\n * MCP tool for getting all routes that become entry points in a Next.js application.\n *\n * This tool discovers routes by scanning the filesystem directly. It finds all route\n * files in the app/ and pages/ directories and converts them to route paths.\n *\n * Returns routes grouped by router type:\n * - appRouter: App Router pages and route handlers\n * - pagesRouter: Pages Router pages and API routes\n *\n * Dynamic route segments appear as [id], [slug], or [...slug] patterns. This tool\n * does NOT expand getStaticParams - it only shows the route patterns as defined in\n * the filesystem.\n */\nimport type { McpServer } from 'next/dist/compiled/@modelcontextprotocol/sdk/server/mcp'\nimport { mcpTelemetryTracker } from '../mcp-telemetry-tracker'\nimport {\n  collectAppFiles,\n  collectPagesFiles,\n  processAppRoutes,\n  processPageRoutes,\n  createPagesMapping,\n} from '../../../build/entries'\nimport { createValidFileMatcher } from '../../lib/find-page-file'\nimport { PAGE_TYPES } from '../../../lib/page-types'\nimport type { NextConfigComplete } from '../../../server/config-shared'\nimport z from 'next/dist/compiled/zod'\n\ninterface RouteInfo {\n  route: string\n  type: 'app' | 'page' | 'api'\n}\n\nexport function registerGetRoutesTool(\n  server: McpServer,\n  options: {\n    projectPath: string\n    nextConfig: NextConfigComplete\n    pagesDir: string | undefined\n    appDir: string | undefined\n  }\n) {\n  server.registerTool(\n    'get_routes',\n    {\n      description:\n        'Get all routes that will become entry points in the Next.js application by scanning the filesystem. Returns routes grouped by router type (appRouter, pagesRouter). Dynamic segments appear as [param] or [...slug] patterns. API routes are included in their respective routers (e.g., /api/* routes from pages/ are in pagesRouter). Optional parameter: routerType (\"app\" | \"pages\") - filter by specific router type, omit to get all routes.',\n      inputSchema: {\n        routerType: z.union([z.literal('app'), z.literal('pages')]).optional(),\n      },\n    },\n    async (request) => {\n      // Track telemetry\n      mcpTelemetryTracker.recordToolCall('mcp/get_routes')\n\n      try {\n        const routerType =\n          request.routerType === 'app' || request.routerType === 'pages'\n            ? request.routerType\n            : undefined\n\n        const routes: RouteInfo[] = []\n\n        const { projectPath, nextConfig, pagesDir, appDir } = options\n\n        // Check if we have any directories to scan\n        if (!pagesDir && !appDir) {\n          return {\n            content: [\n              {\n                type: 'text',\n                text: JSON.stringify({\n                  error: 'No pages or app directory found in the project.',\n                }),\n              },\n            ],\n          }\n        }\n\n        const isSrcDir =\n          (pagesDir && pagesDir.includes('/src/')) ||\n          (appDir && appDir.includes('/src/'))\n\n        // Create valid file matcher for filtering\n        const validFileMatcher = createValidFileMatcher(\n          nextConfig.pageExtensions,\n          appDir\n        )\n\n        // Collect and process App Router routes if requested\n        if (appDir && (!routerType || routerType === 'app')) {\n          try {\n            const { appPaths } = await collectAppFiles(appDir, validFileMatcher)\n\n            if (appPaths.length > 0) {\n              const mappedAppPages = await createPagesMapping({\n                pagePaths: appPaths,\n                isDev: true,\n                pagesType: PAGE_TYPES.APP,\n                pageExtensions: nextConfig.pageExtensions,\n                pagesDir,\n                appDir,\n                appDirOnly: pagesDir ? false : true,\n              })\n\n              const { appRoutes, appRouteHandlers } = processAppRoutes(\n                mappedAppPages,\n                validFileMatcher,\n                projectPath,\n                isSrcDir || false\n              )\n\n              // Add app page routes\n              for (const { route } of appRoutes) {\n                routes.push({\n                  route,\n                  type: 'app',\n                })\n              }\n\n              // Add app route handlers\n              for (const { route } of appRouteHandlers) {\n                routes.push({\n                  route,\n                  type: 'app',\n                })\n              }\n            }\n          } catch (error) {\n            // Error collecting app routes - continue anyway\n          }\n        }\n\n        // Collect and process Pages Router routes if requested\n        if (pagesDir && (!routerType || routerType === 'pages')) {\n          try {\n            const pagePaths = await collectPagesFiles(\n              pagesDir,\n              validFileMatcher\n            )\n\n            if (pagePaths.length > 0) {\n              const mappedPages = await createPagesMapping({\n                pagePaths,\n                isDev: true,\n                pagesType: PAGE_TYPES.PAGES,\n                pageExtensions: nextConfig.pageExtensions,\n                pagesDir,\n                appDir,\n                appDirOnly: false,\n              })\n\n              const { pageRoutes, pageApiRoutes } = processPageRoutes(\n                mappedPages,\n                projectPath,\n                isSrcDir || false\n              )\n\n              // Add page routes\n              for (const { route } of pageRoutes) {\n                routes.push({\n                  route,\n                  type: 'page',\n                })\n              }\n\n              // Add API routes (always included as part of pages router)\n              for (const { route } of pageApiRoutes) {\n                routes.push({\n                  route,\n                  type: 'api',\n                })\n              }\n            }\n          } catch (error) {\n            // Error collecting pages routes - continue anyway\n          }\n        }\n\n        if (routes.length === 0) {\n          return {\n            content: [\n              {\n                type: 'text',\n                text: JSON.stringify({\n                  appRouter: [],\n                  pagesRouter: [],\n                }),\n              },\n            ],\n          }\n        }\n\n        // Group routes by router type\n        const appRoutes = routes\n          .filter((r) => r.type === 'app')\n          .map((r) => r.route)\n          .sort()\n        const pageRoutes = routes\n          .filter((r) => r.type === 'page' || r.type === 'api')\n          .map((r) => r.route)\n          .sort()\n\n        // Format the output with grouped routes\n        const output = {\n          appRouter: appRoutes.length > 0 ? appRoutes : undefined,\n          pagesRouter: pageRoutes.length > 0 ? pageRoutes : undefined,\n        }\n\n        return {\n          content: [\n            {\n              type: 'text',\n              text: JSON.stringify(output, null, 2),\n            },\n          ],\n        }\n      } catch (error) {\n        return {\n          content: [\n            {\n              type: 'text',\n              text: JSON.stringify({\n                error: error instanceof Error ? error.message : String(error),\n              }),\n            },\n          ],\n        }\n      }\n    }\n  )\n}\n"],"names":["registerGetRoutesTool","server","options","registerTool","description","inputSchema","routerType","z","union","literal","optional","request","mcpTelemetryTracker","recordToolCall","undefined","routes","projectPath","nextConfig","pagesDir","appDir","content","type","text","JSON","stringify","error","isSrcDir","includes","validFileMatcher","createValidFileMatcher","pageExtensions","appPaths","collectAppFiles","length","mappedAppPages","createPagesMapping","pagePaths","isDev","pagesType","PAGE_TYPES","APP","appDirOnly","appRoutes","appRouteHandlers","processAppRoutes","route","push","collectPagesFiles","mappedPages","PAGES","pageRoutes","pageApiRoutes","processPageRoutes","appRouter","pagesRouter","filter","r","map","sort","output","Error","message","String"],"mappings":"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","ignoreList":[0]}