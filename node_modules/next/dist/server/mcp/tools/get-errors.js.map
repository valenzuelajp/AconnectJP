{"version":3,"sources":["../../../../src/server/mcp/tools/get-errors.ts"],"sourcesContent":["/**\n * MCP tool for retrieving error state from Next.js dev server.\n *\n * This tool provides comprehensive error reporting including:\n * - Next.js global errors (e.g., next.config validation errors)\n * - Browser runtime errors with source-mapped stack traces\n * - Build errors from webpack/turbopack compilation\n *\n * For browser errors, it leverages the HMR infrastructure for server-to-browser communication.\n *\n * Flow:\n *   MCP client → server generates request ID → HMR message to browser →\n *   browser queries error overlay state → HMR response back → server performs source mapping →\n *   combined with global errors → formatted output.\n */\nimport type { McpServer } from 'next/dist/compiled/@modelcontextprotocol/sdk/server/mcp'\nimport type { OverlayState } from '../../../next-devtools/dev-overlay/shared'\nimport {\n  HMR_MESSAGE_SENT_TO_BROWSER,\n  type HmrMessageSentToBrowser,\n} from '../../dev/hot-reloader-types'\nimport { formatErrors } from './utils/format-errors'\nimport {\n  createBrowserRequest,\n  handleBrowserPageResponse,\n  DEFAULT_BROWSER_REQUEST_TIMEOUT_MS,\n} from './utils/browser-communication'\nimport { NextInstanceErrorState } from './next-instance-error-state'\nimport { mcpTelemetryTracker } from '../mcp-telemetry-tracker'\n\nexport function registerGetErrorsTool(\n  server: McpServer,\n  sendHmrMessage: (message: HmrMessageSentToBrowser) => void,\n  getActiveConnectionCount: () => number\n) {\n  server.registerTool(\n    'get_errors',\n    {\n      description:\n        'Get the current error state from the Next.js dev server, including Next.js global errors (e.g., next.config validation), browser runtime errors, and build errors with source-mapped stack traces',\n      inputSchema: {},\n    },\n    async (_request) => {\n      // Track telemetry\n      mcpTelemetryTracker.recordToolCall('mcp/get_errors')\n\n      try {\n        const connectionCount = getActiveConnectionCount()\n        if (connectionCount === 0) {\n          return {\n            content: [\n              {\n                type: 'text',\n                text: JSON.stringify({\n                  error:\n                    'No browser sessions connected. Please open your application in a browser to retrieve error state.',\n                }),\n              },\n            ],\n          }\n        }\n\n        const responses = await createBrowserRequest<OverlayState>(\n          HMR_MESSAGE_SENT_TO_BROWSER.REQUEST_CURRENT_ERROR_STATE,\n          sendHmrMessage,\n          getActiveConnectionCount,\n          DEFAULT_BROWSER_REQUEST_TIMEOUT_MS\n        )\n\n        // The error state for each route\n        // key is the route path, value is the error state\n        const routesErrorState = new Map<string, OverlayState>()\n        for (const response of responses) {\n          if (response.data) {\n            routesErrorState.set(response.url, response.data)\n          }\n        }\n\n        const hasRouteErrors = Array.from(routesErrorState.values()).some(\n          (state) => state.errors.length > 0 || !!state.buildError\n        )\n        const hasInstanceErrors = NextInstanceErrorState.nextConfig.length > 0\n\n        if (!hasRouteErrors && !hasInstanceErrors) {\n          return {\n            content: [\n              {\n                type: 'text',\n                text: JSON.stringify({\n                  configErrors: [],\n                  sessionErrors: [],\n                }),\n              },\n            ],\n          }\n        }\n\n        const output = await formatErrors(\n          routesErrorState,\n          NextInstanceErrorState\n        )\n\n        return {\n          content: [\n            {\n              type: 'text',\n              text: JSON.stringify(output),\n            },\n          ],\n        }\n      } catch (error) {\n        return {\n          content: [\n            {\n              type: 'text',\n              text: JSON.stringify({\n                error: error instanceof Error ? error.message : String(error),\n              }),\n            },\n          ],\n        }\n      }\n    }\n  )\n}\n\n// Browser will first receive an HMR message from server to send back its error state.\n// The actual state is sent back in a subsequent HMR message, which is handled by this function\n// on the server.\nexport function handleErrorStateResponse(\n  requestId: string,\n  errorState: OverlayState | null,\n  url: string | undefined\n) {\n  handleBrowserPageResponse<OverlayState | null>(\n    requestId,\n    errorState,\n    url || ''\n  )\n}\n"],"names":["handleErrorStateResponse","registerGetErrorsTool","server","sendHmrMessage","getActiveConnectionCount","registerTool","description","inputSchema","_request","mcpTelemetryTracker","recordToolCall","connectionCount","content","type","text","JSON","stringify","error","responses","createBrowserRequest","HMR_MESSAGE_SENT_TO_BROWSER","REQUEST_CURRENT_ERROR_STATE","DEFAULT_BROWSER_REQUEST_TIMEOUT_MS","routesErrorState","Map","response","data","set","url","hasRouteErrors","Array","from","values","some","state","errors","length","buildError","hasInstanceErrors","NextInstanceErrorState","nextConfig","configErrors","sessionErrors","output","formatErrors","Error","message","String","requestId","errorState","handleBrowserPageResponse"],"mappings":"AAAA;;;;;;;;;;;;;;CAcC;;;;;;;;;;;;;;;IAmHeA,wBAAwB;eAAxBA;;IAnGAC,qBAAqB;eAArBA;;;kCAVT;8BACsB;sCAKtB;wCACgC;qCACH;AAE7B,SAASA,sBACdC,MAAiB,EACjBC,cAA0D,EAC1DC,wBAAsC;IAEtCF,OAAOG,YAAY,CACjB,cACA;QACEC,aACE;QACFC,aAAa,CAAC;IAChB,GACA,OAAOC;QACL,kBAAkB;QAClBC,wCAAmB,CAACC,cAAc,CAAC;QAEnC,IAAI;YACF,MAAMC,kBAAkBP;YACxB,IAAIO,oBAAoB,GAAG;gBACzB,OAAO;oBACLC,SAAS;wBACP;4BACEC,MAAM;4BACNC,MAAMC,KAAKC,SAAS,CAAC;gCACnBC,OACE;4BACJ;wBACF;qBACD;gBACH;YACF;YAEA,MAAMC,YAAY,MAAMC,IAAAA,0CAAoB,EAC1CC,6CAA2B,CAACC,2BAA2B,EACvDlB,gBACAC,0BACAkB,wDAAkC;YAGpC,iCAAiC;YACjC,kDAAkD;YAClD,MAAMC,mBAAmB,IAAIC;YAC7B,KAAK,MAAMC,YAAYP,UAAW;gBAChC,IAAIO,SAASC,IAAI,EAAE;oBACjBH,iBAAiBI,GAAG,CAACF,SAASG,GAAG,EAAEH,SAASC,IAAI;gBAClD;YACF;YAEA,MAAMG,iBAAiBC,MAAMC,IAAI,CAACR,iBAAiBS,MAAM,IAAIC,IAAI,CAC/D,CAACC,QAAUA,MAAMC,MAAM,CAACC,MAAM,GAAG,KAAK,CAAC,CAACF,MAAMG,UAAU;YAE1D,MAAMC,oBAAoBC,8CAAsB,CAACC,UAAU,CAACJ,MAAM,GAAG;YAErE,IAAI,CAACP,kBAAkB,CAACS,mBAAmB;gBACzC,OAAO;oBACL1B,SAAS;wBACP;4BACEC,MAAM;4BACNC,MAAMC,KAAKC,SAAS,CAAC;gCACnByB,cAAc,EAAE;gCAChBC,eAAe,EAAE;4BACnB;wBACF;qBACD;gBACH;YACF;YAEA,MAAMC,SAAS,MAAMC,IAAAA,0BAAY,EAC/BrB,kBACAgB,8CAAsB;YAGxB,OAAO;gBACL3B,SAAS;oBACP;wBACEC,MAAM;wBACNC,MAAMC,KAAKC,SAAS,CAAC2B;oBACvB;iBACD;YACH;QACF,EAAE,OAAO1B,OAAO;YACd,OAAO;gBACLL,SAAS;oBACP;wBACEC,MAAM;wBACNC,MAAMC,KAAKC,SAAS,CAAC;4BACnBC,OAAOA,iBAAiB4B,QAAQ5B,MAAM6B,OAAO,GAAGC,OAAO9B;wBACzD;oBACF;iBACD;YACH;QACF;IACF;AAEJ;AAKO,SAASjB,yBACdgD,SAAiB,EACjBC,UAA+B,EAC/BrB,GAAuB;IAEvBsB,IAAAA,+CAAyB,EACvBF,WACAC,YACArB,OAAO;AAEX","ignoreList":[0]}