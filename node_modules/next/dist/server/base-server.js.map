{"version":3,"sources":["../../src/server/base-server.ts"],"sourcesContent":["import type { __ApiPreviewProps } from './api-utils'\nimport type {\n  GenericComponentMod,\n  LoadComponentsReturnType,\n} from './load-components'\nimport type { MiddlewareRouteMatch } from '../shared/lib/router/utils/middleware-route-matcher'\nimport type { Params } from './request/params'\nimport type { NextConfig, NextConfigRuntime } from './config-shared'\nimport {\n  DEFAULT_MAX_POSTPONED_STATE_SIZE,\n  parseMaxPostponedStateSize,\n} from './config-shared'\nimport type {\n  NextParsedUrlQuery,\n  NextUrlWithParsedQuery,\n  RequestMeta,\n} from './request-meta'\nimport type { ParsedUrlQuery } from 'querystring'\nimport type { RenderOptsPartial as PagesRenderOptsPartial } from './render'\nimport type {\n  RenderOptsPartial as AppRenderOptsPartial,\n  ServerOnInstrumentationRequestError,\n} from './app-render/types'\nimport type { ServerComponentsHmrCache } from './response-cache'\nimport {\n  NormalizeError,\n  DecodeError,\n  normalizeRepeatedSlashes,\n  MissingStaticPage,\n} from '../shared/lib/utils'\nimport type { PagesManifest } from '../build/webpack/plugins/pages-manifest-plugin'\nimport type { BaseNextRequest, BaseNextResponse } from './base-http'\nimport type {\n  ManifestRewriteRoute,\n  ManifestRoute,\n  PrerenderManifest,\n} from '../build'\nimport type { ClientReferenceManifest } from '../build/webpack/plugins/flight-manifest-plugin'\nimport type { NextFontManifest } from '../build/webpack/plugins/next-font-manifest-plugin'\nimport type { PagesAPIRouteMatch } from './route-matches/pages-api-route-match'\nimport type {\n  Server as HTTPServer,\n  IncomingMessage,\n  ServerResponse as HTTPServerResponse,\n} from 'http'\nimport type { ProxyMatcher } from '../build/analysis/get-page-static-info'\nimport type { TLSSocket } from 'tls'\nimport type { PathnameNormalizer } from './normalizers/request/pathname-normalizer'\nimport type { InstrumentationModule } from './instrumentation/types'\n\nimport * as path from 'path'\nimport { format as formatUrl } from 'url'\nimport { formatHostname } from './lib/format-hostname'\nimport {\n  APP_PATHS_MANIFEST,\n  NEXT_BUILTIN_DOCUMENT,\n  PAGES_MANIFEST,\n  STATIC_STATUS_PAGES,\n  UNDERSCORE_NOT_FOUND_ROUTE,\n  UNDERSCORE_NOT_FOUND_ROUTE_ENTRY,\n} from '../shared/lib/constants'\nimport { isDynamicRoute } from '../shared/lib/router/utils'\nimport { execOnce } from '../shared/lib/utils'\nimport { isBlockedPage } from './utils'\nimport { getBotType, isBot } from '../shared/lib/router/utils/is-bot'\nimport RenderResult from './render-result'\nimport { removeTrailingSlash } from '../shared/lib/router/utils/remove-trailing-slash'\nimport { denormalizePagePath } from '../shared/lib/page-path/denormalize-page-path'\nimport * as Log from '../build/output/log'\nimport { getServerUtils } from './server-utils'\nimport isError, { getProperError } from '../lib/is-error'\nimport {\n  addRequestMeta,\n  getRequestMeta,\n  removeRequestMeta,\n  setRequestMeta,\n} from './request-meta'\nimport { removePathPrefix } from '../shared/lib/router/utils/remove-path-prefix'\nimport { normalizeAppPath } from '../shared/lib/router/utils/app-paths'\nimport { getHostname } from '../shared/lib/get-hostname'\nimport {\n  parseUrl,\n  parseUrl as parseUrlUtil,\n} from '../shared/lib/router/utils/parse-url'\nimport { getNextPathnameInfo } from '../shared/lib/router/utils/get-next-pathname-info'\nimport {\n  RSC_HEADER,\n  NEXT_RSC_UNION_QUERY,\n  NEXT_ROUTER_PREFETCH_HEADER,\n  NEXT_ROUTER_SEGMENT_PREFETCH_HEADER,\n  NEXT_URL,\n  NEXT_ROUTER_STATE_TREE_HEADER,\n} from '../client/components/app-router-headers'\nimport type {\n  MatchOptions,\n  RouteMatcherManager,\n} from './route-matcher-managers/route-matcher-manager'\nimport { LocaleRouteNormalizer } from './normalizers/locale-route-normalizer'\nimport { DefaultRouteMatcherManager } from './route-matcher-managers/default-route-matcher-manager'\nimport { AppPageRouteMatcherProvider } from './route-matcher-providers/app-page-route-matcher-provider'\nimport { AppRouteRouteMatcherProvider } from './route-matcher-providers/app-route-route-matcher-provider'\nimport { PagesAPIRouteMatcherProvider } from './route-matcher-providers/pages-api-route-matcher-provider'\nimport { PagesRouteMatcherProvider } from './route-matcher-providers/pages-route-matcher-provider'\nimport { ServerManifestLoader } from './route-matcher-providers/helpers/manifest-loaders/server-manifest-loader'\nimport {\n  getTracer,\n  isBubbledError,\n  SpanKind,\n  SpanStatusCode,\n} from './lib/trace/tracer'\nimport { BaseServerSpan } from './lib/trace/constants'\nimport { I18NProvider } from './lib/i18n-provider'\nimport { sendResponse } from './send-response'\nimport { normalizeNextQueryParam } from './web/utils'\nimport {\n  HTML_CONTENT_TYPE_HEADER,\n  JSON_CONTENT_TYPE_HEADER,\n  MATCHED_PATH_HEADER,\n  NEXT_RESUME_HEADER,\n} from '../lib/constants'\nimport { normalizeLocalePath } from '../shared/lib/i18n/normalize-locale-path'\nimport { matchNextDataPathname } from './lib/match-next-data-pathname'\nimport getRouteFromAssetPath from '../shared/lib/router/utils/get-route-from-asset-path'\nimport { RSCPathnameNormalizer } from './normalizers/request/rsc'\nimport { stripFlightHeaders } from './app-render/strip-flight-headers'\nimport {\n  isAppPageRouteModule,\n  isAppRouteRouteModule,\n} from './route-modules/checks'\nimport { NextDataPathnameNormalizer } from './normalizers/request/next-data'\nimport { getIsPossibleServerAction } from './lib/server-action-request-meta'\nimport { isInterceptionRouteAppPath } from '../shared/lib/router/utils/interception-routes'\nimport { toRoute } from './lib/to-route'\nimport type { DeepReadonly } from '../shared/lib/deep-readonly'\nimport { isNodeNextRequest, isNodeNextResponse } from './base-http/helpers'\nimport { patchSetHeaderWithCookieSupport } from './lib/patch-set-header'\nimport { checkIsAppPPREnabled } from './lib/experimental/ppr'\nimport {\n  getBuiltinRequestContext,\n  type WaitUntil,\n} from './after/builtin-request-context'\nimport { NextRequestHint } from './web/adapter'\nimport type { RouteModule } from './route-modules/route-module'\nimport { type FallbackMode, parseFallbackField } from '../lib/fallback'\nimport { SegmentPrefixRSCPathnameNormalizer } from './normalizers/request/segment-prefix-rsc'\nimport { shouldServeStreamingMetadata } from './lib/streaming-metadata'\nimport { decodeQueryPathParameter } from './lib/decode-query-path-parameter'\nimport { NoFallbackError } from '../shared/lib/no-fallback-error.external'\nimport { fixMojibake } from './lib/fix-mojibake'\nimport { computeCacheBustingSearchParam } from '../shared/lib/router/utils/cache-busting-search-param'\nimport { setCacheBustingSearchParamWithHash } from '../client/components/router-reducer/set-cache-busting-search-param'\nimport type { CacheControl } from './lib/cache-control'\nimport type { PrerenderedRoute } from '../build/static-paths/types'\nimport { createOpaqueFallbackRouteParams } from './request/fallback-params'\nimport { RouteKind } from './route-kind'\nimport type { ErrorModule } from './load-default-error-components'\n\nexport type FindComponentsResult<\n  NextModule extends GenericComponentMod = GenericComponentMod,\n> = {\n  components: LoadComponentsReturnType<NextModule>\n  query: NextParsedUrlQuery\n}\n\nexport interface MiddlewareRoutingItem {\n  page: string\n  match: MiddlewareRouteMatch\n  matchers?: ProxyMatcher[]\n}\n\nexport type RouteHandler<\n  ServerRequest extends BaseNextRequest = BaseNextRequest,\n  ServerResponse extends BaseNextResponse = BaseNextResponse,\n> = (\n  req: ServerRequest,\n  res: ServerResponse,\n  parsedUrl: NextUrlWithParsedQuery\n) => PromiseLike<boolean> | boolean\n\n/**\n * The normalized route manifest is the same as the route manifest, but with\n * the rewrites normalized to the object shape that the router expects.\n */\nexport type NormalizedRouteManifest = {\n  readonly dynamicRoutes: ReadonlyArray<ManifestRoute>\n  readonly rewrites: {\n    readonly beforeFiles: ReadonlyArray<ManifestRewriteRoute>\n    readonly afterFiles: ReadonlyArray<ManifestRewriteRoute>\n    readonly fallback: ReadonlyArray<ManifestRewriteRoute>\n  }\n}\n\nexport interface Options {\n  /**\n   * Object containing the configuration next.config.js\n   */\n  conf: NextConfig\n  /**\n   * Set to false when the server was created by Next.js\n   */\n  customServer?: boolean\n  /**\n   * Tells if Next.js is running in dev mode\n   */\n  dev?: boolean\n  /**\n   * Enables the experimental testing mode.\n   */\n  experimentalTestProxy?: boolean\n\n  /**\n   * Whether or not the dev server is running in experimental HTTPS mode\n   */\n  experimentalHttpsServer?: boolean\n  /**\n   * Where the Next project is located\n   */\n  dir?: string\n  /**\n   * Tells if Next.js is at the platform-level\n   */\n  minimalMode?: boolean\n  /**\n   * Hide error messages containing server information\n   */\n  quiet?: boolean\n  /**\n   * The hostname the server is running behind\n   */\n  hostname?: string\n  /**\n   * The port the server is running behind\n   */\n  port?: number\n  /**\n   * The HTTP Server that Next.js is running behind\n   */\n  httpServer?: HTTPServer\n}\n\nexport type RenderOpts = PagesRenderOptsPartial & AppRenderOptsPartial\n\nexport type LoadedRenderOpts<\n  NextModule extends GenericComponentMod = GenericComponentMod,\n> = RenderOpts & LoadComponentsReturnType<NextModule> & RequestLifecycleOpts\n\nexport type RequestLifecycleOpts = {\n  waitUntil: ((promise: Promise<any>) => void) | undefined\n  onClose: (callback: () => void) => void\n  onAfterTaskError: ((error: unknown) => void) | undefined\n}\n\ntype BaseRenderOpts = RenderOpts & {\n  poweredByHeader: boolean\n  generateEtags: boolean\n  previewProps: __ApiPreviewProps\n}\n\n/**\n * The public interface for rendering with the server programmatically. This\n * would typically only allow the base request or response to extend it, but\n * because this can be programmatically accessed, we assume that it could also\n * be the base Node.js request and response types.\n */\nexport interface BaseRequestHandler<\n  ServerRequest extends BaseNextRequest | IncomingMessage = BaseNextRequest,\n  ServerResponse extends\n    | BaseNextResponse\n    | HTTPServerResponse = BaseNextResponse,\n> {\n  (\n    req: ServerRequest,\n    res: ServerResponse,\n    parsedUrl?: NextUrlWithParsedQuery | undefined\n  ): Promise<void> | void\n}\n\nexport type RequestContext<\n  ServerRequest extends BaseNextRequest = BaseNextRequest,\n  ServerResponse extends BaseNextResponse = BaseNextResponse,\n> = {\n  req: ServerRequest\n  res: ServerResponse\n  pathname: string\n  query: NextParsedUrlQuery\n  renderOpts: RenderOpts\n}\n\n// Internal wrapper around build errors at development\n// time, to prevent us from propagating or logging them\nexport class WrappedBuildError extends Error {\n  innerError: Error\n\n  constructor(innerError: Error) {\n    super()\n    this.innerError = innerError\n  }\n}\n\ntype ResponsePayload = {\n  body: RenderResult\n  cacheControl?: CacheControl\n}\n\nexport type NextEnabledDirectories = {\n  readonly pages: boolean\n  readonly app: boolean\n}\n\nexport default abstract class Server<\n  ServerOptions extends Options = Options,\n  ServerRequest extends BaseNextRequest = BaseNextRequest,\n  ServerResponse extends BaseNextResponse = BaseNextResponse,\n> {\n  public readonly hostname?: string\n  public readonly fetchHostname?: string\n  public readonly port?: number\n  protected readonly dir: string\n  protected readonly quiet: boolean\n  protected readonly nextConfig: NextConfigRuntime\n  protected readonly distDir: string\n  protected readonly publicDir: string\n  protected readonly hasStaticDir: boolean\n  protected readonly pagesManifest?: PagesManifest\n  protected readonly appPathsManifest?: PagesManifest\n  protected readonly buildId: string\n  protected readonly deploymentId: string\n  protected readonly minimalMode: boolean\n  protected readonly renderOpts: BaseRenderOpts\n  protected readonly serverOptions: Readonly<ServerOptions>\n  protected readonly appPathRoutes?: Record<string, string[]>\n  protected readonly clientReferenceManifest?: DeepReadonly<ClientReferenceManifest>\n  protected interceptionRoutePatterns: RegExp[]\n  protected nextFontManifest?: DeepReadonly<NextFontManifest>\n  protected instrumentation: InstrumentationModule | undefined\n\n  protected abstract getPublicDir(): string\n  protected abstract getHasStaticDir(): boolean\n  protected abstract getPagesManifest(): PagesManifest | undefined\n  protected abstract getAppPathsManifest(): PagesManifest | undefined\n  protected abstract getBuildId(): string\n  protected abstract getinterceptionRoutePatterns(): RegExp[]\n\n  protected readonly enabledDirectories: NextEnabledDirectories\n  protected abstract getEnabledDirectories(dev: boolean): NextEnabledDirectories\n\n  protected readonly experimentalTestProxy?: boolean\n\n  protected abstract findPageComponents(params: {\n    locale: string | undefined\n    page: string\n    query: NextParsedUrlQuery\n    params: Params\n    isAppPath: boolean\n    // The following parameters are used in the development server's\n    // implementation.\n    sriEnabled?: boolean\n    appPaths?: ReadonlyArray<string> | null\n    shouldEnsure?: boolean\n    url?: string\n  }): Promise<FindComponentsResult | null>\n  protected abstract getPrerenderManifest(): DeepReadonly<PrerenderManifest>\n  protected abstract getNextFontManifest():\n    | DeepReadonly<NextFontManifest>\n    | undefined\n  protected abstract attachRequestMeta(\n    req: ServerRequest,\n    parsedUrl: NextUrlWithParsedQuery\n  ): void\n  protected abstract hasPage(pathname: string): Promise<boolean>\n\n  protected abstract sendRenderResult(\n    req: ServerRequest,\n    res: ServerResponse,\n    options: {\n      result: RenderResult\n      generateEtags: boolean\n      poweredByHeader: boolean\n      cacheControl: CacheControl | undefined\n    }\n  ): Promise<void>\n\n  protected abstract runApi(\n    req: ServerRequest,\n    res: ServerResponse,\n    query: ParsedUrlQuery,\n    match: PagesAPIRouteMatch\n  ): Promise<boolean>\n\n  protected abstract renderHTML(\n    req: ServerRequest,\n    res: ServerResponse,\n    pathname: string,\n    query: NextParsedUrlQuery,\n    renderOpts: LoadedRenderOpts\n  ): Promise<RenderResult>\n\n  protected abstract getIncrementalCache(options: {\n    requestHeaders: Record<string, undefined | string | string[]>\n  }): Promise<import('./lib/incremental-cache').IncrementalCache>\n\n  protected getServerComponentsHmrCache():\n    | ServerComponentsHmrCache\n    | undefined {\n    return this.nextConfig.experimental.serverComponentsHmrCache\n      ? (globalThis as any).__serverComponentsHmrCache\n      : undefined\n  }\n\n  protected abstract loadEnvConfig(params: {\n    dev: boolean\n    forceReload: boolean\n  }): void\n\n  // TODO-APP: (wyattjoh): Make protected again. Used for turbopack in route-resolver.ts right now.\n  public readonly matchers: RouteMatcherManager\n  protected readonly i18nProvider?: I18NProvider\n  protected readonly localeNormalizer?: LocaleRouteNormalizer\n\n  protected readonly normalizers: {\n    readonly rsc: RSCPathnameNormalizer | undefined\n    readonly segmentPrefetchRSC: SegmentPrefixRSCPathnameNormalizer | undefined\n    readonly data: NextDataPathnameNormalizer | undefined\n  }\n\n  private readonly isAppPPREnabled: boolean\n\n  /**\n   * This is used to persist cache scopes across\n   * prefetch -> full route requests for cache components\n   * it's only fully used in dev\n   */\n\n  public constructor(options: ServerOptions) {\n    const {\n      dir = '.',\n      quiet = false,\n      conf,\n      dev = false,\n      minimalMode = false,\n      hostname,\n      port,\n      experimentalTestProxy,\n    } = options\n\n    this.experimentalTestProxy = experimentalTestProxy\n    this.serverOptions = options\n\n    this.dir = path.resolve(/* turbopackIgnore: true */ dir)\n\n    this.quiet = quiet\n    this.loadEnvConfig({ dev, forceReload: false })\n\n    // TODO: should conf be normalized to prevent missing\n    // values from causing issues as this can be user provided\n    this.nextConfig = conf as NextConfigRuntime\n\n    if (this.nextConfig.experimental.runtimeServerDeploymentId) {\n      if (!process.env.NEXT_DEPLOYMENT_ID) {\n        throw new Error(\n          'process.env.NEXT_DEPLOYMENT_ID is missing but runtimeServerDeploymentId is enabled'\n        )\n      }\n      this.deploymentId = process.env.NEXT_DEPLOYMENT_ID\n      ;(globalThis as any).NEXT_CLIENT_ASSET_SUFFIX = this.deploymentId\n        ? `?dpl=${this.deploymentId}`\n        : ''\n    } else {\n      let id = this.nextConfig.experimental.useSkewCookie\n        ? ''\n        : this.nextConfig.deploymentId || ''\n\n      this.deploymentId = id\n      process.env.NEXT_DEPLOYMENT_ID = id\n      ;(globalThis as any).NEXT_CLIENT_ASSET_SUFFIX = id ? `?dpl=${id}` : ''\n    }\n\n    this.hostname = hostname\n    if (this.hostname) {\n      // we format the hostname so that it can be fetched\n      this.fetchHostname = formatHostname(this.hostname)\n    }\n    this.port = port\n    this.distDir = path.join(\n      /* turbopackIgnore: true */ this.dir,\n      this.nextConfig.distDir\n    )\n    this.publicDir = this.getPublicDir()\n    this.hasStaticDir = !minimalMode && this.getHasStaticDir()\n\n    this.i18nProvider = this.nextConfig.i18n?.locales\n      ? new I18NProvider(this.nextConfig.i18n)\n      : undefined\n\n    // Configure the locale normalizer, it's used for routes inside `pages/`.\n    this.localeNormalizer = this.i18nProvider\n      ? new LocaleRouteNormalizer(this.i18nProvider)\n      : undefined\n\n    const { assetPrefix, generateEtags } = this.nextConfig\n\n    this.buildId = this.getBuildId()\n    // this is a hack to avoid Webpack knowing this is equal to this.minimalMode\n    // because we replace this.minimalMode to true in production bundles.\n    const minimalModeKey = 'minimalMode'\n    this[minimalModeKey] =\n      minimalMode || !!process.env.NEXT_PRIVATE_MINIMAL_MODE\n\n    this.enabledDirectories = this.getEnabledDirectories(dev)\n\n    this.isAppPPREnabled =\n      this.enabledDirectories.app &&\n      checkIsAppPPREnabled(this.nextConfig.experimental.ppr)\n\n    this.normalizers = {\n      // We should normalize the pathname from the RSC prefix only in minimal\n      // mode as otherwise that route is not exposed external to the server as\n      // we instead only rely on the headers.\n      rsc:\n        this.enabledDirectories.app && this.minimalMode\n          ? new RSCPathnameNormalizer()\n          : undefined,\n      segmentPrefetchRSC: this.minimalMode\n        ? new SegmentPrefixRSCPathnameNormalizer()\n        : undefined,\n      data: this.enabledDirectories.pages\n        ? new NextDataPathnameNormalizer(this.buildId)\n        : undefined,\n    }\n\n    this.nextFontManifest = this.getNextFontManifest()\n\n    this.renderOpts = {\n      dir: this.dir,\n      supportsDynamicResponse: true,\n      trailingSlash: this.nextConfig.trailingSlash,\n      poweredByHeader: this.nextConfig.poweredByHeader,\n      generateEtags,\n      previewProps: this.getPrerenderManifest().preview,\n      basePath: this.nextConfig.basePath,\n      images: this.nextConfig.images,\n      optimizeCss: this.nextConfig.experimental.optimizeCss,\n      nextConfigOutput: this.nextConfig.output,\n      nextScriptWorkers: this.nextConfig.experimental.nextScriptWorkers,\n      disableOptimizedLoading:\n        this.nextConfig.experimental.disableOptimizedLoading,\n      domainLocales: this.nextConfig.i18n?.domains,\n      distDir: this.distDir,\n      serverComponents: this.enabledDirectories.app,\n      cacheLifeProfiles: this.nextConfig.cacheLife,\n      enableTainting: this.nextConfig.experimental.taint,\n      crossOrigin: this.nextConfig.crossOrigin\n        ? this.nextConfig.crossOrigin\n        : undefined,\n      largePageDataBytes: this.nextConfig.experimental.largePageDataBytes,\n\n      isExperimentalCompile: this.nextConfig.experimental.isExperimentalCompile,\n      // `htmlLimitedBots` is passed to server as serialized config in string format\n      htmlLimitedBots: this.nextConfig.htmlLimitedBots,\n      cacheComponents: this.nextConfig.cacheComponents ?? false,\n      experimental: {\n        expireTime: this.nextConfig.expireTime,\n        staleTimes: this.nextConfig.experimental.staleTimes,\n        clientTraceMetadata: this.nextConfig.experimental.clientTraceMetadata,\n        clientParamParsingOrigins:\n          this.nextConfig.experimental.clientParamParsingOrigins,\n        dynamicOnHover: this.nextConfig.experimental.dynamicOnHover ?? false,\n        optimisticRouting:\n          this.nextConfig.experimental.optimisticRouting ?? false,\n        inlineCss: this.nextConfig.experimental.inlineCss ?? false,\n        authInterrupts: !!this.nextConfig.experimental.authInterrupts,\n        maxPostponedStateSizeBytes: parseMaxPostponedStateSize(\n          this.nextConfig.experimental.maxPostponedStateSize\n        ),\n      },\n      onInstrumentationRequestError:\n        this.instrumentationOnRequestError.bind(this),\n      reactMaxHeadersLength: this.nextConfig.reactMaxHeadersLength,\n    }\n\n    this.pagesManifest = this.getPagesManifest()\n    this.appPathsManifest = this.getAppPathsManifest()\n    this.appPathRoutes = this.getAppPathRoutes()\n    this.interceptionRoutePatterns = this.getinterceptionRoutePatterns()\n\n    // Configure the routes.\n    this.matchers = this.getRouteMatchers()\n\n    // Start route compilation. We don't wait for the routes to finish loading\n    // because we use the `waitTillReady` promise below in `handleRequest` to\n    // wait. Also we can't `await` in the constructor.\n    void this.matchers.reload()\n\n    this.setAssetPrefix(assetPrefix)\n  }\n\n  protected reloadMatchers() {\n    return this.matchers.reload()\n  }\n\n  private handleRSCRequest: RouteHandler<ServerRequest, ServerResponse> = (\n    req,\n    _res,\n    parsedUrl\n  ) => {\n    if (!parsedUrl.pathname) return false\n\n    if (this.normalizers.segmentPrefetchRSC?.match(parsedUrl.pathname)) {\n      const result = this.normalizers.segmentPrefetchRSC.extract(\n        parsedUrl.pathname\n      )\n      if (!result) return false\n\n      const { originalPathname, segmentPath } = result\n      parsedUrl.pathname = originalPathname\n\n      // Mark the request as a router prefetch request.\n      req.headers[RSC_HEADER] = '1'\n      req.headers[NEXT_ROUTER_PREFETCH_HEADER] = '1'\n      req.headers[NEXT_ROUTER_SEGMENT_PREFETCH_HEADER] = segmentPath\n\n      addRequestMeta(req, 'isRSCRequest', true)\n      addRequestMeta(req, 'isPrefetchRSCRequest', true)\n      addRequestMeta(req, 'segmentPrefetchRSCRequest', segmentPath)\n    } else if (this.normalizers.rsc?.match(parsedUrl.pathname)) {\n      parsedUrl.pathname = this.normalizers.rsc.normalize(\n        parsedUrl.pathname,\n        true\n      )\n\n      // Mark the request as a RSC request.\n      req.headers[RSC_HEADER] = '1'\n      addRequestMeta(req, 'isRSCRequest', true)\n    } else if (req.headers['x-now-route-matches']) {\n      // If we didn't match, return with the flight headers stripped. If in\n      // minimal mode we didn't match based on the path, this can't be a RSC\n      // request. This is because Vercel only sends this header during\n      // revalidation requests and we want the cache to instead depend on the\n      // request path for flight information.\n      stripFlightHeaders(req.headers)\n\n      return false\n    } else if (req.headers[RSC_HEADER] === '1') {\n      addRequestMeta(req, 'isRSCRequest', true)\n\n      if (req.headers[NEXT_ROUTER_PREFETCH_HEADER] === '1') {\n        addRequestMeta(req, 'isPrefetchRSCRequest', true)\n\n        const segmentPrefetchRSCRequest =\n          req.headers[NEXT_ROUTER_SEGMENT_PREFETCH_HEADER]\n        if (typeof segmentPrefetchRSCRequest === 'string') {\n          addRequestMeta(\n            req,\n            'segmentPrefetchRSCRequest',\n            segmentPrefetchRSCRequest\n          )\n        }\n      }\n    } else {\n      // Otherwise just return without doing anything.\n      return false\n    }\n\n    if (req.url) {\n      const parsed = parseUrl(req.url)\n      parsed.pathname = parsedUrl.pathname\n      req.url = formatUrl(parsed)\n    }\n\n    return false\n  }\n\n  private handleNextDataRequest: RouteHandler<ServerRequest, ServerResponse> =\n    async (req, res, parsedUrl) => {\n      const middleware = await this.getMiddleware()\n      const params = matchNextDataPathname(parsedUrl.pathname)\n\n      // ignore for non-next data URLs\n      if (!params || !params.path) {\n        return false\n      }\n\n      if (params.path[0] !== this.buildId) {\n        // Ignore if its a middleware request when we aren't on edge.\n        if (getRequestMeta(req, 'middlewareInvoke')) {\n          return false\n        }\n\n        // Make sure to 404 if the buildId isn't correct\n        await this.render404(req, res, parsedUrl)\n        return true\n      }\n\n      // remove buildId from URL\n      params.path.shift()\n\n      const lastParam = params.path[params.path.length - 1]\n\n      // show 404 if it doesn't end with .json\n      if (typeof lastParam !== 'string' || !lastParam.endsWith('.json')) {\n        await this.render404(req, res, parsedUrl)\n        return true\n      }\n\n      // re-create page's pathname\n      let pathname = `/${params.path.join('/')}`\n      pathname = getRouteFromAssetPath(pathname, '.json')\n\n      // ensure trailing slash is normalized per config\n      if (middleware) {\n        if (this.nextConfig.trailingSlash && !pathname.endsWith('/')) {\n          pathname += '/'\n        }\n        if (\n          !this.nextConfig.trailingSlash &&\n          pathname.length > 1 &&\n          pathname.endsWith('/')\n        ) {\n          pathname = pathname.substring(0, pathname.length - 1)\n        }\n      }\n\n      if (this.i18nProvider) {\n        // Remove the port from the hostname if present.\n        const hostname = req?.headers.host?.split(':', 1)[0].toLowerCase()\n\n        const domainLocale = this.i18nProvider.detectDomainLocale(hostname)\n        const defaultLocale =\n          domainLocale?.defaultLocale ?? this.i18nProvider.config.defaultLocale\n\n        const localePathResult = this.i18nProvider.analyze(pathname)\n\n        // If the locale is detected from the path, we need to remove it\n        // from the pathname.\n        if (localePathResult.detectedLocale) {\n          pathname = localePathResult.pathname\n        }\n\n        // Update the query with the detected locale and default locale.\n        addRequestMeta(req, 'locale', localePathResult.detectedLocale)\n        addRequestMeta(req, 'defaultLocale', defaultLocale)\n\n        // If the locale is not detected from the path, we need to mark that\n        // it was not inferred from default.\n        if (!localePathResult.detectedLocale) {\n          removeRequestMeta(req, 'localeInferredFromDefault')\n        }\n\n        // If no locale was detected and we don't have middleware, we need\n        // to render a 404 page.\n        if (!localePathResult.detectedLocale && !middleware) {\n          addRequestMeta(req, 'locale', defaultLocale)\n          await this.render404(req, res, parsedUrl)\n          return true\n        }\n      }\n\n      parsedUrl.pathname = pathname\n      addRequestMeta(req, 'isNextDataReq', true)\n\n      return false\n    }\n\n  protected handleNextImageRequest: RouteHandler<\n    ServerRequest,\n    ServerResponse\n  > = () => false\n\n  protected handleCatchallRenderRequest: RouteHandler<\n    ServerRequest,\n    ServerResponse\n  > = () => false\n\n  protected handleCatchallMiddlewareRequest: RouteHandler<\n    ServerRequest,\n    ServerResponse\n  > = () => false\n\n  protected getRouteMatchers(): RouteMatcherManager {\n    // Create a new manifest loader that get's the manifests from the server.\n    const manifestLoader = new ServerManifestLoader((name) => {\n      switch (name) {\n        case PAGES_MANIFEST:\n          return this.getPagesManifest() ?? null\n        case APP_PATHS_MANIFEST:\n          return this.getAppPathsManifest() ?? null\n        default:\n          return null\n      }\n    })\n\n    // Configure the matchers and handlers.\n    const matchers: RouteMatcherManager = new DefaultRouteMatcherManager()\n\n    // Match pages under `pages/`.\n    matchers.push(\n      new PagesRouteMatcherProvider(\n        this.distDir,\n        manifestLoader,\n        this.i18nProvider\n      )\n    )\n\n    // Match api routes under `pages/api/`.\n    matchers.push(\n      new PagesAPIRouteMatcherProvider(\n        this.distDir,\n        manifestLoader,\n        this.i18nProvider\n      )\n    )\n\n    // If the app directory is enabled, then add the app matchers and handlers.\n    if (this.enabledDirectories.app) {\n      // Match app pages under `app/`.\n      matchers.push(\n        new AppPageRouteMatcherProvider(this.distDir, manifestLoader)\n      )\n      matchers.push(\n        new AppRouteRouteMatcherProvider(this.distDir, manifestLoader)\n      )\n    }\n\n    return matchers\n  }\n\n  protected async instrumentationOnRequestError(\n    ...args: Parameters<ServerOnInstrumentationRequestError>\n  ) {\n    const [err, req, ctx] = args\n\n    if (this.instrumentation) {\n      try {\n        await this.instrumentation.onRequestError?.(\n          err,\n          {\n            path: req.url || '',\n            method: req.method || 'GET',\n            // Normalize middleware headers and other server request headers\n            headers:\n              req instanceof NextRequestHint\n                ? Object.fromEntries(req.headers.entries())\n                : req.headers,\n          },\n          ctx\n        )\n      } catch (handlerErr) {\n        // Log the soft error and continue, since errors can thrown from react stream handler\n        console.error('Error in instrumentation.onRequestError:', handlerErr)\n      }\n    }\n  }\n\n  public logError(err: unknown): void {\n    if (this.quiet) return\n    Log.error(err)\n  }\n\n  public async handleRequest(\n    req: ServerRequest,\n    res: ServerResponse,\n    parsedUrl?: NextUrlWithParsedQuery\n  ): Promise<void> {\n    await this.prepare()\n    const method = req.method.toUpperCase()\n    const tracer = getTracer()\n\n    return tracer.withPropagatedContext(req.headers, () => {\n      return tracer.trace(\n        BaseServerSpan.handleRequest,\n        {\n          spanName: `${method}`,\n          kind: SpanKind.SERVER,\n          attributes: {\n            'http.method': method,\n            'http.target': req.url,\n          },\n        },\n        async (span) =>\n          this.handleRequestImpl(req, res, parsedUrl).finally(() => {\n            if (!span) return\n\n            const isRSCRequest = getRequestMeta(req, 'isRSCRequest') ?? false\n            span.setAttributes({\n              'http.status_code': res.statusCode,\n              'next.rsc': isRSCRequest,\n            })\n\n            if (res.statusCode && res.statusCode >= 500) {\n              // For 5xx status codes: SHOULD be set to 'Error' span status.\n              // x-ref: https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status\n              span.setStatus({\n                code: SpanStatusCode.ERROR,\n              })\n              // For span status 'Error', SHOULD set 'error.type' attribute.\n              span.setAttribute('error.type', res.statusCode.toString())\n            }\n\n            const rootSpanAttributes = tracer.getRootSpanAttributes()\n            // We were unable to get attributes, probably OTEL is not enabled\n            if (!rootSpanAttributes) return\n\n            if (\n              rootSpanAttributes.get('next.span_type') !==\n              BaseServerSpan.handleRequest\n            ) {\n              console.warn(\n                `Unexpected root span type '${rootSpanAttributes.get(\n                  'next.span_type'\n                )}'. Please report this Next.js issue https://github.com/vercel/next.js`\n              )\n              return\n            }\n\n            const route = rootSpanAttributes.get('next.route')\n            if (route) {\n              const name = isRSCRequest\n                ? `RSC ${method} ${route}`\n                : `${method} ${route}`\n\n              span.setAttributes({\n                'next.route': route,\n                'http.route': route,\n                'next.span_name': name,\n              })\n              span.updateName(name)\n            } else {\n              span.updateName(isRSCRequest ? `RSC ${method}` : `${method}`)\n            }\n          })\n      )\n    })\n  }\n\n  private async handleRequestImpl(\n    req: ServerRequest,\n    res: ServerResponse,\n    parsedUrl?: NextUrlWithParsedQuery\n  ): Promise<void> {\n    try {\n      // Wait for the matchers to be ready.\n      await this.matchers.waitTillReady()\n\n      // ensure cookies set in middleware are merged and\n      // not overridden by API routes/getServerSideProps\n      patchSetHeaderWithCookieSupport(\n        req,\n        isNodeNextResponse(res) ? res.originalResponse : res\n      )\n\n      const urlParts = (req.url || '').split('?', 1)\n      const urlNoQuery = urlParts[0]\n\n      // this normalizes repeated slashes in the path e.g. hello//world ->\n      // hello/world or backslashes to forward slashes, this does not\n      // handle trailing slash as that is handled the same as a next.config.js\n      // redirect\n      if (urlNoQuery?.match(/(\\\\|\\/\\/)/)) {\n        const cleanUrl = normalizeRepeatedSlashes(req.url!)\n        res.redirect(cleanUrl, 308).body(cleanUrl).send()\n        return\n      }\n\n      // Parse url if parsedUrl not provided\n      if (!parsedUrl || typeof parsedUrl !== 'object') {\n        if (!req.url) {\n          throw new Error('Invariant: url can not be undefined')\n        }\n\n        parsedUrl = parseUrl(req.url)\n      }\n\n      if (!parsedUrl.pathname) {\n        throw new Error(\"Invariant: pathname can't be empty\")\n      }\n\n      // Parse the querystring ourselves if the user doesn't handle querystring parsing\n      if (typeof parsedUrl.query === 'string') {\n        parsedUrl.query = Object.fromEntries(\n          new URLSearchParams(parsedUrl.query)\n        )\n      }\n\n      // Update the `x-forwarded-*` headers.\n      const { originalRequest = null } = isNodeNextRequest(req) ? req : {}\n      const xForwardedProto = originalRequest?.headers['x-forwarded-proto']\n      const isHttps = xForwardedProto\n        ? xForwardedProto === 'https'\n        : !!(originalRequest?.socket as TLSSocket)?.encrypted\n\n      req.headers['x-forwarded-host'] ??= req.headers['host'] ?? this.hostname\n      req.headers['x-forwarded-port'] ??= this.port\n        ? this.port.toString()\n        : isHttps\n          ? '443'\n          : '80'\n      req.headers['x-forwarded-proto'] ??= isHttps ? 'https' : 'http'\n      req.headers['x-forwarded-for'] ??= originalRequest?.socket?.remoteAddress\n\n      // This should be done before any normalization of the pathname happens as\n      // it captures the initial URL.\n      this.attachRequestMeta(req, parsedUrl)\n\n      let finished = await this.handleRSCRequest(req, res, parsedUrl)\n      if (finished) return\n\n      const domainLocale = this.i18nProvider?.detectDomainLocale(\n        getHostname(parsedUrl, req.headers)\n      )\n\n      const defaultLocale =\n        domainLocale?.defaultLocale || this.nextConfig.i18n?.defaultLocale\n      addRequestMeta(req, 'defaultLocale', defaultLocale)\n\n      const url = parseUrlUtil(req.url.replace(/^\\/+/, '/'))\n      const pathnameInfo = getNextPathnameInfo(url.pathname, {\n        nextConfig: this.nextConfig,\n        i18nProvider: this.i18nProvider,\n      })\n      url.pathname = pathnameInfo.pathname\n\n      if (pathnameInfo.basePath) {\n        req.url = removePathPrefix(req.url!, this.nextConfig.basePath)\n      }\n\n      const useMatchedPathHeader =\n        this.minimalMode && typeof req.headers[MATCHED_PATH_HEADER] === 'string'\n\n      // TODO: merge handling with invokePath\n      if (useMatchedPathHeader) {\n        try {\n          if (this.enabledDirectories.app) {\n            // ensure /index path is normalized for prerender\n            // in minimal mode\n            if (req.url.match(/^\\/index($|\\?)/)) {\n              req.url = req.url.replace(/^\\/index/, '/')\n            }\n            parsedUrl.pathname =\n              parsedUrl.pathname === '/index' ? '/' : parsedUrl.pathname\n          }\n\n          // x-matched-path is the source of truth, it tells what page\n          // should be rendered because we don't process rewrites in minimalMode\n          let { pathname: matchedPath } = new URL(\n            fixMojibake(req.headers[MATCHED_PATH_HEADER] as string),\n            'http://localhost'\n          )\n\n          let { pathname: urlPathname } = new URL(req.url, 'http://localhost')\n\n          // For ISR the URL is normalized to the prerenderPath so if\n          // it's a data request the URL path will be the data URL,\n          // basePath is already stripped by this point\n          if (this.normalizers.data?.match(urlPathname)) {\n            addRequestMeta(req, 'isNextDataReq', true)\n          }\n\n          // It's important to execute the following block even it the request\n          // matches a pages data route from above.\n          if (\n            this.isAppPPREnabled &&\n            this.minimalMode &&\n            req.headers[NEXT_RESUME_HEADER] === '1' &&\n            req.method === 'POST'\n          ) {\n            // Get the configured max postponed state size.\n            const maxPostponedStateSize =\n              this.nextConfig.experimental.maxPostponedStateSize ??\n              DEFAULT_MAX_POSTPONED_STATE_SIZE\n            const maxPostponedStateSizeBytes = parseMaxPostponedStateSize(\n              this.nextConfig.experimental.maxPostponedStateSize\n            )\n            if (maxPostponedStateSizeBytes === undefined) {\n              throw new Error(\n                'maxPostponedStateSize must be a valid number (bytes) or filesize format string (e.g., \"5mb\")'\n              )\n            }\n\n            // Decode the postponed state from the request body, it will come as\n            // an array of buffers, so collect them and then concat them to form\n            // the string.\n            const body: Array<Buffer> = []\n            let size = 0\n            for await (const chunk of req.body) {\n              size += Buffer.byteLength(chunk)\n              if (size > maxPostponedStateSizeBytes) {\n                res.statusCode = 413\n                const errorMessage =\n                  `Postponed state exceeded ${maxPostponedStateSize} limit. ` +\n                  `To configure the limit, see: https://nextjs.org/docs/app/api-reference/config/next-config-js/max-postponed-state-size`\n                res.body(errorMessage).send()\n                return\n              }\n              body.push(chunk)\n            }\n            const postponed = Buffer.concat(body).toString('utf8')\n\n            addRequestMeta(req, 'postponed', postponed)\n          }\n\n          // If the request is a next data request and it has a postponed state,\n          // we should error, as it represents an unprocessable request.\n          if (\n            getRequestMeta(req, 'isNextDataReq') &&\n            getRequestMeta(req, 'postponed')\n          ) {\n            // The server understood that this is a PPR resume request, as the\n            // headers were included to correctly indicate a resume request, but\n            // because the request URL indicates that this should render a next\n            // data route (a pages router route), this represents an\n            // unprocessable request.\n            res.statusCode = 422\n            res.send()\n            return\n          }\n\n          matchedPath = this.normalize(matchedPath)\n          const normalizedUrlPath = this.stripNextDataPath(urlPathname)\n\n          matchedPath = denormalizePagePath(matchedPath)\n\n          // Perform locale detection and normalization.\n          const localeAnalysisResult = this.i18nProvider?.analyze(matchedPath, {\n            defaultLocale,\n          })\n\n          // The locale result will be defined even if the locale was not\n          // detected for the request because it will be inferred from the\n          // default locale.\n          if (localeAnalysisResult) {\n            addRequestMeta(req, 'locale', localeAnalysisResult.detectedLocale)\n\n            // If the detected locale was inferred from the default locale, we\n            // need to modify the metadata on the request to indicate that.\n            if (localeAnalysisResult.inferredFromDefault) {\n              addRequestMeta(req, 'localeInferredFromDefault', true)\n            } else {\n              removeRequestMeta(req, 'localeInferredFromDefault')\n            }\n          }\n\n          let srcPathname = matchedPath\n          let pageIsDynamic = isDynamicRoute(srcPathname)\n          let paramsResult: {\n            params: ParsedUrlQuery | false\n            hasValidParams: boolean\n          } = {\n            params: false,\n            hasValidParams: false,\n          }\n\n          const match = await this.matchers.match(srcPathname, {\n            i18n: localeAnalysisResult,\n          })\n\n          if (!pageIsDynamic && match) {\n            // Update the source pathname to the matched page's pathname.\n            srcPathname = match.definition.pathname\n\n            // The page is dynamic if the params are defined. We know at this\n            // stage that the matched path is not a static page if the params\n            // were parsed from the matched path header.\n            if (typeof match.params !== 'undefined') {\n              pageIsDynamic = true\n              paramsResult.params = match.params\n              paramsResult.hasValidParams = true\n            }\n          }\n\n          // The rest of this function can't handle i18n properly, so ensure we\n          // restore the pathname with the locale information stripped from it\n          // now that we're done matching if we're using i18n.\n          if (localeAnalysisResult) {\n            matchedPath = localeAnalysisResult.pathname\n          }\n\n          const utils = getServerUtils({\n            pageIsDynamic,\n            page: srcPathname,\n            i18n: this.nextConfig.i18n,\n            basePath: this.nextConfig.basePath,\n            rewrites: this.getRoutesManifest()?.rewrites || {\n              beforeFiles: [],\n              afterFiles: [],\n              fallback: [],\n            },\n            caseSensitive: !!this.nextConfig.experimental.caseSensitiveRoutes,\n          })\n\n          // Ensure parsedUrl.pathname includes locale before processing\n          // rewrites or they won't match correctly.\n          if (defaultLocale && !pathnameInfo.locale) {\n            parsedUrl.pathname = `/${defaultLocale}${parsedUrl.pathname}`\n          }\n\n          // Store a copy of `parsedUrl.query` before calling handleRewrites.\n          // Since `handleRewrites` might add new queries to `parsedUrl.query`.\n          const originQueryParams = { ...parsedUrl.query }\n\n          const pathnameBeforeRewrite = parsedUrl.pathname\n          const { rewriteParams, rewrittenParsedUrl } = utils.handleRewrites(\n            req,\n            parsedUrl\n          )\n          const rewriteParamKeys = Object.keys(rewriteParams)\n\n          // Create a copy of the query params to avoid mutating the original\n          // object. This prevents any overlapping query params that have the\n          // same normalized key from causing issues.\n          const rewrittenQueryParams = { ...rewrittenParsedUrl.query }\n          const didRewrite =\n            pathnameBeforeRewrite !== rewrittenParsedUrl.pathname\n\n          if (didRewrite && rewrittenParsedUrl.pathname) {\n            addRequestMeta(\n              req,\n              'rewrittenPathname',\n              rewrittenParsedUrl.pathname\n            )\n          }\n\n          const routeParamKeys = new Set<string>()\n          for (const [key, value] of Object.entries(parsedUrl.query)) {\n            const normalizedKey = normalizeNextQueryParam(key)\n            if (!normalizedKey) continue\n\n            // Remove the prefixed key from the query params because we want\n            // to consume it for the dynamic route matcher.\n            delete parsedUrl.query[key]\n            routeParamKeys.add(normalizedKey)\n\n            if (typeof value === 'undefined') continue\n\n            rewrittenQueryParams[normalizedKey] = Array.isArray(value)\n              ? value.map((v) => decodeQueryPathParameter(v))\n              : decodeQueryPathParameter(value)\n          }\n\n          // interpolate dynamic params and normalize URL if needed\n          if (pageIsDynamic) {\n            let params: ParsedUrlQuery | false = {}\n\n            // If we don't already have valid params, try to parse them from\n            // the query params.\n            if (!paramsResult.hasValidParams) {\n              paramsResult = utils.normalizeDynamicRouteParams(\n                rewrittenQueryParams,\n                false\n              )\n            }\n\n            // for prerendered ISR paths we attempt parsing the route\n            // params from the URL directly as route-matches may not\n            // contain the correct values due to the filesystem path\n            // matching before the dynamic route has been matched\n            if (\n              !paramsResult.hasValidParams &&\n              !isDynamicRoute(normalizedUrlPath)\n            ) {\n              let matcherParams = utils.dynamicRouteMatcher?.(normalizedUrlPath)\n\n              if (matcherParams) {\n                utils.normalizeDynamicRouteParams(matcherParams, false)\n                Object.assign(paramsResult.params, matcherParams)\n                paramsResult.hasValidParams = true\n              }\n            }\n\n            // if an action request is bypassing a prerender and we\n            // don't have the params in the URL since it was prerendered\n            // and matched during handle: 'filesystem' rather than dynamic route\n            // resolving we need to parse the params from the matched-path.\n            // Note: this is similar to above case but from match-path instead\n            // of from the request URL since a rewrite could cause that to not\n            // match the src pathname\n            if (\n              // we can have a collision with /index and a top-level /[slug]\n              matchedPath !== '/index' &&\n              !paramsResult.hasValidParams &&\n              !isDynamicRoute(matchedPath)\n            ) {\n              let matcherParams = utils.dynamicRouteMatcher?.(matchedPath)\n\n              if (matcherParams) {\n                const curParamsResult = utils.normalizeDynamicRouteParams(\n                  matcherParams,\n                  false\n                )\n\n                if (curParamsResult.hasValidParams) {\n                  Object.assign(params, matcherParams)\n                  paramsResult = curParamsResult\n                }\n              }\n            }\n\n            if (paramsResult.hasValidParams) {\n              params = paramsResult.params\n            }\n\n            const routeMatchesHeader = req.headers['x-now-route-matches']\n            if (\n              typeof routeMatchesHeader === 'string' &&\n              routeMatchesHeader &&\n              isDynamicRoute(matchedPath) &&\n              !paramsResult.hasValidParams\n            ) {\n              const routeMatches =\n                utils.getParamsFromRouteMatches(routeMatchesHeader)\n\n              if (routeMatches) {\n                paramsResult = utils.normalizeDynamicRouteParams(\n                  routeMatches,\n                  true\n                )\n\n                if (paramsResult.hasValidParams) {\n                  params = paramsResult.params\n                }\n              }\n            }\n\n            // Try to parse the params from the query if we couldn't parse them\n            // from the route matches but ignore missing optional params.\n            if (!paramsResult.hasValidParams) {\n              paramsResult = utils.normalizeDynamicRouteParams(\n                rewrittenQueryParams,\n                true\n              )\n\n              if (paramsResult.hasValidParams) {\n                params = paramsResult.params\n              }\n            }\n\n            // If the pathname being requested is the same as the source\n            // pathname, and we don't have valid params, we want to use the\n            // default route matches.\n            if (\n              utils.defaultRouteMatches &&\n              normalizedUrlPath === srcPathname &&\n              !paramsResult.hasValidParams\n            ) {\n              params = utils.defaultRouteMatches\n\n              // If the route matches header is an empty string, we want to\n              // render a fallback shell. This is because we know this came from\n              // a prerender (it has the header) but it's values were filtered\n              // out (because the allowQuery was empty). If it was undefined\n              // then we know that the request is hitting the lambda directly.\n              if (routeMatchesHeader === '') {\n                addRequestMeta(req, 'renderFallbackShell', true)\n              }\n            }\n\n            if (params) {\n              matchedPath = utils.interpolateDynamicPath(srcPathname, params)\n              req.url = utils.interpolateDynamicPath(req.url!, params)\n\n              // If the request is for a segment prefetch, we need to update the\n              // segment prefetch request path to include the interpolated\n              // params.\n              let segmentPrefetchRSCRequest = getRequestMeta(\n                req,\n                'segmentPrefetchRSCRequest'\n              )\n              if (\n                segmentPrefetchRSCRequest &&\n                isDynamicRoute(segmentPrefetchRSCRequest, false)\n              ) {\n                segmentPrefetchRSCRequest = utils.interpolateDynamicPath(\n                  segmentPrefetchRSCRequest,\n                  params\n                )\n\n                req.headers[NEXT_ROUTER_SEGMENT_PREFETCH_HEADER] =\n                  segmentPrefetchRSCRequest\n                addRequestMeta(\n                  req,\n                  'segmentPrefetchRSCRequest',\n                  segmentPrefetchRSCRequest\n                )\n              }\n            }\n          }\n\n          if (pageIsDynamic || didRewrite) {\n            utils.normalizeCdnUrl(req, [\n              ...rewriteParamKeys,\n              ...Object.keys(utils.defaultRouteRegex?.groups || {}),\n            ])\n          }\n\n          // Remove the route `params` keys from `parsedUrl.query` if they are\n          // not in the original query params.\n          // If it's used in both route `params` and query `searchParams`, it should be kept.\n          for (const key of routeParamKeys) {\n            if (!(key in originQueryParams)) {\n              delete parsedUrl.query[key]\n            }\n          }\n\n          parsedUrl.pathname = matchedPath\n          url.pathname = parsedUrl.pathname\n\n          // For Pages Router routes, use the normalized queryParams from\n          // handleRewrites to ensure catch-all routes get proper array values.\n          // App Router routes should not include rewrite query params as they\n          // affect RSC payload.\n          if (\n            match?.definition.kind === RouteKind.PAGES ||\n            match?.definition.kind === RouteKind.PAGES_API\n          ) {\n            parsedUrl.query = rewrittenQueryParams\n          }\n\n          finished = await this.normalizeAndAttachMetadata(req, res, parsedUrl)\n          if (finished) return\n        } catch (err) {\n          if (err instanceof DecodeError || err instanceof NormalizeError) {\n            res.statusCode = 400\n            return this.renderError(null, req, res, '/_error', {})\n          }\n          throw err\n        }\n      }\n\n      addRequestMeta(req, 'isLocaleDomain', Boolean(domainLocale))\n\n      if (pathnameInfo.locale) {\n        req.url = formatUrl(url)\n        addRequestMeta(req, 'didStripLocale', true)\n      }\n\n      // If we aren't in minimal mode or there is no locale in the query\n      // string, add the locale to the query string.\n      if (!this.minimalMode || !getRequestMeta(req, 'locale')) {\n        // If the locale is in the pathname, add it to the query string.\n        if (pathnameInfo.locale) {\n          addRequestMeta(req, 'locale', pathnameInfo.locale)\n        }\n        // If the default locale is available, add it to the query string and\n        // mark it as inferred rather than implicit.\n        else if (defaultLocale) {\n          addRequestMeta(req, 'locale', defaultLocale)\n          addRequestMeta(req, 'localeInferredFromDefault', true)\n        }\n      }\n\n      // set incremental cache to request meta so it can\n      // be passed down for edge functions and the fetch disk\n      // cache can be leveraged locally\n      if (\n        !(this.serverOptions as any).webServerConfig &&\n        !getRequestMeta(req, 'incrementalCache')\n      ) {\n        const incrementalCache = await this.getIncrementalCache({\n          requestHeaders: Object.assign({}, req.headers),\n        })\n\n        incrementalCache.resetRequestCache()\n        addRequestMeta(req, 'incrementalCache', incrementalCache)\n        // This is needed for pages router to leverage unstable_cache\n        // TODO: re-work this handling to not use global and use a AsyncStore\n        ;(globalThis as any).__incrementalCache = incrementalCache\n      }\n\n      // set server components HMR cache to request meta so it can be passed\n      // down for edge functions\n      if (!getRequestMeta(req, 'serverComponentsHmrCache')) {\n        addRequestMeta(\n          req,\n          'serverComponentsHmrCache',\n          this.getServerComponentsHmrCache()\n        )\n      }\n\n      // when invokePath is specified we can short short circuit resolving\n      // we only honor this header if we are inside of a render worker to\n      // prevent external users coercing the routing path\n      const invokePath = getRequestMeta(req, 'invokePath')\n      const useInvokePath = !useMatchedPathHeader && invokePath\n\n      if (useInvokePath) {\n        const invokeStatus = getRequestMeta(req, 'invokeStatus')\n        if (invokeStatus) {\n          const invokeQuery = getRequestMeta(req, 'invokeQuery')\n\n          if (invokeQuery) {\n            Object.assign(parsedUrl.query, invokeQuery)\n          }\n\n          res.statusCode = invokeStatus\n          let err: Error | null = getRequestMeta(req, 'invokeError') || null\n\n          return this.renderError(err, req, res, '/_error', parsedUrl.query)\n        }\n\n        const parsedMatchedPath = new URL(invokePath || '/', 'http://n')\n        const invokePathnameInfo = getNextPathnameInfo(\n          parsedMatchedPath.pathname,\n          {\n            nextConfig: this.nextConfig,\n            parseData: false,\n          }\n        )\n\n        if (invokePathnameInfo.locale) {\n          addRequestMeta(req, 'locale', invokePathnameInfo.locale)\n        }\n\n        if (parsedUrl.pathname !== parsedMatchedPath.pathname) {\n          parsedUrl.pathname = parsedMatchedPath.pathname\n          addRequestMeta(req, 'rewrittenPathname', invokePathnameInfo.pathname)\n        }\n        const normalizeResult = normalizeLocalePath(\n          removePathPrefix(parsedUrl.pathname, this.nextConfig.basePath || ''),\n          this.nextConfig.i18n?.locales\n        )\n\n        if (normalizeResult.detectedLocale) {\n          addRequestMeta(req, 'locale', normalizeResult.detectedLocale)\n        }\n        parsedUrl.pathname = normalizeResult.pathname\n\n        for (const key of Object.keys(parsedUrl.query)) {\n          delete parsedUrl.query[key]\n        }\n        const invokeQuery = getRequestMeta(req, 'invokeQuery')\n\n        if (invokeQuery) {\n          Object.assign(parsedUrl.query, invokeQuery)\n        }\n\n        finished = await this.normalizeAndAttachMetadata(req, res, parsedUrl)\n        if (finished) return\n\n        await this.handleCatchallRenderRequest(req, res, parsedUrl)\n        return\n      }\n\n      if (getRequestMeta(req, 'middlewareInvoke')) {\n        finished = await this.normalizeAndAttachMetadata(req, res, parsedUrl)\n        if (finished) return\n\n        finished = await this.handleCatchallMiddlewareRequest(\n          req,\n          res,\n          parsedUrl\n        )\n        if (finished) return\n\n        const err = new Error()\n        ;(err as any).result = {\n          response: new Response(null, {\n            headers: {\n              'x-middleware-next': '1',\n            },\n          }),\n        }\n        ;(err as any).bubble = true\n        throw err\n      }\n\n      // This wasn't a request via the matched path or the invoke path, so\n      // prepare for a legacy run by removing the base path.\n\n      // ensure we strip the basePath when not using an invoke header\n      if (!useMatchedPathHeader && pathnameInfo.basePath) {\n        parsedUrl.pathname = removePathPrefix(\n          parsedUrl.pathname,\n          pathnameInfo.basePath\n        )\n      }\n\n      res.statusCode = 200\n      return await this.run(req, res, parsedUrl)\n    } catch (err: any) {\n      if (err instanceof NoFallbackError) {\n        throw err\n      }\n\n      if (\n        (err && typeof err === 'object' && err.code === 'ERR_INVALID_URL') ||\n        err instanceof DecodeError ||\n        err instanceof NormalizeError\n      ) {\n        res.statusCode = 400\n        return this.renderError(null, req, res, '/_error', {})\n      }\n\n      if (\n        this.minimalMode ||\n        this.renderOpts.dev ||\n        (isBubbledError(err) && err.bubble)\n      ) {\n        throw err\n      }\n      this.logError(getProperError(err))\n      res.statusCode = 500\n      res.body('Internal Server Error').send()\n    }\n  }\n\n  /**\n   * Normalizes a pathname without attaching any metadata from any matched\n   * normalizer.\n   *\n   * @param pathname the pathname to normalize\n   * @returns the normalized pathname\n   */\n  private normalize = (pathname: string) => {\n    const normalizers: Array<PathnameNormalizer> = []\n\n    if (this.normalizers.data) {\n      normalizers.push(this.normalizers.data)\n    }\n\n    // We have to put the segment prefetch normalizer before the RSC normalizer\n    // because the RSC normalizer will match the prefetch RSC routes too.\n    if (this.normalizers.segmentPrefetchRSC) {\n      normalizers.push(this.normalizers.segmentPrefetchRSC)\n    }\n\n    if (this.normalizers.rsc) {\n      normalizers.push(this.normalizers.rsc)\n    }\n\n    for (const normalizer of normalizers) {\n      if (!normalizer.match(pathname)) continue\n\n      return normalizer.normalize(pathname, true)\n    }\n\n    return pathname\n  }\n\n  private normalizeAndAttachMetadata: RouteHandler<\n    ServerRequest,\n    ServerResponse\n  > = async (req, res, url) => {\n    let finished = await this.handleNextImageRequest(req, res, url)\n    if (finished) return true\n\n    if (this.enabledDirectories.pages) {\n      finished = await this.handleNextDataRequest(req, res, url)\n      if (finished) return true\n    }\n\n    return false\n  }\n\n  /**\n   * @internal - this method is internal to Next.js and should not be used directly by end-users\n   */\n  public getRequestHandlerWithMetadata(\n    meta: RequestMeta\n  ): BaseRequestHandler<ServerRequest, ServerResponse> {\n    const handler = this.getRequestHandler()\n    return (req, res, parsedUrl) => {\n      setRequestMeta(req, meta)\n      return handler(req, res, parsedUrl)\n    }\n  }\n\n  public getRequestHandler(): BaseRequestHandler<\n    ServerRequest,\n    ServerResponse\n  > {\n    return this.handleRequest.bind(this)\n  }\n\n  protected abstract handleUpgrade(\n    req: ServerRequest,\n    socket: any,\n    head?: any\n  ): Promise<void>\n\n  public setAssetPrefix(prefix?: string): void {\n    this.nextConfig.assetPrefix = prefix ? prefix.replace(/\\/$/, '') : ''\n  }\n\n  protected prepared: boolean = false\n  protected preparedPromise: Promise<void> | null = null\n  /**\n   * Runs async initialization of server.\n   * It is idempotent, won't fire underlying initialization more than once.\n   */\n  public async prepare(): Promise<void> {\n    if (this.prepared) return\n\n    // Get instrumentation module\n    if (!this.instrumentation) {\n      this.instrumentation = await this.loadInstrumentationModule()\n    }\n    if (this.preparedPromise === null) {\n      this.preparedPromise = this.prepareImpl().then(() => {\n        this.prepared = true\n        this.preparedPromise = null\n      })\n    }\n    return this.preparedPromise\n  }\n  protected async prepareImpl(): Promise<void> {}\n  protected async loadInstrumentationModule(): Promise<any> {}\n\n  public async close(): Promise<void> {}\n\n  protected getAppPathRoutes(): Record<string, string[]> {\n    const appPathRoutes: Record<string, string[]> = {}\n\n    Object.keys(this.appPathsManifest || {}).forEach((entry) => {\n      const normalizedPath = normalizeAppPath(entry)\n      if (!appPathRoutes[normalizedPath]) {\n        appPathRoutes[normalizedPath] = []\n      }\n      appPathRoutes[normalizedPath].push(entry)\n    })\n    return appPathRoutes\n  }\n\n  protected async run(\n    req: ServerRequest,\n    res: ServerResponse,\n    parsedUrl: NextUrlWithParsedQuery\n  ): Promise<void> {\n    return getTracer().trace(BaseServerSpan.run, async () =>\n      this.runImpl(req, res, parsedUrl)\n    )\n  }\n\n  private async runImpl(\n    req: ServerRequest,\n    res: ServerResponse,\n    parsedUrl: NextUrlWithParsedQuery\n  ): Promise<void> {\n    await this.handleCatchallRenderRequest(req, res, parsedUrl)\n  }\n\n  private async pipe(\n    fn: (\n      ctx: RequestContext<ServerRequest, ServerResponse>\n    ) => Promise<ResponsePayload | null>,\n    partialContext: Omit<\n      RequestContext<ServerRequest, ServerResponse>,\n      'renderOpts'\n    >\n  ): Promise<void> {\n    return getTracer().trace(BaseServerSpan.pipe, async () =>\n      this.pipeImpl(fn, partialContext)\n    )\n  }\n\n  private async pipeImpl(\n    fn: (\n      ctx: RequestContext<ServerRequest, ServerResponse>\n    ) => Promise<ResponsePayload | null>,\n    partialContext: Omit<\n      RequestContext<ServerRequest, ServerResponse>,\n      'renderOpts'\n    >\n  ): Promise<void> {\n    const ua = partialContext.req.headers['user-agent'] || ''\n\n    const ctx: RequestContext<ServerRequest, ServerResponse> = {\n      ...partialContext,\n      renderOpts: {\n        ...this.renderOpts,\n        // `renderOpts.botType` is accumulated in `this.renderImpl()`\n        supportsDynamicResponse: !this.renderOpts.botType,\n        serveStreamingMetadata: shouldServeStreamingMetadata(\n          ua,\n          this.nextConfig.htmlLimitedBots\n        ),\n      },\n    }\n\n    const payload = await fn(ctx)\n    if (payload === null) {\n      return\n    }\n    const { req, res } = ctx\n    const originalStatus = res.statusCode\n    const { body } = payload\n    let { cacheControl } = payload\n    if (!res.sent) {\n      const { generateEtags, poweredByHeader, dev } = this.renderOpts\n\n      // In dev, we should not cache pages for any reason.\n      if (dev) {\n        res.setHeader(\n          'Cache-Control',\n          this.nextConfig.experimental.devCacheControlNoCache\n            ? 'no-cache, must-revalidate'\n            : 'no-store, must-revalidate'\n        )\n        cacheControl = undefined\n      }\n\n      if (cacheControl && cacheControl.expire === undefined) {\n        cacheControl.expire = this.nextConfig.expireTime\n      }\n\n      await this.sendRenderResult(req, res, {\n        result: body,\n        generateEtags,\n        poweredByHeader,\n        cacheControl,\n      })\n      res.statusCode = originalStatus\n    }\n  }\n\n  private async getStaticHTML(\n    fn: (\n      ctx: RequestContext<ServerRequest, ServerResponse>\n    ) => Promise<ResponsePayload | null>,\n    partialContext: Omit<\n      RequestContext<ServerRequest, ServerResponse>,\n      'renderOpts'\n    >\n  ): Promise<string | null> {\n    const ctx: RequestContext<ServerRequest, ServerResponse> = {\n      ...partialContext,\n      renderOpts: {\n        ...this.renderOpts,\n        supportsDynamicResponse: false,\n      },\n    }\n    const payload = await fn(ctx)\n    if (payload === null) {\n      return null\n    }\n    return payload.body.toUnchunkedString()\n  }\n\n  public async render(\n    req: ServerRequest,\n    res: ServerResponse,\n    pathname: string,\n    query: NextParsedUrlQuery = {},\n    parsedUrl?: NextUrlWithParsedQuery,\n    internalRender = false\n  ): Promise<void> {\n    return getTracer().trace(BaseServerSpan.render, async () =>\n      this.renderImpl(req, res, pathname, query, parsedUrl, internalRender)\n    )\n  }\n\n  protected getWaitUntil(): WaitUntil | undefined {\n    const builtinRequestContext = getBuiltinRequestContext()\n    if (builtinRequestContext) {\n      // the platform provided a request context.\n      // use the `waitUntil` from there, whether actually present or not --\n      // if not present, `after` will error.\n\n      // NOTE: if we're in an edge runtime sandbox, this context will be used to forward the outer waitUntil.\n      return builtinRequestContext.waitUntil\n    }\n\n    if (this.minimalMode) {\n      // we're built for a serverless environment, and `waitUntil` is not available,\n      // but using a noop would likely lead to incorrect behavior,\n      // because we have no way of keeping the invocation alive.\n      // return nothing, and `after` will error if used.\n      //\n      // NOTE: for edge functions, `NextWebServer` always runs in minimal mode.\n      //\n      // NOTE: if we're in an edge runtime sandbox, waitUntil will be passed in using \"@next/request-context\",\n      // so we won't get here.\n      return undefined\n    }\n\n    return this.getInternalWaitUntil()\n  }\n\n  protected getInternalWaitUntil(): WaitUntil | undefined {\n    return undefined\n  }\n\n  private async renderImpl(\n    req: ServerRequest,\n    res: ServerResponse,\n    pathname: string,\n    query: NextParsedUrlQuery = {},\n    parsedUrl?: NextUrlWithParsedQuery,\n    internalRender = false\n  ): Promise<void> {\n    if (!pathname.startsWith('/')) {\n      console.warn(\n        `Cannot render page with path \"${pathname}\", did you mean \"/${pathname}\"?. See more info here: https://nextjs.org/docs/messages/render-no-starting-slash`\n      )\n    }\n\n    if (\n      this.serverOptions.customServer &&\n      pathname === '/index' &&\n      !(await this.hasPage('/index'))\n    ) {\n      // maintain backwards compatibility for custom server\n      // (see custom-server integration tests)\n      pathname = '/'\n    }\n\n    const ua = req.headers['user-agent'] || ''\n    this.renderOpts.botType = getBotType(ua)\n\n    // we allow custom servers to call render for all URLs\n    // so check if we need to serve a static _next file or not.\n    // we don't modify the URL for _next/data request but still\n    // call render so we special case this to prevent an infinite loop\n    if (\n      !internalRender &&\n      !this.minimalMode &&\n      !getRequestMeta(req, 'isNextDataReq') &&\n      (req.url?.match(/^\\/_next\\//) ||\n        (this.hasStaticDir && req.url!.match(/^\\/static\\//)))\n    ) {\n      return this.handleRequest(req, res, parsedUrl)\n    }\n\n    if (isBlockedPage(pathname)) {\n      return this.render404(req, res, parsedUrl)\n    }\n\n    return this.pipe((ctx) => this.renderToResponse(ctx), {\n      req,\n      res,\n      pathname,\n      query,\n    })\n  }\n\n  protected async getStaticPaths({\n    pathname,\n  }: {\n    pathname: string\n    urlPathname: string\n    requestHeaders: import('./lib/incremental-cache').IncrementalCache['requestHeaders']\n    page: string\n    isAppPath: boolean\n  }): Promise<{\n    staticPaths?: string[]\n    prerenderedRoutes?: PrerenderedRoute[]\n    fallbackMode?: FallbackMode\n  }> {\n    // Read whether or not fallback should exist from the manifest.\n    const fallbackField =\n      this.getPrerenderManifest().dynamicRoutes[pathname]?.fallback\n\n    return {\n      // `staticPaths` is intentionally set to `undefined` as it should've\n      // been caught when checking disk data.\n      staticPaths: undefined,\n      fallbackMode: parseFallbackField(fallbackField),\n    }\n  }\n\n  private async renderToResponseWithComponents(\n    requestContext: RequestContext<ServerRequest, ServerResponse>,\n    findComponentsResult: FindComponentsResult\n  ): Promise<ResponsePayload | null> {\n    return getTracer().trace(\n      BaseServerSpan.renderToResponseWithComponents,\n      async () =>\n        this.renderToResponseWithComponentsImpl(\n          requestContext,\n          findComponentsResult\n        )\n    )\n  }\n\n  protected pathCouldBeIntercepted(resolvedPathname: string): boolean {\n    return (\n      isInterceptionRouteAppPath(resolvedPathname) ||\n      this.interceptionRoutePatterns.some((regexp) => {\n        return regexp.test(resolvedPathname)\n      })\n    )\n  }\n\n  protected setVaryHeader(\n    req: ServerRequest,\n    res: ServerResponse,\n    isAppPath: boolean,\n    resolvedPathname: string\n  ): void {\n    const baseVaryHeader = `${RSC_HEADER}, ${NEXT_ROUTER_STATE_TREE_HEADER}, ${NEXT_ROUTER_PREFETCH_HEADER}, ${NEXT_ROUTER_SEGMENT_PREFETCH_HEADER}`\n    const isRSCRequest = getRequestMeta(req, 'isRSCRequest') ?? false\n\n    let addedNextUrlToVary = false\n\n    if (isAppPath && this.pathCouldBeIntercepted(resolvedPathname)) {\n      // Interception route responses can vary based on the `Next-URL` header.\n      // We use the Vary header to signal this behavior to the client to properly cache the response.\n      res.appendHeader('vary', `${baseVaryHeader}, ${NEXT_URL}`)\n      addedNextUrlToVary = true\n    } else if (isAppPath || isRSCRequest) {\n      // We don't need to include `Next-URL` in the Vary header for non-interception routes since it won't affect the response.\n      // We also set this header for pages to avoid caching issues when navigating between pages and app.\n      res.appendHeader('vary', baseVaryHeader)\n    }\n\n    if (!addedNextUrlToVary) {\n      // Remove `Next-URL` from the request headers we determined it wasn't necessary to include in the Vary header.\n      // This is to avoid any dependency on the `Next-URL` header being present when preparing the response.\n      delete req.headers[NEXT_URL]\n    }\n  }\n\n  private async renderToResponseWithComponentsImpl(\n    {\n      req,\n      res,\n      pathname,\n      renderOpts: opts,\n    }: RequestContext<ServerRequest, ServerResponse>,\n    { components, query }: FindComponentsResult\n  ): Promise<ResponsePayload | null> {\n    if (pathname === UNDERSCORE_NOT_FOUND_ROUTE) {\n      pathname = '/404'\n    }\n    const isErrorPathname = pathname === '/_error'\n    const is404Page =\n      pathname === '/404' || (isErrorPathname && res.statusCode === 404)\n    const is500Page =\n      pathname === '/500' || (isErrorPathname && res.statusCode === 500)\n    const isAppPath = components.isAppPath === true\n\n    const hasServerProps = !!components.getServerSideProps\n    const isPossibleServerAction = getIsPossibleServerAction(req)\n    let isSSG = !!components.getStaticProps\n    // NOTE: Don't delete headers[RSC] yet, it still needs to be used in renderToHTML later\n    const isRSCRequest = getRequestMeta(req, 'isRSCRequest') ?? false\n\n    // Not all CDNs respect the Vary header when caching. We must assume that\n    // only the URL is used to vary the responses. The Next client computes a\n    // hash of the header values and sends it as a search param. Before\n    // responding to a request, we must verify that the hash matches the\n    // expected value. Neglecting to do this properly can lead to cache\n    // poisoning attacks on certain CDNs.\n    if (\n      !this.minimalMode &&\n      this.nextConfig.experimental.validateRSCRequestHeaders &&\n      isRSCRequest &&\n      // In the event that we're serving a NoFallbackError, the headers will\n      // already be stripped so this comparison will always fail, resulting in\n      // a redirect loop.\n      !is404Page\n    ) {\n      const headers = req.headers\n\n      const prefetchHeaderValue = headers[NEXT_ROUTER_PREFETCH_HEADER]\n      const routerPrefetch =\n        prefetchHeaderValue !== undefined\n          ? // We only recognize '1' and '2'. Strip all other values here.\n            prefetchHeaderValue === '1' || prefetchHeaderValue === '2'\n            ? prefetchHeaderValue\n            : undefined\n          : // For runtime prefetches, we always perform a dynamic request,\n            // so we don't expect the header to be stripped by an intermediate layer.\n            // This should only happen for static prefetches, so we only handle those here.\n            getRequestMeta(req, 'isPrefetchRSCRequest')\n            ? '1'\n            : undefined\n\n      const segmentPrefetchRSCRequest =\n        headers[NEXT_ROUTER_SEGMENT_PREFETCH_HEADER] ||\n        getRequestMeta(req, 'segmentPrefetchRSCRequest')\n\n      const expectedHash = computeCacheBustingSearchParam(\n        routerPrefetch,\n        segmentPrefetchRSCRequest,\n        headers[NEXT_ROUTER_STATE_TREE_HEADER],\n        headers[NEXT_URL]\n      )\n      const actualHash =\n        getRequestMeta(req, 'cacheBustingSearchParam') ??\n        new URL(req.url || '', 'http://localhost').searchParams.get(\n          NEXT_RSC_UNION_QUERY\n        )\n\n      if (expectedHash !== actualHash) {\n        // The hash sent by the client does not match the expected value.\n        // Redirect to the URL with the correct cache-busting search param.\n        // This prevents cache poisoning attacks on CDNs that don't respect Vary headers.\n        // Note: When no headers are present, expectedHash is empty string and client\n        // must send `_rsc` param, otherwise actualHash is null and hash check fails.\n        const url = new URL(req.url || '', 'http://localhost')\n        setCacheBustingSearchParamWithHash(url, expectedHash)\n        res.statusCode = 307\n        res.setHeader('location', `${url.pathname}${url.search}`)\n        res.body('').send()\n        return null\n      }\n    }\n\n    // Compute the iSSG cache key. We use the rewritten pathname since\n    // pages with fallback: false are allowed to be rewritten to\n    // and we need to look up the path by the rewritten path\n    let urlPathname = parseUrl(req.url || '').pathname || '/'\n\n    let resolvedUrlPathname =\n      getRequestMeta(req, 'rewrittenPathname') || urlPathname\n\n    this.setVaryHeader(req, res, isAppPath, resolvedUrlPathname)\n\n    let staticPaths: string[] | undefined\n    let hasFallback = false\n\n    const prerenderManifest = this.getPrerenderManifest()\n\n    if (\n      hasFallback ||\n      staticPaths?.includes(resolvedUrlPathname) ||\n      // this signals revalidation in deploy environments\n      // TODO: make this more generic\n      req.headers['x-now-route-matches']\n    ) {\n      isSSG = true\n    } else if (!this.renderOpts.dev) {\n      isSSG ||= !!prerenderManifest.routes[toRoute(pathname)]\n    }\n\n    // Toggle whether or not this is a Data request\n    const isNextDataRequest =\n      !!(\n        getRequestMeta(req, 'isNextDataReq') ||\n        (req.headers['x-nextjs-data'] &&\n          (this.serverOptions as any).webServerConfig)\n      ) &&\n      (isSSG || hasServerProps)\n\n    // when we are handling a middleware prefetch and it doesn't\n    // resolve to a static data route we bail early to avoid\n    // unexpected SSR invocations\n    if (\n      !isSSG &&\n      req.headers['x-middleware-prefetch'] &&\n      !(is404Page || pathname === '/_error')\n    ) {\n      res.setHeader(MATCHED_PATH_HEADER, pathname)\n      res.setHeader('x-middleware-skip', '1')\n      res.setHeader(\n        'cache-control',\n        'private, no-cache, no-store, max-age=0, must-revalidate'\n      )\n      res.body('{}').send()\n      return null\n    }\n\n    // normalize req.url for SSG paths as it is not exposed\n    // to getStaticProps and the asPath should not expose /_next/data\n    if (\n      isSSG &&\n      this.minimalMode &&\n      req.headers[MATCHED_PATH_HEADER] &&\n      req.url.startsWith('/_next/data')\n    ) {\n      req.url = this.stripNextDataPath(req.url)\n    }\n\n    const locale = getRequestMeta(req, 'locale')\n\n    if (\n      !!req.headers['x-nextjs-data'] &&\n      (!res.statusCode || res.statusCode === 200)\n    ) {\n      res.setHeader(\n        'x-nextjs-matched-path',\n        `${locale ? `/${locale}` : ''}${pathname}`\n      )\n    }\n\n    let routeModule: RouteModule | undefined\n    if (components.routeModule) {\n      routeModule = components.routeModule\n    }\n\n    /**\n     * If the route being rendered is an app page, and the ppr feature has been\n     * enabled, then the given route _could_ support PPR.\n     */\n    const couldSupportPPR: boolean =\n      this.isAppPPREnabled &&\n      typeof routeModule !== 'undefined' &&\n      isAppPageRouteModule(routeModule)\n\n    // When enabled, this will allow the use of the `?__nextppronly` query to\n    // enable debugging of the static shell.\n    const hasDebugStaticShellQuery =\n      process.env.__NEXT_EXPERIMENTAL_STATIC_SHELL_DEBUGGING === '1' &&\n      typeof query.__nextppronly !== 'undefined' &&\n      couldSupportPPR\n\n    // This page supports PPR if it is marked as being `PARTIALLY_STATIC` in the\n    // prerender manifest and this is an app page.\n    const isRoutePPREnabled: boolean =\n      couldSupportPPR &&\n      ((\n        prerenderManifest.routes[pathname] ??\n        prerenderManifest.dynamicRoutes[pathname]\n      )?.renderingMode === 'PARTIALLY_STATIC' ||\n        // Ideally we'd want to check the appConfig to see if this page has PPR\n        // enabled or not, but that would require plumbing the appConfig through\n        // to the server during development. We assume that the page supports it\n        // but only during development.\n        (hasDebugStaticShellQuery &&\n          (this.renderOpts.dev === true ||\n            this.experimentalTestProxy === true)))\n\n    // If we're in minimal mode, then try to get the postponed information from\n    // the request metadata. If available, use it for resuming the postponed\n    // render.\n    const minimalPostponed = isRoutePPREnabled\n      ? getRequestMeta(req, 'postponed')\n      : undefined\n\n    // we need to ensure the status code if /404 is visited directly\n    if (is404Page && !isNextDataRequest && !isRSCRequest) {\n      res.statusCode = 404\n    }\n\n    // ensure correct status is set when visiting a status page\n    // directly e.g. /500\n    if (STATIC_STATUS_PAGES.includes(pathname)) {\n      res.statusCode = parseInt(pathname.slice(1), 10)\n    }\n\n    if (\n      // Server actions can use non-GET/HEAD methods.\n      !isPossibleServerAction &&\n      // Resume can use non-GET/HEAD methods.\n      !minimalPostponed &&\n      !is404Page &&\n      !is500Page &&\n      pathname !== '/_error' &&\n      req.method !== 'HEAD' &&\n      req.method !== 'GET' &&\n      (typeof components.Component === 'string' || isSSG)\n    ) {\n      res.statusCode = 405\n      res.setHeader('Allow', ['GET', 'HEAD'])\n      res.body('Method Not Allowed').send()\n      return null\n    }\n\n    // handle static page\n    if (typeof components.Component === 'string') {\n      return {\n        body: RenderResult.fromStatic(\n          components.Component,\n          HTML_CONTENT_TYPE_HEADER\n        ),\n      }\n    }\n\n    if (opts.supportsDynamicResponse === true) {\n      const ua = req.headers['user-agent'] || ''\n      const isBotRequest = isBot(ua)\n      const isSupportedDocument =\n        typeof components.Document?.getInitialProps !== 'function' ||\n        // The built-in `Document` component also supports dynamic HTML for concurrent mode.\n        NEXT_BUILTIN_DOCUMENT in components.Document\n\n      // Disable dynamic HTML in cases that we know it won't be generated,\n      // so that we can continue generating a cache key when possible.\n      // TODO-APP: should the first render for a dynamic app path\n      // be static so we can collect revalidate and populate the\n      // cache if there are no dynamic data requirements\n      opts.supportsDynamicResponse =\n        !isSSG && !isBotRequest && isSupportedDocument\n    }\n\n    // In development, we always want to generate dynamic HTML.\n    if (!isNextDataRequest && isAppPath && opts.dev) {\n      opts.supportsDynamicResponse = true\n    }\n\n    if (isSSG && this.minimalMode && req.headers[MATCHED_PATH_HEADER]) {\n      // the url value is already correct when the matched-path header is set\n      resolvedUrlPathname = urlPathname\n    }\n\n    urlPathname = removeTrailingSlash(urlPathname)\n    resolvedUrlPathname = removeTrailingSlash(resolvedUrlPathname)\n    if (this.localeNormalizer) {\n      resolvedUrlPathname = this.localeNormalizer.normalize(resolvedUrlPathname)\n    }\n\n    // remove /_next/data prefix from urlPathname so it matches\n    // for direct page visit and /_next/data visit\n    if (isNextDataRequest) {\n      resolvedUrlPathname = this.stripNextDataPath(resolvedUrlPathname)\n      urlPathname = this.stripNextDataPath(urlPathname)\n    }\n\n    // use existing incrementalCache instance if available\n    const incrementalCache: import('./lib/incremental-cache').IncrementalCache =\n      await this.getIncrementalCache({\n        requestHeaders: Object.assign({}, req.headers),\n      })\n\n    // TODO: investigate, this is not safe across multiple concurrent requests\n    incrementalCache.resetRequestCache()\n\n    if (\n      routeModule?.isDev &&\n      isDynamicRoute(pathname) &&\n      (components.getStaticPaths || isAppPath)\n    ) {\n      let getStaticPathsStart: bigint | undefined\n      if (opts.dev) {\n        getStaticPathsStart = process.hrtime.bigint()\n      }\n\n      const pathsResults = await this.getStaticPaths({\n        pathname,\n        urlPathname,\n        requestHeaders: req.headers,\n        page: components.page,\n        isAppPath,\n      })\n\n      if (opts.dev && getStaticPathsStart && pathsResults.staticPaths?.length) {\n        addRequestMeta(\n          req,\n          'devGenerateStaticParamsDuration',\n          process.hrtime.bigint() - getStaticPathsStart\n        )\n      }\n\n      if (isAppPath && this.nextConfig.cacheComponents) {\n        if (pathsResults.prerenderedRoutes?.length) {\n          let smallestFallbackRouteParams = null\n          for (const route of pathsResults.prerenderedRoutes) {\n            const fallbackRouteParams = route.fallbackRouteParams\n            if (!fallbackRouteParams || fallbackRouteParams.length === 0) {\n              // There are no fallback route params so we don't need to continue\n              smallestFallbackRouteParams = null\n              break\n            }\n            if (\n              smallestFallbackRouteParams === null ||\n              fallbackRouteParams.length < smallestFallbackRouteParams.length\n            ) {\n              smallestFallbackRouteParams = fallbackRouteParams\n            }\n          }\n          if (smallestFallbackRouteParams) {\n            addRequestMeta(\n              req,\n              'devFallbackParams',\n              createOpaqueFallbackRouteParams(smallestFallbackRouteParams)!\n            )\n          }\n        }\n      }\n    }\n\n    // An OPTIONS request to a page handler is invalid.\n    if (\n      req.method === 'OPTIONS' &&\n      !is404Page &&\n      (!routeModule || !isAppRouteRouteModule(routeModule))\n    ) {\n      await sendResponse(req, res, new Response(null, { status: 400 }))\n      return null\n    }\n\n    const request = isNodeNextRequest(req) ? req.originalRequest : req\n    const response = isNodeNextResponse(res) ? res.originalResponse : res\n\n    const parsedInitUrl = parseUrl(getRequestMeta(req, 'initURL') || req.url)\n    let initPathname = parsedInitUrl.pathname || '/'\n\n    for (const normalizer of [\n      this.normalizers.segmentPrefetchRSC,\n      this.normalizers.rsc,\n    ]) {\n      if (normalizer?.match(initPathname)) {\n        initPathname = normalizer.normalize(initPathname)\n      }\n    }\n\n    // On minimal mode, the request url of dynamic route can be a\n    // literal dynamic route ('/[slug]') instead of actual URL, so overwriting to initPathname\n    // will transform back the resolved url to the dynamic route pathname.\n    if (!(this.minimalMode && isErrorPathname)) {\n      request.url = `${initPathname}${parsedInitUrl.search || ''}`\n    }\n\n    // propagate the request context for dev\n    setRequestMeta(request, getRequestMeta(req))\n    addRequestMeta(request, 'distDir', this.distDir)\n    addRequestMeta(request, 'query', query)\n    addRequestMeta(request, 'params', opts.params)\n    addRequestMeta(request, 'minimalMode', this.minimalMode)\n\n    if (opts.err) {\n      addRequestMeta(request, 'invokeError', opts.err)\n    }\n\n    const maybeDevRequest: ServerRequest | IncomingMessage =\n      // we need to capture fetch metrics when they are set\n      // and can't wait for handler to resolve as the fetch\n      // metrics are logged on response close which happens\n      // before handler resolves\n      process.env.NODE_ENV === 'development'\n        ? new Proxy(request, {\n            get(target: any, prop) {\n              if (typeof target[prop] === 'function') {\n                return target[prop].bind(target)\n              }\n              return target[prop]\n            },\n            set(target: any, prop, value) {\n              if (prop === 'fetchMetrics') {\n                ;(req as any).fetchMetrics = value\n              }\n              target[prop] = value\n              return true\n            },\n          })\n        : request\n\n    // @ts-expect-error This isn't entirely correct, but the ServerRequest type param seems overly\n    // generic anyway.\n    let handlerReq: IncomingMessage = maybeDevRequest\n    // @ts-expect-error This isn't entirely correct, but the ServerResponse type param seems overly\n    // generic anyway.\n    let handlerRes: HTTPServerResponse = response\n\n    await components.ComponentMod.handler(handlerReq, handlerRes, {\n      waitUntil: this.getWaitUntil(),\n    })\n\n    // response is handled fully in handler\n    return null\n  }\n\n  private stripNextDataPath(filePath: string, stripLocale = true) {\n    if (filePath.includes(this.buildId)) {\n      const splitPath = filePath.substring(\n        filePath.indexOf(this.buildId) + this.buildId.length\n      )\n\n      filePath = denormalizePagePath(splitPath.replace(/\\.json$/, ''))\n    }\n\n    if (this.localeNormalizer && stripLocale) {\n      return this.localeNormalizer.normalize(filePath)\n    }\n    return filePath\n  }\n\n  // map the route to the actual bundle name\n  protected getOriginalAppPaths(route: string) {\n    if (this.enabledDirectories.app) {\n      const originalAppPath = this.appPathRoutes?.[route]\n\n      if (!originalAppPath) {\n        return null\n      }\n\n      return originalAppPath\n    }\n    return null\n  }\n\n  protected async renderPageComponent(\n    ctx: RequestContext<ServerRequest, ServerResponse>,\n    bubbleNoFallback: boolean\n  ) {\n    const { query, pathname } = ctx\n\n    const appPaths = this.getOriginalAppPaths(pathname)\n    const isAppPath = Array.isArray(appPaths)\n\n    let page = pathname\n    if (isAppPath) {\n      // the last item in the array is the root page, if there are parallel routes\n      page = appPaths[appPaths.length - 1]\n    }\n\n    const result = await this.findPageComponents({\n      locale: getRequestMeta(ctx.req, 'locale'),\n      page,\n      query,\n      params: ctx.renderOpts.params || {},\n      isAppPath,\n      sriEnabled: !!this.nextConfig.experimental.sri?.algorithm,\n      appPaths,\n      // Ensuring for loading page component routes is done via the matcher.\n      shouldEnsure: false,\n    })\n    if (result) {\n      getTracer().setRootSpanAttribute('next.route', pathname)\n      try {\n        return await this.renderToResponseWithComponents(ctx, result)\n      } catch (err) {\n        const isNoFallbackError = err instanceof NoFallbackError\n\n        if (!isNoFallbackError || (isNoFallbackError && bubbleNoFallback)) {\n          throw err\n        }\n      }\n    }\n    return false\n  }\n\n  private async renderToResponse(\n    ctx: RequestContext<ServerRequest, ServerResponse>\n  ): Promise<ResponsePayload | null> {\n    return getTracer().trace(\n      BaseServerSpan.renderToResponse,\n      {\n        spanName: `rendering page`,\n        attributes: {\n          'next.route': ctx.pathname,\n        },\n      },\n      async () => {\n        return this.renderToResponseImpl(ctx)\n      }\n    )\n  }\n\n  protected abstract getMiddleware(): Promise<MiddlewareRoutingItem | undefined>\n  protected abstract getFallbackErrorComponents(\n    url?: string\n  ): Promise<LoadComponentsReturnType<ErrorModule> | null>\n  protected abstract getRoutesManifest(): NormalizedRouteManifest | undefined\n\n  private async renderToResponseImpl(\n    ctx: RequestContext<ServerRequest, ServerResponse>\n  ): Promise<ResponsePayload | null> {\n    const { req, res, query, pathname } = ctx\n    let page = pathname\n    const bubbleNoFallback =\n      getRequestMeta(ctx.req, 'bubbleNoFallback') ?? false\n\n    if (\n      !this.minimalMode &&\n      this.nextConfig.experimental.validateRSCRequestHeaders\n    ) {\n      addRequestMeta(\n        ctx.req,\n        'cacheBustingSearchParam',\n        query[NEXT_RSC_UNION_QUERY]\n      )\n    }\n    delete query[NEXT_RSC_UNION_QUERY]\n\n    const options: MatchOptions = {\n      i18n: this.i18nProvider?.fromRequest(req, pathname),\n    }\n\n    const existingMatch = getRequestMeta(ctx.req, 'match')\n\n    let fastPath = true\n    // when a specific invoke-output is meant to be matched\n    // ensure a prior dynamic route/page doesn't take priority\n    const invokeOutput = getRequestMeta(ctx.req, 'invokeOutput')\n\n    if (\n      (!this.minimalMode &&\n        typeof invokeOutput === 'string' &&\n        isDynamicRoute(invokeOutput || '') &&\n        invokeOutput !== existingMatch?.definition.pathname) ||\n      // Parallel routes are matched in `existingMatch` but since currently\n      // there can be multiple matches it's not guaranteed to be the right match\n      // therefor we need to opt-out of the fast path for parallel routes.\n      existingMatch?.definition.page.includes('/@')\n    ) {\n      fastPath = false\n    }\n\n    try {\n      for await (const match of fastPath && existingMatch\n        ? [existingMatch]\n        : this.matchers.matchAll(pathname, options)) {\n        if (\n          !this.minimalMode &&\n          typeof invokeOutput === 'string' &&\n          isDynamicRoute(invokeOutput || '') &&\n          invokeOutput !== match.definition.pathname\n        ) {\n          continue\n        }\n\n        const result = await this.renderPageComponent(\n          {\n            ...ctx,\n            pathname: match.definition.pathname,\n            renderOpts: {\n              ...ctx.renderOpts,\n              params: match.params,\n            },\n          },\n          bubbleNoFallback\n        )\n        if (result !== false) return result\n      }\n\n      // currently edge functions aren't receiving the x-matched-path\n      // header so we need to fallback to matching the current page\n      // when we weren't able to match via dynamic route to handle\n      // the rewrite case\n      // @ts-expect-error extended in child class web-server\n      if (this.serverOptions.webServerConfig) {\n        // @ts-expect-error extended in child class web-server\n        ctx.pathname = this.serverOptions.webServerConfig.page\n        const result = await this.renderPageComponent(ctx, bubbleNoFallback)\n        if (result !== false) return result\n      }\n    } catch (error) {\n      const err = getProperError(error)\n\n      if (error instanceof MissingStaticPage) {\n        console.error(\n          'Invariant: failed to load static page',\n          JSON.stringify(\n            {\n              page,\n              url: ctx.req.url,\n              matchedPath: ctx.req.headers[MATCHED_PATH_HEADER],\n              initUrl: getRequestMeta(ctx.req, 'initURL'),\n              didRewrite: !!getRequestMeta(ctx.req, 'rewrittenPathname'),\n              rewrittenPathname: getRequestMeta(ctx.req, 'rewrittenPathname'),\n            },\n            null,\n            2\n          )\n        )\n        throw err\n      }\n\n      if (err instanceof NoFallbackError && bubbleNoFallback) {\n        throw err\n      }\n      if (err instanceof DecodeError || err instanceof NormalizeError) {\n        res.statusCode = 400\n        return await this.renderErrorToResponse(ctx, err)\n      }\n\n      res.statusCode = 500\n\n      // if pages/500 is present we still need to trigger\n      // /_error `getInitialProps` to allow reporting error\n      if (await this.hasPage('/500')) {\n        addRequestMeta(ctx.req, 'customErrorRender', true)\n        await this.renderErrorToResponse(ctx, err)\n        removeRequestMeta(ctx.req, 'customErrorRender')\n      }\n\n      const isWrappedError = err instanceof WrappedBuildError\n\n      if (!isWrappedError) {\n        if (this.minimalMode || this.renderOpts.dev) {\n          if (isError(err)) err.page = page\n          throw err\n        }\n        this.logError(getProperError(err))\n      }\n      const response = await this.renderErrorToResponse(\n        ctx,\n        isWrappedError ? (err as WrappedBuildError).innerError : err\n      )\n      return response\n    }\n\n    const middleware = await this.getMiddleware()\n    if (\n      middleware &&\n      !!ctx.req.headers['x-nextjs-data'] &&\n      (!res.statusCode || res.statusCode === 200 || res.statusCode === 404)\n    ) {\n      const locale = getRequestMeta(req, 'locale')\n\n      res.setHeader(\n        'x-nextjs-matched-path',\n        `${locale ? `/${locale}` : ''}${pathname}`\n      )\n      res.statusCode = 200\n      res.setHeader('Content-Type', JSON_CONTENT_TYPE_HEADER)\n      res.body('{}')\n      res.send()\n      return null\n    }\n\n    res.statusCode = 404\n    return this.renderErrorToResponse(ctx, null)\n  }\n\n  public async renderToHTML(\n    req: ServerRequest,\n    res: ServerResponse,\n    pathname: string,\n    query: ParsedUrlQuery = {}\n  ): Promise<string | null> {\n    return getTracer().trace(BaseServerSpan.renderToHTML, async () => {\n      return this.renderToHTMLImpl(req, res, pathname, query)\n    })\n  }\n\n  private async renderToHTMLImpl(\n    req: ServerRequest,\n    res: ServerResponse,\n    pathname: string,\n    query: ParsedUrlQuery = {}\n  ): Promise<string | null> {\n    return this.getStaticHTML((ctx) => this.renderToResponse(ctx), {\n      req,\n      res,\n      pathname,\n      query,\n    })\n  }\n\n  public async renderError(\n    err: Error | null,\n    req: ServerRequest,\n    res: ServerResponse,\n    pathname: string,\n    query: NextParsedUrlQuery = {},\n    setHeaders = true\n  ): Promise<void> {\n    return getTracer().trace(BaseServerSpan.renderError, async () => {\n      return this.renderErrorImpl(err, req, res, pathname, query, setHeaders)\n    })\n  }\n\n  private async renderErrorImpl(\n    err: Error | null,\n    req: ServerRequest,\n    res: ServerResponse,\n    pathname: string,\n    query: NextParsedUrlQuery = {},\n    setHeaders = true\n  ): Promise<void> {\n    if (setHeaders) {\n      res.setHeader(\n        'Cache-Control',\n        'private, no-cache, no-store, max-age=0, must-revalidate'\n      )\n    }\n\n    return this.pipe(\n      async (ctx) => {\n        const response = await this.renderErrorToResponse(ctx, err)\n        if (this.minimalMode && res.statusCode === 500) {\n          throw err\n        }\n        return response\n      },\n      { req, res, pathname, query }\n    )\n  }\n\n  private customErrorNo404Warn = execOnce(() => {\n    Log.warn(\n      `You have added a custom /_error page without a custom /404 page. This prevents the 404 page from being auto statically optimized.\\nSee here for info: https://nextjs.org/docs/messages/custom-error-no-custom-404`\n    )\n  })\n\n  private async renderErrorToResponse(\n    ctx: RequestContext<ServerRequest, ServerResponse>,\n    err: Error | null\n  ): Promise<ResponsePayload | null> {\n    return getTracer().trace(BaseServerSpan.renderErrorToResponse, async () => {\n      return this.renderErrorToResponseImpl(ctx, err)\n    })\n  }\n\n  protected async renderErrorToResponseImpl(\n    ctx: RequestContext<ServerRequest, ServerResponse>,\n    err: Error | null\n  ): Promise<ResponsePayload | null> {\n    // Short-circuit favicon.ico in development to avoid compiling 404 page when the app has no favicon.ico.\n    // Since favicon.ico is automatically requested by the browser.\n    if (this.renderOpts.dev && ctx.pathname === '/favicon.ico') {\n      return {\n        body: RenderResult.EMPTY,\n      }\n    }\n    const { res, query } = ctx\n\n    try {\n      let result: null | FindComponentsResult = null\n\n      const is404 = res.statusCode === 404\n      let using404Page = false\n      const hasAppDir = this.enabledDirectories.app\n\n      if (is404) {\n        if (hasAppDir) {\n          // Use the not-found entry in app directory\n          result = await this.findPageComponents({\n            locale: getRequestMeta(ctx.req, 'locale'),\n            page: UNDERSCORE_NOT_FOUND_ROUTE_ENTRY,\n            query,\n            params: {},\n            isAppPath: true,\n            shouldEnsure: true,\n            url: ctx.req.url,\n          })\n          using404Page = result !== null\n        }\n\n        if (!result && (await this.hasPage('/404'))) {\n          result = await this.findPageComponents({\n            locale: getRequestMeta(ctx.req, 'locale'),\n            page: '/404',\n            query,\n            params: {},\n            isAppPath: false,\n            // Ensuring can't be done here because you never \"match\" a 404 route.\n            shouldEnsure: true,\n            url: ctx.req.url,\n          })\n          using404Page = result !== null\n        }\n      }\n      let statusPage = `/${res.statusCode}`\n\n      if (\n        !getRequestMeta(ctx.req, 'customErrorRender') &&\n        !result &&\n        STATIC_STATUS_PAGES.includes(statusPage)\n      ) {\n        // skip ensuring /500 in dev mode as it isn't used and the\n        // dev overlay is used instead\n        if (statusPage !== '/500' || !this.renderOpts.dev) {\n          if (!result && hasAppDir) {\n            // Otherwise if app router present, load app router built-in 500 page\n            result = await this.findPageComponents({\n              locale: getRequestMeta(ctx.req, 'locale'),\n              page: statusPage,\n              query,\n              params: {},\n              isAppPath: true,\n              // Ensuring can't be done here because you never \"match\" a 500\n              // route.\n              shouldEnsure: true,\n              url: ctx.req.url,\n            })\n          }\n          // If the above App Router result is empty, fallback to pages router 500 page\n          result = await this.findPageComponents({\n            locale: getRequestMeta(ctx.req, 'locale'),\n            page: statusPage,\n            query,\n            params: {},\n            isAppPath: false,\n            // Ensuring can't be done here because you never \"match\" a 500\n            // route.\n            shouldEnsure: true,\n            url: ctx.req.url,\n          })\n        }\n      }\n\n      if (!result) {\n        result = await this.findPageComponents({\n          locale: getRequestMeta(ctx.req, 'locale'),\n          page: '/_error',\n          query,\n          params: {},\n          isAppPath: false,\n          // Ensuring can't be done here because you never \"match\" an error\n          // route.\n          shouldEnsure: true,\n          url: ctx.req.url,\n        })\n        statusPage = '/_error'\n      }\n\n      if (\n        process.env.NODE_ENV !== 'production' &&\n        !using404Page &&\n        (await this.hasPage('/_error')) &&\n        !(await this.hasPage('/404'))\n      ) {\n        this.customErrorNo404Warn()\n      }\n\n      if (!result) {\n        // this can occur when a project directory has been moved/deleted\n        // which is handled in the parent process in development\n        if (this.renderOpts.dev) {\n          return {\n            // wait for dev-server to restart before refreshing\n            body: RenderResult.fromStatic(\n              `\n              <pre>missing required error components, refreshing...</pre>\n              <script>\n                async function check() {\n                  const res = await fetch(location.href).catch(() => ({}))\n\n                  if (res.status === 200) {\n                    location.reload()\n                  } else {\n                    setTimeout(check, 1000)\n                  }\n                }\n                check()\n              </script>`,\n              HTML_CONTENT_TYPE_HEADER\n            ),\n          }\n        }\n\n        throw new WrappedBuildError(\n          new Error('missing required error components')\n        )\n      }\n\n      // If the page has a route module, use it for the new match. If it doesn't\n      // have a route module, remove the match.\n      if (result.components.routeModule) {\n        addRequestMeta(ctx.req, 'match', {\n          definition: result.components.routeModule.definition,\n          params: undefined,\n        })\n      } else {\n        removeRequestMeta(ctx.req, 'match')\n      }\n\n      try {\n        return await this.renderToResponseWithComponents(\n          {\n            ...ctx,\n            pathname: statusPage,\n            renderOpts: {\n              ...ctx.renderOpts,\n              err,\n            },\n          },\n          result\n        )\n      } catch (maybeFallbackError) {\n        if (maybeFallbackError instanceof NoFallbackError) {\n          throw new Error('invariant: failed to render error page')\n        }\n        throw maybeFallbackError\n      }\n    } catch (error) {\n      const renderToHtmlError = getProperError(error)\n      const isWrappedError = renderToHtmlError instanceof WrappedBuildError\n      if (!isWrappedError) {\n        this.logError(renderToHtmlError)\n      }\n      res.statusCode = 500\n      const fallbackComponents = await this.getFallbackErrorComponents(\n        ctx.req.url\n      )\n\n      if (fallbackComponents) {\n        // There was an error, so use it's definition from the route module\n        // to add the match to the request.\n        addRequestMeta(ctx.req, 'match', {\n          definition: fallbackComponents.routeModule!.definition,\n          params: undefined,\n        })\n\n        return this.renderToResponseWithComponents(\n          {\n            ...ctx,\n            pathname: '/_error',\n            renderOpts: {\n              ...ctx.renderOpts,\n              // We render `renderToHtmlError` here because `err` is\n              // already captured in the stacktrace.\n              err: isWrappedError\n                ? renderToHtmlError.innerError\n                : renderToHtmlError,\n            },\n          },\n          {\n            query,\n            components: fallbackComponents,\n          }\n        )\n      }\n      return {\n        body: RenderResult.fromStatic('Internal Server Error', 'text/plain'),\n      }\n    }\n  }\n\n  public async renderErrorToHTML(\n    err: Error | null,\n    req: ServerRequest,\n    res: ServerResponse,\n    pathname: string,\n    query: ParsedUrlQuery = {}\n  ): Promise<string | null> {\n    return this.getStaticHTML((ctx) => this.renderErrorToResponse(ctx, err), {\n      req,\n      res,\n      pathname,\n      query,\n    })\n  }\n\n  public async render404(\n    req: ServerRequest,\n    res: ServerResponse,\n    parsedUrl?: Pick<NextUrlWithParsedQuery, 'pathname' | 'query'>,\n    setHeaders = true\n  ): Promise<void> {\n    const { pathname, query } = parsedUrl ? parsedUrl : parseUrl(req.url)\n\n    // Ensure the locales are provided on the request meta.\n    if (this.nextConfig.i18n) {\n      if (!getRequestMeta(req, 'locale')) {\n        addRequestMeta(req, 'locale', this.nextConfig.i18n.defaultLocale)\n      }\n      addRequestMeta(req, 'defaultLocale', this.nextConfig.i18n.defaultLocale)\n    }\n\n    res.statusCode = 404\n    return this.renderError(null, req, res, pathname!, query, setHeaders)\n  }\n}\n"],"names":["WrappedBuildError","Server","Error","constructor","innerError","getServerComponentsHmrCache","nextConfig","experimental","serverComponentsHmrCache","globalThis","__serverComponentsHmrCache","undefined","options","handleRSCRequest","req","_res","parsedUrl","pathname","normalizers","segmentPrefetchRSC","match","result","extract","originalPathname","segmentPath","headers","RSC_HEADER","NEXT_ROUTER_PREFETCH_HEADER","NEXT_ROUTER_SEGMENT_PREFETCH_HEADER","addRequestMeta","rsc","normalize","stripFlightHeaders","segmentPrefetchRSCRequest","url","parsed","parseUrl","formatUrl","handleNextDataRequest","res","middleware","getMiddleware","params","matchNextDataPathname","path","buildId","getRequestMeta","render404","shift","lastParam","length","endsWith","join","getRouteFromAssetPath","trailingSlash","substring","i18nProvider","hostname","host","split","toLowerCase","domainLocale","detectDomainLocale","defaultLocale","config","localePathResult","analyze","detectedLocale","removeRequestMeta","handleNextImageRequest","handleCatchallRenderRequest","handleCatchallMiddlewareRequest","data","push","normalizer","normalizeAndAttachMetadata","finished","enabledDirectories","pages","prepared","preparedPromise","customErrorNo404Warn","execOnce","Log","warn","dir","quiet","conf","dev","minimalMode","port","experimentalTestProxy","serverOptions","resolve","loadEnvConfig","forceReload","runtimeServerDeploymentId","process","env","NEXT_DEPLOYMENT_ID","deploymentId","NEXT_CLIENT_ASSET_SUFFIX","id","useSkewCookie","fetchHostname","formatHostname","distDir","publicDir","getPublicDir","hasStaticDir","getHasStaticDir","i18n","locales","I18NProvider","localeNormalizer","LocaleRouteNormalizer","assetPrefix","generateEtags","getBuildId","minimalModeKey","NEXT_PRIVATE_MINIMAL_MODE","getEnabledDirectories","isAppPPREnabled","app","checkIsAppPPREnabled","ppr","RSCPathnameNormalizer","SegmentPrefixRSCPathnameNormalizer","NextDataPathnameNormalizer","nextFontManifest","getNextFontManifest","renderOpts","supportsDynamicResponse","poweredByHeader","previewProps","getPrerenderManifest","preview","basePath","images","optimizeCss","nextConfigOutput","output","nextScriptWorkers","disableOptimizedLoading","domainLocales","domains","serverComponents","cacheLifeProfiles","cacheLife","enableTainting","taint","crossOrigin","largePageDataBytes","isExperimentalCompile","htmlLimitedBots","cacheComponents","expireTime","staleTimes","clientTraceMetadata","clientParamParsingOrigins","dynamicOnHover","optimisticRouting","inlineCss","authInterrupts","maxPostponedStateSizeBytes","parseMaxPostponedStateSize","maxPostponedStateSize","onInstrumentationRequestError","instrumentationOnRequestError","bind","reactMaxHeadersLength","pagesManifest","getPagesManifest","appPathsManifest","getAppPathsManifest","appPathRoutes","getAppPathRoutes","interceptionRoutePatterns","getinterceptionRoutePatterns","matchers","getRouteMatchers","reload","setAssetPrefix","reloadMatchers","manifestLoader","ServerManifestLoader","name","PAGES_MANIFEST","APP_PATHS_MANIFEST","DefaultRouteMatcherManager","PagesRouteMatcherProvider","PagesAPIRouteMatcherProvider","AppPageRouteMatcherProvider","AppRouteRouteMatcherProvider","args","err","ctx","instrumentation","onRequestError","method","NextRequestHint","Object","fromEntries","entries","handlerErr","console","error","logError","handleRequest","prepare","toUpperCase","tracer","getTracer","withPropagatedContext","trace","BaseServerSpan","spanName","kind","SpanKind","SERVER","attributes","span","handleRequestImpl","finally","isRSCRequest","setAttributes","statusCode","setStatus","code","SpanStatusCode","ERROR","setAttribute","toString","rootSpanAttributes","getRootSpanAttributes","get","route","updateName","originalRequest","waitTillReady","patchSetHeaderWithCookieSupport","isNodeNextResponse","originalResponse","urlParts","urlNoQuery","cleanUrl","normalizeRepeatedSlashes","redirect","body","send","query","URLSearchParams","isNodeNextRequest","xForwardedProto","isHttps","socket","encrypted","remoteAddress","attachRequestMeta","getHostname","parseUrlUtil","replace","pathnameInfo","getNextPathnameInfo","removePathPrefix","useMatchedPathHeader","MATCHED_PATH_HEADER","matchedPath","URL","fixMojibake","urlPathname","NEXT_RESUME_HEADER","DEFAULT_MAX_POSTPONED_STATE_SIZE","size","chunk","Buffer","byteLength","errorMessage","postponed","concat","normalizedUrlPath","stripNextDataPath","denormalizePagePath","localeAnalysisResult","inferredFromDefault","srcPathname","pageIsDynamic","isDynamicRoute","paramsResult","hasValidParams","definition","utils","getServerUtils","page","rewrites","getRoutesManifest","beforeFiles","afterFiles","fallback","caseSensitive","caseSensitiveRoutes","locale","originQueryParams","pathnameBeforeRewrite","rewriteParams","rewrittenParsedUrl","handleRewrites","rewriteParamKeys","keys","rewrittenQueryParams","didRewrite","routeParamKeys","Set","key","value","normalizedKey","normalizeNextQueryParam","add","Array","isArray","map","v","decodeQueryPathParameter","normalizeDynamicRouteParams","matcherParams","dynamicRouteMatcher","assign","curParamsResult","routeMatchesHeader","routeMatches","getParamsFromRouteMatches","defaultRouteMatches","interpolateDynamicPath","normalizeCdnUrl","defaultRouteRegex","groups","RouteKind","PAGES","PAGES_API","DecodeError","NormalizeError","renderError","Boolean","webServerConfig","incrementalCache","getIncrementalCache","requestHeaders","resetRequestCache","__incrementalCache","invokePath","useInvokePath","invokeStatus","invokeQuery","parsedMatchedPath","invokePathnameInfo","parseData","normalizeResult","normalizeLocalePath","response","Response","bubble","run","NoFallbackError","isBubbledError","getProperError","getRequestHandlerWithMetadata","meta","handler","getRequestHandler","setRequestMeta","prefix","loadInstrumentationModule","prepareImpl","then","close","forEach","entry","normalizedPath","normalizeAppPath","runImpl","pipe","fn","partialContext","pipeImpl","ua","botType","serveStreamingMetadata","shouldServeStreamingMetadata","payload","originalStatus","cacheControl","sent","setHeader","devCacheControlNoCache","expire","sendRenderResult","getStaticHTML","toUnchunkedString","render","internalRender","renderImpl","getWaitUntil","builtinRequestContext","getBuiltinRequestContext","waitUntil","getInternalWaitUntil","startsWith","customServer","hasPage","getBotType","isBlockedPage","renderToResponse","getStaticPaths","fallbackField","dynamicRoutes","staticPaths","fallbackMode","parseFallbackField","renderToResponseWithComponents","requestContext","findComponentsResult","renderToResponseWithComponentsImpl","pathCouldBeIntercepted","resolvedPathname","isInterceptionRouteAppPath","some","regexp","test","setVaryHeader","isAppPath","baseVaryHeader","NEXT_ROUTER_STATE_TREE_HEADER","addedNextUrlToVary","appendHeader","NEXT_URL","opts","components","prerenderManifest","UNDERSCORE_NOT_FOUND_ROUTE","isErrorPathname","is404Page","is500Page","hasServerProps","getServerSideProps","isPossibleServerAction","getIsPossibleServerAction","isSSG","getStaticProps","validateRSCRequestHeaders","prefetchHeaderValue","routerPrefetch","expectedHash","computeCacheBustingSearchParam","actualHash","searchParams","NEXT_RSC_UNION_QUERY","setCacheBustingSearchParamWithHash","search","resolvedUrlPathname","hasFallback","includes","routes","toRoute","isNextDataRequest","routeModule","couldSupportPPR","isAppPageRouteModule","hasDebugStaticShellQuery","__NEXT_EXPERIMENTAL_STATIC_SHELL_DEBUGGING","__nextppronly","isRoutePPREnabled","renderingMode","minimalPostponed","STATIC_STATUS_PAGES","parseInt","slice","Component","RenderResult","fromStatic","HTML_CONTENT_TYPE_HEADER","isBotRequest","isBot","isSupportedDocument","Document","getInitialProps","NEXT_BUILTIN_DOCUMENT","removeTrailingSlash","isDev","pathsResults","getStaticPathsStart","hrtime","bigint","prerenderedRoutes","smallestFallbackRouteParams","fallbackRouteParams","createOpaqueFallbackRouteParams","isAppRouteRouteModule","sendResponse","status","request","parsedInitUrl","initPathname","maybeDevRequest","NODE_ENV","Proxy","target","prop","set","fetchMetrics","handlerReq","handlerRes","ComponentMod","filePath","stripLocale","splitPath","indexOf","getOriginalAppPaths","originalAppPath","renderPageComponent","bubbleNoFallback","appPaths","findPageComponents","sriEnabled","sri","algorithm","shouldEnsure","setRootSpanAttribute","isNoFallbackError","renderToResponseImpl","fromRequest","existingMatch","fastPath","invokeOutput","matchAll","MissingStaticPage","JSON","stringify","initUrl","rewrittenPathname","renderErrorToResponse","isWrappedError","isError","JSON_CONTENT_TYPE_HEADER","renderToHTML","renderToHTMLImpl","setHeaders","renderErrorImpl","renderErrorToResponseImpl","EMPTY","is404","using404Page","hasAppDir","UNDERSCORE_NOT_FOUND_ROUTE_ENTRY","statusPage","maybeFallbackError","renderToHtmlError","fallbackComponents","getFallbackErrorComponents","renderErrorToHTML"],"mappings":"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","ignoreList":[0]}