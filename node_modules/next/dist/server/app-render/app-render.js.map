{"version":3,"sources":["../../../src/server/app-render/app-render.tsx"],"sourcesContent":["import type { ComponentType, ErrorInfo, JSX, ReactNode } from 'react'\nimport type { RenderOpts, PreloadCallbacks } from './types'\nimport type {\n  ActionResult,\n  DynamicParamTypesShort,\n  DynamicSegmentTuple,\n  FlightRouterState,\n  CacheNodeSeedData,\n  RSCPayload,\n  FlightData,\n  InitialRSCPayload,\n  FlightDataPath,\n} from '../../shared/lib/app-router-types'\nimport type { Readable } from 'node:stream'\nimport {\n  workAsyncStorage,\n  type WorkStore,\n} from '../app-render/work-async-storage.external'\nimport type {\n  PrerenderStoreModernRuntime,\n  RequestStore,\n} from '../app-render/work-unit-async-storage.external'\nimport type { NextParsedUrlQuery } from '../request-meta'\nimport type { LoaderTree } from '../lib/app-dir-module'\nimport type { AppPageModule } from '../route-modules/app-page/module'\nimport type { BaseNextRequest, BaseNextResponse } from '../base-http'\nimport type { IncomingHttpHeaders } from 'http'\nimport * as ReactClient from 'react'\n\nimport RenderResult, {\n  type AppPageRenderResultMetadata,\n  type RenderResultOptions,\n} from '../render-result'\nimport {\n  chainStreams,\n  renderToInitialFizzStream,\n  createDocumentClosingStream,\n  continueFizzStream,\n  continueDynamicPrerender,\n  continueStaticPrerender,\n  continueDynamicHTMLResume,\n  streamToBuffer,\n  streamToString,\n  continueStaticFallbackPrerender,\n} from '../stream-utils/node-web-streams-helper'\nimport { stripInternalQueries } from '../internal-utils'\nimport {\n  NEXT_HMR_REFRESH_HEADER,\n  NEXT_ROUTER_PREFETCH_HEADER,\n  NEXT_ROUTER_STATE_TREE_HEADER,\n  NEXT_ROUTER_STALE_TIME_HEADER,\n  NEXT_URL,\n  RSC_HEADER,\n  NEXT_ROUTER_SEGMENT_PREFETCH_HEADER,\n  NEXT_REQUEST_ID_HEADER,\n  NEXT_HTML_REQUEST_ID_HEADER,\n} from '../../client/components/app-router-headers'\nimport { createMetadataContext } from '../../lib/metadata/metadata-context'\nimport { createRequestStoreForRender } from '../async-storage/request-store'\nimport { createWorkStore } from '../async-storage/work-store'\nimport {\n  getAccessFallbackErrorTypeByStatus,\n  getAccessFallbackHTTPStatus,\n  isHTTPAccessFallbackError,\n} from '../../client/components/http-access-fallback/http-access-fallback'\nimport {\n  getURLFromRedirectError,\n  getRedirectStatusCodeFromError,\n} from '../../client/components/redirect'\nimport { isRedirectError } from '../../client/components/redirect-error'\nimport { getImplicitTags, type ImplicitTags } from '../lib/implicit-tags'\nimport { AppRenderSpan, NextNodeServerSpan } from '../lib/trace/constants'\nimport { getTracer, SpanStatusCode } from '../lib/trace/tracer'\nimport { FlightRenderResult } from './flight-render-result'\nimport {\n  createReactServerErrorHandler,\n  createHTMLErrorHandler,\n  type DigestedError,\n  isUserLandError,\n  getDigestForWellKnownError,\n} from './create-error-handler'\nimport { dynamicParamTypes } from './get-short-dynamic-param-type'\nimport { getSegmentParam } from '../../shared/lib/router/utils/get-segment-param'\nimport { getScriptNonceFromHeader } from './get-script-nonce-from-header'\nimport { parseAndValidateFlightRouterState } from './parse-and-validate-flight-router-state'\nimport { createFlightRouterStateFromLoaderTree } from './create-flight-router-state-from-loader-tree'\nimport { handleAction } from './action-handler'\nimport { isBailoutToCSRError } from '../../shared/lib/lazy-dynamic/bailout-to-csr'\nimport { warn, error } from '../../build/output/log'\nimport { appendMutableCookies } from '../web/spec-extension/adapters/request-cookies'\nimport { createServerInsertedHTML } from './server-inserted-html'\nimport { getRequiredScripts } from './required-scripts'\nimport { addPathPrefix } from '../../shared/lib/router/utils/add-path-prefix'\nimport { makeGetServerInsertedHTML } from './make-get-server-inserted-html'\nimport { walkTreeWithFlightRouterState } from './walk-tree-with-flight-router-state'\nimport { createComponentTree, getRootParams } from './create-component-tree'\nimport { getAssetQueryString } from './get-asset-query-string'\nimport {\n  getClientReferenceManifest,\n  getServerModuleMap,\n} from './manifests-singleton'\nimport {\n  DynamicState,\n  type PostponedState,\n  DynamicHTMLPreludeState,\n  parsePostponedState,\n} from './postponed-state'\nimport {\n  getDynamicDataPostponedState,\n  getDynamicHTMLPostponedState,\n  getPostponedFromState,\n} from './postponed-state'\nimport { isDynamicServerError } from '../../client/components/hooks-server-context'\nimport {\n  getFlightStream,\n  createInlinedDataReadableStream,\n} from './use-flight-response'\nimport {\n  StaticGenBailoutError,\n  isStaticGenBailoutError,\n} from '../../client/components/static-generation-bailout'\nimport { getStackWithoutErrorMessage } from '../../lib/format-server-error'\nimport {\n  accessedDynamicData,\n  createRenderInBrowserAbortSignal,\n  formatDynamicAPIAccesses,\n  isPrerenderInterruptedError,\n  createDynamicTrackingState,\n  createDynamicValidationState,\n  trackAllowedDynamicAccess,\n  throwIfDisallowedDynamic,\n  PreludeState,\n  consumeDynamicAccess,\n  type DynamicAccess,\n  logDisallowedDynamicError,\n  trackDynamicHoleInRuntimeShell,\n  trackDynamicHoleInStaticShell,\n  getStaticShellDisallowedDynamicReasons,\n} from './dynamic-rendering'\nimport {\n  getClientComponentLoaderMetrics,\n  wrapClientComponentLoader,\n} from '../client-component-renderer-logger'\nimport { isNodeNextRequest } from '../base-http/helpers'\nimport { parseRelativeUrl } from '../../shared/lib/router/utils/parse-relative-url'\nimport AppRouter from '../../client/components/app-router'\nimport type { ServerComponentsHmrCache } from '../response-cache'\nimport type { RequestErrorContext } from '../instrumentation/types'\nimport { getIsPossibleServerAction } from '../lib/server-action-request-meta'\nimport { createInitialRouterState } from '../../client/components/router-reducer/create-initial-router-state'\nimport { createMutableActionQueue } from '../../client/components/app-router-instance'\nimport { getRevalidateReason } from '../instrumentation/utils'\nimport { PAGE_SEGMENT_KEY } from '../../shared/lib/segment'\nimport type { OpaqueFallbackRouteParams } from '../request/fallback-params'\nimport {\n  prerenderAndAbortInSequentialTasksWithStages,\n  processPrelude,\n} from './app-render-prerender-utils'\nimport {\n  type ReactServerPrerenderResult,\n  ReactServerResult,\n  createReactServerPrerenderResult,\n  createReactServerPrerenderResultFromRender,\n  prerenderAndAbortInSequentialTasks,\n} from './app-render-prerender-utils'\nimport {\n  Phase,\n  printDebugThrownValueForProspectiveRender,\n} from './prospective-render-utils'\nimport {\n  pipelineInSequentialTasks,\n  scheduleInSequentialTasks,\n} from './app-render-render-utils'\nimport { waitAtLeastOneReactRenderTask } from '../../lib/scheduler'\nimport {\n  getHmrRefreshHash,\n  workUnitAsyncStorage,\n  type PrerenderStore,\n} from './work-unit-async-storage.external'\nimport { consoleAsyncStorage } from './console-async-storage.external'\nimport { CacheSignal } from './cache-signal'\nimport {\n  createResponseVaryParamsAccumulator,\n  finishAccumulatingVaryParams,\n  getMetadataVaryParamsThenable,\n} from './vary-params'\nimport { getTracedMetadata } from '../lib/trace/utils'\nimport { InvariantError } from '../../shared/lib/invariant-error'\n\nimport { HTML_CONTENT_TYPE_HEADER, INFINITE_CACHE } from '../../lib/constants'\nimport { createComponentStylesAndScripts } from './create-component-styles-and-scripts'\nimport { parseLoaderTree } from '../../shared/lib/router/utils/parse-loader-tree'\nimport {\n  createPrerenderResumeDataCache,\n  createRenderResumeDataCache,\n  type PrerenderResumeDataCache,\n  type RenderResumeDataCache,\n} from '../resume-data-cache/resume-data-cache'\nimport type { MetadataErrorType } from '../../lib/metadata/resolve-metadata'\nimport isError from '../../lib/is-error'\nimport { createServerInsertedMetadata } from './metadata-insertion/create-server-inserted-metadata'\nimport { getPreviouslyRevalidatedTags } from '../server-utils'\nimport { executeRevalidates } from '../revalidation-utils'\nimport {\n  trackPendingChunkLoad,\n  trackPendingImport,\n  trackPendingModules,\n} from './module-loading/track-module-loading.external'\nimport { isReactLargeShellError } from './react-large-shell-error'\nimport type { GlobalErrorComponent } from '../../client/components/builtin/global-error'\nimport { normalizeConventionFilePath } from './segment-explorer-path'\nimport { getRequestMeta } from '../request-meta'\nimport {\n  getDynamicParam,\n  interpolateParallelRouteParams,\n} from '../../shared/lib/router/utils/get-dynamic-param'\nimport type { ExperimentalConfig } from '../config-shared'\nimport type { Params } from '../request/params'\nimport { createPromiseWithResolvers } from '../../shared/lib/promise-with-resolvers'\nimport { ImageConfigContext } from '../../shared/lib/image-config-context.shared-runtime'\nimport { imageConfigDefault } from '../../shared/lib/image-config'\nimport { RenderStage, StagedRenderingController } from './staged-rendering'\nimport { anySegmentHasRuntimePrefetchEnabled } from './staged-validation'\nimport { warnOnce } from '../../shared/lib/utils/warn-once'\n\nexport type GetDynamicParamFromSegment = (\n  // The LoaderTree to extract the dynamic param from\n  loaderTree: LoaderTree\n) => DynamicParam | null\n\nexport type DynamicParam = {\n  param: string\n  value: string | string[] | null\n  treeSegment: DynamicSegmentTuple\n  type: DynamicParamTypesShort\n}\n\nexport type GenerateFlight = typeof generateDynamicFlightRenderResult\n\nexport type AppSharedContext = {\n  buildId: string\n  deploymentId: string\n}\n\nexport type AppRenderContext = {\n  sharedContext: AppSharedContext\n  workStore: WorkStore\n  url: ReturnType<typeof parseRelativeUrl>\n  componentMod: AppPageModule\n  renderOpts: RenderOpts\n  parsedRequestHeaders: ParsedRequestHeaders\n  getDynamicParamFromSegment: GetDynamicParamFromSegment\n  query: NextParsedUrlQuery\n  isPrefetch: boolean\n  isPossibleServerAction: boolean\n  requestTimestamp: number\n  appUsingSizeAdjustment: boolean\n  flightRouterState?: FlightRouterState\n  requestId: string\n  htmlRequestId: string\n  pagePath: string\n  assetPrefix: string\n  isNotFoundPath: boolean\n  nonce: string | undefined\n  res: BaseNextResponse\n  /**\n   * For now, the implicit tags are common for the whole route. If we ever start\n   * rendering/revalidating segments independently, they need to move to the\n   * work unit store.\n   */\n  implicitTags: ImplicitTags\n}\n\ninterface ParseRequestHeadersOptions {\n  readonly isRoutePPREnabled: boolean\n  readonly previewModeId: string | undefined\n}\n\nconst flightDataPathHeadKey = 'h'\nconst getFlightViewportKey = (requestId: string) => requestId + 'v'\nconst getFlightMetadataKey = (requestId: string) => requestId + 'm'\n\nconst filterStackFrame =\n  process.env.NODE_ENV !== 'production'\n    ? (require('../lib/source-maps') as typeof import('../lib/source-maps'))\n        .filterStackFrameDEV\n    : undefined\n\ninterface ParsedRequestHeaders {\n  /**\n   * Router state provided from the client-side router. Used to handle rendering\n   * from the common layout down. This value will be undefined if the request is\n   * not a client-side navigation request, or if the request is a prefetch\n   * request.\n   */\n  readonly flightRouterState: FlightRouterState | undefined\n  readonly isPrefetchRequest: boolean\n  readonly isRuntimePrefetchRequest: boolean\n  readonly isRouteTreePrefetchRequest: boolean\n  readonly isHmrRefresh: boolean\n  readonly isRSCRequest: boolean\n  readonly nonce: string | undefined\n  readonly previouslyRevalidatedTags: string[]\n  readonly requestId: string | undefined\n  readonly htmlRequestId: string | undefined\n}\n\nfunction parseRequestHeaders(\n  headers: IncomingHttpHeaders,\n  options: ParseRequestHeadersOptions\n): ParsedRequestHeaders {\n  // runtime prefetch requests are *not* treated as prefetch requests\n  // (TODO: this is confusing, we should refactor this to express this better)\n  const isPrefetchRequest = headers[NEXT_ROUTER_PREFETCH_HEADER] === '1'\n\n  const isRuntimePrefetchRequest = headers[NEXT_ROUTER_PREFETCH_HEADER] === '2'\n\n  const isHmrRefresh = headers[NEXT_HMR_REFRESH_HEADER] !== undefined\n\n  const isRSCRequest = headers[RSC_HEADER] !== undefined\n\n  const shouldProvideFlightRouterState =\n    isRSCRequest && (!isPrefetchRequest || !options.isRoutePPREnabled)\n\n  const flightRouterState = shouldProvideFlightRouterState\n    ? parseAndValidateFlightRouterState(headers[NEXT_ROUTER_STATE_TREE_HEADER])\n    : undefined\n\n  // Checks if this is a prefetch of the Route Tree by the Segment Cache\n  const isRouteTreePrefetchRequest =\n    headers[NEXT_ROUTER_SEGMENT_PREFETCH_HEADER] === '/_tree'\n\n  const csp =\n    headers['content-security-policy'] ||\n    headers['content-security-policy-report-only']\n\n  const nonce =\n    typeof csp === 'string' ? getScriptNonceFromHeader(csp) : undefined\n\n  const previouslyRevalidatedTags = getPreviouslyRevalidatedTags(\n    headers,\n    options.previewModeId\n  )\n\n  let requestId: string | undefined\n  let htmlRequestId: string | undefined\n\n  if (process.env.NODE_ENV !== 'production') {\n    // The request IDs are only used in development mode to send debug\n    // information to the matching client (identified by the HTML request ID\n    // that was sent to the client with the HTML document) for the current\n    // request (identified by the request ID, as defined by the client).\n\n    requestId =\n      typeof headers[NEXT_REQUEST_ID_HEADER] === 'string'\n        ? headers[NEXT_REQUEST_ID_HEADER]\n        : undefined\n\n    htmlRequestId =\n      typeof headers[NEXT_HTML_REQUEST_ID_HEADER] === 'string'\n        ? headers[NEXT_HTML_REQUEST_ID_HEADER]\n        : undefined\n  }\n\n  return {\n    flightRouterState,\n    isPrefetchRequest,\n    isRuntimePrefetchRequest,\n    isRouteTreePrefetchRequest,\n    isHmrRefresh,\n    isRSCRequest,\n    nonce,\n    previouslyRevalidatedTags,\n    requestId,\n    htmlRequestId,\n  }\n}\n\nfunction createNotFoundLoaderTree(loaderTree: LoaderTree): LoaderTree {\n  const components = loaderTree[2]\n  const hasGlobalNotFound = !!components['global-not-found']\n  const notFoundTreeComponents: LoaderTree[2] = hasGlobalNotFound\n    ? {\n        layout: components['global-not-found']!,\n        page: [() => null, 'next/dist/client/components/builtin/empty-stub'],\n      }\n    : {\n        page: components['not-found'],\n      }\n\n  return [\n    '',\n    {\n      children: [PAGE_SEGMENT_KEY, {}, notFoundTreeComponents, null],\n    },\n    // Always include global-error so that getGlobalErrorStyles can access it.\n    // When global-not-found is present, use full components.\n    // Otherwise, only include global-error module.\n    hasGlobalNotFound\n      ? components\n      : { 'global-error': components['global-error'] },\n    null, // staticSiblings\n  ]\n}\n\n/**\n * Returns a function that parses the dynamic segment and return the associated value.\n */\nfunction makeGetDynamicParamFromSegment(\n  interpolatedParams: Params,\n  fallbackRouteParams: OpaqueFallbackRouteParams | null,\n  optimisticRouting: boolean\n): GetDynamicParamFromSegment {\n  return function getDynamicParamFromSegment(loaderTree: LoaderTree) {\n    const [segment, , , staticSiblings] = loaderTree\n    const segmentParam = getSegmentParam(segment)\n    if (!segmentParam) {\n      return null\n    }\n    const segmentKey = segmentParam.paramName\n    const dynamicParamType = dynamicParamTypes[segmentParam.paramType]\n    // Static siblings are only included when optimistic routing is enabled\n    const siblings = optimisticRouting ? staticSiblings : null\n    return getDynamicParam(\n      interpolatedParams,\n      segmentKey,\n      dynamicParamType,\n      fallbackRouteParams,\n      siblings\n    )\n  }\n}\n\nfunction NonIndex({\n  createElement,\n  pagePath,\n  statusCode,\n  isPossibleServerAction,\n}: {\n  createElement: typeof ReactClient.createElement\n  pagePath: string\n  statusCode: number | undefined\n  isPossibleServerAction: boolean\n}) {\n  const is404Page = pagePath === '/404'\n  const isInvalidStatusCode = typeof statusCode === 'number' && statusCode > 400\n\n  // Only render noindex for page request, skip for server actions\n  // TODO: is this correct if `isPossibleServerAction` is a false positive?\n  if (!isPossibleServerAction && (is404Page || isInvalidStatusCode)) {\n    return createElement('meta', {\n      name: 'robots',\n      content: 'noindex',\n    })\n  }\n  return null\n}\n\n/**\n * This is used by server actions & client-side navigations to generate RSC data from a client-side request.\n * This function is only called on \"dynamic\" requests (ie, there wasn't already a static response).\n * It uses request headers (namely `next-router-state-tree`) to determine where to start rendering.\n */\nasync function generateDynamicRSCPayload(\n  ctx: AppRenderContext,\n  options?: {\n    actionResult?: ActionResult\n    skipPageRendering?: boolean\n    runtimePrefetchSentinel?: number\n  }\n): Promise<RSCPayload> {\n  // Flight data that is going to be passed to the browser.\n  // Currently a single item array but in the future multiple patches might be combined in a single request.\n\n  // We initialize `flightData` to an empty string because the client router knows how to tolerate\n  // it (treating it as an MPA navigation). The only time this function wouldn't generate flight data\n  // is for server actions, if the server action handler instructs this function to skip it. When the server\n  // action reducer sees a falsy value, it'll simply resolve the action with no data.\n  let flightData: FlightData = ''\n\n  const {\n    componentMod: {\n      routeModule: {\n        userland: { loaderTree },\n      },\n      createElement,\n      createMetadataComponents,\n      Fragment,\n    },\n    getDynamicParamFromSegment,\n    query,\n    requestId,\n    flightRouterState,\n    workStore,\n    url,\n  } = ctx\n\n  const serveStreamingMetadata = !!ctx.renderOpts.serveStreamingMetadata\n\n  if (!options?.skipPageRendering) {\n    const preloadCallbacks: PreloadCallbacks = []\n\n    const { Viewport, Metadata, MetadataOutlet } = createMetadataComponents({\n      tree: loaderTree,\n      parsedQuery: query,\n      pathname: url.pathname,\n      metadataContext: createMetadataContext(ctx.renderOpts),\n      getDynamicParamFromSegment,\n      workStore,\n      serveStreamingMetadata,\n    })\n\n    flightData = (\n      await walkTreeWithFlightRouterState({\n        ctx,\n        loaderTreeToFilter: loaderTree,\n        parentParams: {},\n        flightRouterState,\n        // For flight, render metadata inside leaf page\n        rscHead: createElement(\n          Fragment,\n          {\n            key: flightDataPathHeadKey,\n          },\n          createElement(NonIndex, {\n            createElement,\n            pagePath: ctx.pagePath,\n            statusCode: ctx.res.statusCode,\n            isPossibleServerAction: ctx.isPossibleServerAction,\n          }),\n          createElement(Viewport, {\n            key: getFlightViewportKey(requestId),\n          }),\n          createElement(Metadata, {\n            key: getFlightMetadataKey(requestId),\n          })\n        ),\n        injectedCSS: new Set(),\n        injectedJS: new Set(),\n        injectedFontPreloadTags: new Set(),\n        rootLayoutIncluded: false,\n        preloadCallbacks,\n        MetadataOutlet,\n      })\n    ).map((path) => path.slice(1)) // remove the '' (root) segment\n  }\n\n  const varyHeader = ctx.res.getHeader('vary')\n  const couldBeIntercepted =\n    typeof varyHeader === 'string' && varyHeader.includes(NEXT_URL)\n\n  // If we have an action result, then this is a server action response.\n  // We can rely on this because `ActionResult` will always be a promise, even if\n  // the result is falsey.\n  if (options?.actionResult) {\n    return {\n      a: options.actionResult,\n      f: flightData,\n      b: ctx.sharedContext.buildId,\n      q: getRenderedSearch(query),\n      i: !!couldBeIntercepted,\n    }\n  }\n\n  // Otherwise, it's a regular RSC response.\n  const baseResponse = {\n    b: ctx.sharedContext.buildId,\n    f: flightData,\n    q: getRenderedSearch(query),\n    i: !!couldBeIntercepted,\n    S: workStore.isStaticGeneration,\n    h: getMetadataVaryParamsThenable(),\n  }\n\n  // For runtime prefetches, we encode the stale time and isPartial flag in the response body\n  // rather than relying on response headers. Both of these values will be transformed\n  // by a transform stream before being sent to the client.\n  if (options?.runtimePrefetchSentinel !== undefined) {\n    return {\n      ...baseResponse,\n      rp: [options.runtimePrefetchSentinel] as any,\n    }\n  }\n\n  return baseResponse\n}\n\nfunction createErrorContext(\n  ctx: AppRenderContext,\n  renderSource: RequestErrorContext['renderSource']\n): RequestErrorContext {\n  return {\n    routerKind: 'App Router',\n    routePath: ctx.pagePath,\n    // TODO: is this correct if `isPossibleServerAction` is a false positive?\n    routeType: ctx.isPossibleServerAction ? 'action' : 'render',\n    renderSource,\n    revalidateReason: getRevalidateReason(ctx.workStore),\n  }\n}\n\n/**\n * Produces a RenderResult containing the Flight data for the given request. See\n * `generateDynamicRSCPayload` for information on the contents of the render result.\n */\nasync function generateDynamicFlightRenderResult(\n  req: BaseNextRequest,\n  ctx: AppRenderContext,\n  requestStore: RequestStore,\n  options?: {\n    actionResult: ActionResult\n    skipPageRendering: boolean\n    componentTree?: CacheNodeSeedData\n    preloadCallbacks?: PreloadCallbacks\n    temporaryReferences?: WeakMap<any, string>\n    waitUntil?: Promise<unknown>\n  }\n): Promise<RenderResult> {\n  const {\n    componentMod: { renderToReadableStream },\n    htmlRequestId,\n    renderOpts,\n    requestId,\n    workStore,\n  } = ctx\n\n  const {\n    dev = false,\n    onInstrumentationRequestError,\n    setReactDebugChannel,\n    isBuildTimePrerendering = false,\n  } = renderOpts\n\n  function onFlightDataRenderError(err: DigestedError, silenceLog: boolean) {\n    return onInstrumentationRequestError?.(\n      err,\n      req,\n      createErrorContext(ctx, 'react-server-components-payload'),\n      silenceLog\n    )\n  }\n\n  const onError = createReactServerErrorHandler(\n    dev,\n    isBuildTimePrerendering,\n    workStore.reactServerErrorsByDigest,\n    onFlightDataRenderError\n  )\n\n  const debugChannel = setReactDebugChannel && createDebugChannel()\n\n  if (debugChannel) {\n    setReactDebugChannel(debugChannel.clientSide, htmlRequestId, requestId)\n  }\n\n  const { clientModules } = getClientReferenceManifest()\n\n  // For app dir, use the bundled version of Flight server renderer (renderToReadableStream)\n  // which contains the subset React.\n  const rscPayload = await workUnitAsyncStorage.run(\n    requestStore,\n    generateDynamicRSCPayload,\n    ctx,\n    options\n  )\n\n  const flightReadableStream = workUnitAsyncStorage.run(\n    requestStore,\n    renderToReadableStream,\n    rscPayload,\n    clientModules,\n    {\n      onError,\n      temporaryReferences: options?.temporaryReferences,\n      filterStackFrame,\n      debugChannel: debugChannel?.serverSide,\n    }\n  )\n\n  return new FlightRenderResult(\n    flightReadableStream,\n    { fetchMetrics: workStore.fetchMetrics },\n    options?.waitUntil\n  )\n}\n\ntype RenderToReadableStreamServerOptions = NonNullable<\n  Parameters<\n    (typeof import('react-server-dom-webpack/server.node'))['renderToReadableStream']\n  >[2]\n>\n\nasync function stagedRenderToReadableStreamWithoutCachesInDev(\n  ctx: AppRenderContext,\n  requestStore: RequestStore,\n  getPayload: (requestStore: RequestStore) => Promise<RSCPayload>,\n  options: Omit<RenderToReadableStreamServerOptions, 'environmentName'>\n) {\n  const {\n    componentMod: { renderToReadableStream },\n  } = ctx\n  // We're rendering while bypassing caches,\n  // so we have no hope of showing a useful runtime stage.\n  // But we still want things like `params` to show up in devtools correctly,\n  // which relies on mechanisms we've set up for staged rendering,\n  // so we do a 2-task version (Static -> Dynamic) instead.\n\n  // We aren't doing any validation in this kind of render so we say there\n  // is not runtime prefetch regardless of whether there is or not\n  const hasRuntimePrefetch = false\n\n  // We aren't filling caches so we don't need to abort this render, it'll\n  // stream in a single pass\n  const abortSignal = null\n\n  const stageController = new StagedRenderingController(\n    abortSignal,\n    hasRuntimePrefetch\n  )\n  const environmentName = () => {\n    const currentStage = stageController.currentStage\n    switch (currentStage) {\n      case RenderStage.Before:\n      case RenderStage.Static:\n        return 'Prerender'\n      case RenderStage.Runtime:\n      case RenderStage.Dynamic:\n      case RenderStage.Abandoned:\n        return 'Server'\n      default:\n        currentStage satisfies never\n        throw new InvariantError(`Invalid render stage: ${currentStage}`)\n    }\n  }\n\n  requestStore.stagedRendering = stageController\n  requestStore.asyncApiPromises = createAsyncApiPromisesInDev(\n    stageController,\n    requestStore.cookies,\n    requestStore.mutableCookies,\n    requestStore.headers\n  )\n\n  const { clientModules } = getClientReferenceManifest()\n  const rscPayload = await getPayload(requestStore)\n\n  return await workUnitAsyncStorage.run(\n    requestStore,\n    scheduleInSequentialTasks,\n    () => {\n      stageController.advanceStage(RenderStage.Static)\n      return renderToReadableStream(rscPayload, clientModules, {\n        ...options,\n        environmentName,\n      })\n    },\n    () => {\n      stageController.advanceStage(RenderStage.Dynamic)\n    }\n  )\n}\n\n/**\n * Fork of `generateDynamicFlightRenderResult` that renders using `renderWithRestartOnCacheMissInDev`\n * to ensure correct separation of environments Prerender/Server (for use in Cache Components)\n */\nasync function generateDynamicFlightRenderResultWithStagesInDev(\n  req: BaseNextRequest,\n  ctx: AppRenderContext,\n  initialRequestStore: RequestStore,\n  createRequestStore: (() => RequestStore) | undefined,\n  devFallbackParams: OpaqueFallbackRouteParams | null\n): Promise<RenderResult> {\n  const {\n    htmlRequestId,\n    renderOpts,\n    requestId,\n    workStore,\n    componentMod: { createElement },\n    url,\n  } = ctx\n\n  const {\n    dev = false,\n    onInstrumentationRequestError,\n    setReactDebugChannel,\n    setCacheStatus,\n    isBuildTimePrerendering = false,\n  } = renderOpts\n\n  function onFlightDataRenderError(err: DigestedError, silenceLog: boolean) {\n    return onInstrumentationRequestError?.(\n      err,\n      req,\n      createErrorContext(ctx, 'react-server-components-payload'),\n      silenceLog\n    )\n  }\n\n  const onError = createReactServerErrorHandler(\n    dev,\n    isBuildTimePrerendering,\n    workStore.reactServerErrorsByDigest,\n    onFlightDataRenderError\n  )\n\n  // We only validate RSC requests if it is for HMR refreshes since we know we\n  // will render all the layouts necessary to perform the validation.\n  const shouldValidate =\n    !isBypassingCachesInDev(renderOpts, initialRequestStore) &&\n    initialRequestStore.isHmrRefresh === true\n\n  const getPayload = async (requestStore: RequestStore) => {\n    const payload: RSCPayload &\n      RSCPayloadDevProperties &\n      RSCInitialPayloadPartialDev = await workUnitAsyncStorage.run(\n      requestStore,\n      generateDynamicRSCPayload,\n      ctx,\n      undefined\n    )\n\n    if (isBypassingCachesInDev(renderOpts, requestStore)) {\n      // Mark the RSC payload to indicate that caches were bypassed in dev.\n      // This lets the client know not to cache anything based on this render.\n      payload._bypassCachesInDev = createElement(WarnForBypassCachesInDev, {\n        route: workStore.route,\n      })\n    } else if (shouldValidate) {\n      // If this payload will be used for validation, it needs to contain the\n      // canonical URL. Without it we'd get an error.\n      payload.c = prepareInitialCanonicalUrl(url)\n    }\n\n    return payload\n  }\n\n  let debugChannel: DebugChannelPair | undefined\n  let stream: ReadableStream<Uint8Array>\n\n  if (\n    // We only do this flow if we can safely recreate the store from scratch\n    // (which is not the case for renders after an action)\n    createRequestStore &&\n    // We only do this flow if we're not bypassing caches in dev using\n    // \"disable cache\" in devtools or a hard refresh (cache-control: \"no-store\")\n    !isBypassingCachesInDev(renderOpts, initialRequestStore)\n  ) {\n    // Before we kick off the render, we set the cache status back to it's initial state\n    // in case a previous render bypassed the cache.\n    if (setCacheStatus) {\n      setCacheStatus('ready', htmlRequestId)\n    }\n\n    const {\n      stream: serverStream,\n      accumulatedChunksPromise,\n      staticInterruptReason,\n      runtimeInterruptReason,\n      staticStageEndTime,\n      runtimeStageEndTime,\n      debugChannel: returnedDebugChannel,\n      requestStore: finalRequestStore,\n    } = await renderWithRestartOnCacheMissInDev(\n      ctx,\n      initialRequestStore,\n      createRequestStore,\n      getPayload,\n      onError\n    )\n\n    if (shouldValidate) {\n      let validationDebugChannelClient: Readable | undefined = undefined\n      if (returnedDebugChannel) {\n        const [t1, t2] = returnedDebugChannel.clientSide.readable.tee()\n        returnedDebugChannel.clientSide.readable = t1\n        validationDebugChannelClient = nodeStreamFromReadableStream(t2)\n      }\n      consoleAsyncStorage.run(\n        { dim: true },\n        spawnStaticShellValidationInDev,\n        accumulatedChunksPromise,\n        staticInterruptReason,\n        runtimeInterruptReason,\n        staticStageEndTime,\n        runtimeStageEndTime,\n        ctx,\n        finalRequestStore,\n        devFallbackParams,\n        validationDebugChannelClient\n      )\n    }\n\n    debugChannel = returnedDebugChannel\n    stream = serverStream\n  } else {\n    // We're either bypassing caches or we can't restart the render.\n    // Do a dynamic render, but with (basic) environment labels.\n\n    // Set cache status to bypass when specifically bypassing caches in dev\n    if (setCacheStatus) {\n      setCacheStatus('bypass', htmlRequestId)\n    }\n\n    debugChannel = setReactDebugChannel && createDebugChannel()\n\n    stream = await stagedRenderToReadableStreamWithoutCachesInDev(\n      ctx,\n      initialRequestStore,\n      getPayload,\n      {\n        onError: onError,\n        filterStackFrame,\n        debugChannel: debugChannel?.serverSide,\n      }\n    )\n  }\n\n  if (debugChannel && setReactDebugChannel) {\n    setReactDebugChannel(debugChannel.clientSide, htmlRequestId, requestId)\n  }\n\n  return new FlightRenderResult(stream, {\n    fetchMetrics: workStore.fetchMetrics,\n  })\n}\n\nasync function generateRuntimePrefetchResult(\n  req: BaseNextRequest,\n  ctx: AppRenderContext,\n  requestStore: RequestStore\n): Promise<RenderResult> {\n  const { workStore, renderOpts } = ctx\n  const { isBuildTimePrerendering = false, onInstrumentationRequestError } =\n    renderOpts\n\n  function onFlightDataRenderError(err: DigestedError, silenceLog: boolean) {\n    return onInstrumentationRequestError?.(\n      err,\n      req,\n      // TODO(runtime-ppr): should we use a different value?\n      createErrorContext(ctx, 'react-server-components-payload'),\n      silenceLog\n    )\n  }\n\n  const onError = createReactServerErrorHandler(\n    false,\n    isBuildTimePrerendering,\n    workStore.reactServerErrorsByDigest,\n    onFlightDataRenderError\n  )\n\n  const metadata: AppPageRenderResultMetadata = {}\n\n  // Generate a random sentinel that will be used as a placeholder in the payload\n  // and later replaced by the transform stream\n  const runtimePrefetchSentinel = Math.floor(\n    Math.random() * Number.MAX_SAFE_INTEGER\n  )\n\n  const generatePayload = () =>\n    generateDynamicRSCPayload(ctx, { runtimePrefetchSentinel })\n\n  const {\n    componentMod: {\n      routeModule: {\n        userland: { loaderTree },\n      },\n    },\n    getDynamicParamFromSegment,\n  } = ctx\n  const rootParams = getRootParams(loaderTree, getDynamicParamFromSegment)\n\n  // We need to share caches between the prospective prerender and the final prerender,\n  // but we're not going to persist this anywhere.\n  const prerenderResumeDataCache = createPrerenderResumeDataCache()\n  // We're not resuming an existing render.\n  const renderResumeDataCache = null\n\n  await prospectiveRuntimeServerPrerender(\n    ctx,\n    generatePayload,\n    prerenderResumeDataCache,\n    renderResumeDataCache,\n    rootParams,\n    requestStore.headers,\n    requestStore.cookies,\n    requestStore.draftMode\n  )\n\n  const response = await finalRuntimeServerPrerender(\n    ctx,\n    generatePayload,\n    prerenderResumeDataCache,\n    renderResumeDataCache,\n    rootParams,\n    requestStore.headers,\n    requestStore.cookies,\n    requestStore.draftMode,\n    onError,\n    runtimePrefetchSentinel\n  )\n\n  applyMetadataFromPrerenderResult(response, metadata, workStore)\n  metadata.fetchMetrics = ctx.workStore.fetchMetrics\n\n  return new FlightRenderResult(response.result.prelude, metadata)\n}\n\nasync function prospectiveRuntimeServerPrerender(\n  ctx: AppRenderContext,\n  getPayload: () => any,\n  prerenderResumeDataCache: PrerenderResumeDataCache | null,\n  renderResumeDataCache: RenderResumeDataCache | null,\n  rootParams: Params,\n  headers: PrerenderStoreModernRuntime['headers'],\n  cookies: PrerenderStoreModernRuntime['cookies'],\n  draftMode: PrerenderStoreModernRuntime['draftMode']\n) {\n  const { implicitTags, renderOpts, workStore } = ctx\n  const { ComponentMod } = renderOpts\n\n  // Prerender controller represents the lifetime of the prerender.\n  // It will be aborted when a Task is complete or a synchronously aborting\n  // API is called. Notably during cache-filling renders this does not actually\n  // terminate the render itself which will continue until all caches are filled\n  const initialServerPrerenderController = new AbortController()\n\n  // This controller represents the lifetime of the React render call. Notably\n  // during the cache-filling render it is different from the prerender controller\n  // because we don't want to end the react render until all caches are filled.\n  const initialServerRenderController = new AbortController()\n\n  // The cacheSignal helps us track whether caches are still filling or we are ready\n  // to cut the render off.\n  const cacheSignal = new CacheSignal()\n\n  const initialServerPrerenderStore: PrerenderStoreModernRuntime = {\n    type: 'prerender-runtime',\n    phase: 'render',\n    rootParams,\n    implicitTags,\n    renderSignal: initialServerRenderController.signal,\n    controller: initialServerPrerenderController,\n    // During the initial prerender we need to track all cache reads to ensure\n    // we render long enough to fill every cache it is possible to visit during\n    // the final prerender.\n    cacheSignal,\n    // We only need to track dynamic accesses during the final prerender.\n    dynamicTracking: null,\n    // Runtime prefetches are never cached server-side, only client-side,\n    // so we set `expire` and `revalidate` to their minimum values just in case.\n    revalidate: 1,\n    expire: 0,\n    stale: INFINITE_CACHE,\n    tags: [...implicitTags.tags],\n    renderResumeDataCache,\n    prerenderResumeDataCache,\n    hmrRefreshHash: undefined,\n    // We don't track vary params during initial prerender, only the final one\n    varyParamsAccumulator: null,\n    // We only need task sequencing in the final prerender.\n    runtimeStagePromise: null,\n    // These are not present in regular prerenders, but allowed in a runtime prerender.\n    headers,\n    cookies,\n    draftMode,\n  }\n\n  const { clientModules } = getClientReferenceManifest()\n\n  // We're not going to use the result of this render because the only time it could be used\n  // is if it completes in a microtask and that's likely very rare for any non-trivial app\n  const initialServerPayload = await workUnitAsyncStorage.run(\n    initialServerPrerenderStore,\n    getPayload\n  )\n\n  const pendingInitialServerResult = workUnitAsyncStorage.run(\n    initialServerPrerenderStore,\n    ComponentMod.prerender,\n    initialServerPayload,\n    clientModules,\n    {\n      filterStackFrame,\n      onError: (err) => {\n        const digest = getDigestForWellKnownError(err)\n\n        if (digest) {\n          return digest\n        }\n\n        if (initialServerPrerenderController.signal.aborted) {\n          // The render aborted before this error was handled which indicates\n          // the error is caused by unfinished components within the render\n          return\n        } else if (\n          process.env.NEXT_DEBUG_BUILD ||\n          process.env.__NEXT_VERBOSE_LOGGING\n        ) {\n          printDebugThrownValueForProspectiveRender(\n            err,\n            workStore.route,\n            Phase.ProspectiveRender\n          )\n        }\n      },\n      // We don't want to stop rendering until the cacheSignal is complete so we pass\n      // a different signal to this render call than is used by dynamic APIs to signify\n      // transitioning out of the prerender environment\n      signal: initialServerRenderController.signal,\n    }\n  )\n\n  // Wait for all caches to be finished filling and for async imports to resolve\n  trackPendingModules(cacheSignal)\n  await cacheSignal.cacheReady()\n\n  initialServerRenderController.abort()\n  initialServerPrerenderController.abort()\n\n  // We don't need to continue the prerender process if we already\n  // detected invalid dynamic usage in the initial prerender phase.\n  if (workStore.invalidDynamicUsageError) {\n    throw workStore.invalidDynamicUsageError\n  }\n\n  try {\n    return await createReactServerPrerenderResult(pendingInitialServerResult)\n  } catch (err) {\n    if (\n      initialServerRenderController.signal.aborted ||\n      initialServerPrerenderController.signal.aborted\n    ) {\n      // These are expected errors that might error the prerender. we ignore them.\n    } else if (\n      process.env.NEXT_DEBUG_BUILD ||\n      process.env.__NEXT_VERBOSE_LOGGING\n    ) {\n      // We don't normally log these errors because we are going to retry anyway but\n      // it can be useful for debugging Next.js itself to get visibility here when needed\n      printDebugThrownValueForProspectiveRender(\n        err,\n        workStore.route,\n        Phase.ProspectiveRender\n      )\n    }\n    return null\n  }\n}\n/**\n * Updates the runtime prefetch metadata in the RSC payload as it streams:\n *   \"rp\":[<sentinel>] -> \"rp\":[<isPartial>,<staleTime>]\n *\n * We use a transform stream to do this to avoid needing to trigger an additional render.\n * A random sentinel number guarantees no collision with user data.\n */\nfunction createRuntimePrefetchTransformStream(\n  sentinel: number,\n  isPartial: boolean,\n  staleTime: number\n): TransformStream<Uint8Array, Uint8Array> {\n  const encoder = new TextEncoder()\n\n  // Search for: [<sentinel>]\n  // Replace with: [<isPartial>,<staleTime>]\n  const search = encoder.encode(`[${sentinel}]`)\n  const first = search[0]\n  const replace = encoder.encode(`[${isPartial},${staleTime}]`)\n  const searchLen = search.length\n\n  let currentChunk: Uint8Array | null = null\n  let found = false\n\n  function processChunk(\n    controller: TransformStreamDefaultController<Uint8Array>,\n    nextChunk: null | Uint8Array\n  ) {\n    if (found) {\n      if (nextChunk) {\n        controller.enqueue(nextChunk)\n      }\n      return\n    }\n\n    if (currentChunk) {\n      // We can't search past the index that can contain a full match\n      let exclusiveUpperBound = currentChunk.length - (searchLen - 1)\n      if (nextChunk) {\n        // If we have any overflow bytes we can search up to the chunk's final byte\n        exclusiveUpperBound += Math.min(nextChunk.length, searchLen - 1)\n      }\n      if (exclusiveUpperBound < 1) {\n        // we can't match the current chunk.\n        controller.enqueue(currentChunk)\n        currentChunk = nextChunk // advance so we don't process this chunk again\n        return\n      }\n\n      let currentIndex = currentChunk.indexOf(first)\n\n      // check the current candidate match if it is within the bounds of our search space for the currentChunk\n      candidateLoop: while (\n        -1 < currentIndex &&\n        currentIndex < exclusiveUpperBound\n      ) {\n        // We already know index 0 matches because we used indexOf to find the candidateIndex so we start at index 1\n        let matchIndex = 1\n        while (matchIndex < searchLen) {\n          const candidateIndex = currentIndex + matchIndex\n          const candidateValue =\n            candidateIndex < currentChunk.length\n              ? currentChunk[candidateIndex]\n              : // if we ever hit this condition it is because there is a nextChunk we can read from\n                nextChunk![candidateIndex - currentChunk.length]\n          if (candidateValue !== search[matchIndex]) {\n            // No match, reset and continue the search from the next position\n            currentIndex = currentChunk.indexOf(first, currentIndex + 1)\n            continue candidateLoop\n          }\n          matchIndex++\n        }\n        // We found a complete match. currentIndex is our starting point to replace the value.\n        found = true\n        // enqueue everything up to the match\n        controller.enqueue(currentChunk.subarray(0, currentIndex))\n        // enqueue the replacement value\n        controller.enqueue(replace)\n        // If there are bytes in the currentChunk after the match enqueue them\n        if (currentIndex + searchLen < currentChunk.length) {\n          controller.enqueue(currentChunk.slice(currentIndex + searchLen))\n        }\n        // If we have a next chunk we enqueue it now\n        if (nextChunk) {\n          // if replacement spills over to the next chunk we first exclude the replaced bytes\n          const overflowBytes = currentIndex + searchLen - currentChunk.length\n          const truncatedChunk =\n            overflowBytes > 0 ? nextChunk!.subarray(overflowBytes) : nextChunk\n          controller.enqueue(truncatedChunk)\n        }\n        // We are now in found mode and don't need to track currentChunk anymore\n        currentChunk = null\n        return\n      }\n      // No match found in this chunk, emit it and wait for the next one\n      controller.enqueue(currentChunk)\n    }\n\n    // Advance to the next chunk\n    currentChunk = nextChunk\n  }\n\n  return new TransformStream<Uint8Array, Uint8Array>({\n    transform(chunk, controller) {\n      processChunk(controller, chunk)\n    },\n    flush(controller) {\n      processChunk(controller, null)\n    },\n  })\n}\n\nasync function finalRuntimeServerPrerender(\n  ctx: AppRenderContext,\n  getPayload: () => any,\n  prerenderResumeDataCache: PrerenderResumeDataCache | null,\n  renderResumeDataCache: RenderResumeDataCache | null,\n  rootParams: Params,\n  headers: PrerenderStoreModernRuntime['headers'],\n  cookies: PrerenderStoreModernRuntime['cookies'],\n  draftMode: PrerenderStoreModernRuntime['draftMode'],\n  onError: (err: unknown) => string | undefined,\n  runtimePrefetchSentinel: number\n) {\n  const { implicitTags, renderOpts } = ctx\n  const { ComponentMod, experimental, isDebugDynamicAccesses } = renderOpts\n  const selectStaleTime = createSelectStaleTime(experimental)\n\n  let serverIsDynamic = false\n  const finalServerController = new AbortController()\n\n  const serverDynamicTracking = createDynamicTrackingState(\n    isDebugDynamicAccesses\n  )\n\n  const { promise: runtimeStagePromise, resolve: resolveBlockedRuntimeAPIs } =\n    createPromiseWithResolvers<void>()\n\n  const finalServerPrerenderStore: PrerenderStoreModernRuntime = {\n    type: 'prerender-runtime',\n    phase: 'render',\n    rootParams,\n    implicitTags,\n    renderSignal: finalServerController.signal,\n    controller: finalServerController,\n    // All caches we could read must already be filled so no tracking is necessary\n    cacheSignal: null,\n    dynamicTracking: serverDynamicTracking,\n    // Runtime prefetches are never cached server-side, only client-side,\n    // so we set `expire` and `revalidate` to their minimum values just in case.\n    revalidate: 1,\n    expire: 0,\n    stale: INFINITE_CACHE,\n    tags: [...implicitTags.tags],\n    prerenderResumeDataCache,\n    renderResumeDataCache,\n    hmrRefreshHash: undefined,\n    // TODO: Enable vary params tracking for runtime prefetches.\n    varyParamsAccumulator: null,\n    // Used to separate the \"Static\" stage from the \"Runtime\" stage.\n    runtimeStagePromise,\n    // These are not present in regular prerenders, but allowed in a runtime prerender.\n    headers,\n    cookies,\n    draftMode,\n  }\n\n  const { clientModules } = getClientReferenceManifest()\n\n  const finalRSCPayload = await workUnitAsyncStorage.run(\n    finalServerPrerenderStore,\n    getPayload\n  )\n\n  let prerenderIsPending = true\n  const result = await prerenderAndAbortInSequentialTasksWithStages(\n    async () => {\n      // Static stage\n      const prerenderResult = await workUnitAsyncStorage.run(\n        finalServerPrerenderStore,\n        ComponentMod.prerender,\n        finalRSCPayload,\n        clientModules,\n        {\n          filterStackFrame,\n          onError,\n          signal: finalServerController.signal,\n        }\n      )\n      prerenderIsPending = false\n      return prerenderResult\n    },\n    () => {\n      // Advance to the runtime stage.\n      //\n      // We make runtime APIs hang during the first task (above), and unblock them in the following task (here).\n      // This makes sure that, at this point, we'll have finished all the static parts (what we'd prerender statically).\n      // We know that they don't contain any incorrect sync IO, because that'd have caused a build error.\n      // After we unblock Runtime APIs, if we encounter sync IO (e.g. `await cookies(); Date.now()`),\n      // we'll abort, but we'll produce at least as much output as a static prerender would.\n      resolveBlockedRuntimeAPIs()\n    },\n    () => {\n      // Abort.\n      if (finalServerController.signal.aborted) {\n        // If the server controller is already aborted we must have called something\n        // that required aborting the prerender synchronously such as with new Date()\n        serverIsDynamic = true\n        return\n      }\n\n      if (prerenderIsPending) {\n        // If prerenderIsPending then we have blocked for longer than a Task and we assume\n        // there is something unfinished.\n        serverIsDynamic = true\n      }\n      finalServerController.abort()\n    }\n  )\n\n  // Update the RSC payload stream to replace the sentinel with actual values.\n  // React has already serialized the payload with the sentinel, so we need to transform the stream.\n  const collectedStale = selectStaleTime(finalServerPrerenderStore.stale)\n  result.prelude = result.prelude.pipeThrough(\n    createRuntimePrefetchTransformStream(\n      runtimePrefetchSentinel,\n      serverIsDynamic,\n      collectedStale\n    )\n  )\n\n  return {\n    result,\n    // TODO(runtime-ppr): do we need to produce a digest map here?\n    // digestErrorsMap: ...,\n    dynamicAccess: serverDynamicTracking,\n    isPartial: serverIsDynamic,\n    collectedRevalidate: finalServerPrerenderStore.revalidate,\n    collectedExpire: finalServerPrerenderStore.expire,\n    collectedStale,\n    collectedTags: finalServerPrerenderStore.tags,\n  }\n}\n\n/**\n * Crawlers will inadvertently think the canonicalUrl in the RSC payload should be crawled\n * when our intention is to just seed the router state with the current URL.\n * This function splits up the pathname so that we can later join it on\n * when we're ready to consume the path.\n */\nfunction prepareInitialCanonicalUrl(url: RequestStore['url']) {\n  return (url.pathname + url.search).split('/')\n}\n\nfunction getRenderedSearch(query: NextParsedUrlQuery): string {\n  // Inlined implementation of querystring.encode, which is not available in\n  // the Edge runtime.\n  const pairs = []\n  for (const key in query) {\n    const value = query[key]\n    if (value == null) continue\n    if (Array.isArray(value)) {\n      for (const v of value) {\n        pairs.push(\n          `${encodeURIComponent(key)}=${encodeURIComponent(String(v))}`\n        )\n      }\n    } else {\n      pairs.push(\n        `${encodeURIComponent(key)}=${encodeURIComponent(String(value))}`\n      )\n    }\n  }\n\n  // The result should match the format of a web URL's `search` property, since\n  // this is the format that's stored in the App Router state.\n  // TODO: We're a bit inconsistent about this. The x-nextjs-rewritten-query\n  // header omits the leading question mark. Should refactor to always do\n  // that instead.\n  if (pairs.length === 0) {\n    // If the search string is empty, return an empty string.\n    return ''\n  }\n  // Prepend '?' to the search params string.\n  return '?' + pairs.join('&')\n}\n\n// This is the data necessary to render <AppRouter /> when no SSR errors are encountered\nasync function getRSCPayload(\n  tree: LoaderTree,\n  ctx: AppRenderContext,\n  is404: boolean\n): Promise<InitialRSCPayload & { P: ReactNode }> {\n  const injectedCSS = new Set<string>()\n  const injectedJS = new Set<string>()\n  const injectedFontPreloadTags = new Set<string>()\n  let missingSlots: Set<string> | undefined\n\n  // We only track missing parallel slots in development\n  if (process.env.NODE_ENV === 'development') {\n    missingSlots = new Set<string>()\n  }\n\n  const {\n    getDynamicParamFromSegment,\n    query,\n    appUsingSizeAdjustment,\n    componentMod: { createMetadataComponents, createElement, Fragment },\n    url,\n    workStore,\n  } = ctx\n\n  const initialTree = createFlightRouterStateFromLoaderTree(\n    tree,\n    getDynamicParamFromSegment,\n    query\n  )\n  const serveStreamingMetadata = !!ctx.renderOpts.serveStreamingMetadata\n  const hasGlobalNotFound = !!tree[2]['global-not-found']\n\n  const { Viewport, Metadata, MetadataOutlet } = createMetadataComponents({\n    tree,\n    // When it's using global-not-found, metadata errorType is undefined, which will retrieve the\n    // metadata from the page.\n    // When it's using not-found, metadata errorType is 'not-found', which will retrieve the\n    // metadata from the not-found.js boundary.\n    // TODO: remove this condition and keep it undefined when global-not-found is stabilized.\n    errorType: is404 && !hasGlobalNotFound ? 'not-found' : undefined,\n    parsedQuery: query,\n    pathname: url.pathname,\n    metadataContext: createMetadataContext(ctx.renderOpts),\n    getDynamicParamFromSegment,\n    workStore,\n    serveStreamingMetadata,\n  })\n\n  const preloadCallbacks: PreloadCallbacks = []\n\n  const seedData = await createComponentTree({\n    ctx,\n    loaderTree: tree,\n    parentParams: {},\n    injectedCSS,\n    injectedJS,\n    injectedFontPreloadTags,\n    rootLayoutIncluded: false,\n    missingSlots,\n    preloadCallbacks,\n    authInterrupts: ctx.renderOpts.experimental.authInterrupts,\n    MetadataOutlet,\n  })\n\n  // When the `vary` response header is present with `Next-URL`, that means there's a chance\n  // it could respond differently if there's an interception route. We provide this information\n  // to `AppRouter` so that it can properly seed the prefetch cache with a prefix, if needed.\n  const varyHeader = ctx.res.getHeader('vary')\n  const couldBeIntercepted =\n    typeof varyHeader === 'string' && varyHeader.includes(NEXT_URL)\n\n  const initialHead = createElement(\n    Fragment,\n    {\n      key: flightDataPathHeadKey,\n    },\n    createElement(NonIndex, {\n      createElement,\n      pagePath: ctx.pagePath,\n      statusCode: ctx.res.statusCode,\n      isPossibleServerAction: ctx.isPossibleServerAction,\n    }),\n    createElement(Viewport, null),\n    createElement(Metadata, null),\n    appUsingSizeAdjustment\n      ? createElement('meta', {\n          name: 'next-size-adjust',\n          content: '',\n        })\n      : null\n  )\n\n  const { GlobalError, styles: globalErrorStyles } = await getGlobalErrorStyles(\n    tree,\n    ctx\n  )\n\n  // Assume the head we're rendering contains only partial data if PPR is\n  // enabled and this is a statically generated response. This is used by the\n  // client Segment Cache after a prefetch to determine if it can skip the\n  // second request to fill in the dynamic data.\n  //\n  // See similar comment in create-component-tree.tsx for more context.\n  const isPossiblyPartialHead =\n    workStore.isStaticGeneration &&\n    ctx.renderOpts.experimental.isRoutePPREnabled === true\n\n  return {\n    // See the comment above the `Preloads` component (below) for why this is part of the payload\n    P: createElement(Preloads, {\n      preloadCallbacks: preloadCallbacks,\n    }),\n    b: ctx.sharedContext.buildId,\n    c: prepareInitialCanonicalUrl(url),\n    q: getRenderedSearch(query),\n    i: !!couldBeIntercepted,\n    f: [\n      [\n        initialTree,\n        seedData,\n        initialHead,\n        isPossiblyPartialHead,\n      ] as FlightDataPath,\n    ],\n    m: missingSlots,\n    G: [GlobalError, globalErrorStyles],\n    S: workStore.isStaticGeneration,\n    h: getMetadataVaryParamsThenable(),\n  }\n}\n\n/**\n * Preload calls (such as `ReactDOM.preloadStyle` and `ReactDOM.preloadFont`) need to be called during rendering\n * in order to create the appropriate preload tags in the DOM, otherwise they're a no-op. Since we invoke\n * renderToReadableStream with a function that returns component props rather than a component itself, we use\n * this component to \"render  \" the preload calls.\n */\nfunction Preloads({ preloadCallbacks }: { preloadCallbacks: Function[] }) {\n  preloadCallbacks.forEach((preloadFn) => preloadFn())\n  return null\n}\n\n// This is the data necessary to render <AppRouter /> when an error state is triggered\nasync function getErrorRSCPayload(\n  tree: LoaderTree,\n  ctx: AppRenderContext,\n  ssrError: unknown,\n  errorType: MetadataErrorType | 'redirect' | undefined\n) {\n  const {\n    getDynamicParamFromSegment,\n    query,\n    componentMod: { createMetadataComponents, createElement, Fragment },\n    url,\n    workStore,\n  } = ctx\n\n  const serveStreamingMetadata = !!ctx.renderOpts.serveStreamingMetadata\n  const { Viewport, Metadata } = createMetadataComponents({\n    tree,\n    parsedQuery: query,\n    pathname: url.pathname,\n    metadataContext: createMetadataContext(ctx.renderOpts),\n    errorType,\n    getDynamicParamFromSegment,\n    workStore,\n    serveStreamingMetadata: serveStreamingMetadata,\n  })\n\n  const initialHead = createElement(\n    Fragment,\n    {\n      key: flightDataPathHeadKey,\n    },\n    createElement(NonIndex, {\n      createElement,\n      pagePath: ctx.pagePath,\n      statusCode: ctx.res.statusCode,\n      isPossibleServerAction: ctx.isPossibleServerAction,\n    }),\n    createElement(Viewport, null),\n    process.env.NODE_ENV === 'development' &&\n      createElement('meta', {\n        name: 'next-error',\n        content: 'not-found',\n      }),\n    createElement(Metadata, null)\n  )\n\n  const initialTree = createFlightRouterStateFromLoaderTree(\n    tree,\n    getDynamicParamFromSegment,\n    query\n  )\n\n  let err: Error | undefined = undefined\n  if (ssrError) {\n    err = isError(ssrError) ? ssrError : new Error(ssrError + '')\n  }\n\n  // For metadata notFound error there's no global not found boundary on top\n  // so we create a not found page with AppRouter\n  const seedData: CacheNodeSeedData = [\n    createElement(\n      'html',\n      {\n        id: '__next_error__',\n      },\n      createElement('head', null),\n      createElement(\n        'body',\n        null,\n        process.env.NODE_ENV !== 'production' && err\n          ? createElement('template', {\n              'data-next-error-message': err.message,\n              'data-next-error-digest': 'digest' in err ? err.digest : '',\n              'data-next-error-stack': err.stack,\n            })\n          : null\n      )\n    ),\n    {},\n    null,\n    false,\n    false, // We don't currently support runtime prefetching for error pages.\n    null, // varyParams - not tracked for error pages\n  ]\n\n  const { GlobalError, styles: globalErrorStyles } = await getGlobalErrorStyles(\n    tree,\n    ctx\n  )\n\n  const isPossiblyPartialHead =\n    workStore.isStaticGeneration &&\n    ctx.renderOpts.experimental.isRoutePPREnabled === true\n\n  return {\n    b: ctx.sharedContext.buildId,\n    c: prepareInitialCanonicalUrl(url),\n    q: getRenderedSearch(query),\n    m: undefined,\n    i: false,\n    f: [\n      [\n        initialTree,\n        seedData,\n        initialHead,\n        isPossiblyPartialHead,\n      ] as FlightDataPath,\n    ],\n    G: [GlobalError, globalErrorStyles],\n    S: workStore.isStaticGeneration,\n    h: getMetadataVaryParamsThenable(),\n  } satisfies InitialRSCPayload\n}\n\n// This component must run in an SSR context. It will render the RSC root component\nfunction App<T>({\n  reactServerStream,\n  reactDebugStream,\n  debugEndTime,\n  preinitScripts,\n  ServerInsertedHTMLProvider,\n  nonce,\n  images,\n}: {\n  /* eslint-disable @next/internal/no-ambiguous-jsx -- React Client */\n  reactServerStream: Readable | BinaryStreamOf<T>\n  reactDebugStream: Readable | ReadableStream<Uint8Array> | undefined\n  debugEndTime: number | undefined\n  preinitScripts: () => void\n  ServerInsertedHTMLProvider: ComponentType<{\n    children: JSX.Element\n  }>\n  images: RenderOpts['images']\n  nonce?: string\n}): JSX.Element {\n  preinitScripts()\n  const response = ReactClient.use(\n    getFlightStream<InitialRSCPayload>(\n      reactServerStream,\n      reactDebugStream,\n      debugEndTime,\n      nonce\n    )\n  )\n\n  const initialState = createInitialRouterState({\n    // This is not used during hydration, so we don't have to pass a\n    // real timestamp.\n    navigatedAt: -1,\n    initialFlightData: response.f,\n    initialCanonicalUrlParts: response.c,\n    initialRenderedSearch: response.q,\n    initialCouldBeIntercepted: response.i,\n    initialPrerendered: response.S,\n    // location is not initialized in the SSR render\n    // it's set to window.location during hydration\n    location: null,\n  })\n\n  const actionQueue = createMutableActionQueue(initialState, null)\n\n  const { HeadManagerContext } =\n    require('../../shared/lib/head-manager-context.shared-runtime') as typeof import('../../shared/lib/head-manager-context.shared-runtime')\n\n  return (\n    <HeadManagerContext.Provider\n      value={{\n        appDir: true,\n        nonce,\n      }}\n    >\n      <ImageConfigContext.Provider value={images ?? imageConfigDefault}>\n        <ServerInsertedHTMLProvider>\n          <AppRouter actionQueue={actionQueue} globalErrorState={response.G} />\n        </ServerInsertedHTMLProvider>\n      </ImageConfigContext.Provider>\n    </HeadManagerContext.Provider>\n  )\n  /* eslint-enable @next/internal/no-ambiguous-jsx -- React Client */\n}\n\n// @TODO our error stream should be probably just use the same root component. But it was previously\n// different I don't want to figure out if that is meaningful at this time so just keeping the behavior\n// consistent for now.\nfunction ErrorApp<T>({\n  reactServerStream,\n  preinitScripts,\n  ServerInsertedHTMLProvider,\n  nonce,\n  images,\n}: {\n  reactServerStream: BinaryStreamOf<T>\n  preinitScripts: () => void\n  ServerInsertedHTMLProvider: ComponentType<{\n    children: JSX.Element\n  }>\n  nonce?: string\n  images: RenderOpts['images']\n}): JSX.Element {\n  /* eslint-disable @next/internal/no-ambiguous-jsx -- React Client */\n  preinitScripts()\n  const response = ReactClient.use(\n    getFlightStream<InitialRSCPayload>(\n      reactServerStream,\n      undefined,\n      undefined,\n      nonce\n    )\n  )\n\n  const initialState = createInitialRouterState({\n    // This is not used during hydration, so we don't have to pass a\n    // real timestamp.\n    navigatedAt: -1,\n    initialFlightData: response.f,\n    initialCanonicalUrlParts: response.c,\n    initialRenderedSearch: response.q,\n    initialCouldBeIntercepted: response.i,\n    initialPrerendered: response.S,\n    // location is not initialized in the SSR render\n    // it's set to window.location during hydration\n    location: null,\n  })\n\n  const actionQueue = createMutableActionQueue(initialState, null)\n\n  return (\n    <ImageConfigContext.Provider value={images ?? imageConfigDefault}>\n      <ServerInsertedHTMLProvider>\n        <AppRouter actionQueue={actionQueue} globalErrorState={response.G} />\n      </ServerInsertedHTMLProvider>\n    </ImageConfigContext.Provider>\n  )\n  /* eslint-enable @next/internal/no-ambiguous-jsx -- React Client */\n}\n\n// We use a trick with TS Generics to branch streams with a type so we can\n// consume the parsed value of a Readable Stream if it was constructed with a\n// certain object shape. The generic type is not used directly in the type so it\n// requires a disabling of the eslint rule disallowing unused vars\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nexport type BinaryStreamOf<T> = ReadableStream<Uint8Array>\n\nasync function renderToHTMLOrFlightImpl(\n  req: BaseNextRequest,\n  res: BaseNextResponse,\n  url: ReturnType<typeof parseRelativeUrl>,\n  pagePath: string,\n  query: NextParsedUrlQuery,\n  renderOpts: RenderOpts,\n  workStore: WorkStore,\n  parsedRequestHeaders: ParsedRequestHeaders,\n  postponedState: PostponedState | null,\n  serverComponentsHmrCache: ServerComponentsHmrCache | undefined,\n  sharedContext: AppSharedContext,\n  interpolatedParams: Params,\n  fallbackRouteParams: OpaqueFallbackRouteParams | null\n) {\n  const isNotFoundPath = pagePath === '/404'\n  if (isNotFoundPath) {\n    res.statusCode = 404\n  }\n\n  // A unique request timestamp used by development to ensure that it's\n  // consistent and won't change during this request. This is important to\n  // avoid that resources can be deduped by React Float if the same resource is\n  // rendered or preloaded multiple times: `<link href=\"a.css?v={Date.now()}\"/>`.\n  const requestTimestamp = Date.now()\n\n  const {\n    ComponentMod,\n    nextFontManifest,\n    serverActions,\n    assetPrefix = '',\n    enableTainting,\n    cacheComponents,\n  } = renderOpts\n\n  // We need to expose the bundled `require` API globally for\n  // react-server-dom-webpack. This is a hack until we find a better way.\n  if (ComponentMod.__next_app__) {\n    const instrumented = wrapClientComponentLoader(ComponentMod)\n\n    // When we are prerendering if there is a cacheSignal for tracking\n    // cache reads we track calls to `loadChunk` and `require`. This allows us\n    // to treat chunk/module loading with similar semantics as cache reads to avoid\n    // module loading from causing a prerender to abort too early.\n\n    const shouldTrackModuleLoading = () => {\n      if (!cacheComponents) {\n        return false\n      }\n      if (renderOpts.dev) {\n        return true\n      }\n      const workUnitStore = workUnitAsyncStorage.getStore()\n\n      if (!workUnitStore) {\n        return false\n      }\n\n      switch (workUnitStore.type) {\n        case 'prerender':\n        case 'prerender-client':\n        case 'prerender-runtime':\n        case 'cache':\n        case 'private-cache':\n          return true\n        case 'prerender-ppr':\n        case 'prerender-legacy':\n        case 'request':\n        case 'unstable-cache':\n          return false\n        default:\n          workUnitStore satisfies never\n      }\n    }\n\n    const __next_require__: typeof instrumented.require = (...args) => {\n      const exportsOrPromise = instrumented.require(...args)\n      if (shouldTrackModuleLoading()) {\n        // requiring an async module returns a promise.\n        trackPendingImport(exportsOrPromise)\n      }\n      return exportsOrPromise\n    }\n    // @ts-expect-error\n    globalThis.__next_require__ = __next_require__\n\n    const __next_chunk_load__: typeof instrumented.loadChunk = (...args) => {\n      const loadingChunk = instrumented.loadChunk(...args)\n      if (shouldTrackModuleLoading()) {\n        trackPendingChunkLoad(loadingChunk)\n      }\n      return loadingChunk\n    }\n    // @ts-expect-error\n    globalThis.__next_chunk_load__ = __next_chunk_load__\n  }\n\n  if (\n    process.env.NODE_ENV === 'development' &&\n    renderOpts.setIsrStatus &&\n    !cacheComponents\n  ) {\n    // Reset the ISR status at start of request.\n    const { pathname } = new URL(req.url || '/', 'http://n')\n    renderOpts.setIsrStatus(\n      pathname,\n      // Only pages using the Node runtime can use ISR, Edge is always dynamic.\n      process.env.NEXT_RUNTIME === 'edge' ? false : undefined\n    )\n  }\n\n  if (\n    // The type check here ensures that `req` is correctly typed, and the\n    // environment variable check provides dead code elimination.\n    process.env.NEXT_RUNTIME !== 'edge' &&\n    isNodeNextRequest(req)\n  ) {\n    res.onClose(() => {\n      // We stop tracking fetch metrics when the response closes, since we\n      // report them at that time.\n      workStore.shouldTrackFetchMetrics = false\n    })\n\n    req.originalRequest.on('end', () => {\n      if ('performance' in globalThis) {\n        const metrics = getClientComponentLoaderMetrics({ reset: true })\n        if (metrics) {\n          getTracer()\n            .startSpan(NextNodeServerSpan.clientComponentLoading, {\n              startTime: metrics.clientComponentLoadStart,\n              attributes: {\n                'next.clientComponentLoadCount':\n                  metrics.clientComponentLoadCount,\n                'next.span_type': NextNodeServerSpan.clientComponentLoading,\n              },\n            })\n            .end(\n              metrics.clientComponentLoadStart +\n                metrics.clientComponentLoadTimes\n            )\n        }\n      }\n    })\n  }\n\n  const metadata: AppPageRenderResultMetadata = {\n    statusCode: isNotFoundPath ? 404 : undefined,\n  }\n\n  const appUsingSizeAdjustment = !!nextFontManifest?.appUsingSizeAdjust\n\n  ComponentMod.patchFetch()\n\n  // Pull out the hooks/references from the component.\n  const {\n    routeModule: {\n      userland: { loaderTree },\n    },\n    taintObjectReference,\n  } = ComponentMod\n  if (enableTainting) {\n    taintObjectReference(\n      'Do not pass process.env to Client Components since it will leak sensitive data',\n      process.env\n    )\n  }\n\n  workStore.fetchMetrics = []\n  metadata.fetchMetrics = workStore.fetchMetrics\n\n  // don't modify original query object\n  query = { ...query }\n  stripInternalQueries(query)\n\n  const { isStaticGeneration } = workStore\n\n  let requestId: string\n  let htmlRequestId: string\n\n  const {\n    flightRouterState,\n    isPrefetchRequest,\n    isRuntimePrefetchRequest,\n    isRSCRequest,\n    isHmrRefresh,\n    nonce,\n  } = parsedRequestHeaders\n\n  if (parsedRequestHeaders.requestId) {\n    // If the client has provided a request ID (in development mode), we use it.\n    requestId = parsedRequestHeaders.requestId\n  } else {\n    // Otherwise we generate a new request ID.\n    if (isStaticGeneration) {\n      requestId = Buffer.from(\n        await crypto.subtle.digest('SHA-1', Buffer.from(req.url))\n      ).toString('hex')\n    } else if (process.env.NEXT_RUNTIME === 'edge') {\n      requestId = crypto.randomUUID()\n    } else {\n      requestId = (\n        require('next/dist/compiled/nanoid') as typeof import('next/dist/compiled/nanoid')\n      ).nanoid()\n    }\n  }\n\n  // If the client has provided an HTML request ID, we use it to associate the\n  // request with the HTML document from which it originated, which is used to\n  // send debug information to the associated WebSocket client. Otherwise, this\n  // is the request for the HTML document, so we use the request ID also as the\n  // HTML request ID.\n  htmlRequestId = parsedRequestHeaders.htmlRequestId || requestId\n\n  const getDynamicParamFromSegment = makeGetDynamicParamFromSegment(\n    interpolatedParams,\n    fallbackRouteParams,\n    renderOpts.experimental.optimisticRouting\n  )\n\n  const isPossibleActionRequest = getIsPossibleServerAction(req)\n\n  // For implicit tags, we use the resolved pathname which has dynamic params\n  // interpolated, is decoded, and has trailing slash removed.\n  const resolvedPathname = getRequestMeta(req, 'resolvedPathname')\n  if (!resolvedPathname) {\n    throw new InvariantError('resolvedPathname must be set in request metadata')\n  }\n\n  const implicitTags = await getImplicitTags(\n    workStore.page,\n    resolvedPathname,\n    fallbackRouteParams\n  )\n\n  const ctx: AppRenderContext = {\n    componentMod: ComponentMod,\n    url,\n    renderOpts,\n    workStore,\n    parsedRequestHeaders,\n    getDynamicParamFromSegment,\n    query,\n    isPrefetch: isPrefetchRequest,\n    isPossibleServerAction: isPossibleActionRequest,\n    requestTimestamp,\n    appUsingSizeAdjustment,\n    flightRouterState,\n    requestId,\n    htmlRequestId,\n    pagePath,\n    assetPrefix,\n    isNotFoundPath,\n    nonce,\n    res,\n    sharedContext,\n    implicitTags,\n  }\n\n  getTracer().setRootSpanAttribute('next.route', pagePath)\n\n  if (isStaticGeneration) {\n    // We're either building or revalidating. In either case we need to\n    // prerender our page rather than render it.\n    const prerenderToStreamWithTracing = getTracer().wrap(\n      AppRenderSpan.getBodyResult,\n      {\n        spanName: `prerender route (app) ${pagePath}`,\n        attributes: {\n          'next.route': pagePath,\n        },\n      },\n      prerenderToStream\n    )\n\n    const response = await prerenderToStreamWithTracing(\n      req,\n      res,\n      ctx,\n      metadata,\n      loaderTree,\n      fallbackRouteParams\n    )\n\n    // If we're debugging partial prerendering, print all the dynamic API accesses\n    // that occurred during the render.\n    // @TODO move into renderToStream function\n    if (\n      response.dynamicAccess &&\n      accessedDynamicData(response.dynamicAccess) &&\n      renderOpts.isDebugDynamicAccesses\n    ) {\n      warn('The following dynamic usage was detected:')\n      for (const access of formatDynamicAPIAccesses(response.dynamicAccess)) {\n        warn(access)\n      }\n    }\n\n    // If we encountered any unexpected errors during build we fail the\n    // prerendering phase and the build.\n    if (workStore.invalidDynamicUsageError) {\n      logDisallowedDynamicError(workStore, workStore.invalidDynamicUsageError)\n      throw new StaticGenBailoutError()\n    }\n    if (response.digestErrorsMap.size) {\n      const buildFailingError = response.digestErrorsMap.values().next().value\n      if (buildFailingError) throw buildFailingError\n    }\n    // Pick first userland SSR error, which is also not a RSC error.\n    if (response.ssrErrors.length) {\n      const buildFailingError = response.ssrErrors.find((err) =>\n        isUserLandError(err)\n      )\n      if (buildFailingError) throw buildFailingError\n    }\n\n    const options: RenderResultOptions = {\n      metadata,\n      contentType: HTML_CONTENT_TYPE_HEADER,\n    }\n\n    // If we have pending revalidates, wait until they are all resolved.\n    const maybeRevalidatesPromise = executeRevalidates(workStore)\n    if (maybeRevalidatesPromise !== false) {\n      const revalidatesPromise = maybeRevalidatesPromise.finally(() => {\n        if (process.env.NEXT_PRIVATE_DEBUG_CACHE) {\n          console.log('pending revalidates promise finished for:', url.href)\n        }\n      })\n      if (renderOpts.waitUntil) {\n        renderOpts.waitUntil(revalidatesPromise)\n      } else {\n        options.waitUntil = revalidatesPromise\n      }\n    }\n\n    applyMetadataFromPrerenderResult(response, metadata, workStore)\n\n    if (response.renderResumeDataCache) {\n      metadata.renderResumeDataCache = response.renderResumeDataCache\n    }\n\n    return new RenderResult(await streamToString(response.stream), options)\n  } else {\n    // We're rendering dynamically\n    const renderResumeDataCache =\n      renderOpts.renderResumeDataCache ??\n      postponedState?.renderResumeDataCache ??\n      null\n\n    const rootParams = getRootParams(loaderTree, ctx.getDynamicParamFromSegment)\n    const devFallbackParams = getRequestMeta(req, 'devFallbackParams') || null\n\n    const createRequestStore = createRequestStoreForRender.bind(\n      null,\n      req,\n      res,\n      url,\n      rootParams,\n      implicitTags,\n      renderOpts.onUpdateCookies,\n      renderOpts.previewProps,\n      isHmrRefresh,\n      serverComponentsHmrCache,\n      renderResumeDataCache,\n      devFallbackParams\n    )\n    const requestStore = createRequestStore()\n\n    if (\n      process.env.NODE_ENV === 'development' &&\n      renderOpts.setIsrStatus &&\n      !cacheComponents &&\n      // Only pages using the Node runtime can use ISR, so we only need to\n      // update the status for those.\n      // The type check here ensures that `req` is correctly typed, and the\n      // environment variable check provides dead code elimination.\n      process.env.NEXT_RUNTIME !== 'edge' &&\n      isNodeNextRequest(req)\n    ) {\n      const setIsrStatus = renderOpts.setIsrStatus\n      req.originalRequest.on('end', () => {\n        const { pathname } = new URL(req.url || '/', 'http://n')\n        const isStatic = !requestStore.usedDynamic && !workStore.forceDynamic\n        setIsrStatus(pathname, isStatic)\n      })\n    }\n\n    if (isRSCRequest) {\n      if (isRuntimePrefetchRequest) {\n        return generateRuntimePrefetchResult(req, ctx, requestStore)\n      } else {\n        if (\n          process.env.NODE_ENV === 'development' &&\n          process.env.NEXT_RUNTIME !== 'edge' &&\n          cacheComponents\n        ) {\n          return generateDynamicFlightRenderResultWithStagesInDev(\n            req,\n            ctx,\n            requestStore,\n            createRequestStore,\n            devFallbackParams\n          )\n        } else {\n          return generateDynamicFlightRenderResult(req, ctx, requestStore)\n        }\n      }\n    }\n\n    let didExecuteServerAction = false\n    let formState: null | any = null\n    if (isPossibleActionRequest) {\n      // For action requests, we handle them differently with a special render result.\n      const actionRequestResult = await handleAction({\n        req,\n        res,\n        ComponentMod,\n        generateFlight: generateDynamicFlightRenderResult,\n        workStore,\n        requestStore,\n        serverActions,\n        ctx,\n        metadata,\n      })\n\n      if (actionRequestResult) {\n        if (actionRequestResult.type === 'not-found') {\n          const notFoundLoaderTree = createNotFoundLoaderTree(loaderTree)\n          res.statusCode = 404\n          metadata.statusCode = 404\n          const stream = await renderToStream(\n            requestStore,\n            req,\n            res,\n            ctx,\n            notFoundLoaderTree,\n            formState,\n            postponedState,\n            metadata,\n            undefined, // Prevent restartable-render behavior in dev + Cache Components mode\n            devFallbackParams\n          )\n\n          return new RenderResult(stream, {\n            metadata,\n            contentType: HTML_CONTENT_TYPE_HEADER,\n          })\n        } else if (actionRequestResult.type === 'done') {\n          if (actionRequestResult.result) {\n            actionRequestResult.result.assignMetadata(metadata)\n            return actionRequestResult.result\n          } else if (actionRequestResult.formState) {\n            formState = actionRequestResult.formState\n          }\n        }\n      }\n\n      didExecuteServerAction = true\n    }\n\n    const options: RenderResultOptions = {\n      metadata,\n      contentType: HTML_CONTENT_TYPE_HEADER,\n    }\n\n    const stream = await renderToStream(\n      // NOTE: in Cache Components (dev), if the render is restarted, it will use a different requestStore\n      // than the one that we're passing in here.\n      requestStore,\n      req,\n      res,\n      ctx,\n      loaderTree,\n      formState,\n      postponedState,\n      metadata,\n      // If we're rendering HTML after an action, we don't want restartable-render behavior\n      // because the result should be dynamic, like it is in prod.\n      // Also, the request store might have been mutated by the action (e.g. enabling draftMode)\n      // and we currently we don't copy changes over when creating a new store,\n      // so the restarted render wouldn't be correct.\n      didExecuteServerAction ? undefined : createRequestStore,\n      devFallbackParams\n    )\n\n    // Invalid dynamic usages should only error the request in development.\n    // In production, it's better to produce a result.\n    // (the dynamic error will still be thrown inside the component tree, but it's catchable by error boundaries)\n    if (workStore.invalidDynamicUsageError && workStore.dev) {\n      throw workStore.invalidDynamicUsageError\n    }\n\n    // If we have pending revalidates, wait until they are all resolved.\n    const maybeRevalidatesPromise = executeRevalidates(workStore)\n    if (maybeRevalidatesPromise !== false) {\n      const revalidatesPromise = maybeRevalidatesPromise.finally(() => {\n        if (process.env.NEXT_PRIVATE_DEBUG_CACHE) {\n          console.log('pending revalidates promise finished for:', url.href)\n        }\n      })\n      if (renderOpts.waitUntil) {\n        renderOpts.waitUntil(revalidatesPromise)\n      } else {\n        options.waitUntil = revalidatesPromise\n      }\n    }\n\n    // Create the new render result for the response.\n    return new RenderResult(stream, options)\n  }\n}\n\nexport type AppPageRender = (\n  req: BaseNextRequest,\n  res: BaseNextResponse,\n  pagePath: string,\n  query: NextParsedUrlQuery,\n  fallbackRouteParams: OpaqueFallbackRouteParams | null,\n  renderOpts: RenderOpts,\n  serverComponentsHmrCache: ServerComponentsHmrCache | undefined,\n  sharedContext: AppSharedContext\n) => Promise<RenderResult<AppPageRenderResultMetadata>>\n\nexport const renderToHTMLOrFlight: AppPageRender = (\n  req,\n  res,\n  pagePath,\n  query,\n  fallbackRouteParams,\n  renderOpts,\n  serverComponentsHmrCache,\n  sharedContext\n) => {\n  if (!req.url) {\n    throw new Error('Invalid URL')\n  }\n\n  const url = parseRelativeUrl(req.url, undefined, false)\n\n  // We read these values from the request object as, in certain cases,\n  // base-server will strip them to opt into different rendering behavior.\n  const parsedRequestHeaders = parseRequestHeaders(req.headers, {\n    isRoutePPREnabled: renderOpts.experimental.isRoutePPREnabled === true,\n    previewModeId: renderOpts.previewProps?.previewModeId,\n  })\n\n  const { isPrefetchRequest, previouslyRevalidatedTags, nonce } =\n    parsedRequestHeaders\n\n  let interpolatedParams: Params\n  let postponedState: PostponedState | null = null\n\n  // If provided, the postpone state should be parsed so it can be provided to\n  // React.\n  if (typeof renderOpts.postponed === 'string') {\n    if (fallbackRouteParams) {\n      throw new InvariantError(\n        'postponed state should not be provided when fallback params are provided'\n      )\n    }\n\n    interpolatedParams = interpolateParallelRouteParams(\n      renderOpts.ComponentMod.routeModule.userland.loaderTree,\n      renderOpts.params ?? {},\n      pagePath,\n      fallbackRouteParams\n    )\n\n    postponedState = parsePostponedState(\n      renderOpts.postponed,\n      interpolatedParams,\n      renderOpts.experimental.maxPostponedStateSizeBytes\n    )\n  } else {\n    interpolatedParams = interpolateParallelRouteParams(\n      renderOpts.ComponentMod.routeModule.userland.loaderTree,\n      renderOpts.params ?? {},\n      pagePath,\n      fallbackRouteParams\n    )\n  }\n\n  if (\n    postponedState?.renderResumeDataCache &&\n    renderOpts.renderResumeDataCache\n  ) {\n    throw new InvariantError(\n      'postponed state and dev warmup immutable resume data cache should not be provided together'\n    )\n  }\n\n  const workStore = createWorkStore({\n    page: renderOpts.routeModule.definition.page,\n    renderOpts,\n    // @TODO move to workUnitStore of type Request\n    isPrefetchRequest,\n    buildId: sharedContext.buildId,\n    previouslyRevalidatedTags,\n    nonce,\n  })\n\n  return workAsyncStorage.run(\n    workStore,\n    // The function to run\n    renderToHTMLOrFlightImpl,\n    // all of it's args\n    req,\n    res,\n    url,\n    pagePath,\n    query,\n    renderOpts,\n    workStore,\n    parsedRequestHeaders,\n    postponedState,\n    serverComponentsHmrCache,\n    sharedContext,\n    interpolatedParams,\n    fallbackRouteParams\n  )\n}\n\nfunction applyMetadataFromPrerenderResult(\n  response: Pick<\n    PrerenderToStreamResult,\n    | 'collectedExpire'\n    | 'collectedRevalidate'\n    | 'collectedStale'\n    | 'collectedTags'\n  >,\n  metadata: AppPageRenderResultMetadata,\n  workStore: WorkStore\n) {\n  if (response.collectedTags) {\n    metadata.fetchTags = response.collectedTags.join(',')\n  }\n\n  // Let the client router know how long to keep the cached entry around.\n  const staleHeader = String(response.collectedStale)\n  metadata.headers ??= {}\n  metadata.headers[NEXT_ROUTER_STALE_TIME_HEADER] = staleHeader\n\n  // If force static is specifically set to false, we should not revalidate\n  // the page.\n  if (workStore.forceStatic === false || response.collectedRevalidate === 0) {\n    metadata.cacheControl = { revalidate: 0, expire: undefined }\n  } else {\n    // Copy the cache control value onto the render result metadata.\n    metadata.cacheControl = {\n      revalidate:\n        response.collectedRevalidate >= INFINITE_CACHE\n          ? false\n          : response.collectedRevalidate,\n      expire:\n        response.collectedExpire >= INFINITE_CACHE\n          ? undefined\n          : response.collectedExpire,\n    }\n  }\n\n  // provide bailout info for debugging\n  if (metadata.cacheControl.revalidate === 0) {\n    metadata.staticBailoutInfo = {\n      description: workStore.dynamicUsageDescription,\n      stack: workStore.dynamicUsageStack,\n    }\n  }\n}\n\ntype RSCPayloadDevProperties = {\n  /** Only available during cacheComponents development builds. Used for logging errors. */\n  _validation?: Promise<ReactNode>\n  _bypassCachesInDev?: ReactNode\n}\n\ntype RSCInitialPayloadPartialDev = {\n  c?: InitialRSCPayload['c']\n}\n\nasync function renderToStream(\n  requestStore: RequestStore,\n  req: BaseNextRequest,\n  res: BaseNextResponse,\n  ctx: AppRenderContext,\n  tree: LoaderTree,\n  formState: any,\n  postponedState: PostponedState | null,\n  metadata: AppPageRenderResultMetadata,\n  createRequestStore: (() => RequestStore) | undefined,\n  devFallbackParams: OpaqueFallbackRouteParams | null\n): Promise<ReadableStream<Uint8Array>> {\n  /* eslint-disable @next/internal/no-ambiguous-jsx -- React Client */\n  const {\n    assetPrefix,\n    htmlRequestId,\n    nonce,\n    pagePath,\n    renderOpts,\n    requestId,\n    workStore,\n  } = ctx\n\n  const {\n    basePath,\n    buildManifest,\n    ComponentMod: {\n      createElement,\n      renderToReadableStream: serverRenderToReadableStream,\n    },\n    crossOrigin,\n    dev = false,\n    experimental,\n    isBuildTimePrerendering = false,\n    onInstrumentationRequestError,\n    page,\n    reactMaxHeadersLength,\n    setReactDebugChannel,\n    shouldWaitOnAllReady,\n    subresourceIntegrityManifest,\n    supportsDynamicResponse,\n    cacheComponents,\n  } = renderOpts\n\n  const { ServerInsertedHTMLProvider, renderServerInsertedHTML } =\n    createServerInsertedHTML()\n  const getServerInsertedMetadata = createServerInsertedMetadata(nonce)\n\n  const tracingMetadata = getTracedMetadata(\n    getTracer().getTracePropagationData(),\n    experimental.clientTraceMetadata\n  )\n\n  const polyfills: JSX.IntrinsicElements['script'][] =\n    buildManifest.polyfillFiles\n      .filter(\n        (polyfill) =>\n          polyfill.endsWith('.js') && !polyfill.endsWith('.module.js')\n      )\n      .map((polyfill) => ({\n        src: `${assetPrefix}/_next/${polyfill}${getAssetQueryString(\n          ctx,\n          false\n        )}`,\n        integrity: subresourceIntegrityManifest?.[polyfill],\n        crossOrigin,\n        noModule: true,\n        nonce,\n      }))\n\n  const [preinitScripts, bootstrapScript] = getRequiredScripts(\n    buildManifest,\n    // Why is assetPrefix optional on renderOpts?\n    // @TODO make it default empty string on renderOpts and get rid of it from ctx\n    assetPrefix,\n    crossOrigin,\n    subresourceIntegrityManifest,\n    getAssetQueryString(ctx, true),\n    nonce,\n    page\n  )\n\n  // In development mode, set the request ID as a global variable, before the\n  // bootstrap script is executed, which depends on it during hydration.\n  const bootstrapScriptContent =\n    process.env.NODE_ENV !== 'production'\n      ? `self.__next_r=${JSON.stringify(requestId)}`\n      : undefined\n\n  // Create the \"render route (app)\" span manually so we can keep it open during streaming.\n  // This is necessary because errors inside Suspense boundaries are reported asynchronously\n  // during stream consumption, after a typical wrapped function would have ended the span.\n  // Note: We pass the full span name as the first argument since startSpan uses it directly.\n  const renderSpan = getTracer().startSpan(\n    `render route (app) ${pagePath}` as any,\n    {\n      attributes: {\n        'next.span_name': `render route (app) ${pagePath}`,\n        'next.span_type': AppRenderSpan.getBodyResult,\n        'next.route': pagePath,\n      },\n    }\n  )\n\n  // Helper to end the span with error status (used when throwing from catch blocks)\n  const endSpanWithError = (err: unknown) => {\n    if (!renderSpan.isRecording()) return\n    if (err instanceof Error) {\n      renderSpan.recordException(err)\n      renderSpan.setAttribute('error.type', err.name)\n    }\n    renderSpan.setStatus({\n      code: SpanStatusCode.ERROR,\n      message: err instanceof Error ? err.message : undefined,\n    })\n    renderSpan.end()\n  }\n\n  // Run the rest of the function within the span's context so child spans\n  // (like \"build component tree\", \"generateMetadata\") are properly parented.\n  return getTracer().withSpan(renderSpan, async () => {\n    const { reactServerErrorsByDigest } = workStore\n    function onHTMLRenderRSCError(err: DigestedError, silenceLog: boolean) {\n      return onInstrumentationRequestError?.(\n        err,\n        req,\n        createErrorContext(ctx, 'react-server-components'),\n        silenceLog\n      )\n    }\n    const serverComponentsErrorHandler = createReactServerErrorHandler(\n      dev,\n      isBuildTimePrerendering,\n      reactServerErrorsByDigest,\n      onHTMLRenderRSCError,\n      renderSpan\n    )\n\n    function onHTMLRenderSSRError(err: DigestedError) {\n      // We don't need to silence logs here. onHTMLRenderSSRError won't be called\n      // at all if the error was logged before in the RSC error handler.\n      const silenceLog = false\n      return onInstrumentationRequestError?.(\n        err,\n        req,\n        createErrorContext(ctx, 'server-rendering'),\n        silenceLog\n      )\n    }\n\n    const allCapturedErrors: Array<unknown> = []\n    const htmlRendererErrorHandler = createHTMLErrorHandler(\n      dev,\n      isBuildTimePrerendering,\n      reactServerErrorsByDigest,\n      allCapturedErrors,\n      onHTMLRenderSSRError,\n      renderSpan\n    )\n\n    let reactServerResult: null | ReactServerResult = null\n    let reactDebugStream: ReadableStream<Uint8Array> | undefined\n\n    const setHeader = res.setHeader.bind(res)\n    const appendHeader = res.appendHeader.bind(res)\n    const { clientModules } = getClientReferenceManifest()\n\n    try {\n      if (\n        // We only want this behavior when we have React's dev builds available\n        process.env.NODE_ENV === 'development' &&\n        // We only want this behavior when running `next dev`\n        dev &&\n        // Edge routes never prerender so we don't have a Prerender environment for anything in edge runtime\n        process.env.NEXT_RUNTIME !== 'edge' &&\n        // We only have a Prerender environment for projects opted into cacheComponents\n        cacheComponents\n      ) {\n        let debugChannel: DebugChannelPair | undefined\n\n        const getPayload = async (\n          // eslint-disable-next-line @typescript-eslint/no-shadow\n          requestStore: RequestStore\n        ) => {\n          const payload: InitialRSCPayload & RSCPayloadDevProperties =\n            await workUnitAsyncStorage.run(\n              requestStore,\n              getRSCPayload,\n              tree,\n              ctx,\n              res.statusCode === 404\n            )\n\n          if (isBypassingCachesInDev(renderOpts, requestStore)) {\n            // Mark the RSC payload to indicate that caches were bypassed in dev.\n            // This lets the client know not to cache anything based on this render.\n            if (renderOpts.setCacheStatus) {\n              // we know this is available  when cacheComponents is enabled, but typeguard to be safe\n              renderOpts.setCacheStatus('bypass', htmlRequestId)\n            }\n            payload._bypassCachesInDev = createElement(\n              WarnForBypassCachesInDev,\n              {\n                route: workStore.route,\n              }\n            )\n          }\n\n          return payload\n        }\n\n        if (\n          // We only do this flow if we can safely recreate the store from scratch\n          // (which is not the case for renders after an action)\n          createRequestStore &&\n          // We only do this flow if we're not bypassing caches in dev using\n          // \"disable cache\" in devtools or a hard refresh (cache-control: \"no-store\")\n          !isBypassingCachesInDev(renderOpts, requestStore)\n        ) {\n          const {\n            stream: serverStream,\n            accumulatedChunksPromise,\n            staticInterruptReason,\n            runtimeInterruptReason,\n            staticStageEndTime,\n            runtimeStageEndTime,\n            debugChannel: returnedDebugChannel,\n            requestStore: finalRequestStore,\n          } = await renderWithRestartOnCacheMissInDev(\n            ctx,\n            requestStore,\n            createRequestStore,\n            getPayload,\n            serverComponentsErrorHandler\n          )\n\n          let validationDebugChannelClient: Readable | undefined = undefined\n          if (returnedDebugChannel) {\n            const [t1, t2] = returnedDebugChannel.clientSide.readable.tee()\n            returnedDebugChannel.clientSide.readable = t1\n            validationDebugChannelClient = nodeStreamFromReadableStream(t2)\n          }\n\n          consoleAsyncStorage.run(\n            { dim: true },\n            spawnStaticShellValidationInDev,\n            accumulatedChunksPromise,\n            staticInterruptReason,\n            runtimeInterruptReason,\n            staticStageEndTime,\n            runtimeStageEndTime,\n            ctx,\n            finalRequestStore,\n            devFallbackParams,\n            validationDebugChannelClient\n          )\n\n          reactServerResult = new ReactServerResult(serverStream)\n          requestStore = finalRequestStore\n          debugChannel = returnedDebugChannel\n        } else {\n          // We're either bypassing caches or we can't restart the render.\n          // Do a dynamic render, but with (basic) environment labels.\n\n          debugChannel = setReactDebugChannel && createDebugChannel()\n\n          const serverStream =\n            await stagedRenderToReadableStreamWithoutCachesInDev(\n              ctx,\n              requestStore,\n              getPayload,\n              {\n                onError: serverComponentsErrorHandler,\n                filterStackFrame,\n                debugChannel: debugChannel?.serverSide,\n              }\n            )\n          reactServerResult = new ReactServerResult(serverStream)\n        }\n\n        if (debugChannel && setReactDebugChannel) {\n          const [readableSsr, readableBrowser] =\n            debugChannel.clientSide.readable.tee()\n\n          reactDebugStream = readableSsr\n\n          setReactDebugChannel(\n            { readable: readableBrowser },\n            htmlRequestId,\n            requestId\n          )\n        }\n      } else {\n        // This is a dynamic render. We don't do dynamic tracking because we're not prerendering\n        const RSCPayload: RSCPayload & RSCPayloadDevProperties =\n          await workUnitAsyncStorage.run(\n            requestStore,\n            getRSCPayload,\n            tree,\n            ctx,\n            res.statusCode === 404\n          )\n\n        const debugChannel = setReactDebugChannel && createDebugChannel()\n\n        if (debugChannel) {\n          const [readableSsr, readableBrowser] =\n            debugChannel.clientSide.readable.tee()\n\n          reactDebugStream = readableSsr\n\n          setReactDebugChannel(\n            { readable: readableBrowser },\n            htmlRequestId,\n            requestId\n          )\n        }\n\n        reactServerResult = new ReactServerResult(\n          workUnitAsyncStorage.run(\n            requestStore,\n            serverRenderToReadableStream,\n            RSCPayload,\n            clientModules,\n            {\n              filterStackFrame,\n              onError: serverComponentsErrorHandler,\n              debugChannel: debugChannel?.serverSide,\n            }\n          )\n        )\n      }\n\n      // React doesn't start rendering synchronously but we want the RSC render to have a chance to start\n      // before we begin SSR rendering because we want to capture any available preload headers so we tick\n      // one task before continuing\n      await waitAtLeastOneReactRenderTask()\n\n      // If provided, the postpone state should be parsed as JSON so it can be\n      // provided to React.\n      if (typeof renderOpts.postponed === 'string') {\n        if (postponedState?.type === DynamicState.DATA) {\n          // We have a complete HTML Document in the prerender but we need to\n          // still include the new server component render because it was not included\n          // in the static prelude.\n          const inlinedReactServerDataStream = createInlinedDataReadableStream(\n            reactServerResult.tee(),\n            nonce,\n            formState\n          )\n\n          // End the span since there's no async rendering in this path\n          if (renderSpan.isRecording()) renderSpan.end()\n          return chainStreams(\n            inlinedReactServerDataStream,\n            createDocumentClosingStream()\n          )\n        } else if (postponedState) {\n          // We assume we have dynamic HTML requiring a resume render to complete\n          const { postponed, preludeState } =\n            getPostponedFromState(postponedState)\n          const resume = (\n            require('react-dom/server') as typeof import('react-dom/server')\n          ).resume\n\n          const htmlStream = await workUnitAsyncStorage.run(\n            requestStore,\n            resume,\n            <App\n              reactServerStream={reactServerResult.tee()}\n              reactDebugStream={reactDebugStream}\n              debugEndTime={undefined}\n              preinitScripts={preinitScripts}\n              ServerInsertedHTMLProvider={ServerInsertedHTMLProvider}\n              nonce={nonce}\n              images={ctx.renderOpts.images}\n            />,\n            postponed,\n            { onError: htmlRendererErrorHandler, nonce }\n          )\n\n          // End the render span only after React completed rendering (including anything inside Suspense boundaries)\n          htmlStream.allReady.finally(() => {\n            if (renderSpan.isRecording()) renderSpan.end()\n          })\n\n          const getServerInsertedHTML = makeGetServerInsertedHTML({\n            polyfills,\n            renderServerInsertedHTML,\n            serverCapturedErrors: allCapturedErrors,\n            basePath,\n            tracingMetadata: tracingMetadata,\n          })\n          return await continueDynamicHTMLResume(htmlStream, {\n            // If the prelude is empty (i.e. is no static shell), we should wait for initial HTML to be rendered\n            // to avoid injecting RSC data too early.\n            // If we have a non-empty-prelude (i.e. a static HTML shell), then it's already been sent separately,\n            // so we shouldn't wait for any HTML to be emitted from the resume before sending RSC data.\n            delayDataUntilFirstHtmlChunk:\n              preludeState === DynamicHTMLPreludeState.Empty,\n            inlinedDataStream: createInlinedDataReadableStream(\n              reactServerResult.consume(),\n              nonce,\n              formState\n            ),\n            getServerInsertedHTML,\n            getServerInsertedMetadata,\n            deploymentId: ctx.sharedContext.deploymentId,\n          })\n        }\n      }\n\n      // This is a regular dynamic render\n      const renderToReadableStream = (\n        require('react-dom/server') as typeof import('react-dom/server')\n      ).renderToReadableStream\n\n      const htmlStream = await workUnitAsyncStorage.run(\n        requestStore,\n        renderToReadableStream,\n        <App\n          reactServerStream={reactServerResult.tee()}\n          reactDebugStream={reactDebugStream}\n          debugEndTime={undefined}\n          preinitScripts={preinitScripts}\n          ServerInsertedHTMLProvider={ServerInsertedHTMLProvider}\n          nonce={nonce}\n          images={ctx.renderOpts.images}\n        />,\n        {\n          onError: htmlRendererErrorHandler,\n          nonce,\n          onHeaders: (headers: Headers) => {\n            headers.forEach((value, key) => {\n              appendHeader(key, value)\n            })\n          },\n          maxHeadersLength: reactMaxHeadersLength,\n          bootstrapScriptContent,\n          bootstrapScripts: [bootstrapScript],\n          formState,\n        }\n      )\n\n      // End the render span only after React completed rendering (including anything inside Suspense boundaries)\n      htmlStream.allReady.finally(() => {\n        if (renderSpan.isRecording()) renderSpan.end()\n      })\n\n      const getServerInsertedHTML = makeGetServerInsertedHTML({\n        polyfills,\n        renderServerInsertedHTML,\n        serverCapturedErrors: allCapturedErrors,\n        basePath,\n        tracingMetadata: tracingMetadata,\n      })\n      /**\n       * Rules of Static & Dynamic HTML:\n       *\n       *    1.) We must generate static HTML unless the caller explicitly opts\n       *        in to dynamic HTML support.\n       *\n       *    2.) If dynamic HTML support is requested, we must honor that request\n       *        or throw an error. It is the sole responsibility of the caller to\n       *        ensure they aren't e.g. requesting dynamic HTML for a static page.\n       *\n       *   3.) If `shouldWaitOnAllReady` is true, which indicates we need to\n       *       resolve all suspenses and generate a full HTML. e.g. when it's a\n       *       html limited bot requests, we produce the full HTML content.\n       *\n       * These rules help ensure that other existing features like request caching,\n       * coalescing, and ISR continue working as intended.\n       */\n      const generateStaticHTML =\n        supportsDynamicResponse !== true || !!shouldWaitOnAllReady\n\n      return await continueFizzStream(htmlStream, {\n        inlinedDataStream: createInlinedDataReadableStream(\n          reactServerResult.consume(),\n          nonce,\n          formState\n        ),\n        isStaticGeneration: generateStaticHTML,\n        isBuildTimePrerendering: ctx.workStore.isBuildTimePrerendering === true,\n        buildId: ctx.workStore.buildId,\n        deploymentId: ctx.sharedContext.deploymentId,\n        getServerInsertedHTML,\n        getServerInsertedMetadata,\n        validateRootLayout: dev,\n      })\n    } catch (err) {\n      if (\n        isStaticGenBailoutError(err) ||\n        (typeof err === 'object' &&\n          err !== null &&\n          'message' in err &&\n          typeof err.message === 'string' &&\n          err.message.includes(\n            'https://nextjs.org/docs/advanced-features/static-html-export'\n          ))\n      ) {\n        // Ensure that \"next dev\" prints the red error overlay\n        endSpanWithError(err)\n        throw err\n      }\n\n      // If a bailout made it to this point, it means it wasn't wrapped inside\n      // a suspense boundary.\n      const shouldBailoutToCSR = isBailoutToCSRError(err)\n      if (shouldBailoutToCSR) {\n        const stack = getStackWithoutErrorMessage(err)\n        error(\n          `${err.reason} should be wrapped in a suspense boundary at page \"${pagePath}\". Read more: https://nextjs.org/docs/messages/missing-suspense-with-csr-bailout\\n${stack}`\n        )\n\n        endSpanWithError(err)\n        throw err\n      }\n\n      let errorType: MetadataErrorType | 'redirect' | undefined\n\n      if (isHTTPAccessFallbackError(err)) {\n        res.statusCode = getAccessFallbackHTTPStatus(err)\n        metadata.statusCode = res.statusCode\n        errorType = getAccessFallbackErrorTypeByStatus(res.statusCode)\n      } else if (isRedirectError(err)) {\n        errorType = 'redirect'\n        res.statusCode = getRedirectStatusCodeFromError(err)\n        metadata.statusCode = res.statusCode\n\n        const redirectUrl = addPathPrefix(\n          getURLFromRedirectError(err),\n          basePath\n        )\n\n        // If there were mutable cookies set, we need to set them on the\n        // response.\n        const headers = new Headers()\n        if (appendMutableCookies(headers, requestStore.mutableCookies)) {\n          setHeader('set-cookie', Array.from(headers.values()))\n        }\n\n        setHeader('location', redirectUrl)\n      } else if (!shouldBailoutToCSR) {\n        res.statusCode = 500\n        metadata.statusCode = res.statusCode\n      }\n\n      const [errorPreinitScripts, errorBootstrapScript] = getRequiredScripts(\n        buildManifest,\n        assetPrefix,\n        crossOrigin,\n        subresourceIntegrityManifest,\n        getAssetQueryString(ctx, false),\n        nonce,\n        '/_not-found/page'\n      )\n\n      let errorRSCPayload: InitialRSCPayload\n      let errorServerStream: ReturnType<typeof serverRenderToReadableStream>\n\n      try {\n        errorRSCPayload = await workUnitAsyncStorage.run(\n          requestStore,\n          getErrorRSCPayload,\n          tree,\n          ctx,\n          reactServerErrorsByDigest.has((err as any).digest) ? null : err,\n          errorType\n        )\n\n        errorServerStream = workUnitAsyncStorage.run(\n          requestStore,\n          serverRenderToReadableStream,\n          errorRSCPayload,\n          clientModules,\n          {\n            filterStackFrame,\n            onError: serverComponentsErrorHandler,\n          }\n        )\n\n        if (reactServerResult === null) {\n          // We errored when we did not have an RSC stream to read from. This is not just a render\n          // error, we need to throw early\n          endSpanWithError(err)\n          throw err\n        }\n      } catch (setupErr) {\n        endSpanWithError(setupErr)\n        throw setupErr\n      }\n\n      try {\n        const fizzStream = await workUnitAsyncStorage.run(\n          requestStore,\n          renderToInitialFizzStream,\n          {\n            ReactDOMServer:\n              require('react-dom/server') as typeof import('react-dom/server'),\n            element: (\n              <ErrorApp\n                reactServerStream={errorServerStream}\n                ServerInsertedHTMLProvider={ServerInsertedHTMLProvider}\n                preinitScripts={errorPreinitScripts}\n                nonce={nonce}\n                images={ctx.renderOpts.images}\n              />\n            ),\n            streamOptions: {\n              nonce,\n              bootstrapScriptContent,\n              // Include hydration scripts in the HTML\n              bootstrapScripts: [errorBootstrapScript],\n              formState,\n            },\n          }\n        )\n\n        // End the render span only after React completed rendering (including anything inside Suspense boundaries)\n        fizzStream.allReady.finally(() => {\n          if (renderSpan.isRecording()) renderSpan.end()\n        })\n\n        /**\n         * Rules of Static & Dynamic HTML:\n         *\n         *    1.) We must generate static HTML unless the caller explicitly opts\n         *        in to dynamic HTML support.\n         *\n         *    2.) If dynamic HTML support is requested, we must honor that request\n         *        or throw an error. It is the sole responsibility of the caller to\n         *        ensure they aren't e.g. requesting dynamic HTML for a static page.\n         *    3.) If `shouldWaitOnAllReady` is true, which indicates we need to\n         *        resolve all suspenses and generate a full HTML. e.g. when it's a\n         *        html limited bot requests, we produce the full HTML content.\n         *\n         * These rules help ensure that other existing features like request caching,\n         * coalescing, and ISR continue working as intended.\n         */\n        const generateStaticHTML =\n          supportsDynamicResponse !== true || !!shouldWaitOnAllReady\n        return await continueFizzStream(fizzStream, {\n          inlinedDataStream: createInlinedDataReadableStream(\n            // This is intentionally using the readable datastream from the\n            // main render rather than the flight data from the error page\n            // render\n            reactServerResult.consume(),\n            nonce,\n            formState\n          ),\n          isStaticGeneration: generateStaticHTML,\n          isBuildTimePrerendering:\n            ctx.workStore.isBuildTimePrerendering === true,\n          buildId: ctx.workStore.buildId,\n          deploymentId: ctx.sharedContext.deploymentId,\n          getServerInsertedHTML: makeGetServerInsertedHTML({\n            polyfills,\n            renderServerInsertedHTML,\n            serverCapturedErrors: [],\n            basePath,\n            tracingMetadata: tracingMetadata,\n          }),\n          getServerInsertedMetadata,\n          validateRootLayout: dev,\n        })\n      } catch (finalErr: any) {\n        if (\n          process.env.NODE_ENV === 'development' &&\n          isHTTPAccessFallbackError(finalErr)\n        ) {\n          const { bailOnRootNotFound } =\n            require('../../client/components/dev-root-http-access-fallback-boundary') as typeof import('../../client/components/dev-root-http-access-fallback-boundary')\n          bailOnRootNotFound()\n        }\n        endSpanWithError(finalErr)\n        throw finalErr\n      }\n    }\n  })\n  /* eslint-enable @next/internal/no-ambiguous-jsx */\n}\n\nasync function renderWithRestartOnCacheMissInDev(\n  ctx: AppRenderContext,\n  initialRequestStore: RequestStore,\n  createRequestStore: () => RequestStore,\n  getPayload: (requestStore: RequestStore) => Promise<RSCPayload>,\n  onError: (error: unknown) => void\n) {\n  const {\n    htmlRequestId,\n    renderOpts,\n    componentMod: {\n      routeModule: {\n        userland: { loaderTree },\n      },\n    },\n  } = ctx\n\n  const { ComponentMod, setCacheStatus, setReactDebugChannel } = renderOpts\n\n  const hasRuntimePrefetch =\n    await anySegmentHasRuntimePrefetchEnabled(loaderTree)\n\n  // If the render is restarted, we'll recreate a fresh request store\n  let requestStore: RequestStore = initialRequestStore\n\n  const environmentName = () => {\n    const currentStage = requestStore.stagedRendering!.currentStage\n    switch (currentStage) {\n      case RenderStage.Before:\n      case RenderStage.Static:\n        return 'Prerender'\n      case RenderStage.Runtime:\n        return hasRuntimePrefetch ? 'Prefetch' : 'Prefetchable'\n      case RenderStage.Dynamic:\n      case RenderStage.Abandoned:\n        return 'Server'\n      default:\n        currentStage satisfies never\n        throw new InvariantError(`Invalid render stage: ${currentStage}`)\n    }\n  }\n\n  //===============================================\n  // Initial render\n  //===============================================\n\n  // Try to render the page and see if there's any cache misses.\n  // If there are, wait for caches to finish and restart the render.\n\n  // This render might end up being used as a prospective render (if there's cache misses),\n  // so we need to set it up for filling caches.\n  const cacheSignal = new CacheSignal()\n\n  // If we encounter async modules that delay rendering, we'll also need to restart.\n  // TODO(restart-on-cache-miss): technically, we only need to wait for pending *server* modules here,\n  // but `trackPendingModules` doesn't distinguish between client and server.\n  trackPendingModules(cacheSignal)\n\n  const prerenderResumeDataCache = createPrerenderResumeDataCache()\n\n  const initialReactController = new AbortController()\n  const initialDataController = new AbortController() // Controls hanging promises we create\n  const initialStageController = new StagedRenderingController(\n    initialDataController.signal,\n    hasRuntimePrefetch\n  )\n\n  requestStore.prerenderResumeDataCache = prerenderResumeDataCache\n  // `getRenderResumeDataCache` will fall back to using `prerenderResumeDataCache` as `renderResumeDataCache`,\n  // so not having a resume data cache won't break any expectations in case we don't need to restart.\n  requestStore.renderResumeDataCache = null\n  requestStore.stagedRendering = initialStageController\n  requestStore.asyncApiPromises = createAsyncApiPromisesInDev(\n    initialStageController,\n    requestStore.cookies,\n    requestStore.mutableCookies,\n    requestStore.headers\n  )\n  requestStore.cacheSignal = cacheSignal\n\n  let debugChannel = setReactDebugChannel && createDebugChannel()\n  const { clientModules } = getClientReferenceManifest()\n\n  // Note: The stage controller starts out in the `Before` stage,\n  // where sync IO does not cause aborts, so it's okay if it happens before render.\n  const initialRscPayload = await getPayload(requestStore)\n\n  const maybeInitialStreamResult = await workUnitAsyncStorage.run(\n    requestStore,\n    () =>\n      pipelineInSequentialTasks(\n        () => {\n          // Static stage\n          initialStageController.advanceStage(RenderStage.Static)\n\n          const stream = ComponentMod.renderToReadableStream(\n            initialRscPayload,\n            clientModules,\n            {\n              onError,\n              environmentName,\n              filterStackFrame,\n              debugChannel: debugChannel?.serverSide,\n              signal: initialReactController.signal,\n            }\n          )\n          // If we abort the render, we want to reject the stage-dependent promises as well.\n          // Note that we want to install this listener after the render is started\n          // so that it runs after react is finished running its abort code.\n          initialReactController.signal.addEventListener('abort', () => {\n            initialDataController.abort(initialReactController.signal.reason)\n          })\n\n          const [continuationStream, accumulatingStream] = stream.tee()\n          const accumulatedChunksPromise = accumulateStreamChunks(\n            accumulatingStream,\n            initialStageController,\n            initialDataController.signal\n          )\n          return { stream: continuationStream, accumulatedChunksPromise }\n        },\n        ({ stream, accumulatedChunksPromise }) => {\n          // Runtime stage\n\n          if (initialStageController.currentStage === RenderStage.Abandoned) {\n            // If we abandoned the render in the static stage, we won't proceed further.\n            return null\n          }\n\n          // If we had a cache miss in the static stage, we'll have to discard this stream\n          // and render again once the caches are warm.\n          // If we already advanced stages we similarly had sync IO that might be from module loading\n          // and need to render again once the caches are warm.\n          if (cacheSignal.hasPendingReads()) {\n            // Regardless of whether we are going to abandon this\n            // render we need the unblock runtime b/c it's essential\n            // filling caches.\n            initialStageController.abandonRender()\n            return null\n          }\n\n          initialStageController.advanceStage(RenderStage.Runtime)\n          return { stream, accumulatedChunksPromise }\n        },\n        (result) => {\n          // Dynamic stage\n          if (\n            result === null ||\n            initialStageController.currentStage === RenderStage.Abandoned\n          ) {\n            // If we abandoned the render in the static or runtime stage, we won't proceed further.\n            return null\n          }\n\n          // If we had cache misses in either of the previous stages,\n          // then we'll only use this render for filling caches.\n          // We won't advance the stage, and thus leave dynamic APIs hanging,\n          // because they won't be cached anyway, so it'd be wasted work.\n          if (cacheSignal.hasPendingReads()) {\n            initialStageController.abandonRender()\n            return null\n          }\n\n          // Regardless of whether we are going to abandon this\n          // render we need the unblock runtime b/c it's essential\n          // filling caches.\n          initialStageController.advanceStage(RenderStage.Dynamic)\n          return result\n        }\n      )\n  )\n\n  if (maybeInitialStreamResult !== null) {\n    // No cache misses. We can use the result as-is.\n    return {\n      stream: maybeInitialStreamResult.stream,\n      accumulatedChunksPromise:\n        maybeInitialStreamResult.accumulatedChunksPromise,\n      staticInterruptReason: initialStageController.getStaticInterruptReason(),\n      runtimeInterruptReason:\n        initialStageController.getRuntimeInterruptReason(),\n      staticStageEndTime: initialStageController.getStaticStageEndTime(),\n      runtimeStageEndTime: initialStageController.getRuntimeStageEndTime(),\n      debugChannel,\n      requestStore,\n    }\n  }\n\n  if (process.env.NODE_ENV === 'development' && setCacheStatus) {\n    setCacheStatus('filling', htmlRequestId)\n  }\n\n  // Cache miss. We will use the initial render to fill caches, and discard its result.\n  // Then, we can render again with warm caches.\n\n  // TODO(restart-on-cache-miss):\n  // This might end up waiting for more caches than strictly necessary,\n  // because we can't abort the render yet, and we'll let runtime/dynamic APIs resolve.\n  // Ideally we'd only wait for caches that are needed in the static stage.\n  // This will be optimized in the future by not allowing runtime/dynamic APIs to resolve.\n\n  await cacheSignal.cacheReady()\n  initialReactController.abort()\n\n  //===============================================\n  // Final render (restarted)\n  //===============================================\n\n  // The initial render acted as a prospective render to warm the caches.\n  requestStore = createRequestStore()\n\n  // We are going to render this pass all the way through because we've already\n  // filled any caches so we won't be aborting this time.\n  const abortSignal = null\n  const finalStageController = new StagedRenderingController(\n    abortSignal,\n    hasRuntimePrefetch\n  )\n\n  // We've filled the caches, so now we can render as usual,\n  // without any cache-filling mechanics.\n  requestStore.prerenderResumeDataCache = null\n  requestStore.renderResumeDataCache = createRenderResumeDataCache(\n    prerenderResumeDataCache\n  )\n  requestStore.stagedRendering = finalStageController\n  requestStore.cacheSignal = null\n  requestStore.asyncApiPromises = createAsyncApiPromisesInDev(\n    finalStageController,\n    requestStore.cookies,\n    requestStore.mutableCookies,\n    requestStore.headers\n  )\n\n  // The initial render already wrote to its debug channel.\n  // We're not using it, so we need to create a new one.\n  debugChannel = setReactDebugChannel && createDebugChannel()\n\n  // Note: The stage controller starts out in the `Before` stage,\n  // where sync IO does not cause aborts, so it's okay if it happens before render.\n  const finalRscPayload = await getPayload(requestStore)\n\n  const finalStreamResult = await workUnitAsyncStorage.run(requestStore, () =>\n    pipelineInSequentialTasks(\n      () => {\n        // Static stage\n        finalStageController.advanceStage(RenderStage.Static)\n\n        const stream = ComponentMod.renderToReadableStream(\n          finalRscPayload,\n          clientModules,\n          {\n            onError,\n            environmentName,\n            filterStackFrame,\n            debugChannel: debugChannel?.serverSide,\n          }\n        )\n\n        const [continuationStream, accumulatingStream] = stream.tee()\n        const accumulatedChunksPromise = accumulateStreamChunks(\n          accumulatingStream,\n          finalStageController,\n          null\n        )\n        return { stream: continuationStream, accumulatedChunksPromise }\n      },\n      (result) => {\n        // Runtime stage\n        finalStageController.advanceStage(RenderStage.Runtime)\n        return result\n      },\n      (result) => {\n        // Dynamic stage\n        finalStageController.advanceStage(RenderStage.Dynamic)\n        return result\n      }\n    )\n  )\n\n  if (process.env.NODE_ENV === 'development' && setCacheStatus) {\n    setCacheStatus('filled', htmlRequestId)\n  }\n\n  return {\n    stream: finalStreamResult.stream,\n    accumulatedChunksPromise: finalStreamResult.accumulatedChunksPromise,\n    staticInterruptReason: finalStageController.getStaticInterruptReason(),\n    runtimeInterruptReason: finalStageController.getRuntimeInterruptReason(),\n    staticStageEndTime: finalStageController.getStaticStageEndTime(),\n    runtimeStageEndTime: finalStageController.getRuntimeStageEndTime(),\n    debugChannel,\n    requestStore,\n  }\n}\n\ninterface AccumulatedStreamChunks {\n  readonly staticChunks: Array<Uint8Array>\n  readonly runtimeChunks: Array<Uint8Array>\n  readonly dynamicChunks: Array<Uint8Array>\n}\n\nasync function accumulateStreamChunks(\n  stream: ReadableStream<Uint8Array>,\n  stageController: StagedRenderingController,\n  signal: AbortSignal | null\n): Promise<AccumulatedStreamChunks> {\n  const staticChunks: Array<Uint8Array> = []\n  const runtimeChunks: Array<Uint8Array> = []\n  const dynamicChunks: Array<Uint8Array> = []\n  const reader = stream.getReader()\n\n  let cancelled = false\n  function cancel() {\n    if (!cancelled) {\n      cancelled = true\n      reader.cancel()\n    }\n  }\n\n  if (signal) {\n    signal.addEventListener('abort', cancel, { once: true })\n  }\n\n  try {\n    while (!cancelled) {\n      const { done, value } = await reader.read()\n      if (done) {\n        cancel()\n        break\n      }\n      switch (stageController.currentStage) {\n        case RenderStage.Before:\n          throw new InvariantError(\n            'Unexpected stream chunk while in Before stage'\n          )\n        case RenderStage.Static:\n          staticChunks.push(value)\n        // fall through\n        case RenderStage.Runtime:\n          runtimeChunks.push(value)\n        // fall through\n        case RenderStage.Dynamic:\n          dynamicChunks.push(value)\n          break\n        case RenderStage.Abandoned:\n          // If the render was abandoned, we won't use the chunks,\n          // so there's no need to accumulate them\n          break\n        default:\n          stageController.currentStage satisfies never\n          break\n      }\n    }\n  } catch {\n    // When we release the lock we may reject the read\n  }\n\n  return { staticChunks, runtimeChunks, dynamicChunks }\n}\n\nfunction createAsyncApiPromisesInDev(\n  stagedRendering: StagedRenderingController,\n  cookies: RequestStore['cookies'],\n  mutableCookies: RequestStore['mutableCookies'],\n  headers: RequestStore['headers']\n): NonNullable<RequestStore['asyncApiPromises']> {\n  return {\n    // Runtime APIs\n    cookies: stagedRendering.delayUntilStage(\n      RenderStage.Runtime,\n      'cookies',\n      cookies\n    ),\n    mutableCookies: stagedRendering.delayUntilStage(\n      RenderStage.Runtime,\n      'cookies',\n      mutableCookies as RequestStore['cookies']\n    ),\n    headers: stagedRendering.delayUntilStage(\n      RenderStage.Runtime,\n      'headers',\n      headers\n    ),\n    // These are not used directly, but we chain other `params`/`searchParams` promises off of them.\n    sharedParamsParent: stagedRendering.delayUntilStage(\n      RenderStage.Runtime,\n      undefined,\n      '<internal params>'\n    ),\n    sharedSearchParamsParent: stagedRendering.delayUntilStage(\n      RenderStage.Runtime,\n      undefined,\n      '<internal searchParams>'\n    ),\n    connection: stagedRendering.delayUntilStage(\n      RenderStage.Dynamic,\n      'connection',\n      undefined\n    ),\n  }\n}\n\ntype DebugChannelPair = {\n  serverSide: DebugChannelServer\n  clientSide: DebugChannelClient\n}\n\ntype DebugChannelServer = {\n  readable?: ReadableStream<Uint8Array>\n  writable: WritableStream<Uint8Array>\n}\ntype DebugChannelClient = {\n  readable: ReadableStream<Uint8Array>\n  writable?: WritableStream<Uint8Array>\n}\n\nfunction createDebugChannel(): DebugChannelPair | undefined {\n  if (process.env.NODE_ENV === 'production') {\n    return undefined\n  }\n\n  let readableController: ReadableStreamDefaultController | undefined\n\n  let clientSideReadable = new ReadableStream<Uint8Array>({\n    start(controller) {\n      readableController = controller\n    },\n  })\n\n  return {\n    serverSide: {\n      writable: new WritableStream<Uint8Array>({\n        write(chunk) {\n          readableController?.enqueue(chunk)\n        },\n        close() {\n          readableController?.close()\n        },\n        abort(err) {\n          readableController?.error(err)\n        },\n      }),\n    },\n    clientSide: { readable: clientSideReadable },\n  }\n}\n\n/**\n * Logs the given messages, and sends the error instances to the browser as an\n * RSC stream, where they can be deserialized and logged (or otherwise presented\n * in the devtools), while leveraging React's capabilities to not only\n * source-map the stack frames (via findSourceMapURL), but also create virtual\n * server modules that allow users to inspect the server source code in the\n * browser.\n */\nasync function logMessagesAndSendErrorsToBrowser(\n  messages: unknown[],\n  ctx: AppRenderContext\n): Promise<void> {\n  const { componentMod: ComponentMod, htmlRequestId, renderOpts } = ctx\n  const { sendErrorsToBrowser } = renderOpts\n\n  const errors: Error[] = []\n  for (const message of messages) {\n    // Log the error to the CLI. Prevent the logs from being dimmed, which we\n    // apply for other logs during the spawned validation.\n    consoleAsyncStorage.exit(() => {\n      console.error(message)\n    })\n\n    // Error instances are also sent to the browser. We're currently using a\n    // non-Error message only in debug build mode as a message that is only\n    // meant for the CLI. FIXME: This is a bit spooky action at a distance. We\n    // should maybe have a more explicit way of determining which messages\n    // should be sent to the browser. Regardless, only real errors with a proper\n    // stack make sense to be \"replayed\" in the browser.\n    if (message instanceof Error) {\n      errors.push(message)\n    }\n  }\n\n  if (errors.length > 0) {\n    if (!sendErrorsToBrowser) {\n      throw new InvariantError(\n        'Expected `sendErrorsToBrowser` to be defined in renderOpts.'\n      )\n    }\n\n    const { clientModules } = getClientReferenceManifest()\n\n    const errorsRscStream = ComponentMod.renderToReadableStream(\n      errors,\n      clientModules,\n      { filterStackFrame }\n    )\n\n    sendErrorsToBrowser(errorsRscStream, htmlRequestId)\n  }\n}\n\n/**\n * This function is a fork of prerenderToStream cacheComponents branch.\n * While it doesn't return a stream we want it to have identical\n * prerender semantics to prerenderToStream and should update it\n * in conjunction with any changes to that function.\n */\nasync function spawnStaticShellValidationInDev(\n  accumulatedChunksPromise: Promise<AccumulatedStreamChunks>,\n  staticInterruptReason: Error | null,\n  runtimeInterruptReason: Error | null,\n  staticStageEndTime: number,\n  runtimeStageEndTime: number,\n  ctx: AppRenderContext,\n  requestStore: RequestStore,\n  fallbackRouteParams: OpaqueFallbackRouteParams | null,\n  debugChannelClient: Readable | undefined\n): Promise<void> {\n  const {\n    componentMod: ComponentMod,\n    getDynamicParamFromSegment,\n    renderOpts,\n    workStore,\n  } = ctx\n\n  const { allowEmptyStaticShell = false } = renderOpts\n\n  const rootParams = getRootParams(\n    ComponentMod.routeModule.userland.loaderTree,\n    getDynamicParamFromSegment\n  )\n\n  const hmrRefreshHash = getHmrRefreshHash(workStore, requestStore)\n\n  // We don't need to continue the prerender process if we already\n  // detected invalid dynamic usage in the initial prerender phase.\n  const { invalidDynamicUsageError } = workStore\n  if (invalidDynamicUsageError) {\n    return logMessagesAndSendErrorsToBrowser([invalidDynamicUsageError], ctx)\n  }\n\n  if (staticInterruptReason) {\n    return logMessagesAndSendErrorsToBrowser([staticInterruptReason], ctx)\n  }\n\n  if (runtimeInterruptReason) {\n    return logMessagesAndSendErrorsToBrowser([runtimeInterruptReason], ctx)\n  }\n\n  const { staticChunks, runtimeChunks, dynamicChunks } =\n    await accumulatedChunksPromise\n\n  // First we warmup SSR with the runtime chunks. This ensures that when we do\n  // the full prerender pass with dynamic tracking module loading won't\n  // interrupt the prerender and can properly observe the entire content\n  await warmupModuleCacheForRuntimeValidationInDev(\n    runtimeChunks,\n    dynamicChunks,\n    rootParams,\n    fallbackRouteParams,\n    allowEmptyStaticShell,\n    ctx\n  )\n\n  let debugChunks: Uint8Array[] | null = null\n  if (debugChannelClient) {\n    debugChunks = []\n    debugChannelClient.on('data', (c) => debugChunks!.push(c))\n  }\n\n  const runtimeResult = await validateStagedShell(\n    runtimeChunks,\n    dynamicChunks,\n    debugChunks,\n    runtimeStageEndTime,\n    rootParams,\n    fallbackRouteParams,\n    allowEmptyStaticShell,\n    ctx,\n    hmrRefreshHash,\n    trackDynamicHoleInRuntimeShell\n  )\n\n  if (runtimeResult.length > 0) {\n    // We have something to report from the runtime validation\n    // We can skip the static validation\n    return logMessagesAndSendErrorsToBrowser(runtimeResult, ctx)\n  }\n\n  const staticResult = await validateStagedShell(\n    staticChunks,\n    dynamicChunks,\n    debugChunks,\n    staticStageEndTime,\n    rootParams,\n    fallbackRouteParams,\n    allowEmptyStaticShell,\n    ctx,\n    hmrRefreshHash,\n    trackDynamicHoleInStaticShell\n  )\n\n  return logMessagesAndSendErrorsToBrowser(staticResult, ctx)\n}\n\nasync function warmupModuleCacheForRuntimeValidationInDev(\n  runtimeServerChunks: Array<Uint8Array>,\n  allServerChunks: Array<Uint8Array>,\n  rootParams: Params,\n  fallbackRouteParams: OpaqueFallbackRouteParams | null,\n  allowEmptyStaticShell: boolean,\n  ctx: AppRenderContext\n) {\n  const { implicitTags, nonce, workStore } = ctx\n\n  // Warmup SSR\n  const initialClientPrerenderController = new AbortController()\n  const initialClientReactController = new AbortController()\n  const initialClientRenderController = new AbortController()\n\n  const preinitScripts = () => {}\n  const { ServerInsertedHTMLProvider } = createServerInsertedHTML()\n\n  const initialClientPrerenderStore: PrerenderStore = {\n    type: 'prerender-client',\n    phase: 'render',\n    rootParams,\n    fallbackRouteParams,\n    implicitTags,\n    renderSignal: initialClientRenderController.signal,\n    controller: initialClientPrerenderController,\n    // For HTML Generation the only cache tracked activity\n    // is module loading, which has it's own cache signal\n    cacheSignal: null,\n    dynamicTracking: null,\n    allowEmptyStaticShell,\n    revalidate: INFINITE_CACHE,\n    expire: INFINITE_CACHE,\n    stale: INFINITE_CACHE,\n    tags: [...implicitTags.tags],\n    // TODO should this be removed from client stores?\n    prerenderResumeDataCache: null,\n    renderResumeDataCache: null,\n    hmrRefreshHash: undefined,\n    // Client prerenders don't track server param access\n    varyParamsAccumulator: null,\n  }\n\n  const runtimeServerStream = createNodeStreamFromChunks(\n    runtimeServerChunks,\n    allServerChunks,\n    initialClientReactController.signal\n  )\n\n  const prerender = (\n    require('react-dom/static') as typeof import('react-dom/static')\n  ).prerender\n  const pendingInitialClientResult = workUnitAsyncStorage.run(\n    initialClientPrerenderStore,\n    prerender,\n    // eslint-disable-next-line @next/internal/no-ambiguous-jsx -- React Client\n    <App\n      reactServerStream={runtimeServerStream}\n      reactDebugStream={undefined}\n      debugEndTime={undefined}\n      preinitScripts={preinitScripts}\n      ServerInsertedHTMLProvider={ServerInsertedHTMLProvider}\n      nonce={nonce}\n      images={ctx.renderOpts.images}\n    />,\n    {\n      signal: initialClientReactController.signal,\n      onError: (err) => {\n        const digest = getDigestForWellKnownError(err)\n\n        if (digest) {\n          return digest\n        }\n\n        if (isReactLargeShellError(err)) {\n          // TODO: Aggregate\n          console.error(err)\n          return undefined\n        }\n\n        if (initialClientReactController.signal.aborted) {\n          // These are expected errors that might error the prerender. we ignore them.\n        } else if (\n          process.env.NEXT_DEBUG_BUILD ||\n          process.env.__NEXT_VERBOSE_LOGGING\n        ) {\n          // We don't normally log these errors because we are going to retry anyway but\n          // it can be useful for debugging Next.js itself to get visibility here when needed\n          printDebugThrownValueForProspectiveRender(\n            err,\n            workStore.route,\n            Phase.ProspectiveRender\n          )\n        }\n      },\n      // We don't need bootstrap scripts in this prerender\n      // bootstrapScripts: [bootstrapScript],\n    }\n  )\n\n  // The listener to abort our own render controller must be added after React\n  // has added its listener, to ensure that pending I/O is not\n  // aborted/rejected too early.\n  initialClientReactController.signal.addEventListener(\n    'abort',\n    () => {\n      initialClientRenderController.abort()\n    },\n    { once: true }\n  )\n\n  pendingInitialClientResult.catch((err) => {\n    if (\n      initialClientReactController.signal.aborted ||\n      isPrerenderInterruptedError(err)\n    ) {\n      // These are expected errors that might error the prerender. we ignore them.\n    } else if (\n      process.env.NEXT_DEBUG_BUILD ||\n      process.env.__NEXT_VERBOSE_LOGGING\n    ) {\n      // We don't normally log these errors because we are going to retry anyway but\n      // it can be useful for debugging Next.js itself to get visibility here when needed\n      printDebugThrownValueForProspectiveRender(\n        err,\n        workStore.route,\n        Phase.ProspectiveRender\n      )\n    }\n  })\n\n  // This is mostly needed for dynamic `import()`s in client components.\n  // Promises passed to client were already awaited above (assuming that they came from cached functions)\n  const cacheSignal = new CacheSignal()\n  trackPendingModules(cacheSignal)\n  await cacheSignal.cacheReady()\n  initialClientReactController.abort()\n}\n\nasync function validateStagedShell(\n  stageChunks: Array<Uint8Array>,\n  allServerChunks: Array<Uint8Array>,\n  debugChunks: null | Array<Uint8Array>,\n  debugEndTime: number | undefined,\n  rootParams: Params,\n  fallbackRouteParams: OpaqueFallbackRouteParams | null,\n  allowEmptyStaticShell: boolean,\n  ctx: AppRenderContext,\n  hmrRefreshHash: string | undefined,\n  trackDynamicHole:\n    | typeof trackDynamicHoleInStaticShell\n    | typeof trackDynamicHoleInRuntimeShell\n): Promise<Array<unknown>> {\n  const { implicitTags, nonce, workStore } = ctx\n\n  const clientDynamicTracking = createDynamicTrackingState(\n    false //isDebugDynamicAccesses\n  )\n  const clientReactController = new AbortController()\n  const clientRenderController = new AbortController()\n\n  const preinitScripts = () => {}\n  const { ServerInsertedHTMLProvider } = createServerInsertedHTML()\n\n  const finalClientPrerenderStore: PrerenderStore = {\n    type: 'prerender-client',\n    phase: 'render',\n    rootParams,\n    fallbackRouteParams,\n    implicitTags,\n    renderSignal: clientRenderController.signal,\n    controller: clientReactController,\n    // No APIs require a cacheSignal through the workUnitStore during the HTML prerender\n    cacheSignal: null,\n    dynamicTracking: clientDynamicTracking,\n    allowEmptyStaticShell,\n    revalidate: INFINITE_CACHE,\n    expire: INFINITE_CACHE,\n    stale: INFINITE_CACHE,\n    tags: [...implicitTags.tags],\n    // TODO should this be removed from client stores?\n    prerenderResumeDataCache: null,\n    renderResumeDataCache: null,\n    hmrRefreshHash,\n    // Client prerenders don't track server param access\n    varyParamsAccumulator: null,\n  }\n\n  let runtimeDynamicValidation = createDynamicValidationState()\n\n  const serverStream = createNodeStreamFromChunks(\n    stageChunks,\n    allServerChunks,\n    clientReactController.signal\n  )\n\n  const debugChannelClient = debugChunks\n    ? createNodeStreamFromChunks(\n        debugChunks,\n        debugChunks,\n        clientReactController.signal\n      )\n    : undefined\n\n  const prerender = (\n    require('react-dom/static') as typeof import('react-dom/static')\n  ).prerender\n  try {\n    let { prelude: unprocessedPrelude } =\n      await prerenderAndAbortInSequentialTasks(\n        () => {\n          const pendingFinalClientResult = workUnitAsyncStorage.run(\n            finalClientPrerenderStore,\n            prerender,\n            // eslint-disable-next-line @next/internal/no-ambiguous-jsx -- React Client\n            <App\n              reactServerStream={serverStream}\n              reactDebugStream={debugChannelClient}\n              debugEndTime={debugEndTime}\n              preinitScripts={preinitScripts}\n              ServerInsertedHTMLProvider={ServerInsertedHTMLProvider}\n              nonce={nonce}\n              images={ctx.renderOpts.images}\n            />,\n            {\n              signal: clientReactController.signal,\n              onError: (err: unknown, errorInfo: ErrorInfo) => {\n                if (\n                  isPrerenderInterruptedError(err) ||\n                  clientReactController.signal.aborted\n                ) {\n                  const componentStack = errorInfo.componentStack\n                  if (typeof componentStack === 'string') {\n                    trackDynamicHole(\n                      workStore,\n                      componentStack,\n                      runtimeDynamicValidation,\n                      clientDynamicTracking\n                    )\n                  }\n                  return\n                }\n\n                if (isReactLargeShellError(err)) {\n                  // TODO: Aggregate\n                  console.error(err)\n                  return undefined\n                }\n\n                return getDigestForWellKnownError(err)\n              },\n              // We don't need bootstrap scripts in this prerender\n              // bootstrapScripts: [bootstrapScript],\n            }\n          )\n\n          // The listener to abort our own render controller must be added after\n          // React has added its listener, to ensure that pending I/O is not\n          // aborted/rejected too early.\n          clientReactController.signal.addEventListener(\n            'abort',\n            () => {\n              clientRenderController.abort()\n            },\n            { once: true }\n          )\n\n          return pendingFinalClientResult\n        },\n        () => {\n          clientReactController.abort()\n        }\n      )\n\n    const { preludeIsEmpty } = await processPrelude(unprocessedPrelude)\n    return getStaticShellDisallowedDynamicReasons(\n      workStore,\n      preludeIsEmpty ? PreludeState.Empty : PreludeState.Full,\n      runtimeDynamicValidation\n    )\n  } catch (thrownValue) {\n    // Even if the root errors we still want to report any cache components errors\n    // that were discovered before the root errored.\n    let errors: Array<unknown> = getStaticShellDisallowedDynamicReasons(\n      workStore,\n      PreludeState.Errored,\n      runtimeDynamicValidation\n    )\n\n    if (process.env.NEXT_DEBUG_BUILD || process.env.__NEXT_VERBOSE_LOGGING) {\n      errors.unshift(\n        'During dynamic validation the root of the page errored. The next logged error is the thrown value. It may be a duplicate of errors reported during the normal development mode render.',\n        thrownValue\n      )\n    }\n\n    return errors\n  }\n}\n\ntype PrerenderToStreamResult = {\n  stream: ReadableStream<Uint8Array>\n  digestErrorsMap: Map<string, DigestedError>\n  ssrErrors: Array<unknown>\n  dynamicAccess?: null | Array<DynamicAccess>\n  collectedRevalidate: number\n  collectedExpire: number\n  collectedStale: number\n  collectedTags: null | string[]\n  renderResumeDataCache?: RenderResumeDataCache\n}\n\n/**\n * Determines whether we should generate static flight data.\n */\nfunction shouldGenerateStaticFlightData(workStore: WorkStore): boolean {\n  const { isStaticGeneration } = workStore\n  if (!isStaticGeneration) return false\n\n  return true\n}\n\nasync function prerenderToStream(\n  req: BaseNextRequest,\n  res: BaseNextResponse,\n  ctx: AppRenderContext,\n  metadata: AppPageRenderResultMetadata,\n  tree: LoaderTree,\n  fallbackRouteParams: OpaqueFallbackRouteParams | null\n): Promise<PrerenderToStreamResult> {\n  // When prerendering formState is always null. We still include it\n  // because some shared APIs expect a formState value and this is slightly\n  // more explicit than making it an optional function argument\n  const formState = null\n\n  const {\n    assetPrefix,\n    getDynamicParamFromSegment,\n    implicitTags,\n    nonce,\n    pagePath,\n    renderOpts,\n    workStore,\n  } = ctx\n\n  const {\n    allowEmptyStaticShell = false,\n    basePath,\n    buildManifest,\n    ComponentMod,\n    crossOrigin,\n    dev = false,\n    experimental,\n    isDebugDynamicAccesses,\n    isBuildTimePrerendering = false,\n    onInstrumentationRequestError,\n    page,\n    reactMaxHeadersLength,\n    subresourceIntegrityManifest,\n    cacheComponents,\n  } = renderOpts\n\n  const rootParams = getRootParams(tree, getDynamicParamFromSegment)\n\n  const { ServerInsertedHTMLProvider, renderServerInsertedHTML } =\n    createServerInsertedHTML()\n  const getServerInsertedMetadata = createServerInsertedMetadata(nonce)\n\n  const tracingMetadata = getTracedMetadata(\n    getTracer().getTracePropagationData(),\n    experimental.clientTraceMetadata\n  )\n\n  const polyfills: JSX.IntrinsicElements['script'][] =\n    buildManifest.polyfillFiles\n      .filter(\n        (polyfill) =>\n          polyfill.endsWith('.js') && !polyfill.endsWith('.module.js')\n      )\n      .map((polyfill) => ({\n        src: `${assetPrefix}/_next/${polyfill}${getAssetQueryString(\n          ctx,\n          false\n        )}`,\n        integrity: subresourceIntegrityManifest?.[polyfill],\n        crossOrigin,\n        noModule: true,\n        nonce,\n      }))\n\n  const [preinitScripts, bootstrapScript] = getRequiredScripts(\n    buildManifest,\n    // Why is assetPrefix optional on renderOpts?\n    // @TODO make it default empty string on renderOpts and get rid of it from ctx\n    assetPrefix,\n    crossOrigin,\n    subresourceIntegrityManifest,\n    getAssetQueryString(ctx, true),\n    nonce,\n    page\n  )\n\n  const { reactServerErrorsByDigest } = workStore\n  // We don't report errors during prerendering through our instrumentation hooks\n  const reportErrors = !experimental.isRoutePPREnabled\n  function onHTMLRenderRSCError(err: DigestedError, silenceLog: boolean) {\n    if (reportErrors) {\n      return onInstrumentationRequestError?.(\n        err,\n        req,\n        createErrorContext(ctx, 'react-server-components'),\n        silenceLog\n      )\n    }\n  }\n  const serverComponentsErrorHandler = createReactServerErrorHandler(\n    dev,\n    isBuildTimePrerendering,\n    reactServerErrorsByDigest,\n    onHTMLRenderRSCError\n  )\n\n  function onHTMLRenderSSRError(err: DigestedError) {\n    if (reportErrors) {\n      // We don't need to silence logs here. onHTMLRenderSSRError won't be\n      // called at all if the error was logged before in the RSC error handler.\n      const silenceLog = false\n      return onInstrumentationRequestError?.(\n        err,\n        req,\n        createErrorContext(ctx, 'server-rendering'),\n        silenceLog\n      )\n    }\n  }\n  const allCapturedErrors: Array<unknown> = []\n  const htmlRendererErrorHandler = createHTMLErrorHandler(\n    dev,\n    isBuildTimePrerendering,\n    reactServerErrorsByDigest,\n    allCapturedErrors,\n    onHTMLRenderSSRError\n  )\n\n  let reactServerPrerenderResult: null | ReactServerPrerenderResult = null\n  const setMetadataHeader = (name: string) => {\n    metadata.headers ??= {}\n    metadata.headers[name] = res.getHeader(name)\n  }\n  const setHeader = (name: string, value: string | string[]) => {\n    res.setHeader(name, value)\n    setMetadataHeader(name)\n    return res\n  }\n  const appendHeader = (name: string, value: string | string[]) => {\n    if (Array.isArray(value)) {\n      value.forEach((item) => {\n        res.appendHeader(name, item)\n      })\n    } else {\n      res.appendHeader(name, value)\n    }\n    setMetadataHeader(name)\n  }\n\n  const selectStaleTime = createSelectStaleTime(experimental)\n  const { clientModules } = getClientReferenceManifest()\n\n  let prerenderStore: PrerenderStore | null = null\n\n  try {\n    if (cacheComponents) {\n      /**\n       * cacheComponents with PPR\n       *\n       * The general approach is to render the RSC stream first allowing any cache reads to resolve.\n       * Once we have settled all cache reads we restart the render and abort after a single Task.\n       *\n       * Unlike with the non PPR case we can't synchronously abort the render when a dynamic API is used\n       * during the initial render because we need to ensure all caches can be filled as part of the initial Task\n       * and a synchronous abort might prevent us from filling all caches.\n       *\n       * Once the render is complete we allow the SSR render to finish and use a combination of the postponed state\n       * and the reactServerIsDynamic value to determine how to treat the resulting render\n       */\n\n      // The prerender controller represents the lifetime of the prerender. It\n      // will be aborted when a task is complete or a synchronously aborting API\n      // is called. Notably, during prospective prerenders, this does not\n      // actually terminate the prerender itself, which will continue until all\n      // caches are filled.\n      const initialServerPrerenderController = new AbortController()\n\n      // This controller is used to abort the React prerender.\n      const initialServerReactController = new AbortController()\n\n      // This controller represents the lifetime of the React prerender. Its\n      // signal can be used for any I/O operation to abort the I/O and/or to\n      // reject, when prerendering aborts. This includes our own hanging\n      // promises for accessing request data, and for fetch calls. It might be\n      // replaced in the future by React.cacheSignal(). It's aborted after the\n      // React controller, so that no pending I/O can register abort listeners\n      // that are called before React's abort listener is called. This ensures\n      // that pending I/O is not rejected too early when aborting the prerender.\n      // Notably, during the prospective prerender, it is different from the\n      // prerender controller because we don't want to end the React prerender\n      // until all caches are filled.\n      const initialServerRenderController = new AbortController()\n\n      // The cacheSignal helps us track whether caches are still filling or we are ready\n      // to cut the render off.\n      const cacheSignal = new CacheSignal()\n\n      // Always start with a fresh prerender RDC so warmup can fill misses,\n      // even when we have a prefilled render RDC to seed from.\n      const prerenderResumeDataCache = createPrerenderResumeDataCache()\n      let renderResumeDataCache: RenderResumeDataCache | null =\n        renderOpts.renderResumeDataCache ?? null\n\n      const initialServerPayloadPrerenderStore: PrerenderStore = {\n        type: 'prerender',\n        phase: 'render',\n        rootParams,\n        fallbackRouteParams,\n        implicitTags,\n        // While this render signal isn't going to be used to abort a React render while getting the RSC payload\n        // various request data APIs bind to this controller to reject after completion.\n        renderSignal: initialServerRenderController.signal,\n        // When we generate the RSC payload we might abort this controller due to sync IO\n        // but we don't actually care about sync IO in this phase so we use a throw away controller\n        // that isn't connected to anything\n        controller: new AbortController(),\n        // During the initial prerender we need to track all cache reads to ensure\n        // we render long enough to fill every cache it is possible to visit during\n        // the final prerender.\n        cacheSignal,\n        dynamicTracking: null,\n        allowEmptyStaticShell,\n        revalidate: INFINITE_CACHE,\n        expire: INFINITE_CACHE,\n        stale: INFINITE_CACHE,\n        tags: [...implicitTags.tags],\n        prerenderResumeDataCache,\n        renderResumeDataCache,\n        hmrRefreshHash: undefined,\n        // We don't track vary params during initial prerender, only the final one\n        varyParamsAccumulator: null,\n      }\n\n      // We're not going to use the result of this render because the only time it could be used\n      // is if it completes in a microtask and that's likely very rare for any non-trivial app\n      const initialServerPayload = await workUnitAsyncStorage.run(\n        initialServerPayloadPrerenderStore,\n        getRSCPayload,\n        tree,\n        ctx,\n        res.statusCode === 404\n      )\n\n      const initialServerPrerenderStore: PrerenderStore = (prerenderStore = {\n        type: 'prerender',\n        phase: 'render',\n        rootParams,\n        fallbackRouteParams,\n        implicitTags,\n        renderSignal: initialServerRenderController.signal,\n        controller: initialServerPrerenderController,\n        // During the initial prerender we need to track all cache reads to ensure\n        // we render long enough to fill every cache it is possible to visit during\n        // the final prerender.\n        cacheSignal,\n        dynamicTracking: null,\n        allowEmptyStaticShell,\n        revalidate: INFINITE_CACHE,\n        expire: INFINITE_CACHE,\n        stale: INFINITE_CACHE,\n        tags: [...implicitTags.tags],\n        prerenderResumeDataCache,\n        renderResumeDataCache,\n        hmrRefreshHash: undefined,\n        // We don't track vary params during initial prerender, only the final one\n        varyParamsAccumulator: null,\n      })\n\n      const pendingInitialServerResult = workUnitAsyncStorage.run(\n        initialServerPrerenderStore,\n        ComponentMod.prerender,\n        initialServerPayload,\n        clientModules,\n        {\n          filterStackFrame,\n          onError: (err) => {\n            const digest = getDigestForWellKnownError(err)\n\n            if (digest) {\n              return digest\n            }\n\n            if (isReactLargeShellError(err)) {\n              // TODO: Aggregate\n              console.error(err)\n              return undefined\n            }\n\n            if (initialServerPrerenderController.signal.aborted) {\n              // The render aborted before this error was handled which indicates\n              // the error is caused by unfinished components within the render\n              return\n            } else if (\n              process.env.NEXT_DEBUG_BUILD ||\n              process.env.__NEXT_VERBOSE_LOGGING\n            ) {\n              printDebugThrownValueForProspectiveRender(\n                err,\n                workStore.route,\n                Phase.ProspectiveRender\n              )\n            }\n          },\n          // We don't want to stop rendering until the cacheSignal is complete so we pass\n          // a different signal to this render call than is used by dynamic APIs to signify\n          // transitioning out of the prerender environment\n          signal: initialServerReactController.signal,\n        }\n      )\n\n      // The listener to abort our own render controller must be added after\n      // React has added its listener, to ensure that pending I/O is not\n      // aborted/rejected too early.\n      initialServerReactController.signal.addEventListener(\n        'abort',\n        () => {\n          initialServerRenderController.abort()\n          initialServerPrerenderController.abort()\n        },\n        { once: true }\n      )\n\n      // Wait for all caches to be finished filling and for async imports to resolve\n      trackPendingModules(cacheSignal)\n      await cacheSignal.cacheReady()\n\n      initialServerReactController.abort()\n\n      // We don't need to continue the prerender process if we already\n      // detected invalid dynamic usage in the initial prerender phase.\n      if (workStore.invalidDynamicUsageError) {\n        logDisallowedDynamicError(workStore, workStore.invalidDynamicUsageError)\n        throw new StaticGenBailoutError()\n      }\n\n      let initialServerResult\n      try {\n        initialServerResult = await createReactServerPrerenderResult(\n          pendingInitialServerResult\n        )\n      } catch (err) {\n        if (\n          initialServerReactController.signal.aborted ||\n          initialServerPrerenderController.signal.aborted\n        ) {\n          // These are expected errors that might error the prerender. we ignore them.\n        } else if (\n          process.env.NEXT_DEBUG_BUILD ||\n          process.env.__NEXT_VERBOSE_LOGGING\n        ) {\n          // We don't normally log these errors because we are going to retry anyway but\n          // it can be useful for debugging Next.js itself to get visibility here when needed\n          printDebugThrownValueForProspectiveRender(\n            err,\n            workStore.route,\n            Phase.ProspectiveRender\n          )\n        }\n      }\n\n      if (initialServerResult) {\n        const initialClientPrerenderController = new AbortController()\n        const initialClientReactController = new AbortController()\n        const initialClientRenderController = new AbortController()\n\n        const initialClientPrerenderStore: PrerenderStore = {\n          type: 'prerender-client',\n          phase: 'render',\n          rootParams,\n          fallbackRouteParams,\n          implicitTags,\n          renderSignal: initialClientRenderController.signal,\n          controller: initialClientPrerenderController,\n          // For HTML Generation the only cache tracked activity\n          // is module loading, which has it's own cache signal\n          cacheSignal: null,\n          dynamicTracking: null,\n          allowEmptyStaticShell,\n          revalidate: INFINITE_CACHE,\n          expire: INFINITE_CACHE,\n          stale: INFINITE_CACHE,\n          tags: [...implicitTags.tags],\n          prerenderResumeDataCache,\n          renderResumeDataCache,\n          hmrRefreshHash: undefined,\n          // Client prerenders don't track server param access\n          varyParamsAccumulator: null,\n        }\n\n        const prerender = (\n          require('react-dom/static') as typeof import('react-dom/static')\n        ).prerender\n        const pendingInitialClientResult = workUnitAsyncStorage.run(\n          initialClientPrerenderStore,\n          prerender,\n          // eslint-disable-next-line @next/internal/no-ambiguous-jsx\n          <App\n            reactServerStream={initialServerResult.asUnclosingStream()}\n            reactDebugStream={undefined}\n            debugEndTime={undefined}\n            preinitScripts={preinitScripts}\n            ServerInsertedHTMLProvider={ServerInsertedHTMLProvider}\n            nonce={nonce}\n            images={ctx.renderOpts.images}\n          />,\n          {\n            signal: initialClientReactController.signal,\n            onError: (err) => {\n              const digest = getDigestForWellKnownError(err)\n\n              if (digest) {\n                return digest\n              }\n\n              if (isReactLargeShellError(err)) {\n                // TODO: Aggregate\n                console.error(err)\n                return undefined\n              }\n\n              if (initialClientReactController.signal.aborted) {\n                // These are expected errors that might error the prerender. we ignore them.\n              } else if (\n                process.env.NEXT_DEBUG_BUILD ||\n                process.env.__NEXT_VERBOSE_LOGGING\n              ) {\n                // We don't normally log these errors because we are going to retry anyway but\n                // it can be useful for debugging Next.js itself to get visibility here when needed\n                printDebugThrownValueForProspectiveRender(\n                  err,\n                  workStore.route,\n                  Phase.ProspectiveRender\n                )\n              }\n            },\n            bootstrapScripts: [bootstrapScript],\n          }\n        )\n\n        // The listener to abort our own render controller must be added after\n        // React has added its listener, to ensure that pending I/O is not\n        // aborted/rejected too early.\n        initialClientReactController.signal.addEventListener(\n          'abort',\n          () => {\n            initialClientRenderController.abort()\n          },\n          { once: true }\n        )\n\n        pendingInitialClientResult.catch((err) => {\n          if (\n            initialClientReactController.signal.aborted ||\n            isPrerenderInterruptedError(err)\n          ) {\n            // These are expected errors that might error the prerender. we ignore them.\n          } else if (\n            process.env.NEXT_DEBUG_BUILD ||\n            process.env.__NEXT_VERBOSE_LOGGING\n          ) {\n            // We don't normally log these errors because we are going to retry anyway but\n            // it can be useful for debugging Next.js itself to get visibility here when needed\n            printDebugThrownValueForProspectiveRender(\n              err,\n              workStore.route,\n              Phase.ProspectiveRender\n            )\n          }\n        })\n\n        // This is mostly needed for dynamic `import()`s in client components.\n        // Promises passed to client were already awaited above (assuming that they came from cached functions)\n        trackPendingModules(cacheSignal)\n        await cacheSignal.cacheReady()\n        initialClientReactController.abort()\n      }\n\n      if (renderOpts.renderResumeDataCache) {\n        // Swap to the warmed cache so the final render uses entries produced during warmup.\n        renderResumeDataCache = createRenderResumeDataCache(\n          prerenderResumeDataCache\n        )\n      }\n\n      const finalServerReactController = new AbortController()\n      const finalServerRenderController = new AbortController()\n\n      const varyParamsAccumulator = createResponseVaryParamsAccumulator()\n\n      const finalServerPayloadPrerenderStore: PrerenderStore = {\n        type: 'prerender',\n        phase: 'render',\n        rootParams,\n        fallbackRouteParams,\n        implicitTags,\n        // While this render signal isn't going to be used to abort a React render while getting the RSC payload\n        // various request data APIs bind to this controller to reject after completion.\n        renderSignal: finalServerRenderController.signal,\n        // When we generate the RSC payload we might abort this controller due to sync IO\n        // but we don't actually care about sync IO in this phase so we use a throw away controller\n        // that isn't connected to anything\n        controller: new AbortController(),\n        // All caches we could read must already be filled so no tracking is necessary\n        cacheSignal: null,\n        dynamicTracking: null,\n        allowEmptyStaticShell,\n        revalidate: INFINITE_CACHE,\n        expire: INFINITE_CACHE,\n        stale: INFINITE_CACHE,\n        tags: [...implicitTags.tags],\n        prerenderResumeDataCache,\n        renderResumeDataCache,\n        hmrRefreshHash: undefined,\n        varyParamsAccumulator,\n      }\n\n      const finalAttemptRSCPayload = await workUnitAsyncStorage.run(\n        finalServerPayloadPrerenderStore,\n        getRSCPayload,\n        tree,\n        ctx,\n        res.statusCode === 404\n      )\n\n      const serverDynamicTracking = createDynamicTrackingState(\n        isDebugDynamicAccesses\n      )\n      let serverIsDynamic = false\n\n      const finalServerPrerenderStore: PrerenderStore = (prerenderStore = {\n        type: 'prerender',\n        phase: 'render',\n        rootParams,\n        fallbackRouteParams,\n        implicitTags,\n        renderSignal: finalServerRenderController.signal,\n        controller: finalServerReactController,\n        // All caches we could read must already be filled so no tracking is necessary\n        cacheSignal: null,\n        dynamicTracking: serverDynamicTracking,\n        allowEmptyStaticShell,\n        revalidate: INFINITE_CACHE,\n        expire: INFINITE_CACHE,\n        stale: INFINITE_CACHE,\n        tags: [...implicitTags.tags],\n        prerenderResumeDataCache,\n        renderResumeDataCache,\n        hmrRefreshHash: undefined,\n        varyParamsAccumulator,\n      })\n\n      let prerenderIsPending = true\n      const reactServerResult = (reactServerPrerenderResult =\n        await createReactServerPrerenderResult(\n          prerenderAndAbortInSequentialTasks(\n            async () => {\n              const pendingPrerenderResult = workUnitAsyncStorage.run(\n                // The store to scope\n                finalServerPrerenderStore,\n                // The function to run\n                ComponentMod.prerender,\n                // ... the arguments for the function to run\n                finalAttemptRSCPayload,\n                clientModules,\n                {\n                  filterStackFrame,\n                  onError: (err: unknown) => {\n                    return serverComponentsErrorHandler(err)\n                  },\n                  signal: finalServerReactController.signal,\n                }\n              )\n\n              // The listener to abort our own render controller must be added\n              // after React has added its listener, to ensure that pending I/O\n              // is not aborted/rejected too early.\n              finalServerReactController.signal.addEventListener(\n                'abort',\n                () => {\n                  finalServerRenderController.abort()\n                },\n                { once: true }\n              )\n\n              const prerenderResult = await pendingPrerenderResult\n              prerenderIsPending = false\n\n              return prerenderResult\n            },\n            async () => {\n              // Now that the prerendering is complete, we know which vary\n              // params were used to compute the response. Resolve the vary\n              // params thenable so it can be sent to the client. The timing\n              // here is important: the thenable was included in the Flight\n              // payload, but it can only be serialized at the very end, after\n              // all the components have finished.\n              //\n              // We resolve the accumulator directly here instead of reading from\n              // the work unit store because this callback runs in a separate\n              // task (via setTimeout) and may not have access to the async\n              // storage context.\n              await finishAccumulatingVaryParams(varyParamsAccumulator)\n\n              if (finalServerReactController.signal.aborted) {\n                // If the server controller is already aborted we must have called something\n                // that required aborting the prerender synchronously such as with new Date()\n                serverIsDynamic = true\n                return\n              }\n\n              if (prerenderIsPending) {\n                // If prerenderIsPending then we have blocked for longer than a Task and we assume\n                // there is something unfinished.\n                serverIsDynamic = true\n              }\n\n              finalServerReactController.abort()\n            }\n          )\n        ))\n\n      const clientDynamicTracking = createDynamicTrackingState(\n        isDebugDynamicAccesses\n      )\n\n      const finalClientReactController = new AbortController()\n      const finalClientRenderController = new AbortController()\n\n      const finalClientPrerenderStore: PrerenderStore = {\n        type: 'prerender-client',\n        phase: 'render',\n        rootParams,\n        fallbackRouteParams,\n        implicitTags,\n        renderSignal: finalClientRenderController.signal,\n        controller: finalClientReactController,\n        // No APIs require a cacheSignal through the workUnitStore during the HTML prerender\n        cacheSignal: null,\n        dynamicTracking: clientDynamicTracking,\n        allowEmptyStaticShell,\n        revalidate: INFINITE_CACHE,\n        expire: INFINITE_CACHE,\n        stale: INFINITE_CACHE,\n        tags: [...implicitTags.tags],\n        prerenderResumeDataCache,\n        renderResumeDataCache,\n        hmrRefreshHash: undefined,\n        // Client prerenders don't track server param access\n        varyParamsAccumulator: null,\n      }\n\n      let dynamicValidation = createDynamicValidationState()\n\n      const prerender = (\n        require('react-dom/static') as typeof import('react-dom/static')\n      ).prerender\n      let { prelude: unprocessedPrelude, postponed } =\n        await prerenderAndAbortInSequentialTasks(\n          () => {\n            const pendingFinalClientResult = workUnitAsyncStorage.run(\n              finalClientPrerenderStore,\n              prerender,\n              // eslint-disable-next-line @next/internal/no-ambiguous-jsx\n              <App\n                reactServerStream={reactServerResult.asUnclosingStream()}\n                reactDebugStream={undefined}\n                debugEndTime={undefined}\n                preinitScripts={preinitScripts}\n                ServerInsertedHTMLProvider={ServerInsertedHTMLProvider}\n                nonce={nonce}\n                images={ctx.renderOpts.images}\n              />,\n              {\n                signal: finalClientReactController.signal,\n                onError: (err: unknown, errorInfo: ErrorInfo) => {\n                  if (\n                    isPrerenderInterruptedError(err) ||\n                    finalClientReactController.signal.aborted\n                  ) {\n                    const componentStack: string | undefined = (\n                      errorInfo as any\n                    ).componentStack\n                    if (typeof componentStack === 'string') {\n                      trackAllowedDynamicAccess(\n                        workStore,\n                        componentStack,\n                        dynamicValidation,\n                        clientDynamicTracking\n                      )\n                    }\n                    return\n                  }\n\n                  return htmlRendererErrorHandler(err, errorInfo)\n                },\n                onHeaders: (headers: Headers) => {\n                  headers.forEach((value, key) => {\n                    appendHeader(key, value)\n                  })\n                },\n                maxHeadersLength: reactMaxHeadersLength,\n                bootstrapScripts: [bootstrapScript],\n              }\n            )\n\n            // The listener to abort our own render controller must be added\n            // after React has added its listener, to ensure that pending I/O is\n            // not aborted/rejected too early.\n            finalClientReactController.signal.addEventListener(\n              'abort',\n              () => {\n                finalClientRenderController.abort()\n              },\n              { once: true }\n            )\n\n            return pendingFinalClientResult\n          },\n          () => {\n            finalClientReactController.abort()\n          }\n        )\n\n      const { prelude, preludeIsEmpty } =\n        await processPrelude(unprocessedPrelude)\n\n      // If we've disabled throwing on empty static shell, then we don't need to\n      // track any dynamic access that occurs above the suspense boundary because\n      // we'll do so in the route shell.\n      if (!allowEmptyStaticShell) {\n        throwIfDisallowedDynamic(\n          workStore,\n          preludeIsEmpty ? PreludeState.Empty : PreludeState.Full,\n          dynamicValidation,\n          serverDynamicTracking\n        )\n      }\n\n      const getServerInsertedHTML = makeGetServerInsertedHTML({\n        polyfills,\n        renderServerInsertedHTML,\n        serverCapturedErrors: allCapturedErrors,\n        basePath,\n        tracingMetadata: tracingMetadata,\n      })\n\n      const flightData = await streamToBuffer(reactServerResult.asStream())\n      metadata.flightData = flightData\n      metadata.segmentData = await collectSegmentData(\n        flightData,\n        finalServerPrerenderStore,\n        ComponentMod,\n        renderOpts\n      )\n\n      if (serverIsDynamic) {\n        // Dynamic case\n        // We will always need to perform a \"resume\" render of some kind when this route is accessed\n        // because the RSC data itself is dynamic. We determine if there are any HTML holes or not\n        // but generally this is a \"partial\" prerender in that there will be a per-request compute\n        // concatenated to the static shell.\n        if (postponed != null) {\n          // Dynamic HTML case\n          metadata.postponed = await getDynamicHTMLPostponedState(\n            postponed,\n            preludeIsEmpty\n              ? DynamicHTMLPreludeState.Empty\n              : DynamicHTMLPreludeState.Full,\n            fallbackRouteParams,\n            prerenderResumeDataCache,\n            cacheComponents\n          )\n        } else {\n          // Dynamic Data case\n          metadata.postponed = await getDynamicDataPostponedState(\n            prerenderResumeDataCache,\n            cacheComponents\n          )\n        }\n        reactServerResult.consume()\n        return {\n          digestErrorsMap: reactServerErrorsByDigest,\n          ssrErrors: allCapturedErrors,\n          stream: await continueDynamicPrerender(prelude, {\n            getServerInsertedHTML,\n            getServerInsertedMetadata,\n            deploymentId: ctx.sharedContext.deploymentId,\n          }),\n          dynamicAccess: consumeDynamicAccess(\n            serverDynamicTracking,\n            clientDynamicTracking\n          ),\n          // TODO: Should this include the SSR pass?\n          collectedRevalidate: finalServerPrerenderStore.revalidate,\n          collectedExpire: finalServerPrerenderStore.expire,\n          collectedStale: selectStaleTime(finalServerPrerenderStore.stale),\n          collectedTags: finalServerPrerenderStore.tags,\n          renderResumeDataCache: createRenderResumeDataCache(\n            prerenderResumeDataCache\n          ),\n        }\n      } else {\n        // Static case\n        // We will not perform resumption per request. The result can be served statically to the requestor\n        // and if there was anything dynamic it will only be rendered in the browser.\n        if (workStore.forceDynamic) {\n          throw new StaticGenBailoutError(\n            'Invariant: a Page with `dynamic = \"force-dynamic\"` did not trigger the dynamic pathway. This is a bug in Next.js'\n          )\n        }\n\n        let htmlStream = prelude\n        if (postponed != null) {\n          // We postponed but nothing dynamic was used. We resume the render now and immediately abort it\n          // so we can set all the postponed boundaries to client render mode before we store the HTML response\n          const resume = (\n            require('react-dom/server') as typeof import('react-dom/server')\n          ).resume\n\n          // We don't actually want to render anything so we just pass a stream\n          // that never resolves. The resume call is going to abort immediately anyway\n          const foreverStream = new ReadableStream<Uint8Array>()\n\n          const resumeStream = await resume(\n            // eslint-disable-next-line @next/internal/no-ambiguous-jsx\n            <App\n              reactServerStream={foreverStream}\n              reactDebugStream={undefined}\n              debugEndTime={undefined}\n              preinitScripts={() => {}}\n              ServerInsertedHTMLProvider={ServerInsertedHTMLProvider}\n              nonce={nonce}\n              images={ctx.renderOpts.images}\n            />,\n            JSON.parse(JSON.stringify(postponed)),\n            {\n              signal: createRenderInBrowserAbortSignal(),\n              onError: htmlRendererErrorHandler,\n              nonce,\n            }\n          )\n\n          // First we write everything from the prerender, then we write everything from the aborted resume render\n          htmlStream = chainStreams(prelude, resumeStream)\n        }\n\n        let finalStream\n        const hasFallbackRouteParams =\n          fallbackRouteParams && fallbackRouteParams.size > 0\n        if (hasFallbackRouteParams) {\n          // This is a \"static fallback\" prerender: although the page didn't\n          // access any runtime params in a Server Component, it may have\n          // accessed a runtime param in a client segment.\n          //\n          // TODO: If there were no client segments, we can use the fully static\n          // path instead.\n          //\n          // Rather than use a dynamic server resume to fill in the params,\n          // we can rely on the client to parse the params from the URL and use\n          // that to hydrate the page.\n          //\n          // Send an empty InitialRSCPayload to the server component renderer\n          // The data will be fetched by the client instead.\n          // TODO: In the future, rather than defer the entire hydration payload\n          // to be fetched by the client, we should only defer the client\n          // segments, since those are the only ones whose data is not complete.\n          const emptyReactServerResult =\n            await createReactServerPrerenderResultFromRender(\n              ComponentMod.renderToReadableStream([], clientModules, {\n                filterStackFrame,\n                onError: serverComponentsErrorHandler,\n              })\n            )\n          finalStream = await continueStaticFallbackPrerender(htmlStream, {\n            inlinedDataStream: createInlinedDataReadableStream(\n              emptyReactServerResult.consumeAsStream(),\n              nonce,\n              formState\n            ),\n            getServerInsertedHTML,\n            getServerInsertedMetadata,\n            isBuildTimePrerendering:\n              ctx.workStore.isBuildTimePrerendering === true,\n            buildId: ctx.workStore.buildId,\n            deploymentId: ctx.sharedContext.deploymentId,\n          })\n        } else {\n          // Normal static prerender case, no fallback param handling needed\n          finalStream = await continueStaticPrerender(htmlStream, {\n            inlinedDataStream: createInlinedDataReadableStream(\n              reactServerResult.consumeAsStream(),\n              nonce,\n              formState\n            ),\n            getServerInsertedHTML,\n            getServerInsertedMetadata,\n            isBuildTimePrerendering:\n              ctx.workStore.isBuildTimePrerendering === true,\n            buildId: ctx.workStore.buildId,\n            deploymentId: ctx.sharedContext.deploymentId,\n          })\n        }\n\n        return {\n          digestErrorsMap: reactServerErrorsByDigest,\n          ssrErrors: allCapturedErrors,\n          stream: finalStream,\n          dynamicAccess: consumeDynamicAccess(\n            serverDynamicTracking,\n            clientDynamicTracking\n          ),\n          // TODO: Should this include the SSR pass?\n          collectedRevalidate: finalServerPrerenderStore.revalidate,\n          collectedExpire: finalServerPrerenderStore.expire,\n          collectedStale: selectStaleTime(finalServerPrerenderStore.stale),\n          collectedTags: finalServerPrerenderStore.tags,\n          renderResumeDataCache: createRenderResumeDataCache(\n            prerenderResumeDataCache\n          ),\n        }\n      }\n    } else if (experimental.isRoutePPREnabled) {\n      // We're statically generating with PPR and need to do dynamic tracking\n      let dynamicTracking = createDynamicTrackingState(isDebugDynamicAccesses)\n\n      const prerenderResumeDataCache = createPrerenderResumeDataCache()\n      const reactServerPrerenderStore: PrerenderStore = (prerenderStore = {\n        type: 'prerender-ppr',\n        phase: 'render',\n        rootParams,\n        fallbackRouteParams,\n        implicitTags,\n        dynamicTracking,\n        revalidate: INFINITE_CACHE,\n        expire: INFINITE_CACHE,\n        stale: INFINITE_CACHE,\n        tags: [...implicitTags.tags],\n        prerenderResumeDataCache,\n      })\n      const RSCPayload = await workUnitAsyncStorage.run(\n        reactServerPrerenderStore,\n        getRSCPayload,\n        tree,\n        ctx,\n        res.statusCode === 404\n      )\n      const reactServerResult = (reactServerPrerenderResult =\n        await createReactServerPrerenderResultFromRender(\n          workUnitAsyncStorage.run(\n            reactServerPrerenderStore,\n            ComponentMod.renderToReadableStream,\n            // ... the arguments for the function to run\n            RSCPayload,\n            clientModules,\n            {\n              filterStackFrame,\n              onError: serverComponentsErrorHandler,\n            }\n          )\n        ))\n\n      const ssrPrerenderStore: PrerenderStore = {\n        type: 'prerender-ppr',\n        phase: 'render',\n        rootParams,\n        fallbackRouteParams,\n        implicitTags,\n        dynamicTracking,\n        revalidate: INFINITE_CACHE,\n        expire: INFINITE_CACHE,\n        stale: INFINITE_CACHE,\n        tags: [...implicitTags.tags],\n        prerenderResumeDataCache,\n      }\n      const prerender = (\n        require('react-dom/static') as typeof import('react-dom/static')\n      ).prerender\n      const { prelude: unprocessedPrelude, postponed } =\n        await workUnitAsyncStorage.run(\n          ssrPrerenderStore,\n          prerender,\n          // eslint-disable-next-line @next/internal/no-ambiguous-jsx\n          <App\n            reactServerStream={reactServerResult.asUnclosingStream()}\n            reactDebugStream={undefined}\n            debugEndTime={undefined}\n            preinitScripts={preinitScripts}\n            ServerInsertedHTMLProvider={ServerInsertedHTMLProvider}\n            nonce={nonce}\n            images={ctx.renderOpts.images}\n          />,\n          {\n            onError: htmlRendererErrorHandler,\n            onHeaders: (headers: Headers) => {\n              headers.forEach((value, key) => {\n                appendHeader(key, value)\n              })\n            },\n            maxHeadersLength: reactMaxHeadersLength,\n            bootstrapScripts: [bootstrapScript],\n          }\n        )\n      const getServerInsertedHTML = makeGetServerInsertedHTML({\n        polyfills,\n        renderServerInsertedHTML,\n        serverCapturedErrors: allCapturedErrors,\n        basePath,\n        tracingMetadata: tracingMetadata,\n      })\n\n      // After awaiting here we've waited for the entire RSC render to complete. Crucially this means\n      // that when we detect whether we've used dynamic APIs below we know we'll have picked up even\n      // parts of the React Server render that might not be used in the SSR render.\n      const flightData = await streamToBuffer(reactServerResult.asStream())\n\n      if (shouldGenerateStaticFlightData(workStore)) {\n        metadata.flightData = flightData\n        metadata.segmentData = await collectSegmentData(\n          flightData,\n          ssrPrerenderStore,\n          ComponentMod,\n          renderOpts\n        )\n      }\n\n      const { prelude, preludeIsEmpty } =\n        await processPrelude(unprocessedPrelude)\n\n      /**\n       * When prerendering there are three outcomes to consider\n       *\n       *   Dynamic HTML:      The prerender has dynamic holes (caused by using Next.js Dynamic Rendering APIs)\n       *                      We will need to resume this result when requests are handled and we don't include\n       *                      any server inserted HTML or inlined flight data in the static HTML\n       *\n       *   Dynamic Data:      The prerender has no dynamic holes but dynamic APIs were used. We will not\n       *                      resume this render when requests are handled but we will generate new inlined\n       *                      flight data since it is dynamic and differences may end up reconciling on the client\n       *\n       *   Static:            The prerender has no dynamic holes and no dynamic APIs were used. We statically encode\n       *                      all server inserted HTML and flight data\n       */\n      // First we check if we have any dynamic holes in our HTML prerender\n      if (accessedDynamicData(dynamicTracking.dynamicAccesses)) {\n        if (postponed != null) {\n          // Dynamic HTML case.\n          metadata.postponed = await getDynamicHTMLPostponedState(\n            postponed,\n            preludeIsEmpty\n              ? DynamicHTMLPreludeState.Empty\n              : DynamicHTMLPreludeState.Full,\n            fallbackRouteParams,\n            prerenderResumeDataCache,\n            cacheComponents\n          )\n        } else {\n          // Dynamic Data case.\n          metadata.postponed = await getDynamicDataPostponedState(\n            prerenderResumeDataCache,\n            cacheComponents\n          )\n        }\n        // Regardless of whether this is the Dynamic HTML or Dynamic Data case we need to ensure we include\n        // server inserted html in the static response because the html that is part of the prerender may depend on it\n        // It is possible in the set of stream transforms for Dynamic HTML vs Dynamic Data may differ but currently both states\n        // require the same set so we unify the code path here\n        reactServerResult.consume()\n        return {\n          digestErrorsMap: reactServerErrorsByDigest,\n          ssrErrors: allCapturedErrors,\n          stream: await continueDynamicPrerender(prelude, {\n            getServerInsertedHTML,\n            getServerInsertedMetadata,\n            deploymentId: ctx.sharedContext.deploymentId,\n          }),\n          dynamicAccess: dynamicTracking.dynamicAccesses,\n          // TODO: Should this include the SSR pass?\n          collectedRevalidate: reactServerPrerenderStore.revalidate,\n          collectedExpire: reactServerPrerenderStore.expire,\n          collectedStale: selectStaleTime(reactServerPrerenderStore.stale),\n          collectedTags: reactServerPrerenderStore.tags,\n        }\n      } else if (fallbackRouteParams && fallbackRouteParams.size > 0) {\n        // Rendering the fallback case.\n        metadata.postponed = await getDynamicDataPostponedState(\n          prerenderResumeDataCache,\n          cacheComponents\n        )\n\n        return {\n          digestErrorsMap: reactServerErrorsByDigest,\n          ssrErrors: allCapturedErrors,\n          stream: await continueDynamicPrerender(prelude, {\n            getServerInsertedHTML,\n            getServerInsertedMetadata,\n            deploymentId: ctx.sharedContext.deploymentId,\n          }),\n          dynamicAccess: dynamicTracking.dynamicAccesses,\n          // TODO: Should this include the SSR pass?\n          collectedRevalidate: reactServerPrerenderStore.revalidate,\n          collectedExpire: reactServerPrerenderStore.expire,\n          collectedStale: selectStaleTime(reactServerPrerenderStore.stale),\n          collectedTags: reactServerPrerenderStore.tags,\n        }\n      } else {\n        // Static case\n        // We still have not used any dynamic APIs. At this point we can produce an entirely static prerender response\n        if (workStore.forceDynamic) {\n          throw new StaticGenBailoutError(\n            'Invariant: a Page with `dynamic = \"force-dynamic\"` did not trigger the dynamic pathway. This is a bug in Next.js'\n          )\n        }\n\n        let htmlStream = prelude\n        if (postponed != null) {\n          // We postponed but nothing dynamic was used. We resume the render now and immediately abort it\n          // so we can set all the postponed boundaries to client render mode before we store the HTML response\n          const resume = (\n            require('react-dom/server') as typeof import('react-dom/server')\n          ).resume\n\n          // We don't actually want to render anything so we just pass a stream\n          // that never resolves. The resume call is going to abort immediately anyway\n          const foreverStream = new ReadableStream<Uint8Array>()\n\n          const resumeStream = await resume(\n            // eslint-disable-next-line @next/internal/no-ambiguous-jsx\n            <App\n              reactServerStream={foreverStream}\n              reactDebugStream={undefined}\n              debugEndTime={undefined}\n              preinitScripts={() => {}}\n              ServerInsertedHTMLProvider={ServerInsertedHTMLProvider}\n              nonce={nonce}\n              images={ctx.renderOpts.images}\n            />,\n            JSON.parse(JSON.stringify(postponed)),\n            {\n              signal: createRenderInBrowserAbortSignal(),\n              onError: htmlRendererErrorHandler,\n              nonce,\n            }\n          )\n\n          // First we write everything from the prerender, then we write everything from the aborted resume render\n          htmlStream = chainStreams(prelude, resumeStream)\n        }\n\n        return {\n          digestErrorsMap: reactServerErrorsByDigest,\n          ssrErrors: allCapturedErrors,\n          stream: await continueStaticPrerender(htmlStream, {\n            inlinedDataStream: createInlinedDataReadableStream(\n              reactServerResult.consumeAsStream(),\n              nonce,\n              formState\n            ),\n            getServerInsertedHTML,\n            getServerInsertedMetadata,\n            isBuildTimePrerendering:\n              ctx.workStore.isBuildTimePrerendering === true,\n            buildId: ctx.workStore.buildId,\n            deploymentId: ctx.sharedContext.deploymentId,\n          }),\n          dynamicAccess: dynamicTracking.dynamicAccesses,\n          // TODO: Should this include the SSR pass?\n          collectedRevalidate: reactServerPrerenderStore.revalidate,\n          collectedExpire: reactServerPrerenderStore.expire,\n          collectedStale: selectStaleTime(reactServerPrerenderStore.stale),\n          collectedTags: reactServerPrerenderStore.tags,\n        }\n      }\n    } else {\n      const prerenderLegacyStore: PrerenderStore = (prerenderStore = {\n        type: 'prerender-legacy',\n        phase: 'render',\n        rootParams,\n        implicitTags,\n        revalidate: INFINITE_CACHE,\n        expire: INFINITE_CACHE,\n        stale: INFINITE_CACHE,\n        tags: [...implicitTags.tags],\n      })\n      // This is a regular static generation. We don't do dynamic tracking because we rely on\n      // the old-school dynamic error handling to bail out of static generation\n      const RSCPayload = await workUnitAsyncStorage.run(\n        prerenderLegacyStore,\n        getRSCPayload,\n        tree,\n        ctx,\n        res.statusCode === 404\n      )\n\n      const reactServerResult = (reactServerPrerenderResult =\n        await createReactServerPrerenderResultFromRender(\n          workUnitAsyncStorage.run(\n            prerenderLegacyStore,\n            ComponentMod.renderToReadableStream,\n            RSCPayload,\n            clientModules,\n            {\n              filterStackFrame,\n              onError: serverComponentsErrorHandler,\n            }\n          )\n        ))\n\n      const renderToReadableStream = (\n        require('react-dom/server') as typeof import('react-dom/server')\n      ).renderToReadableStream\n      const htmlStream = await workUnitAsyncStorage.run(\n        prerenderLegacyStore,\n        renderToReadableStream,\n        // eslint-disable-next-line @next/internal/no-ambiguous-jsx\n        <App\n          reactServerStream={reactServerResult.asUnclosingStream()}\n          reactDebugStream={undefined}\n          debugEndTime={undefined}\n          preinitScripts={preinitScripts}\n          ServerInsertedHTMLProvider={ServerInsertedHTMLProvider}\n          nonce={nonce}\n          images={ctx.renderOpts.images}\n        />,\n        {\n          onError: htmlRendererErrorHandler,\n          nonce,\n          bootstrapScripts: [bootstrapScript],\n        }\n      )\n\n      if (shouldGenerateStaticFlightData(workStore)) {\n        const flightData = await streamToBuffer(reactServerResult.asStream())\n        metadata.flightData = flightData\n        metadata.segmentData = await collectSegmentData(\n          flightData,\n          prerenderLegacyStore,\n          ComponentMod,\n          renderOpts\n        )\n      }\n\n      const getServerInsertedHTML = makeGetServerInsertedHTML({\n        polyfills,\n        renderServerInsertedHTML,\n        serverCapturedErrors: allCapturedErrors,\n        basePath,\n        tracingMetadata: tracingMetadata,\n      })\n      return {\n        digestErrorsMap: reactServerErrorsByDigest,\n        ssrErrors: allCapturedErrors,\n        stream: await continueFizzStream(htmlStream, {\n          inlinedDataStream: createInlinedDataReadableStream(\n            reactServerResult.consumeAsStream(),\n            nonce,\n            formState\n          ),\n          isStaticGeneration: true,\n          isBuildTimePrerendering:\n            ctx.workStore.isBuildTimePrerendering === true,\n          buildId: ctx.workStore.buildId,\n          getServerInsertedHTML,\n          getServerInsertedMetadata,\n          deploymentId: ctx.sharedContext.deploymentId,\n        }),\n        // TODO: Should this include the SSR pass?\n        collectedRevalidate: prerenderLegacyStore.revalidate,\n        collectedExpire: prerenderLegacyStore.expire,\n        collectedStale: selectStaleTime(prerenderLegacyStore.stale),\n        collectedTags: prerenderLegacyStore.tags,\n      }\n    }\n  } catch (err) {\n    if (\n      isStaticGenBailoutError(err) ||\n      (typeof err === 'object' &&\n        err !== null &&\n        'message' in err &&\n        typeof err.message === 'string' &&\n        err.message.includes(\n          'https://nextjs.org/docs/advanced-features/static-html-export'\n        ))\n    ) {\n      // Ensure that \"next dev\" prints the red error overlay\n      throw err\n    }\n\n    // If this is a static generation error, we need to throw it so that it\n    // can be handled by the caller if we're in static generation mode.\n    if (isDynamicServerError(err)) {\n      throw err\n    }\n\n    // If a bailout made it to this point, it means it wasn't wrapped inside\n    // a suspense boundary.\n    const shouldBailoutToCSR = isBailoutToCSRError(err)\n    if (shouldBailoutToCSR) {\n      const stack = getStackWithoutErrorMessage(err)\n      error(\n        `${err.reason} should be wrapped in a suspense boundary at page \"${pagePath}\". Read more: https://nextjs.org/docs/messages/missing-suspense-with-csr-bailout\\n${stack}`\n      )\n\n      throw err\n    }\n\n    // If we errored when we did not have an RSC stream to read from. This is\n    // not just a render error, we need to throw early.\n    if (reactServerPrerenderResult === null) {\n      throw err\n    }\n\n    let errorType: MetadataErrorType | 'redirect' | undefined\n\n    if (isHTTPAccessFallbackError(err)) {\n      res.statusCode = getAccessFallbackHTTPStatus(err)\n      metadata.statusCode = res.statusCode\n      errorType = getAccessFallbackErrorTypeByStatus(res.statusCode)\n    } else if (isRedirectError(err)) {\n      errorType = 'redirect'\n      res.statusCode = getRedirectStatusCodeFromError(err)\n      metadata.statusCode = res.statusCode\n\n      const redirectUrl = addPathPrefix(getURLFromRedirectError(err), basePath)\n\n      setHeader('location', redirectUrl)\n    } else if (!shouldBailoutToCSR) {\n      res.statusCode = 500\n      metadata.statusCode = res.statusCode\n    }\n\n    const [errorPreinitScripts, errorBootstrapScript] = getRequiredScripts(\n      buildManifest,\n      assetPrefix,\n      crossOrigin,\n      subresourceIntegrityManifest,\n      getAssetQueryString(ctx, false),\n      nonce,\n      '/_not-found/page'\n    )\n\n    const prerenderLegacyStore: PrerenderStore = (prerenderStore = {\n      type: 'prerender-legacy',\n      phase: 'render',\n      rootParams,\n      implicitTags: implicitTags,\n      revalidate:\n        typeof prerenderStore?.revalidate !== 'undefined'\n          ? prerenderStore.revalidate\n          : INFINITE_CACHE,\n      expire:\n        typeof prerenderStore?.expire !== 'undefined'\n          ? prerenderStore.expire\n          : INFINITE_CACHE,\n      stale:\n        typeof prerenderStore?.stale !== 'undefined'\n          ? prerenderStore.stale\n          : INFINITE_CACHE,\n      tags: [...(prerenderStore?.tags || implicitTags.tags)],\n    })\n    const errorRSCPayload = await workUnitAsyncStorage.run(\n      prerenderLegacyStore,\n      getErrorRSCPayload,\n      tree,\n      ctx,\n      reactServerErrorsByDigest.has((err as any).digest) ? undefined : err,\n      errorType\n    )\n\n    const errorServerStream = workUnitAsyncStorage.run(\n      prerenderLegacyStore,\n      ComponentMod.renderToReadableStream,\n      errorRSCPayload,\n      clientModules,\n      {\n        filterStackFrame,\n        onError: serverComponentsErrorHandler,\n      }\n    )\n\n    try {\n      // TODO we should use the same prerender semantics that we initially rendered\n      // with in this case too. The only reason why this is ok atm is because it's essentially\n      // an empty page and no user code runs.\n      const fizzStream = await workUnitAsyncStorage.run(\n        prerenderLegacyStore,\n        renderToInitialFizzStream,\n        {\n          ReactDOMServer:\n            require('react-dom/server') as typeof import('react-dom/server'),\n          element: (\n            // eslint-disable-next-line @next/internal/no-ambiguous-jsx\n            <ErrorApp\n              reactServerStream={errorServerStream}\n              ServerInsertedHTMLProvider={ServerInsertedHTMLProvider}\n              preinitScripts={errorPreinitScripts}\n              nonce={nonce}\n              images={ctx.renderOpts.images}\n            />\n          ),\n          streamOptions: {\n            nonce,\n            // Include hydration scripts in the HTML\n            bootstrapScripts: [errorBootstrapScript],\n            formState,\n          },\n        }\n      )\n\n      if (shouldGenerateStaticFlightData(workStore)) {\n        const flightData = await streamToBuffer(\n          reactServerPrerenderResult.asStream()\n        )\n        metadata.flightData = flightData\n        metadata.segmentData = await collectSegmentData(\n          flightData,\n          prerenderLegacyStore,\n          ComponentMod,\n          renderOpts\n        )\n      }\n\n      // This is intentionally using the readable datastream from the main\n      // render rather than the flight data from the error page render\n      const flightStream = reactServerPrerenderResult.consumeAsStream()\n\n      return {\n        // Returning the error that was thrown so it can be used to handle\n        // the response in the caller.\n        digestErrorsMap: reactServerErrorsByDigest,\n        ssrErrors: allCapturedErrors,\n        stream: await continueFizzStream(fizzStream, {\n          inlinedDataStream: createInlinedDataReadableStream(\n            flightStream,\n            nonce,\n            formState\n          ),\n          isStaticGeneration: true,\n          isBuildTimePrerendering:\n            ctx.workStore.isBuildTimePrerendering === true,\n          buildId: ctx.workStore.buildId,\n          getServerInsertedHTML: makeGetServerInsertedHTML({\n            polyfills,\n            renderServerInsertedHTML,\n            serverCapturedErrors: [],\n            basePath,\n            tracingMetadata: tracingMetadata,\n          }),\n          getServerInsertedMetadata,\n          validateRootLayout: dev,\n          deploymentId: ctx.sharedContext.deploymentId,\n        }),\n        dynamicAccess: null,\n        collectedRevalidate:\n          prerenderStore !== null ? prerenderStore.revalidate : INFINITE_CACHE,\n        collectedExpire:\n          prerenderStore !== null ? prerenderStore.expire : INFINITE_CACHE,\n        collectedStale: selectStaleTime(\n          prerenderStore !== null ? prerenderStore.stale : INFINITE_CACHE\n        ),\n        collectedTags: prerenderStore !== null ? prerenderStore.tags : null,\n      }\n    } catch (finalErr: any) {\n      if (\n        process.env.NODE_ENV === 'development' &&\n        isHTTPAccessFallbackError(finalErr)\n      ) {\n        const { bailOnRootNotFound } =\n          require('../../client/components/dev-root-http-access-fallback-boundary') as typeof import('../../client/components/dev-root-http-access-fallback-boundary')\n        bailOnRootNotFound()\n      }\n      throw finalErr\n    }\n  }\n}\n\nconst getGlobalErrorStyles = async (\n  tree: LoaderTree,\n  ctx: AppRenderContext\n): Promise<{\n  GlobalError: GlobalErrorComponent\n  styles: ReactNode | undefined\n}> => {\n  const globalErrorModule = parseLoaderTree(tree).modules['global-error']\n\n  if (!globalErrorModule) {\n    throw new Error(\n      'Invariant: global-error module is required but not found in loader tree'\n    )\n  }\n\n  const {\n    componentMod: { createElement },\n  } = ctx\n\n  // Get the GlobalError component and styles from the loader tree\n  const [GlobalErrorComponent, styles] = await createComponentStylesAndScripts({\n    ctx,\n    filePath: globalErrorModule[1],\n    getComponent: globalErrorModule[0],\n    injectedCSS: new Set(),\n    injectedJS: new Set(),\n  })\n\n  let globalErrorStyles: ReactNode = styles\n\n  if (ctx.renderOpts.dev) {\n    const dir =\n      (process.env.NEXT_RUNTIME === 'edge'\n        ? process.env.__NEXT_EDGE_PROJECT_DIR\n        : ctx.renderOpts.dir) || ''\n\n    const globalErrorModulePath = normalizeConventionFilePath(\n      dir,\n      globalErrorModule[1]\n    )\n    if (globalErrorModulePath) {\n      const SegmentViewNode = ctx.componentMod.SegmentViewNode\n      globalErrorStyles =\n        // This will be rendered next to GlobalError component under ErrorBoundary,\n        // it requires a key to avoid React warning about duplicate keys.\n        createElement(\n          SegmentViewNode,\n          {\n            key: 'ge-svn',\n            type: 'global-error',\n            pagePath: globalErrorModulePath,\n          },\n          globalErrorStyles\n        )\n    }\n  }\n\n  return {\n    GlobalError: GlobalErrorComponent,\n    styles: globalErrorStyles,\n  }\n}\n\nfunction createSelectStaleTime(experimental: ExperimentalConfig) {\n  return (stale: number) =>\n    stale === INFINITE_CACHE &&\n    typeof experimental.staleTimes?.static === 'number'\n      ? experimental.staleTimes.static\n      : stale\n}\n\nasync function collectSegmentData(\n  fullPageDataBuffer: Buffer,\n  prerenderStore: PrerenderStore,\n  ComponentMod: AppPageModule,\n  renderOpts: RenderOpts\n): Promise<Map<string, Buffer> | undefined> {\n  // Per-segment prefetch data\n  //\n  // All of the segments for a page are generated simultaneously, including\n  // during revalidations. This is to ensure consistency, because it's\n  // possible for a mismatch between a layout and page segment can cause the\n  // client to error during rendering. We want to preserve the ability of the\n  // client to recover from such a mismatch by re-requesting all the segments\n  // to get a consistent view of the page.\n  //\n  // For performance, we reuse the Flight output that was created when\n  // generating the initial page HTML. The Flight stream for the whole page is\n  // decomposed into a separate stream per segment.\n\n  const { clientModules, edgeRscModuleMapping, rscModuleMapping } =\n    getClientReferenceManifest()\n\n  // Manifest passed to the Flight client for reading the full-page Flight\n  // stream. Based off similar code in use-cache-wrapper.ts.\n  const isEdgeRuntime = process.env.NEXT_RUNTIME === 'edge'\n  const serverConsumerManifest = {\n    // moduleLoading must be null because we don't want to trigger preloads of ClientReferences\n    // to be added to the consumer. Instead, we'll wait for any ClientReference to be emitted\n    // which themselves will handle the preloading.\n    moduleLoading: null,\n    moduleMap: isEdgeRuntime ? edgeRscModuleMapping : rscModuleMapping,\n    serverModuleMap: getServerModuleMap(),\n  }\n\n  const selectStaleTime = createSelectStaleTime(renderOpts.experimental)\n  const staleTime = selectStaleTime(prerenderStore.stale)\n  return await ComponentMod.collectSegmentData(\n    renderOpts.cacheComponents,\n    fullPageDataBuffer,\n    staleTime,\n    clientModules,\n    serverConsumerManifest\n  )\n}\n\nfunction isBypassingCachesInDev(\n  renderOpts: RenderOpts,\n  requestStore: RequestStore\n): boolean {\n  return (\n    process.env.NODE_ENV === 'development' &&\n    !!renderOpts.dev &&\n    requestStore.headers.get('cache-control') === 'no-cache'\n  )\n}\n\nfunction WarnForBypassCachesInDev({ route }: { route: string }) {\n  warnOnce(\n    `Route ${route} is rendering with server caches disabled. For this navigation, Component Metadata in React DevTools will not accurately reflect what is statically prerenderable and runtime prefetchable. See more info here: https://nextjs.org/docs/messages/cache-bypass-in-dev`\n  )\n  return null\n}\n\nfunction nodeStreamFromReadableStream<T>(stream: ReadableStream<T>) {\n  if (process.env.NEXT_RUNTIME === 'edge') {\n    throw new InvariantError(\n      'nodeStreamFromReadableStream cannot be used in the edge runtime'\n    )\n  } else {\n    const reader = stream.getReader()\n\n    const { Readable } = require('node:stream') as typeof import('node:stream')\n\n    return new Readable({\n      read() {\n        reader\n          .read()\n          .then(({ done, value }) => {\n            if (done) {\n              this.push(null)\n            } else {\n              this.push(value)\n            }\n          })\n          .catch((err) => this.destroy(err))\n      },\n    })\n  }\n}\n\nfunction createNodeStreamFromChunks(\n  partialChunks: Array<Uint8Array>,\n  allChunks: Array<Uint8Array>,\n  signal: AbortSignal\n): Readable {\n  if (process.env.NEXT_RUNTIME === 'edge') {\n    throw new InvariantError(\n      'createNodeStreamFromChunks cannot be used in the edge runtime'\n    )\n  } else {\n    const { Readable } = require('node:stream') as typeof import('node:stream')\n\n    let nextIndex = 0\n\n    const readable = new Readable({\n      read() {\n        while (nextIndex < partialChunks.length) {\n          this.push(partialChunks[nextIndex])\n          nextIndex++\n        }\n      },\n    })\n\n    signal.addEventListener(\n      'abort',\n      () => {\n        // Flush any remaining chunks from the original set\n        while (nextIndex < partialChunks.length) {\n          readable.push(partialChunks[nextIndex])\n          nextIndex++\n        }\n        // Flush all chunks since we're now aborted and can't schedule\n        // any new work but these chunks might unblock debugInfo\n        while (nextIndex < allChunks.length) {\n          readable.push(allChunks[nextIndex])\n          nextIndex++\n        }\n\n        setImmediate(() => {\n          readable.push(null)\n        })\n      },\n      { once: true }\n    )\n\n    return readable\n  }\n}\n"],"names":["renderToHTMLOrFlight","flightDataPathHeadKey","getFlightViewportKey","requestId","getFlightMetadataKey","filterStackFrame","process","env","NODE_ENV","require","filterStackFrameDEV","undefined","parseRequestHeaders","headers","options","isPrefetchRequest","NEXT_ROUTER_PREFETCH_HEADER","isRuntimePrefetchRequest","isHmrRefresh","NEXT_HMR_REFRESH_HEADER","isRSCRequest","RSC_HEADER","shouldProvideFlightRouterState","isRoutePPREnabled","flightRouterState","parseAndValidateFlightRouterState","NEXT_ROUTER_STATE_TREE_HEADER","isRouteTreePrefetchRequest","NEXT_ROUTER_SEGMENT_PREFETCH_HEADER","csp","nonce","getScriptNonceFromHeader","previouslyRevalidatedTags","getPreviouslyRevalidatedTags","previewModeId","htmlRequestId","NEXT_REQUEST_ID_HEADER","NEXT_HTML_REQUEST_ID_HEADER","createNotFoundLoaderTree","loaderTree","components","hasGlobalNotFound","notFoundTreeComponents","layout","page","children","PAGE_SEGMENT_KEY","makeGetDynamicParamFromSegment","interpolatedParams","fallbackRouteParams","optimisticRouting","getDynamicParamFromSegment","segment","staticSiblings","segmentParam","getSegmentParam","segmentKey","paramName","dynamicParamType","dynamicParamTypes","paramType","siblings","getDynamicParam","NonIndex","createElement","pagePath","statusCode","isPossibleServerAction","is404Page","isInvalidStatusCode","name","content","generateDynamicRSCPayload","ctx","flightData","componentMod","routeModule","userland","createMetadataComponents","Fragment","query","workStore","url","serveStreamingMetadata","renderOpts","skipPageRendering","preloadCallbacks","Viewport","Metadata","MetadataOutlet","tree","parsedQuery","pathname","metadataContext","createMetadataContext","walkTreeWithFlightRouterState","loaderTreeToFilter","parentParams","rscHead","key","res","injectedCSS","Set","injectedJS","injectedFontPreloadTags","rootLayoutIncluded","map","path","slice","varyHeader","getHeader","couldBeIntercepted","includes","NEXT_URL","actionResult","a","f","b","sharedContext","buildId","q","getRenderedSearch","i","baseResponse","S","isStaticGeneration","h","getMetadataVaryParamsThenable","runtimePrefetchSentinel","rp","createErrorContext","renderSource","routerKind","routePath","routeType","revalidateReason","getRevalidateReason","generateDynamicFlightRenderResult","req","requestStore","renderToReadableStream","dev","onInstrumentationRequestError","setReactDebugChannel","isBuildTimePrerendering","onFlightDataRenderError","err","silenceLog","onError","createReactServerErrorHandler","reactServerErrorsByDigest","debugChannel","createDebugChannel","clientSide","clientModules","getClientReferenceManifest","rscPayload","workUnitAsyncStorage","run","flightReadableStream","temporaryReferences","serverSide","FlightRenderResult","fetchMetrics","waitUntil","stagedRenderToReadableStreamWithoutCachesInDev","getPayload","hasRuntimePrefetch","abortSignal","stageController","StagedRenderingController","environmentName","currentStage","RenderStage","Before","Static","Runtime","Dynamic","Abandoned","InvariantError","stagedRendering","asyncApiPromises","createAsyncApiPromisesInDev","cookies","mutableCookies","scheduleInSequentialTasks","advanceStage","generateDynamicFlightRenderResultWithStagesInDev","initialRequestStore","createRequestStore","devFallbackParams","setCacheStatus","shouldValidate","isBypassingCachesInDev","payload","_bypassCachesInDev","WarnForBypassCachesInDev","route","c","prepareInitialCanonicalUrl","stream","serverStream","accumulatedChunksPromise","staticInterruptReason","runtimeInterruptReason","staticStageEndTime","runtimeStageEndTime","returnedDebugChannel","finalRequestStore","renderWithRestartOnCacheMissInDev","validationDebugChannelClient","t1","t2","readable","tee","nodeStreamFromReadableStream","consoleAsyncStorage","dim","spawnStaticShellValidationInDev","generateRuntimePrefetchResult","metadata","Math","floor","random","Number","MAX_SAFE_INTEGER","generatePayload","rootParams","getRootParams","prerenderResumeDataCache","createPrerenderResumeDataCache","renderResumeDataCache","prospectiveRuntimeServerPrerender","draftMode","response","finalRuntimeServerPrerender","applyMetadataFromPrerenderResult","result","prelude","implicitTags","ComponentMod","initialServerPrerenderController","AbortController","initialServerRenderController","cacheSignal","CacheSignal","initialServerPrerenderStore","type","phase","renderSignal","signal","controller","dynamicTracking","revalidate","expire","stale","INFINITE_CACHE","tags","hmrRefreshHash","varyParamsAccumulator","runtimeStagePromise","initialServerPayload","pendingInitialServerResult","prerender","digest","getDigestForWellKnownError","aborted","NEXT_DEBUG_BUILD","__NEXT_VERBOSE_LOGGING","printDebugThrownValueForProspectiveRender","Phase","ProspectiveRender","trackPendingModules","cacheReady","abort","invalidDynamicUsageError","createReactServerPrerenderResult","createRuntimePrefetchTransformStream","sentinel","isPartial","staleTime","encoder","TextEncoder","search","encode","first","replace","searchLen","length","currentChunk","found","processChunk","nextChunk","enqueue","exclusiveUpperBound","min","currentIndex","indexOf","candidateLoop","matchIndex","candidateIndex","candidateValue","subarray","overflowBytes","truncatedChunk","TransformStream","transform","chunk","flush","experimental","isDebugDynamicAccesses","selectStaleTime","createSelectStaleTime","serverIsDynamic","finalServerController","serverDynamicTracking","createDynamicTrackingState","promise","resolve","resolveBlockedRuntimeAPIs","createPromiseWithResolvers","finalServerPrerenderStore","finalRSCPayload","prerenderIsPending","prerenderAndAbortInSequentialTasksWithStages","prerenderResult","collectedStale","pipeThrough","dynamicAccess","collectedRevalidate","collectedExpire","collectedTags","split","pairs","value","Array","isArray","v","push","encodeURIComponent","String","join","getRSCPayload","is404","missingSlots","appUsingSizeAdjustment","initialTree","createFlightRouterStateFromLoaderTree","errorType","seedData","createComponentTree","authInterrupts","initialHead","GlobalError","styles","globalErrorStyles","getGlobalErrorStyles","isPossiblyPartialHead","P","Preloads","m","G","forEach","preloadFn","getErrorRSCPayload","ssrError","isError","Error","id","message","stack","App","reactServerStream","reactDebugStream","debugEndTime","preinitScripts","ServerInsertedHTMLProvider","images","ReactClient","use","getFlightStream","initialState","createInitialRouterState","navigatedAt","initialFlightData","initialCanonicalUrlParts","initialRenderedSearch","initialCouldBeIntercepted","initialPrerendered","location","actionQueue","createMutableActionQueue","HeadManagerContext","Provider","appDir","ImageConfigContext","imageConfigDefault","AppRouter","globalErrorState","ErrorApp","renderToHTMLOrFlightImpl","parsedRequestHeaders","postponedState","serverComponentsHmrCache","isNotFoundPath","requestTimestamp","Date","now","nextFontManifest","serverActions","assetPrefix","enableTainting","cacheComponents","__next_app__","instrumented","wrapClientComponentLoader","shouldTrackModuleLoading","workUnitStore","getStore","__next_require__","args","exportsOrPromise","trackPendingImport","globalThis","__next_chunk_load__","loadingChunk","loadChunk","trackPendingChunkLoad","setIsrStatus","URL","NEXT_RUNTIME","isNodeNextRequest","onClose","shouldTrackFetchMetrics","originalRequest","on","metrics","getClientComponentLoaderMetrics","reset","getTracer","startSpan","NextNodeServerSpan","clientComponentLoading","startTime","clientComponentLoadStart","attributes","clientComponentLoadCount","end","clientComponentLoadTimes","appUsingSizeAdjust","patchFetch","taintObjectReference","stripInternalQueries","Buffer","from","crypto","subtle","toString","randomUUID","nanoid","isPossibleActionRequest","getIsPossibleServerAction","resolvedPathname","getRequestMeta","getImplicitTags","isPrefetch","setRootSpanAttribute","prerenderToStreamWithTracing","wrap","AppRenderSpan","getBodyResult","spanName","prerenderToStream","accessedDynamicData","warn","access","formatDynamicAPIAccesses","logDisallowedDynamicError","StaticGenBailoutError","digestErrorsMap","size","buildFailingError","values","next","ssrErrors","find","isUserLandError","contentType","HTML_CONTENT_TYPE_HEADER","maybeRevalidatesPromise","executeRevalidates","revalidatesPromise","finally","NEXT_PRIVATE_DEBUG_CACHE","console","log","href","RenderResult","streamToString","createRequestStoreForRender","bind","onUpdateCookies","previewProps","isStatic","usedDynamic","forceDynamic","didExecuteServerAction","formState","actionRequestResult","handleAction","generateFlight","notFoundLoaderTree","renderToStream","assignMetadata","parseRelativeUrl","postponed","interpolateParallelRouteParams","params","parsePostponedState","maxPostponedStateSizeBytes","createWorkStore","definition","workAsyncStorage","fetchTags","staleHeader","NEXT_ROUTER_STALE_TIME_HEADER","forceStatic","cacheControl","staticBailoutInfo","description","dynamicUsageDescription","dynamicUsageStack","basePath","buildManifest","serverRenderToReadableStream","crossOrigin","reactMaxHeadersLength","shouldWaitOnAllReady","subresourceIntegrityManifest","supportsDynamicResponse","renderServerInsertedHTML","createServerInsertedHTML","getServerInsertedMetadata","createServerInsertedMetadata","tracingMetadata","getTracedMetadata","getTracePropagationData","clientTraceMetadata","polyfills","polyfillFiles","filter","polyfill","endsWith","src","getAssetQueryString","integrity","noModule","bootstrapScript","getRequiredScripts","bootstrapScriptContent","JSON","stringify","renderSpan","endSpanWithError","isRecording","recordException","setAttribute","setStatus","code","SpanStatusCode","ERROR","withSpan","onHTMLRenderRSCError","serverComponentsErrorHandler","onHTMLRenderSSRError","allCapturedErrors","htmlRendererErrorHandler","createHTMLErrorHandler","reactServerResult","setHeader","appendHeader","ReactServerResult","readableSsr","readableBrowser","RSCPayload","waitAtLeastOneReactRenderTask","DynamicState","DATA","inlinedReactServerDataStream","createInlinedDataReadableStream","chainStreams","createDocumentClosingStream","preludeState","getPostponedFromState","resume","htmlStream","allReady","getServerInsertedHTML","makeGetServerInsertedHTML","serverCapturedErrors","continueDynamicHTMLResume","delayDataUntilFirstHtmlChunk","DynamicHTMLPreludeState","Empty","inlinedDataStream","consume","deploymentId","onHeaders","maxHeadersLength","bootstrapScripts","generateStaticHTML","continueFizzStream","validateRootLayout","isStaticGenBailoutError","shouldBailoutToCSR","isBailoutToCSRError","getStackWithoutErrorMessage","error","reason","isHTTPAccessFallbackError","getAccessFallbackHTTPStatus","getAccessFallbackErrorTypeByStatus","isRedirectError","getRedirectStatusCodeFromError","redirectUrl","addPathPrefix","getURLFromRedirectError","Headers","appendMutableCookies","errorPreinitScripts","errorBootstrapScript","errorRSCPayload","errorServerStream","has","setupErr","fizzStream","renderToInitialFizzStream","ReactDOMServer","element","streamOptions","finalErr","bailOnRootNotFound","anySegmentHasRuntimePrefetchEnabled","initialReactController","initialDataController","initialStageController","initialRscPayload","maybeInitialStreamResult","pipelineInSequentialTasks","addEventListener","continuationStream","accumulatingStream","accumulateStreamChunks","hasPendingReads","abandonRender","getStaticInterruptReason","getRuntimeInterruptReason","getStaticStageEndTime","getRuntimeStageEndTime","finalStageController","createRenderResumeDataCache","finalRscPayload","finalStreamResult","staticChunks","runtimeChunks","dynamicChunks","reader","getReader","cancelled","cancel","once","done","read","delayUntilStage","sharedParamsParent","sharedSearchParamsParent","connection","readableController","clientSideReadable","ReadableStream","start","writable","WritableStream","write","close","logMessagesAndSendErrorsToBrowser","messages","sendErrorsToBrowser","errors","exit","errorsRscStream","debugChannelClient","allowEmptyStaticShell","getHmrRefreshHash","warmupModuleCacheForRuntimeValidationInDev","debugChunks","runtimeResult","validateStagedShell","trackDynamicHoleInRuntimeShell","staticResult","trackDynamicHoleInStaticShell","runtimeServerChunks","allServerChunks","initialClientPrerenderController","initialClientReactController","initialClientRenderController","initialClientPrerenderStore","runtimeServerStream","createNodeStreamFromChunks","pendingInitialClientResult","isReactLargeShellError","catch","isPrerenderInterruptedError","stageChunks","trackDynamicHole","clientDynamicTracking","clientReactController","clientRenderController","finalClientPrerenderStore","runtimeDynamicValidation","createDynamicValidationState","unprocessedPrelude","prerenderAndAbortInSequentialTasks","pendingFinalClientResult","errorInfo","componentStack","preludeIsEmpty","processPrelude","getStaticShellDisallowedDynamicReasons","PreludeState","Full","thrownValue","Errored","unshift","shouldGenerateStaticFlightData","reportErrors","reactServerPrerenderResult","setMetadataHeader","item","prerenderStore","initialServerReactController","initialServerPayloadPrerenderStore","initialServerResult","asUnclosingStream","finalServerReactController","finalServerRenderController","createResponseVaryParamsAccumulator","finalServerPayloadPrerenderStore","finalAttemptRSCPayload","pendingPrerenderResult","finishAccumulatingVaryParams","finalClientReactController","finalClientRenderController","dynamicValidation","trackAllowedDynamicAccess","throwIfDisallowedDynamic","streamToBuffer","asStream","segmentData","collectSegmentData","getDynamicHTMLPostponedState","getDynamicDataPostponedState","continueDynamicPrerender","consumeDynamicAccess","foreverStream","resumeStream","parse","createRenderInBrowserAbortSignal","finalStream","hasFallbackRouteParams","emptyReactServerResult","createReactServerPrerenderResultFromRender","continueStaticFallbackPrerender","consumeAsStream","continueStaticPrerender","reactServerPrerenderStore","ssrPrerenderStore","dynamicAccesses","prerenderLegacyStore","isDynamicServerError","flightStream","globalErrorModule","parseLoaderTree","modules","GlobalErrorComponent","createComponentStylesAndScripts","filePath","getComponent","dir","__NEXT_EDGE_PROJECT_DIR","globalErrorModulePath","normalizeConventionFilePath","SegmentViewNode","staleTimes","static","fullPageDataBuffer","edgeRscModuleMapping","rscModuleMapping","isEdgeRuntime","serverConsumerManifest","moduleLoading","moduleMap","serverModuleMap","getServerModuleMap","get","warnOnce","Readable","then","destroy","partialChunks","allChunks","nextIndex","setImmediate"],"mappings":"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","ignoreList":[0]}