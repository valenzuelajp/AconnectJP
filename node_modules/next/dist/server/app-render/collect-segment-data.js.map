{"version":3,"sources":["../../../src/server/app-render/collect-segment-data.tsx"],"sourcesContent":["/* eslint-disable @next/internal/no-ambiguous-jsx -- Bundled in entry-base so it gets the right JSX runtime. */\nimport type {\n  CacheNodeSeedData,\n  FlightRouterState,\n  InitialRSCPayload,\n  DynamicParamTypesShort,\n  HeadData,\n} from '../../shared/lib/app-router-types'\nimport { readVaryParams } from '../../shared/lib/segment-cache/vary-params-decoding'\nimport type { ManifestNode } from '../../build/webpack/plugins/flight-manifest-plugin'\n\n// eslint-disable-next-line import/no-extraneous-dependencies\nimport { createFromReadableStream } from 'react-server-dom-webpack/client'\n// eslint-disable-next-line import/no-extraneous-dependencies\nimport { prerender } from 'react-server-dom-webpack/static'\n\nimport {\n  streamFromBuffer,\n  streamToBuffer,\n} from '../stream-utils/node-web-streams-helper'\nimport { waitAtLeastOneReactRenderTask } from '../../lib/scheduler'\nimport {\n  type SegmentRequestKey,\n  createSegmentRequestKeyPart,\n  appendSegmentRequestKeyPart,\n  ROOT_SEGMENT_REQUEST_KEY,\n  HEAD_REQUEST_KEY,\n} from '../../shared/lib/segment-cache/segment-value-encoding'\nimport { getDigestForWellKnownError } from './create-error-handler'\nimport {\n  Phase,\n  printDebugThrownValueForProspectiveRender,\n} from './prospective-render-utils'\nimport { workAsyncStorage } from './work-async-storage.external'\n\n// Contains metadata about the route tree. The client must fetch this before\n// it can fetch any actual segment data.\nexport type RootTreePrefetch = {\n  buildId: string\n  tree: TreePrefetch\n  staleTime: number\n}\n\nexport type TreePrefetchParam = {\n  type: DynamicParamTypesShort\n  // When cacheComponents is enabled, this field is always null.\n  // Instead we parse the param on the client, allowing us to omit it from\n  // the prefetch response and increase its cacheability.\n  key: string | null\n  // Static sibling segments at the same URL level. Used by the client\n  // router to determine if a prefetch can be reused when navigating to\n  // a static sibling of a dynamic route. For example, if the route is\n  // /products/[id] and there's also /products/sale, then siblings\n  // would be ['sale']. null means the siblings are unknown (e.g. in\n  // webpack dev mode).\n  siblings: readonly string[] | null\n}\n\nexport type TreePrefetch = {\n  name: string\n  // Only present for parameterized (dynamic) segments.\n  param: TreePrefetchParam | null\n\n  // Child segments.\n  slots: null | {\n    [parallelRouteKey: string]: TreePrefetch\n  }\n\n  /** Whether this segment should be fetched using a runtime prefetch */\n  hasRuntimePrefetch: boolean\n\n  // Extra fields that only exist so we can reconstruct a FlightRouterState on\n  // the client. We may be able to unify TreePrefetch and FlightRouterState\n  // after some refactoring, but in the meantime it would be wasteful to add a\n  // bunch of new prefetch-only fields to FlightRouterState. So think of\n  // TreePrefetch as a superset of FlightRouterState.\n  isRootLayout: boolean\n}\n\nexport type SegmentPrefetch = {\n  buildId: string\n  rsc: React.ReactNode | null\n  isPartial: boolean\n  staleTime: number\n  /**\n   * The set of params that this segment's output depends on. Used by the client\n   * cache to determine which entries can be reused across different param\n   * values.\n   * - `null` means vary params were not tracked (conservative: assume all\n   *   params matter)\n   * - Empty set means no params were accessed (segment is reusable for any\n   *   param values)\n   */\n  varyParams: Set<string> | null\n}\n\nconst filterStackFrame =\n  process.env.NODE_ENV !== 'production'\n    ? (require('../lib/source-maps') as typeof import('../lib/source-maps'))\n        .filterStackFrameDEV\n    : undefined\nconst findSourceMapURL =\n  process.env.NODE_ENV !== 'production'\n    ? (require('../lib/source-maps') as typeof import('../lib/source-maps'))\n        .findSourceMapURLDEV\n    : undefined\n\nfunction onSegmentPrerenderError(error: unknown) {\n  const digest = getDigestForWellKnownError(error)\n  if (digest) {\n    return digest\n  }\n  // We don't need to log the errors because we would have already done that\n  // when generating the original Flight stream for the whole page.\n  if (process.env.NEXT_DEBUG_BUILD || process.env.__NEXT_VERBOSE_LOGGING) {\n    const workStore = workAsyncStorage.getStore()\n    printDebugThrownValueForProspectiveRender(\n      error,\n      workStore?.route ?? 'unknown route',\n      Phase.SegmentCollection\n    )\n  }\n}\n\nexport async function collectSegmentData(\n  isCacheComponentsEnabled: boolean,\n  fullPageDataBuffer: Buffer,\n  staleTime: number,\n  clientModules: ManifestNode,\n  serverConsumerManifest: any\n): Promise<Map<SegmentRequestKey, Buffer>> {\n  // Traverse the router tree and generate a prefetch response for each segment.\n\n  // A mutable map to collect the results as we traverse the route tree.\n  const resultMap = new Map<SegmentRequestKey, Buffer>()\n\n  // Before we start, warm up the module cache by decoding the page data once.\n  // Then we can assume that any remaining async tasks that occur the next time\n  // are due to hanging promises caused by dynamic data access. Note we only\n  // have to do this once per page, not per individual segment.\n  //\n  try {\n    await createFromReadableStream(streamFromBuffer(fullPageDataBuffer), {\n      findSourceMapURL,\n      serverConsumerManifest,\n    })\n    await waitAtLeastOneReactRenderTask()\n  } catch {}\n\n  // Create an abort controller that we'll use to stop the stream.\n  const abortController = new AbortController()\n  const onCompletedProcessingRouteTree = async () => {\n    // Since all we're doing is decoding and re-encoding a cached prerender, if\n    // serializing the stream takes longer than a microtask, it must because of\n    // hanging promises caused by dynamic data.\n    await waitAtLeastOneReactRenderTask()\n    abortController.abort()\n  }\n\n  // Generate a stream for the route tree prefetch. While we're walking the\n  // tree, we'll also spawn additional tasks to generate the segment prefetches.\n  // The promises for these tasks are pushed to a mutable array that we will\n  // await once the route tree is fully rendered.\n  const segmentTasks: Array<Promise<[SegmentRequestKey, Buffer]>> = []\n  const { prelude: treeStream } = await prerender(\n    // RootTreePrefetch is not a valid return type for a React component, but\n    // we need to use a component so that when we decode the original stream\n    // inside of it, the side effects are transferred to the new stream.\n    // @ts-expect-error\n    <PrefetchTreeData\n      isClientParamParsingEnabled={isCacheComponentsEnabled}\n      fullPageDataBuffer={fullPageDataBuffer}\n      serverConsumerManifest={serverConsumerManifest}\n      clientModules={clientModules}\n      staleTime={staleTime}\n      segmentTasks={segmentTasks}\n      onCompletedProcessingRouteTree={onCompletedProcessingRouteTree}\n    />,\n    clientModules,\n    {\n      filterStackFrame,\n      signal: abortController.signal,\n      onError: onSegmentPrerenderError,\n    }\n  )\n\n  // Write the route tree to a special `/_tree` segment.\n  const treeBuffer = await streamToBuffer(treeStream)\n  resultMap.set('/_tree' as SegmentRequestKey, treeBuffer)\n\n  // Also output the entire full page data response\n  resultMap.set('/_full' as SegmentRequestKey, fullPageDataBuffer)\n\n  // Now that we've finished rendering the route tree, all the segment tasks\n  // should have been spawned. Await them in parallel and write the segment\n  // prefetches to the result map.\n  for (const [segmentPath, buffer] of await Promise.all(segmentTasks)) {\n    resultMap.set(segmentPath, buffer)\n  }\n\n  return resultMap\n}\n\nasync function PrefetchTreeData({\n  isClientParamParsingEnabled,\n  fullPageDataBuffer,\n  serverConsumerManifest,\n  clientModules,\n  staleTime,\n  segmentTasks,\n  onCompletedProcessingRouteTree,\n}: {\n  isClientParamParsingEnabled: boolean\n  fullPageDataBuffer: Buffer\n  serverConsumerManifest: any\n  clientModules: ManifestNode\n  staleTime: number\n  segmentTasks: Array<Promise<[SegmentRequestKey, Buffer]>>\n  onCompletedProcessingRouteTree: () => void\n}): Promise<RootTreePrefetch | null> {\n  // We're currently rendering a Flight response for the route tree prefetch.\n  // Inside this component, decode the Flight stream for the whole page. This is\n  // a hack to transfer the side effects from the original Flight stream (e.g.\n  // Float preloads) onto the Flight stream for the tree prefetch.\n  // TODO: React needs a better way to do this. Needed for Server Actions, too.\n  const initialRSCPayload: InitialRSCPayload = await createFromReadableStream(\n    createUnclosingPrefetchStream(streamFromBuffer(fullPageDataBuffer)),\n    {\n      findSourceMapURL,\n      serverConsumerManifest,\n    }\n  )\n\n  const buildId = initialRSCPayload.b\n\n  // FlightDataPath is an unsound type, hence the additional checks.\n  const flightDataPaths = initialRSCPayload.f\n  if (flightDataPaths.length !== 1 && flightDataPaths[0].length !== 3) {\n    console.error(\n      'Internal Next.js error: InitialRSCPayload does not match the expected ' +\n        'shape for a prerendered page during segment prefetch generation.'\n    )\n    return null\n  }\n  const flightRouterState: FlightRouterState = flightDataPaths[0][0]\n  const seedData: CacheNodeSeedData = flightDataPaths[0][1]\n  const head: HeadData = flightDataPaths[0][2]\n\n  // Extract the head vary params from the decoded response.\n  // The head vary params thenable should be fulfilled by now; if not, treat\n  // as unknown (null).\n  const headVaryParamsThenable = initialRSCPayload.h\n  const headVaryParams =\n    headVaryParamsThenable !== null\n      ? readVaryParams(headVaryParamsThenable)\n      : null\n\n  // Compute the route metadata tree by traversing the FlightRouterState. As we\n  // walk the tree, we will also spawn a task to produce a prefetch response for\n  // each segment.\n  const tree = collectSegmentDataImpl(\n    isClientParamParsingEnabled,\n    flightRouterState,\n    buildId,\n    staleTime,\n    seedData,\n    clientModules,\n    ROOT_SEGMENT_REQUEST_KEY,\n    segmentTasks\n  )\n\n  // Also spawn a task to produce a prefetch response for the \"head\" segment.\n  // The head contains metadata, like the title; it's not really a route\n  // segment, but it contains RSC data, so it's treated like a segment by\n  // the client cache.\n  segmentTasks.push(\n    waitAtLeastOneReactRenderTask().then(() =>\n      renderSegmentPrefetch(\n        buildId,\n        staleTime,\n        head,\n        HEAD_REQUEST_KEY,\n        headVaryParams,\n        clientModules\n      )\n    )\n  )\n\n  // Notify the abort controller that we're done processing the route tree.\n  // Anything async that happens after this point must be due to hanging\n  // promises in the original stream.\n  onCompletedProcessingRouteTree()\n\n  // Render the route tree to a special `/_tree` segment.\n  const treePrefetch: RootTreePrefetch = {\n    buildId,\n    tree,\n    staleTime,\n  }\n  return treePrefetch\n}\n\nfunction collectSegmentDataImpl(\n  isClientParamParsingEnabled: boolean,\n  route: FlightRouterState,\n  buildId: string,\n  staleTime: number,\n  seedData: CacheNodeSeedData | null,\n  clientModules: ManifestNode,\n  requestKey: SegmentRequestKey,\n  segmentTasks: Array<Promise<[string, Buffer]>>\n): TreePrefetch {\n  // Metadata about the segment. Sent as part of the tree prefetch. Null if\n  // there are no children.\n  let slotMetadata: { [parallelRouteKey: string]: TreePrefetch } | null = null\n\n  const children = route[1]\n  const seedDataChildren = seedData !== null ? seedData[1] : null\n  for (const parallelRouteKey in children) {\n    const childRoute = children[parallelRouteKey]\n    const childSegment = childRoute[0]\n    const childSeedData =\n      seedDataChildren !== null ? seedDataChildren[parallelRouteKey] : null\n\n    const childRequestKey = appendSegmentRequestKeyPart(\n      requestKey,\n      parallelRouteKey,\n      createSegmentRequestKeyPart(childSegment)\n    )\n    const childTree = collectSegmentDataImpl(\n      isClientParamParsingEnabled,\n      childRoute,\n      buildId,\n      staleTime,\n      childSeedData,\n      clientModules,\n      childRequestKey,\n      segmentTasks\n    )\n    if (slotMetadata === null) {\n      slotMetadata = {}\n    }\n    slotMetadata[parallelRouteKey] = childTree\n  }\n\n  const hasRuntimePrefetch = seedData !== null ? seedData[4] : false\n\n  // Determine which params this segment varies on.\n  // Read the vary params thenable directly from the seed data. By the time\n  // collectSegmentData runs, the thenable should be fulfilled. If it's not\n  // fulfilled or null, treat as unknown (null means we can't share cache\n  // entries across param values).\n  const varyParamsThenable = seedData !== null ? seedData[5] : null\n  const varyParams =\n    varyParamsThenable !== null ? readVaryParams(varyParamsThenable) : null\n\n  if (seedData !== null) {\n    // Spawn a task to write the segment data to a new Flight stream.\n    segmentTasks.push(\n      // Since we're already in the middle of a render, wait until after the\n      // current task to escape the current rendering context.\n      waitAtLeastOneReactRenderTask().then(() =>\n        renderSegmentPrefetch(\n          buildId,\n          staleTime,\n          seedData[0],\n          requestKey,\n          varyParams,\n          clientModules\n        )\n      )\n    )\n  } else {\n    // This segment does not have any seed data. Skip generating a prefetch\n    // response for it. We'll still include it in the route tree, though.\n    // TODO: We should encode in the route tree whether a segment is missing\n    // so we don't attempt to fetch it for no reason. As of now this shouldn't\n    // ever happen in practice, though.\n  }\n\n  const segment = route[0]\n  let name: string\n  let param: TreePrefetchParam | null\n  if (typeof segment === 'string') {\n    name = segment\n    param = null\n  } else {\n    name = segment[0]\n    param = {\n      type: segment[2],\n      // This value is omitted from the prefetch response when cacheComponents\n      // is enabled.\n      key: isClientParamParsingEnabled ? null : segment[1],\n      siblings: segment[3],\n    }\n  }\n\n  // Metadata about the segment. Sent to the client as part of the\n  // tree prefetch.\n  return {\n    name,\n    param,\n    hasRuntimePrefetch,\n    slots: slotMetadata,\n    isRootLayout: route[4] === true,\n  }\n}\n\nasync function renderSegmentPrefetch(\n  buildId: string,\n  staleTime: number,\n  rsc: React.ReactNode,\n  requestKey: SegmentRequestKey,\n  varyParams: Set<string> | null,\n  clientModules: ManifestNode\n): Promise<[SegmentRequestKey, Buffer]> {\n  // Render the segment data to a stream.\n  const segmentPrefetch: SegmentPrefetch = {\n    buildId,\n    rsc,\n    isPartial: await isPartialRSCData(rsc, clientModules),\n    staleTime,\n    varyParams,\n  }\n  // Since all we're doing is decoding and re-encoding a cached prerender, if\n  // it takes longer than a microtask, it must because of hanging promises\n  // caused by dynamic data. Abort the stream at the end of the current task.\n  const abortController = new AbortController()\n  waitAtLeastOneReactRenderTask().then(() => abortController.abort())\n  const { prelude: segmentStream } = await prerender(\n    segmentPrefetch,\n    clientModules,\n    {\n      filterStackFrame,\n      signal: abortController.signal,\n      onError: onSegmentPrerenderError,\n    }\n  )\n  const segmentBuffer = await streamToBuffer(segmentStream)\n  if (requestKey === ROOT_SEGMENT_REQUEST_KEY) {\n    return ['/_index' as SegmentRequestKey, segmentBuffer]\n  } else {\n    return [requestKey, segmentBuffer]\n  }\n}\n\nasync function isPartialRSCData(\n  rsc: React.ReactNode,\n  clientModules: ManifestNode\n): Promise<boolean> {\n  // We can determine if a segment contains only partial data if it takes longer\n  // than a task to encode, because dynamic data is encoded as an infinite\n  // promise. We must do this in a separate Flight prerender from the one that\n  // actually generates the prefetch stream because we need to include\n  // `isPartial` in the stream itself.\n  let isPartial = false\n  const abortController = new AbortController()\n  waitAtLeastOneReactRenderTask().then(() => {\n    // If we haven't yet finished the outer task, then it must be because we\n    // accessed dynamic data.\n    isPartial = true\n    abortController.abort()\n  })\n  await prerender(rsc, clientModules, {\n    filterStackFrame,\n    signal: abortController.signal,\n    onError() {},\n  })\n  return isPartial\n}\n\nfunction createUnclosingPrefetchStream(\n  originalFlightStream: ReadableStream<Uint8Array>\n): ReadableStream<Uint8Array> {\n  // When PPR is enabled, prefetch streams may contain references that never\n  // resolve, because that's how we encode dynamic data access. In the decoded\n  // object returned by the Flight client, these are reified into hanging\n  // promises that suspend during render, which is effectively what we want.\n  // The UI resolves when it switches to the dynamic data stream\n  // (via useDeferredValue(dynamic, static)).\n  //\n  // However, the Flight implementation currently errors if the server closes\n  // the response before all the references are resolved. As a cheat to work\n  // around this, we wrap the original stream in a new stream that never closes,\n  // and therefore doesn't error.\n  const reader = originalFlightStream.getReader()\n  return new ReadableStream({\n    async pull(controller) {\n      while (true) {\n        const { done, value } = await reader.read()\n        if (!done) {\n          // Pass to the target stream and keep consuming the Flight response\n          // from the server.\n          controller.enqueue(value)\n          continue\n        }\n        // The server stream has closed. Exit, but intentionally do not close\n        // the target stream.\n        return\n      }\n    },\n  })\n}\n"],"names":["collectSegmentData","filterStackFrame","process","env","NODE_ENV","require","filterStackFrameDEV","undefined","findSourceMapURL","findSourceMapURLDEV","onSegmentPrerenderError","error","digest","getDigestForWellKnownError","NEXT_DEBUG_BUILD","__NEXT_VERBOSE_LOGGING","workStore","workAsyncStorage","getStore","printDebugThrownValueForProspectiveRender","route","Phase","SegmentCollection","isCacheComponentsEnabled","fullPageDataBuffer","staleTime","clientModules","serverConsumerManifest","resultMap","Map","createFromReadableStream","streamFromBuffer","waitAtLeastOneReactRenderTask","abortController","AbortController","onCompletedProcessingRouteTree","abort","segmentTasks","prelude","treeStream","prerender","PrefetchTreeData","isClientParamParsingEnabled","signal","onError","treeBuffer","streamToBuffer","set","segmentPath","buffer","Promise","all","initialRSCPayload","createUnclosingPrefetchStream","buildId","b","flightDataPaths","f","length","console","flightRouterState","seedData","head","headVaryParamsThenable","h","headVaryParams","readVaryParams","tree","collectSegmentDataImpl","ROOT_SEGMENT_REQUEST_KEY","push","then","renderSegmentPrefetch","HEAD_REQUEST_KEY","treePrefetch","requestKey","slotMetadata","children","seedDataChildren","parallelRouteKey","childRoute","childSegment","childSeedData","childRequestKey","appendSegmentRequestKeyPart","createSegmentRequestKeyPart","childTree","hasRuntimePrefetch","varyParamsThenable","varyParams","segment","name","param","type","key","siblings","slots","isRootLayout","rsc","segmentPrefetch","isPartial","isPartialRSCData","segmentStream","segmentBuffer","originalFlightStream","reader","getReader","ReadableStream","pull","controller","done","value","read","enqueue"],"mappings":"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","ignoreList":[0]}