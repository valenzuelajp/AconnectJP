{"version":3,"sources":["../../../src/server/dev/log-requests.ts"],"sourcesContent":["import { hrtimeBigIntDurationToString } from '../../build/duration-to-string'\nimport {\n  blue,\n  bold,\n  gray,\n  green,\n  red,\n  white,\n  yellow,\n  dim,\n} from '../../lib/picocolors'\nimport { stripNextRscUnionQuery } from '../../lib/url'\nimport type { FetchMetric } from '../base-http'\nimport type { NodeNextRequest, NodeNextResponse } from '../base-http/node'\nimport type { LoggingConfig } from '../config-shared'\nimport { getRequestMeta, removeRequestMeta } from '../request-meta'\nimport { formatArgs } from './server-action-logger'\n\n/**\n * Returns true if the incoming request should be ignored for logging.\n */\nexport function ignoreLoggingIncomingRequests(\n  request: NodeNextRequest,\n  loggingConfig: LoggingConfig | undefined\n): boolean {\n  // If it's boolean use the boolean value\n  if (typeof loggingConfig?.incomingRequests === 'boolean') {\n    return !loggingConfig.incomingRequests\n  }\n\n  // Any of the value on the chain is falsy, will not ignore the request.\n  const ignore = loggingConfig?.incomingRequests?.ignore\n\n  // If ignore is not set, don't ignore anything\n  if (!ignore) {\n    return false\n  }\n\n  // If array of RegExp, ignore if any pattern matches\n  return ignore.some((pattern) => pattern.test(request.url))\n}\n\nexport function logRequests(\n  request: NodeNextRequest,\n  response: NodeNextResponse,\n  loggingConfig: LoggingConfig,\n  requestStartTime: bigint,\n  requestEndTime: bigint,\n  devRequestTimingMiddlewareStart: bigint | undefined,\n  devRequestTimingMiddlewareEnd: bigint | undefined,\n  devRequestTimingInternalsEnd: bigint | undefined,\n  devGenerateStaticParamsDuration: bigint | undefined\n): void {\n  if (!ignoreLoggingIncomingRequests(request, loggingConfig)) {\n    logIncomingRequests(\n      request,\n      requestStartTime,\n      requestEndTime,\n      response.statusCode,\n      devRequestTimingMiddlewareStart,\n      devRequestTimingMiddlewareEnd,\n      devRequestTimingInternalsEnd,\n      devGenerateStaticParamsDuration\n    )\n\n    // Log server action after the request log\n    const serverActionLog = getRequestMeta(request, 'devServerActionLog')\n    if (serverActionLog) {\n      const argsStr = formatArgs(serverActionLog.args)\n      process.stdout.write(\n        `  └─ ƒ ${serverActionLog.functionName}(${argsStr}) in ${serverActionLog.duration}ms ${dim(serverActionLog.location)}\\n`\n      )\n      removeRequestMeta(request, 'devServerActionLog')\n    }\n  }\n\n  if (request.fetchMetrics) {\n    for (const fetchMetric of request.fetchMetrics) {\n      logFetchMetric(fetchMetric, loggingConfig)\n    }\n  }\n}\n\nfunction logIncomingRequests(\n  request: NodeNextRequest,\n  requestStartTime: bigint,\n  requestEndTime: bigint,\n  statusCode: number,\n  devRequestTimingMiddlewareStart: bigint | undefined,\n  devRequestTimingMiddlewareEnd: bigint | undefined,\n  devRequestTimingInternalsEnd: bigint | undefined,\n  devGenerateStaticParamsDuration: bigint | undefined\n): void {\n  const isRSC = getRequestMeta(request, 'isRSCRequest')\n  const url = isRSC ? stripNextRscUnionQuery(request.url) : request.url\n\n  const statusCodeColor =\n    statusCode < 200\n      ? white\n      : statusCode < 300\n        ? green\n        : statusCode < 400\n          ? blue\n          : statusCode < 500\n            ? yellow\n            : red\n\n  const coloredStatus = statusCodeColor(statusCode.toString())\n\n  const totalRequestTime = requestEndTime - requestStartTime\n\n  const times: Array<[label: string, time: bigint]> = []\n\n  let middlewareTime: bigint | undefined\n  if (devRequestTimingMiddlewareStart && devRequestTimingMiddlewareEnd) {\n    middlewareTime =\n      devRequestTimingMiddlewareEnd - devRequestTimingMiddlewareStart\n    times.push(['proxy.ts', middlewareTime])\n  }\n\n  if (devRequestTimingInternalsEnd) {\n    let frameworkTime = devRequestTimingInternalsEnd - requestStartTime\n\n    /* Middleware runs during the internals so we have to subtract it from the framework time */\n    if (middlewareTime) {\n      frameworkTime -= middlewareTime\n    }\n    // Insert as the first item to be rendered in the list\n    times.unshift(['compile', frameworkTime])\n\n    // Insert after compile, before render based on the execution order.\n    if (devGenerateStaticParamsDuration) {\n      // Pages Router getStaticPaths are technically \"generate params\" as well.\n      times.push(['generate-params', devGenerateStaticParamsDuration])\n    }\n\n    times.push(['render', requestEndTime - devRequestTimingInternalsEnd])\n  }\n\n  return writeLine(\n    `${request.method} ${url} ${coloredStatus} in ${hrtimeBigIntDurationToString(totalRequestTime)}${times.length > 0 ? dim(` (${times.map(([label, time]) => `${label}: ${hrtimeBigIntDurationToString(time)}`).join(', ')})`) : ''}`\n  )\n}\n\nfunction logFetchMetric(\n  fetchMetric: FetchMetric,\n  loggingConfig: LoggingConfig | undefined\n): void {\n  let {\n    cacheReason,\n    cacheStatus,\n    cacheWarning,\n    end,\n    method,\n    start,\n    status,\n    url,\n  } = fetchMetric\n\n  if (cacheStatus === 'hmr' && !loggingConfig?.fetches?.hmrRefreshes) {\n    // Cache hits during HMR refreshes are intentionally not logged, unless\n    // explicitly enabled in the logging config.\n    return\n  }\n\n  if (loggingConfig?.fetches) {\n    if (url.length > 48 && !loggingConfig.fetches.fullUrl) {\n      url = truncateUrl(url)\n    }\n\n    writeLine(\n      white(\n        `${method} ${url} ${status} in ${Math.round(end - start)}ms ${formatCacheStatus(cacheStatus)}`\n      ),\n      1\n    )\n\n    if (cacheStatus === 'skip' || cacheStatus === 'miss') {\n      writeLine(\n        gray(\n          `Cache ${cacheStatus === 'skip' ? 'skipped' : 'missed'} reason: (${white(cacheReason)})`\n        ),\n        2\n      )\n    }\n  } else if (cacheWarning) {\n    // When logging for fetches is not enabled, we still want to print any\n    // associated warnings, so we print the request first to provide context.\n    writeLine(white(`${method} ${url}`), 1)\n  }\n\n  if (cacheWarning) {\n    writeLine(`${yellow(bold('⚠'))} ${white(cacheWarning)}`, 2)\n  }\n}\n\nfunction writeLine(text: string, indentationLevel = 0): void {\n  process.stdout.write(` ${'│ '.repeat(indentationLevel)}${text}\\n`)\n}\n\nfunction truncate(text: string, maxLength: number): string {\n  return maxLength !== undefined && text.length > maxLength\n    ? text.substring(0, maxLength) + '..'\n    : text\n}\n\nfunction truncateUrl(url: string): string {\n  const { protocol, host, pathname, search } = new URL(url)\n\n  return (\n    protocol +\n    '//' +\n    truncate(host, 16) +\n    truncate(pathname, 24) +\n    truncate(search, 16)\n  )\n}\n\nfunction formatCacheStatus(cacheStatus: FetchMetric['cacheStatus']): string {\n  switch (cacheStatus) {\n    case 'hmr':\n      return green('(HMR cache)')\n    case 'hit':\n      return green('(cache hit)')\n    case 'miss':\n    case 'skip':\n      return yellow(`(cache ${cacheStatus})`)\n    default:\n      return cacheStatus satisfies never\n  }\n}\n"],"names":["ignoreLoggingIncomingRequests","logRequests","request","loggingConfig","incomingRequests","ignore","some","pattern","test","url","response","requestStartTime","requestEndTime","devRequestTimingMiddlewareStart","devRequestTimingMiddlewareEnd","devRequestTimingInternalsEnd","devGenerateStaticParamsDuration","logIncomingRequests","statusCode","serverActionLog","getRequestMeta","argsStr","formatArgs","args","process","stdout","write","functionName","duration","dim","location","removeRequestMeta","fetchMetrics","fetchMetric","logFetchMetric","isRSC","stripNextRscUnionQuery","statusCodeColor","white","green","blue","yellow","red","coloredStatus","toString","totalRequestTime","times","middlewareTime","push","frameworkTime","unshift","writeLine","method","hrtimeBigIntDurationToString","length","map","label","time","join","cacheReason","cacheStatus","cacheWarning","end","start","status","fetches","hmrRefreshes","fullUrl","truncateUrl","Math","round","formatCacheStatus","gray","bold","text","indentationLevel","repeat","truncate","maxLength","undefined","substring","protocol","host","pathname","search","URL"],"mappings":"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","ignoreList":[0]}