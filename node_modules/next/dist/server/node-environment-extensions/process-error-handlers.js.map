{"version":3,"sources":["../../../src/server/node-environment-extensions/process-error-handlers.ts"],"sourcesContent":["import { isPostpone } from '../lib/router-utils/is-postpone'\n\nlet _global = globalThis as typeof globalThis & {\n  nextInitializedProcessErrorHandlers?: boolean\n}\n\nexport function installProcessErrorHandlers(\n  shouldRemoveUncaughtErrorAndRejectionListeners: boolean\n) {\n  if (_global.nextInitializedProcessErrorHandlers) return\n  _global.nextInitializedProcessErrorHandlers = true\n  // The conventional wisdom of Node.js and other runtimes is to treat\n  // unhandled errors as fatal and exit the process.\n  //\n  // But Next.js is not a generic JS runtime â€” it's a specialized runtime for\n  // React Server Components.\n  //\n  // Many unhandled rejections are due to the late-awaiting pattern for\n  // prefetching data. In Next.js it's OK to call an async function without\n  // immediately awaiting it, to start the request as soon as possible\n  // without blocking unncessarily on the result. These can end up\n  // triggering an \"unhandledRejection\" if it later turns out that the\n  // data is not needed to render the page. Example:\n  //\n  //     const promise = fetchData()\n  //     const shouldShow = await checkCondition()\n  //     if (shouldShow) {\n  //       return <Component promise={promise} />\n  //     }\n  //\n  // In this example, `fetchData` is called immediately to start the request\n  // as soon as possible, but if `shouldShow` is false, then it will be\n  // discarded without unwrapping its result. If it errors, it will trigger\n  // an \"unhandledRejection\" event.\n  //\n  // Ideally, we would suppress these rejections completely without warning,\n  // because we don't consider them real errors. (TODO: Currently we do warn.)\n  //\n  // But regardless of whether we do or don't warn, we definitely shouldn't\n  // crash the entire process.\n  //\n  // Even a \"legit\" unhandled error unrelated to prefetching shouldn't\n  // prevent the rest of the page from rendering.\n  //\n  // So, we're going to intentionally override the default error handling\n  // behavior of the outer JS runtime to be more forgiving\n\n  // Remove any existing \"unhandledRejection\" and \"uncaughtException\" handlers.\n  // This is gated behind an experimental flag until we've considered the impact\n  // in various deployment environments. It's possible this may always need to\n  // be configurable.\n  if (shouldRemoveUncaughtErrorAndRejectionListeners) {\n    process.removeAllListeners('uncaughtException')\n    process.removeAllListeners('unhandledRejection')\n  }\n\n  // Install a new handler to prevent the process from crashing.\n  process.on('unhandledRejection', (reason: unknown) => {\n    if (isPostpone(reason)) {\n      // React postpones that are unhandled might end up logged here but they're\n      // not really errors. They're just part of rendering.\n      return\n    }\n    // Immediately log the error.\n    // TODO: Ideally, if we knew that this error was triggered by application\n    // code, we would suppress it entirely without logging. We can't reliably\n    // detect all of these, but when cacheComponents is enabled, we could suppress\n    // at least some of them by waiting to log the error until after all in-\n    // progress renders have completed. Then, only log errors for which there\n    // was not a corresponding \"rejectionHandled\" event.\n    console.error(reason)\n  })\n\n  process.on('rejectionHandled', () => {\n    // TODO: See note in the unhandledRejection handler above. In the future,\n    // we may use the \"rejectionHandled\" event to de-queue an error from\n    // being logged.\n  })\n\n  // Unhandled exceptions are errors triggered by non-async functions, so this\n  // is unrelated to the late-awaiting pattern. However, for similar reasons,\n  // we still shouldn't crash the process. Just log it.\n  process.on('uncaughtException', (reason: unknown) => {\n    if (isPostpone(reason)) {\n      return\n    }\n    console.error(reason)\n  })\n}\n"],"names":["installProcessErrorHandlers","_global","globalThis","shouldRemoveUncaughtErrorAndRejectionListeners","nextInitializedProcessErrorHandlers","process","removeAllListeners","on","reason","isPostpone","console","error"],"mappings":";;;;+BAMgBA;;;eAAAA;;;4BANW;AAE3B,IAAIC,UAAUC;AAIP,SAASF,4BACdG,8CAAuD;IAEvD,IAAIF,QAAQG,mCAAmC,EAAE;IACjDH,QAAQG,mCAAmC,GAAG;IAC9C,oEAAoE;IACpE,kDAAkD;IAClD,EAAE;IACF,2EAA2E;IAC3E,2BAA2B;IAC3B,EAAE;IACF,qEAAqE;IACrE,yEAAyE;IACzE,oEAAoE;IACpE,gEAAgE;IAChE,oEAAoE;IACpE,kDAAkD;IAClD,EAAE;IACF,kCAAkC;IAClC,gDAAgD;IAChD,wBAAwB;IACxB,+CAA+C;IAC/C,QAAQ;IACR,EAAE;IACF,0EAA0E;IAC1E,qEAAqE;IACrE,yEAAyE;IACzE,iCAAiC;IACjC,EAAE;IACF,0EAA0E;IAC1E,4EAA4E;IAC5E,EAAE;IACF,yEAAyE;IACzE,4BAA4B;IAC5B,EAAE;IACF,oEAAoE;IACpE,+CAA+C;IAC/C,EAAE;IACF,uEAAuE;IACvE,wDAAwD;IAExD,6EAA6E;IAC7E,8EAA8E;IAC9E,4EAA4E;IAC5E,mBAAmB;IACnB,IAAID,gDAAgD;QAClDE,QAAQC,kBAAkB,CAAC;QAC3BD,QAAQC,kBAAkB,CAAC;IAC7B;IAEA,8DAA8D;IAC9DD,QAAQE,EAAE,CAAC,sBAAsB,CAACC;QAChC,IAAIC,IAAAA,sBAAU,EAACD,SAAS;YACtB,0EAA0E;YAC1E,qDAAqD;YACrD;QACF;QACA,6BAA6B;QAC7B,yEAAyE;QACzE,yEAAyE;QACzE,8EAA8E;QAC9E,wEAAwE;QACxE,yEAAyE;QACzE,oDAAoD;QACpDE,QAAQC,KAAK,CAACH;IAChB;IAEAH,QAAQE,EAAE,CAAC,oBAAoB;IAC7B,yEAAyE;IACzE,oEAAoE;IACpE,gBAAgB;IAClB;IAEA,4EAA4E;IAC5E,2EAA2E;IAC3E,qDAAqD;IACrDF,QAAQE,EAAE,CAAC,qBAAqB,CAACC;QAC/B,IAAIC,IAAAA,sBAAU,EAACD,SAAS;YACtB;QACF;QACAE,QAAQC,KAAK,CAACH;IAChB;AACF","ignoreList":[0]}