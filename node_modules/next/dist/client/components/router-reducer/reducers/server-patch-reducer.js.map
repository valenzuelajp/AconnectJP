{"version":3,"sources":["../../../../../src/client/components/router-reducer/reducers/server-patch-reducer.ts"],"sourcesContent":["import { createHrefFromUrl } from '../create-href-from-url'\nimport type {\n  ServerPatchAction,\n  ReducerState,\n  ReadonlyReducerState,\n} from '../router-reducer-types'\nimport {\n  completeHardNavigation,\n  navigateToKnownRoute,\n} from '../../segment-cache/navigation'\nimport { refreshReducer } from './refresh-reducer'\nimport { FreshnessPolicy } from '../ppr-navigations'\n\nexport function serverPatchReducer(\n  state: ReadonlyReducerState,\n  action: ServerPatchAction\n): ReducerState {\n  // A \"retry\" is a navigation that happens due to a route mismatch. It's\n  // similar to a refresh, because we will omit any existing dynamic data on\n  // the page. But we seed the retry navigation with the exact tree that the\n  // server just responded with.\n  const retryMpa = action.mpa\n  const retryUrl = new URL(action.url, location.origin)\n  const retrySeed = action.seed\n  // A retry should not create a new history entry.\n  const navigateType = 'replace'\n  if (retryMpa || retrySeed === null) {\n    // If the server did not send back data during the mismatch, fall back to\n    // an MPA navigation.\n    return completeHardNavigation(state, retryUrl, navigateType)\n  }\n  const currentUrl = new URL(state.canonicalUrl, location.origin)\n  const currentRenderedSearch = state.renderedSearch\n  if (action.previousTree !== state.tree) {\n    // There was another, more recent navigation since the once that\n    // mismatched. We can abort the retry, but we still need to refresh the\n    // page to evict any stale dynamic data.\n    return refreshReducer(state)\n  }\n  // There have been no new navigations since the mismatched one. Refresh,\n  // using the tree we just received from the server.\n  const retryCanonicalUrl = createHrefFromUrl(retryUrl)\n  const retryNextUrl = action.nextUrl\n  const shouldScroll = true\n  const now = Date.now()\n  return navigateToKnownRoute(\n    now,\n    state,\n    retryUrl,\n    retryCanonicalUrl,\n    retrySeed,\n    currentUrl,\n    currentRenderedSearch,\n    state.cache,\n    state.tree,\n    FreshnessPolicy.RefreshAll,\n    retryNextUrl,\n    shouldScroll,\n    navigateType,\n    null,\n    // Server patch (retry) navigations don't use route prediction. This is\n    // typically a retry after a previous mismatch, so the route was already\n    // marked as having a dynamic rewrite when the mismatch was detected.\n    null\n  )\n}\n"],"names":["serverPatchReducer","state","action","retryMpa","mpa","retryUrl","URL","url","location","origin","retrySeed","seed","navigateType","completeHardNavigation","currentUrl","canonicalUrl","currentRenderedSearch","renderedSearch","previousTree","tree","refreshReducer","retryCanonicalUrl","createHrefFromUrl","retryNextUrl","nextUrl","shouldScroll","now","Date","navigateToKnownRoute","cache","FreshnessPolicy","RefreshAll"],"mappings":";;;;+BAagBA;;;eAAAA;;;mCAbkB;4BAS3B;gCACwB;gCACC;AAEzB,SAASA,mBACdC,KAA2B,EAC3BC,MAAyB;IAEzB,uEAAuE;IACvE,0EAA0E;IAC1E,0EAA0E;IAC1E,8BAA8B;IAC9B,MAAMC,WAAWD,OAAOE,GAAG;IAC3B,MAAMC,WAAW,IAAIC,IAAIJ,OAAOK,GAAG,EAAEC,SAASC,MAAM;IACpD,MAAMC,YAAYR,OAAOS,IAAI;IAC7B,iDAAiD;IACjD,MAAMC,eAAe;IACrB,IAAIT,YAAYO,cAAc,MAAM;QAClC,yEAAyE;QACzE,qBAAqB;QACrB,OAAOG,IAAAA,kCAAsB,EAACZ,OAAOI,UAAUO;IACjD;IACA,MAAME,aAAa,IAAIR,IAAIL,MAAMc,YAAY,EAAEP,SAASC,MAAM;IAC9D,MAAMO,wBAAwBf,MAAMgB,cAAc;IAClD,IAAIf,OAAOgB,YAAY,KAAKjB,MAAMkB,IAAI,EAAE;QACtC,gEAAgE;QAChE,uEAAuE;QACvE,wCAAwC;QACxC,OAAOC,IAAAA,8BAAc,EAACnB;IACxB;IACA,wEAAwE;IACxE,mDAAmD;IACnD,MAAMoB,oBAAoBC,IAAAA,oCAAiB,EAACjB;IAC5C,MAAMkB,eAAerB,OAAOsB,OAAO;IACnC,MAAMC,eAAe;IACrB,MAAMC,MAAMC,KAAKD,GAAG;IACpB,OAAOE,IAAAA,gCAAoB,EACzBF,KACAzB,OACAI,UACAgB,mBACAX,WACAI,YACAE,uBACAf,MAAM4B,KAAK,EACX5B,MAAMkB,IAAI,EACVW,+BAAe,CAACC,UAAU,EAC1BR,cACAE,cACAb,cACA,MACA,uEAAuE;IACvE,wEAAwE;IACxE,qEAAqE;IACrE;AAEJ","ignoreList":[0]}