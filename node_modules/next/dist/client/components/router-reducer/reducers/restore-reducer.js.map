{"version":3,"sources":["../../../../../src/client/components/router-reducer/reducers/restore-reducer.ts"],"sourcesContent":["import type {\n  ReadonlyReducerState,\n  ReducerState,\n  RestoreAction,\n} from '../router-reducer-types'\nimport { extractPathFromFlightRouterState } from '../compute-changed-path'\nimport {\n  FreshnessPolicy,\n  spawnDynamicRequests,\n  startPPRNavigation,\n  type NavigationRequestAccumulation,\n} from '../ppr-navigations'\nimport type { FlightRouterState } from '../../../../shared/lib/app-router-types'\nimport {\n  completeHardNavigation,\n  completeTraverseNavigation,\n  convertServerPatchToFullTree,\n} from '../../segment-cache/navigation'\n\nexport function restoreReducer(\n  state: ReadonlyReducerState,\n  action: RestoreAction\n): ReducerState {\n  // This action is used to restore the router state from the history state.\n  // However, it's possible that the history state no longer contains the `FlightRouterState`.\n  // We will copy over the internal state on pushState/replaceState events, but if a history entry\n  // occurred before hydration, or if the user navigated to a hash using a regular anchor link,\n  // the history state will not contain the `FlightRouterState`.\n  // In this case, we'll continue to use the existing tree so the router doesn't get into an invalid state.\n  let treeToRestore: FlightRouterState | undefined\n  let renderedSearch: string | undefined\n  const historyState = action.historyState\n  if (historyState) {\n    treeToRestore = historyState.tree\n    renderedSearch = historyState.renderedSearch\n  } else {\n    treeToRestore = state.tree\n    renderedSearch = state.renderedSearch\n  }\n\n  const currentUrl = new URL(state.canonicalUrl, location.origin)\n  const restoredUrl = action.url\n  const restoredNextUrl =\n    extractPathFromFlightRouterState(treeToRestore) ?? restoredUrl.pathname\n\n  const now = Date.now()\n  const accumulation: NavigationRequestAccumulation = {\n    scrollableSegments: null,\n    separateRefreshUrls: null,\n  }\n  const restoreSeed = convertServerPatchToFullTree(\n    treeToRestore,\n    null,\n    renderedSearch\n  )\n  const task = startPPRNavigation(\n    now,\n    currentUrl,\n    state.renderedSearch,\n    state.cache,\n    state.tree,\n    restoreSeed.routeTree,\n    restoreSeed.metadataVaryPath,\n    FreshnessPolicy.HistoryTraversal,\n    null,\n    null,\n    false,\n    accumulation\n  )\n\n  if (task === null) {\n    return completeHardNavigation(state, restoredUrl, 'replace')\n  }\n  spawnDynamicRequests(\n    task,\n    restoredUrl,\n    restoredNextUrl,\n    FreshnessPolicy.HistoryTraversal,\n    accumulation,\n    // History traversal doesn't use route prediction, so there's no route\n    // cache entry to mark as having a dynamic rewrite on mismatch. If a\n    // mismatch occurs, the retry handler will traverse the known route tree\n    // to find and mark the entry.\n    null\n  )\n  return completeTraverseNavigation(\n    state,\n    restoredUrl,\n    renderedSearch,\n    task.node,\n    task.route,\n    restoredNextUrl\n  )\n}\n"],"names":["restoreReducer","state","action","treeToRestore","renderedSearch","historyState","tree","currentUrl","URL","canonicalUrl","location","origin","restoredUrl","url","restoredNextUrl","extractPathFromFlightRouterState","pathname","now","Date","accumulation","scrollableSegments","separateRefreshUrls","restoreSeed","convertServerPatchToFullTree","task","startPPRNavigation","cache","routeTree","metadataVaryPath","FreshnessPolicy","HistoryTraversal","completeHardNavigation","spawnDynamicRequests","completeTraverseNavigation","node","route"],"mappings":";;;;+BAmBgBA;;;eAAAA;;;oCAdiC;gCAM1C;4BAMA;AAEA,SAASA,eACdC,KAA2B,EAC3BC,MAAqB;IAErB,0EAA0E;IAC1E,4FAA4F;IAC5F,gGAAgG;IAChG,6FAA6F;IAC7F,8DAA8D;IAC9D,yGAAyG;IACzG,IAAIC;IACJ,IAAIC;IACJ,MAAMC,eAAeH,OAAOG,YAAY;IACxC,IAAIA,cAAc;QAChBF,gBAAgBE,aAAaC,IAAI;QACjCF,iBAAiBC,aAAaD,cAAc;IAC9C,OAAO;QACLD,gBAAgBF,MAAMK,IAAI;QAC1BF,iBAAiBH,MAAMG,cAAc;IACvC;IAEA,MAAMG,aAAa,IAAIC,IAAIP,MAAMQ,YAAY,EAAEC,SAASC,MAAM;IAC9D,MAAMC,cAAcV,OAAOW,GAAG;IAC9B,MAAMC,kBACJC,IAAAA,oDAAgC,EAACZ,kBAAkBS,YAAYI,QAAQ;IAEzE,MAAMC,MAAMC,KAAKD,GAAG;IACpB,MAAME,eAA8C;QAClDC,oBAAoB;QACpBC,qBAAqB;IACvB;IACA,MAAMC,cAAcC,IAAAA,wCAA4B,EAC9CpB,eACA,MACAC;IAEF,MAAMoB,OAAOC,IAAAA,kCAAkB,EAC7BR,KACAV,YACAN,MAAMG,cAAc,EACpBH,MAAMyB,KAAK,EACXzB,MAAMK,IAAI,EACVgB,YAAYK,SAAS,EACrBL,YAAYM,gBAAgB,EAC5BC,+BAAe,CAACC,gBAAgB,EAChC,MACA,MACA,OACAX;IAGF,IAAIK,SAAS,MAAM;QACjB,OAAOO,IAAAA,kCAAsB,EAAC9B,OAAOW,aAAa;IACpD;IACAoB,IAAAA,oCAAoB,EAClBR,MACAZ,aACAE,iBACAe,+BAAe,CAACC,gBAAgB,EAChCX,cACA,sEAAsE;IACtE,oEAAoE;IACpE,wEAAwE;IACxE,8BAA8B;IAC9B;IAEF,OAAOc,IAAAA,sCAA0B,EAC/BhC,OACAW,aACAR,gBACAoB,KAAKU,IAAI,EACTV,KAAKW,KAAK,EACVrB;AAEJ","ignoreList":[0]}