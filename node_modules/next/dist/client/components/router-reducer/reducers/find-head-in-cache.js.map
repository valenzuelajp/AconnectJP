{"version":3,"sources":["../../../../../src/client/components/router-reducer/reducers/find-head-in-cache.ts"],"sourcesContent":["import type {\n  FlightRouterState,\n  CacheNode,\n} from '../../../../shared/lib/app-router-types'\nimport { DEFAULT_SEGMENT_KEY } from '../../../../shared/lib/segment'\nimport { createRouterCacheKey } from '../create-router-cache-key'\n\nexport function findHeadInCache(\n  cache: CacheNode,\n  parallelRoutes: FlightRouterState[1]\n): [CacheNode, string, string] | null {\n  return findHeadInCacheImpl(cache, parallelRoutes, '', '')\n}\n\nfunction findHeadInCacheImpl(\n  cache: CacheNode,\n  parallelRoutes: FlightRouterState[1],\n  keyPrefix: string,\n  keyPrefixWithoutSearchParams: string\n): [CacheNode, string, string] | null {\n  const isLastItem = Object.keys(parallelRoutes).length === 0\n  if (isLastItem) {\n    // Returns the entire Cache Node of the segment whose head we will render.\n    return [cache, keyPrefix, keyPrefixWithoutSearchParams]\n  }\n\n  // First try the 'children' parallel route if it exists\n  // when starting from the \"root\", this corresponds with the main page component\n  const parallelRoutesKeys = Object.keys(parallelRoutes).filter(\n    (key) => key !== 'children'\n  )\n\n  // if we are at the root, we need to check the children slot first\n  if ('children' in parallelRoutes) {\n    parallelRoutesKeys.unshift('children')\n  }\n\n  const slots = cache.slots\n  if (slots !== null) {\n    for (const key of parallelRoutesKeys) {\n      const [segment, childParallelRoutes] = parallelRoutes[key]\n      // If the parallel is not matched and using the default segment,\n      // skip searching the head from it.\n      if (segment === DEFAULT_SEGMENT_KEY) {\n        continue\n      }\n\n      const childCacheNode = slots[key]\n      if (!childCacheNode) {\n        continue\n      }\n\n      const cacheKey = createRouterCacheKey(segment)\n      const cacheKeyWithoutSearchParams = createRouterCacheKey(segment, true)\n\n      const item = findHeadInCacheImpl(\n        childCacheNode,\n        childParallelRoutes,\n        keyPrefix + '/' + cacheKey,\n        keyPrefix + '/' + cacheKeyWithoutSearchParams\n      )\n\n      if (item) {\n        return item\n      }\n    }\n  }\n\n  return null\n}\n"],"names":["findHeadInCache","cache","parallelRoutes","findHeadInCacheImpl","keyPrefix","keyPrefixWithoutSearchParams","isLastItem","Object","keys","length","parallelRoutesKeys","filter","key","unshift","slots","segment","childParallelRoutes","DEFAULT_SEGMENT_KEY","childCacheNode","cacheKey","createRouterCacheKey","cacheKeyWithoutSearchParams","item"],"mappings":";;;;+BAOgBA;;;eAAAA;;;yBAHoB;sCACC;AAE9B,SAASA,gBACdC,KAAgB,EAChBC,cAAoC;IAEpC,OAAOC,oBAAoBF,OAAOC,gBAAgB,IAAI;AACxD;AAEA,SAASC,oBACPF,KAAgB,EAChBC,cAAoC,EACpCE,SAAiB,EACjBC,4BAAoC;IAEpC,MAAMC,aAAaC,OAAOC,IAAI,CAACN,gBAAgBO,MAAM,KAAK;IAC1D,IAAIH,YAAY;QACd,0EAA0E;QAC1E,OAAO;YAACL;YAAOG;YAAWC;SAA6B;IACzD;IAEA,uDAAuD;IACvD,+EAA+E;IAC/E,MAAMK,qBAAqBH,OAAOC,IAAI,CAACN,gBAAgBS,MAAM,CAC3D,CAACC,MAAQA,QAAQ;IAGnB,kEAAkE;IAClE,IAAI,cAAcV,gBAAgB;QAChCQ,mBAAmBG,OAAO,CAAC;IAC7B;IAEA,MAAMC,QAAQb,MAAMa,KAAK;IACzB,IAAIA,UAAU,MAAM;QAClB,KAAK,MAAMF,OAAOF,mBAAoB;YACpC,MAAM,CAACK,SAASC,oBAAoB,GAAGd,cAAc,CAACU,IAAI;YAC1D,gEAAgE;YAChE,mCAAmC;YACnC,IAAIG,YAAYE,4BAAmB,EAAE;gBACnC;YACF;YAEA,MAAMC,iBAAiBJ,KAAK,CAACF,IAAI;YACjC,IAAI,CAACM,gBAAgB;gBACnB;YACF;YAEA,MAAMC,WAAWC,IAAAA,0CAAoB,EAACL;YACtC,MAAMM,8BAA8BD,IAAAA,0CAAoB,EAACL,SAAS;YAElE,MAAMO,OAAOnB,oBACXe,gBACAF,qBACAZ,YAAY,MAAMe,UAClBf,YAAY,MAAMiB;YAGpB,IAAIC,MAAM;gBACR,OAAOA;YACT;QACF;IACF;IAEA,OAAO;AACT","ignoreList":[0]}