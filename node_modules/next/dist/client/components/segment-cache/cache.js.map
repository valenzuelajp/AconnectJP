{"version":3,"sources":["../../../../src/client/components/segment-cache/cache.ts"],"sourcesContent":["import type {\n  TreePrefetch,\n  RootTreePrefetch,\n  SegmentPrefetch,\n} from '../../../server/app-render/collect-segment-data'\nimport type {\n  CacheNodeSeedData,\n  Segment as FlightRouterStateSegment,\n} from '../../../shared/lib/app-router-types'\nimport {\n  readVaryParams,\n  type VaryParams,\n} from '../../../shared/lib/segment-cache/vary-params-decoding'\nimport { HasLoadingBoundary } from '../../../shared/lib/app-router-types'\nimport {\n  NEXT_DID_POSTPONE_HEADER,\n  NEXT_ROUTER_PREFETCH_HEADER,\n  NEXT_ROUTER_SEGMENT_PREFETCH_HEADER,\n  NEXT_ROUTER_STALE_TIME_HEADER,\n  NEXT_ROUTER_STATE_TREE_HEADER,\n  NEXT_URL,\n  RSC_CONTENT_TYPE_HEADER,\n  RSC_HEADER,\n} from '../app-router-headers'\nimport {\n  createFetch,\n  createFromNextReadableStream,\n  type RSCResponse,\n  type RequestHeaders,\n} from '../router-reducer/fetch-server-response'\nimport {\n  pingPrefetchTask,\n  isPrefetchTaskDirty,\n  type PrefetchTask,\n  type PrefetchSubtaskResult,\n} from './scheduler'\nimport {\n  type RouteVaryPath,\n  type SegmentVaryPath,\n  type PartialSegmentVaryPath,\n  getRouteVaryPath,\n  getFulfilledRouteVaryPath,\n  getFulfilledSegmentVaryPath,\n  getSegmentVaryPathForRequest,\n  appendLayoutVaryPath,\n  finalizeLayoutVaryPath,\n  finalizePageVaryPath,\n  clonePageVaryPathWithNewSearchParams,\n  type PageVaryPath,\n  type LayoutVaryPath,\n  finalizeMetadataVaryPath,\n  getPartialPageVaryPath,\n  getPartialLayoutVaryPath,\n  getRenderedSearchFromVaryPath,\n} from './vary-path'\nimport { getAppBuildId } from '../../app-build-id'\nimport { createHrefFromUrl } from '../router-reducer/create-href-from-url'\nimport type {\n  NormalizedPathname,\n  NormalizedSearch,\n  RouteCacheKey,\n} from './cache-key'\nimport { createCacheKey as createPrefetchRequestKey } from './cache-key'\nimport {\n  doesStaticSegmentAppearInURL,\n  getCacheKeyForDynamicParam,\n  getRenderedPathname,\n  getRenderedSearch,\n  parseDynamicParamFromURLPart,\n} from '../../route-params'\nimport {\n  createCacheMap,\n  getFromCacheMap,\n  setInCacheMap,\n  setSizeInCacheMap,\n  deleteFromCacheMap,\n  isValueExpired,\n  type CacheMap,\n  type UnknownMapEntry,\n} from './cache-map'\nimport {\n  appendSegmentRequestKeyPart,\n  convertSegmentPathToStaticExportFilename,\n  createSegmentRequestKeyPart,\n  HEAD_REQUEST_KEY,\n  ROOT_SEGMENT_REQUEST_KEY,\n  type SegmentRequestKey,\n} from '../../../shared/lib/segment-cache/segment-value-encoding'\nimport type {\n  FlightRouterState,\n  NavigationFlightResponse,\n} from '../../../shared/lib/app-router-types'\nimport {\n  normalizeFlightData,\n  prepareFlightRouterStateForRequest,\n} from '../../flight-data-helpers'\nimport {\n  DYNAMIC_STALETIME_MS,\n  STATIC_STALETIME_MS,\n} from '../router-reducer/reducers/navigate-reducer'\nimport { pingVisibleLinks } from '../links'\nimport { PAGE_SEGMENT_KEY } from '../../../shared/lib/segment'\nimport { FetchStrategy } from './types'\nimport { createPromiseWithResolvers } from '../../../shared/lib/promise-with-resolvers'\nimport { readFromBFCacheDuringRegularNavigation } from './bfcache'\nimport { discoverKnownRoute, matchKnownRoute } from './optimistic-routes'\n\n/**\n * Ensures a minimum stale time of 30s to avoid issues where the server sends a too\n * short-lived stale time, which would prevent anything from being prefetched.\n */\nexport function getStaleTimeMs(staleTimeSeconds: number): number {\n  return Math.max(staleTimeSeconds, 30) * 1000\n}\n\n// A note on async/await when working in the prefetch cache:\n//\n// Most async operations in the prefetch cache should *not* use async/await,\n// Instead, spawn a subtask that writes the results to a cache entry, and attach\n// a \"ping\" listener to notify the prefetch queue to try again.\n//\n// The reason is we need to be able to access the segment cache and traverse its\n// data structures synchronously. For example, if there's a synchronous update\n// we can take an immediate snapshot of the cache to produce something we can\n// render. Limiting the use of async/await also makes it easier to avoid race\n// conditions, which is especially important because is cache is mutable.\n//\n// Another reason is that while we're performing async work, it's possible for\n// existing entries to become stale, or for Link prefetches to be removed from\n// the queue. For optimal scheduling, we need to be able to \"cancel\" subtasks\n// that are no longer needed. So, when a segment is received from the server, we\n// restart from the root of the tree that's being prefetched, to confirm all the\n// parent segments are still cached. If the segment is no longer reachable from\n// the root, then it's effectively canceled. This is similar to the design of\n// Rust Futures, or React Suspense.\n\ntype RouteTreeShared = {\n  requestKey: SegmentRequestKey\n  // TODO: Remove the `segment` field, now that it can be reconstructed\n  // from `param`.\n  segment: FlightRouterStateSegment\n  refreshState: RefreshState | null\n  slots: null | {\n    [parallelRouteKey: string]: RouteTree\n  }\n  isRootLayout: boolean\n\n  // If this is a dynamic route, indicates whether there is a loading boundary\n  // somewhere in the tree. If not, we can skip the prefetch for the data,\n  // because we know it would be an empty response. (For a static/PPR route,\n  // this value is disregarded, because in that model `loading.tsx` is treated\n  // like any other Suspense boundary.)\n  hasLoadingBoundary: HasLoadingBoundary\n\n  // Indicates whether this route has a runtime prefetch that we can request.\n  // This is determined by the server; it's not purely a user configuration\n  // because the server may determine that a route is fully static and doesn't\n  // need runtime prefetching regardless of the configuration.\n  hasRuntimePrefetch: boolean\n}\n\nexport type RefreshState = {\n  canonicalUrl: string\n  renderedSearch: NormalizedSearch\n}\n\ntype LayoutRouteTree = RouteTreeShared & {\n  isPage: false\n  varyPath: LayoutVaryPath\n}\n\ntype PageRouteTree = RouteTreeShared & {\n  isPage: true\n  varyPath: PageVaryPath\n}\n\nexport type RouteTree = LayoutRouteTree | PageRouteTree\n\ntype RouteCacheEntryShared = {\n  // This is false only if we're certain the route cannot be intercepted. It's\n  // true in all other cases, including on initialization when we haven't yet\n  // received a response from the server.\n  couldBeIntercepted: boolean\n\n  // Map-related fields.\n  ref: UnknownMapEntry | null\n  size: number\n  staleAt: number\n  version: number\n}\n\n/**\n * Tracks the status of a cache entry as it progresses from no data (Empty),\n * waiting for server data (Pending), and finished (either Fulfilled or\n * Rejected depending on the response from the server.\n */\nexport const enum EntryStatus {\n  Empty = 0,\n  Pending = 1,\n  Fulfilled = 2,\n  Rejected = 3,\n}\n\nexport type PendingRouteCacheEntry = RouteCacheEntryShared & {\n  status: EntryStatus.Empty | EntryStatus.Pending\n  blockedTasks: Set<PrefetchTask> | null\n  canonicalUrl: null\n  renderedSearch: null\n  tree: null\n  metadata: null\n  isPPREnabled: false\n}\n\ntype RejectedRouteCacheEntry = RouteCacheEntryShared & {\n  status: EntryStatus.Rejected\n  blockedTasks: Set<PrefetchTask> | null\n  canonicalUrl: null\n  renderedSearch: null\n  tree: null\n  metadata: null\n  isPPREnabled: boolean\n}\n\nexport type FulfilledRouteCacheEntry = RouteCacheEntryShared & {\n  status: EntryStatus.Fulfilled\n  blockedTasks: null\n  canonicalUrl: string\n  renderedSearch: NormalizedSearch\n  tree: RouteTree\n  metadata: RouteTree\n  isPPREnabled: boolean\n  // When true, this entry should not be used as a template for route\n  // prediction. Set when we discover that the URL was rewritten by middleware\n  // to a different route structure (e.g., /foo was rewritten to /bar). Since\n  // rewrite behavior can vary by param value, we can't safely predict the\n  // route structure for other URLs matching this pattern.\n  hasDynamicRewrite: boolean\n}\n\nexport type RouteCacheEntry =\n  | PendingRouteCacheEntry\n  | FulfilledRouteCacheEntry\n  | RejectedRouteCacheEntry\n\ntype SegmentCacheEntryShared = {\n  fetchStrategy: FetchStrategy\n\n  // Map-related fields.\n  ref: UnknownMapEntry | null\n  size: number\n  staleAt: number\n  version: number\n}\n\nexport type EmptySegmentCacheEntry = SegmentCacheEntryShared & {\n  status: EntryStatus.Empty\n  rsc: null\n  isPartial: true\n  promise: null\n}\n\nexport type PendingSegmentCacheEntry = SegmentCacheEntryShared & {\n  status: EntryStatus.Pending\n  rsc: null\n  isPartial: boolean\n  promise: null | PromiseWithResolvers<FulfilledSegmentCacheEntry | null>\n}\n\ntype RejectedSegmentCacheEntry = SegmentCacheEntryShared & {\n  status: EntryStatus.Rejected\n  rsc: null\n  isPartial: true\n  promise: null\n}\n\nexport type FulfilledSegmentCacheEntry = SegmentCacheEntryShared & {\n  status: EntryStatus.Fulfilled\n  rsc: React.ReactNode | null\n  isPartial: boolean\n  promise: null\n}\n\nexport type SegmentCacheEntry =\n  | EmptySegmentCacheEntry\n  | PendingSegmentCacheEntry\n  | RejectedSegmentCacheEntry\n  | FulfilledSegmentCacheEntry\n\nexport type NonEmptySegmentCacheEntry = Exclude<\n  SegmentCacheEntry,\n  EmptySegmentCacheEntry\n>\n\nconst isOutputExportMode =\n  process.env.NODE_ENV === 'production' &&\n  process.env.__NEXT_CONFIG_OUTPUT === 'export'\n\nconst MetadataOnlyRequestTree: FlightRouterState = [\n  '',\n  {},\n  null,\n  'metadata-only',\n]\n\nlet routeCacheMap: CacheMap<RouteCacheEntry> = createCacheMap()\nlet segmentCacheMap: CacheMap<SegmentCacheEntry> = createCacheMap()\n\n// All invalidation listeners for the whole cache are tracked in single set.\n// Since we don't yet support tag or path-based invalidation, there's no point\n// tracking them any more granularly than this. Once we add granular\n// invalidation, that may change, though generally the model is to just notify\n// the listeners and allow the caller to poll the prefetch cache with a new\n// prefetch task if desired.\nlet invalidationListeners: Set<PrefetchTask> | null = null\n\n// Incrementing counters used to track cache invalidations. Route and segment\n// caches have separate versions so they can be invalidated independently.\n// Invalidation does not eagerly evict anything from the cache; entries are\n// lazily evicted when read.\nlet currentRouteCacheVersion = 0\nlet currentSegmentCacheVersion = 0\n\nexport function getCurrentRouteCacheVersion(): number {\n  return currentRouteCacheVersion\n}\n\nexport function getCurrentSegmentCacheVersion(): number {\n  return currentSegmentCacheVersion\n}\n\n/**\n * Invalidates all prefetch cache entries (both route and segment caches).\n *\n * After invalidation, triggers re-prefetching of visible links and notifies\n * invalidation listeners.\n */\nexport function invalidateEntirePrefetchCache(\n  nextUrl: string | null,\n  tree: FlightRouterState\n): void {\n  currentRouteCacheVersion++\n  currentSegmentCacheVersion++\n\n  pingVisibleLinks(nextUrl, tree)\n  pingInvalidationListeners(nextUrl, tree)\n}\n\n/**\n * Invalidates all route cache entries. Route entries contain the tree structure\n * (which segments exist at a given URL) but not the segment data itself.\n *\n * After invalidation, triggers re-prefetching of visible links and notifies\n * invalidation listeners.\n */\nexport function invalidateRouteCacheEntries(\n  nextUrl: string | null,\n  tree: FlightRouterState\n): void {\n  currentRouteCacheVersion++\n\n  pingVisibleLinks(nextUrl, tree)\n  pingInvalidationListeners(nextUrl, tree)\n}\n\n/**\n * Invalidates all segment cache entries. Segment entries contain the actual\n * RSC data for each segment.\n *\n * After invalidation, triggers re-prefetching of visible links and notifies\n * invalidation listeners.\n */\nexport function invalidateSegmentCacheEntries(\n  nextUrl: string | null,\n  tree: FlightRouterState\n): void {\n  currentSegmentCacheVersion++\n\n  pingVisibleLinks(nextUrl, tree)\n  pingInvalidationListeners(nextUrl, tree)\n}\n\nfunction attachInvalidationListener(task: PrefetchTask): void {\n  // This function is called whenever a prefetch task reads a cache entry. If\n  // the task has an onInvalidate function associated with it — i.e. the one\n  // optionally passed to router.prefetch(onInvalidate) — then we attach that\n  // listener to the every cache entry that the task reads. Then, if an entry\n  // is invalidated, we call the function.\n  if (task.onInvalidate !== null) {\n    if (invalidationListeners === null) {\n      invalidationListeners = new Set([task])\n    } else {\n      invalidationListeners.add(task)\n    }\n  }\n}\n\nfunction notifyInvalidationListener(task: PrefetchTask): void {\n  const onInvalidate = task.onInvalidate\n  if (onInvalidate !== null) {\n    // Clear the callback from the task object to guarantee it's not called more\n    // than once.\n    task.onInvalidate = null\n\n    // This is a user-space function, so we must wrap in try/catch.\n    try {\n      onInvalidate()\n    } catch (error) {\n      if (typeof reportError === 'function') {\n        reportError(error)\n      } else {\n        console.error(error)\n      }\n    }\n  }\n}\n\nexport function pingInvalidationListeners(\n  nextUrl: string | null,\n  tree: FlightRouterState\n): void {\n  // The rough equivalent of pingVisibleLinks, but for onInvalidate callbacks.\n  // This is called when the Next-Url or the base tree changes, since those\n  // may affect the result of a prefetch task. It's also called after a\n  // cache invalidation.\n  if (invalidationListeners !== null) {\n    const tasks = invalidationListeners\n    invalidationListeners = null\n    for (const task of tasks) {\n      if (isPrefetchTaskDirty(task, nextUrl, tree)) {\n        notifyInvalidationListener(task)\n      }\n    }\n  }\n}\n\nexport function readRouteCacheEntry(\n  now: number,\n  key: RouteCacheKey\n): RouteCacheEntry | null {\n  const varyPath: RouteVaryPath = getRouteVaryPath(\n    key.pathname,\n    key.search,\n    key.nextUrl\n  )\n  const isRevalidation = false\n  const existingEntry = getFromCacheMap(\n    now,\n    getCurrentRouteCacheVersion(),\n    routeCacheMap,\n    varyPath,\n    isRevalidation\n  )\n  if (existingEntry !== null) {\n    return existingEntry\n  }\n\n  // No cache hit. Attempt to construct from template using the new\n  // optimistic routing mechanism (pattern-based matching).\n  if (process.env.__NEXT_OPTIMISTIC_ROUTING) {\n    return matchKnownRoute(key.pathname, key.search)\n  }\n\n  return null\n}\n\nexport function readSegmentCacheEntry(\n  now: number,\n  varyPath: SegmentVaryPath\n): SegmentCacheEntry | null {\n  const isRevalidation = false\n  return getFromCacheMap(\n    now,\n    getCurrentSegmentCacheVersion(),\n    segmentCacheMap,\n    varyPath,\n    isRevalidation\n  )\n}\n\nfunction readRevalidatingSegmentCacheEntry(\n  now: number,\n  varyPath: SegmentVaryPath\n): SegmentCacheEntry | null {\n  const isRevalidation = true\n  return getFromCacheMap(\n    now,\n    getCurrentSegmentCacheVersion(),\n    segmentCacheMap,\n    varyPath,\n    isRevalidation\n  )\n}\n\nexport function waitForSegmentCacheEntry(\n  pendingEntry: PendingSegmentCacheEntry\n): Promise<FulfilledSegmentCacheEntry | null> {\n  // Because the entry is pending, there's already a in-progress request.\n  // Attach a promise to the entry that will resolve when the server responds.\n  let promiseWithResolvers = pendingEntry.promise\n  if (promiseWithResolvers === null) {\n    promiseWithResolvers = pendingEntry.promise =\n      createPromiseWithResolvers<FulfilledSegmentCacheEntry | null>()\n  } else {\n    // There's already a promise we can use\n  }\n  return promiseWithResolvers.promise\n}\n\nfunction createDetachedRouteCacheEntry(): PendingRouteCacheEntry {\n  return {\n    canonicalUrl: null,\n    status: EntryStatus.Empty,\n    blockedTasks: null,\n    tree: null,\n    metadata: null,\n    // This is initialized to true because we don't know yet whether the route\n    // could be intercepted. It's only set to false once we receive a response\n    // from the server.\n    couldBeIntercepted: true,\n    // Similarly, we don't yet know if the route supports PPR.\n    isPPREnabled: false,\n    renderedSearch: null,\n\n    // Map-related fields\n    ref: null,\n    size: 0,\n    // Since this is an empty entry, there's no reason to ever evict it. It will\n    // be updated when the data is populated.\n    staleAt: Infinity,\n    version: getCurrentRouteCacheVersion(),\n  }\n}\n\n/**\n * Checks if an entry for a route exists in the cache. If so, it returns the\n * entry, If not, it adds an empty entry to the cache and returns it.\n */\nexport function readOrCreateRouteCacheEntry(\n  now: number,\n  task: PrefetchTask,\n  key: RouteCacheKey\n): RouteCacheEntry {\n  attachInvalidationListener(task)\n\n  const existingEntry = readRouteCacheEntry(now, key)\n  if (existingEntry !== null) {\n    return existingEntry\n  }\n  // Create a pending entry and add it to the cache.\n  const pendingEntry = createDetachedRouteCacheEntry()\n  const varyPath: RouteVaryPath = getRouteVaryPath(\n    key.pathname,\n    key.search,\n    key.nextUrl\n  )\n  const isRevalidation = false\n  setInCacheMap(routeCacheMap, varyPath, pendingEntry, isRevalidation)\n  return pendingEntry\n}\n\n// TODO: This function predates the new optimisticRouting feature and will be\n// removed once optimisticRouting is stable. The new mechanism (matchKnownRoute)\n// handles search param variations more robustly as part of the general route\n// prediction system. This fallback remains for when optimisticRouting is\n// disabled (staticChildren is null).\nexport function deprecated_requestOptimisticRouteCacheEntry(\n  now: number,\n  requestedUrl: URL,\n  nextUrl: string | null\n): FulfilledRouteCacheEntry | null {\n  // This function is called during a navigation when there was no matching\n  // route tree in the prefetch cache. Before de-opting to a blocking,\n  // unprefetched navigation, we will first attempt to construct an \"optimistic\"\n  // route tree by checking the cache for similar routes.\n  //\n  // Check if there's a route with the same pathname, but with different\n  // search params. We can then base our optimistic route tree on this entry.\n  //\n  // Conceptually, we are simulating what would happen if we did perform a\n  // prefetch the requested URL, under the assumption that the server will\n  // not redirect or rewrite the request in a different manner than the\n  // base route tree. This assumption might not hold, in which case we'll have\n  // to recover when we perform the dynamic navigation request. However, this\n  // is what would happen if a route were dynamically rewritten/redirected\n  // in between the prefetch and the navigation. So the logic needs to exist\n  // to handle this case regardless.\n\n  // Look for a route with the same pathname, but with an empty search string.\n  // TODO: There's nothing inherently special about the empty search string;\n  // it's chosen somewhat arbitrarily, with the rationale that it's the most\n  // likely one to exist. But we should update this to match _any_ search\n  // string. The plan is to generalize this logic alongside other improvements\n  // related to \"fallback\" cache entries.\n  const requestedSearch = requestedUrl.search as NormalizedSearch\n  if (requestedSearch === '') {\n    // The caller would have already checked if a route with an empty search\n    // string is in the cache. So we can bail out here.\n    return null\n  }\n  const urlWithoutSearchParams = new URL(requestedUrl)\n  urlWithoutSearchParams.search = ''\n  const routeWithNoSearchParams = readRouteCacheEntry(\n    now,\n    createPrefetchRequestKey(urlWithoutSearchParams.href, nextUrl)\n  )\n\n  if (\n    routeWithNoSearchParams === null ||\n    routeWithNoSearchParams.status !== EntryStatus.Fulfilled\n  ) {\n    // Bail out of constructing an optimistic route tree. This will result in\n    // a blocking, unprefetched navigation.\n    return null\n  }\n\n  // Now we have a base route tree we can \"patch\" with our optimistic values.\n\n  // Optimistically assume that redirects for the requested pathname do\n  // not vary on the search string. Therefore, if the base route was\n  // redirected to a different search string, then the optimistic route\n  // should be redirected to the same search string. Otherwise, we use\n  // the requested search string.\n  const canonicalUrlForRouteWithNoSearchParams = new URL(\n    routeWithNoSearchParams.canonicalUrl,\n    requestedUrl.origin\n  )\n  const optimisticCanonicalSearch =\n    canonicalUrlForRouteWithNoSearchParams.search !== ''\n      ? // Base route was redirected. Reuse the same redirected search string.\n        canonicalUrlForRouteWithNoSearchParams.search\n      : requestedSearch\n\n  // Similarly, optimistically assume that rewrites for the requested\n  // pathname do not vary on the search string. Therefore, if the base\n  // route was rewritten to a different search string, then the optimistic\n  // route should be rewritten to the same search string. Otherwise, we use\n  // the requested search string.\n  const optimisticRenderedSearch =\n    routeWithNoSearchParams.renderedSearch !== ''\n      ? // Base route was rewritten. Reuse the same rewritten search string.\n        routeWithNoSearchParams.renderedSearch\n      : requestedSearch\n\n  const optimisticUrl = new URL(\n    routeWithNoSearchParams.canonicalUrl,\n    location.origin\n  )\n  optimisticUrl.search = optimisticCanonicalSearch\n  const optimisticCanonicalUrl = createHrefFromUrl(optimisticUrl)\n\n  const optimisticRouteTree = deprecated_createOptimisticRouteTree(\n    routeWithNoSearchParams.tree,\n    optimisticRenderedSearch\n  )\n  const optimisticMetadataTree = deprecated_createOptimisticRouteTree(\n    routeWithNoSearchParams.metadata,\n    optimisticRenderedSearch\n  )\n\n  // Clone the base route tree, and override the relevant fields with our\n  // optimistic values.\n  const optimisticEntry: FulfilledRouteCacheEntry = {\n    canonicalUrl: optimisticCanonicalUrl,\n\n    status: EntryStatus.Fulfilled,\n    // This isn't cloned because it's instance-specific\n    blockedTasks: null,\n    tree: optimisticRouteTree,\n    metadata: optimisticMetadataTree,\n    couldBeIntercepted: routeWithNoSearchParams.couldBeIntercepted,\n    isPPREnabled: routeWithNoSearchParams.isPPREnabled,\n    hasDynamicRewrite: routeWithNoSearchParams.hasDynamicRewrite,\n\n    // Override the rendered search with the optimistic value.\n    renderedSearch: optimisticRenderedSearch,\n\n    // Map-related fields\n    ref: null,\n    size: 0,\n    staleAt: routeWithNoSearchParams.staleAt,\n    version: routeWithNoSearchParams.version,\n  }\n\n  // Do not insert this entry into the cache. It only exists so we can\n  // perform the current navigation. Just return it to the caller.\n  return optimisticEntry\n}\n\nfunction deprecated_createOptimisticRouteTree(\n  tree: RouteTree,\n  newRenderedSearch: NormalizedSearch\n): RouteTree {\n  // Create a new route tree that identical to the original one except for\n  // the rendered search string, which is contained in the vary path.\n\n  let clonedSlots: Record<string, RouteTree> | null = null\n  const originalSlots = tree.slots\n  if (originalSlots !== null) {\n    clonedSlots = {}\n    for (const parallelRouteKey in originalSlots) {\n      const childTree = originalSlots[parallelRouteKey]\n      clonedSlots[parallelRouteKey] = deprecated_createOptimisticRouteTree(\n        childTree,\n        newRenderedSearch\n      )\n    }\n  }\n\n  // We only need to clone the vary path if the route is a page.\n  if (tree.isPage) {\n    return {\n      requestKey: tree.requestKey,\n      segment: tree.segment,\n      refreshState: tree.refreshState,\n      varyPath: clonePageVaryPathWithNewSearchParams(\n        tree.varyPath,\n        newRenderedSearch\n      ),\n      isPage: true,\n      slots: clonedSlots,\n      isRootLayout: tree.isRootLayout,\n      hasLoadingBoundary: tree.hasLoadingBoundary,\n      hasRuntimePrefetch: tree.hasRuntimePrefetch,\n    }\n  }\n\n  return {\n    requestKey: tree.requestKey,\n    segment: tree.segment,\n    refreshState: tree.refreshState,\n    varyPath: tree.varyPath,\n    isPage: false,\n    slots: clonedSlots,\n    isRootLayout: tree.isRootLayout,\n    hasLoadingBoundary: tree.hasLoadingBoundary,\n    hasRuntimePrefetch: tree.hasRuntimePrefetch,\n  }\n}\n\n/**\n * Checks if an entry for a segment exists in the cache. If so, it returns the\n * entry, If not, it adds an empty entry to the cache and returns it.\n */\nexport function readOrCreateSegmentCacheEntry(\n  now: number,\n  fetchStrategy: FetchStrategy,\n  tree: RouteTree\n): SegmentCacheEntry {\n  const existingEntry = readSegmentCacheEntry(now, tree.varyPath)\n  if (existingEntry !== null) {\n    return existingEntry\n  }\n  // Create a pending entry and add it to the cache. The stale time is set to a\n  // default value; the actual stale time will be set when the entry is\n  // fulfilled with data from the server response.\n  const varyPathForRequest = getSegmentVaryPathForRequest(fetchStrategy, tree)\n  const pendingEntry = createDetachedSegmentCacheEntry(now)\n  const isRevalidation = false\n  setInCacheMap(\n    segmentCacheMap,\n    varyPathForRequest,\n    pendingEntry,\n    isRevalidation\n  )\n  return pendingEntry\n}\n\nexport function readOrCreateRevalidatingSegmentEntry(\n  now: number,\n  fetchStrategy: FetchStrategy,\n  tree: RouteTree\n): SegmentCacheEntry {\n  // This function is called when we've already confirmed that a particular\n  // segment is cached, but we want to perform another request anyway in case it\n  // returns more complete and/or fresher data than we already have. The logic\n  // for deciding whether to replace the existing entry is handled elsewhere;\n  // this function just handles retrieving a cache entry that we can use to\n  // track the revalidation.\n  //\n  // The reason revalidations are stored in the cache is because we need to be\n  // able to dedupe multiple revalidation requests. The reason they have to be\n  // handled specially is because we shouldn't overwrite a \"normal\" entry if\n  // one exists at the same keypath. So, for each internal cache location, there\n  // is a special \"revalidation\" slot that is used solely for this purpose.\n  //\n  // You can think of it as if all the revalidation entries were stored in a\n  // separate cache map from the canonical entries, and then transfered to the\n  // canonical cache map once the request is complete — this isn't how it's\n  // actually implemented, since it's more efficient to store them in the same\n  // data structure as the normal entries, but that's how it's modeled\n  // conceptually.\n\n  // TODO: Once we implement Fallback behavior for params, where an entry is\n  // re-keyed based on response information, we'll need to account for the\n  // possibility that the keypath of the previous entry is more generic than\n  // the keypath of the revalidating entry. In other words, the server could\n  // return a less generic entry upon revalidation. For now, though, this isn't\n  // a concern because the keypath is based solely on the prefetch strategy,\n  // not on data contained in the response.\n  const existingEntry = readRevalidatingSegmentCacheEntry(now, tree.varyPath)\n  if (existingEntry !== null) {\n    return existingEntry\n  }\n  // Create a pending entry and add it to the cache. The stale time is set to a\n  // default value; the actual stale time will be set when the entry is\n  // fulfilled with data from the server response.\n  const varyPathForRequest = getSegmentVaryPathForRequest(fetchStrategy, tree)\n  const pendingEntry = createDetachedSegmentCacheEntry(now)\n  const isRevalidation = true\n  setInCacheMap(\n    segmentCacheMap,\n    varyPathForRequest,\n    pendingEntry,\n    isRevalidation\n  )\n  return pendingEntry\n}\n\nexport function overwriteRevalidatingSegmentCacheEntry(\n  now: number,\n  fetchStrategy: FetchStrategy,\n  tree: RouteTree\n) {\n  // This function is called when we've already decided to replace an existing\n  // revalidation entry. Create a new entry and write it into the cache,\n  // overwriting the previous value. The stale time is set to a default value;\n  // the actual stale time will be set when the entry is fulfilled with data\n  // from the server response.\n  const varyPathForRequest = getSegmentVaryPathForRequest(fetchStrategy, tree)\n  const pendingEntry = createDetachedSegmentCacheEntry(now)\n  const isRevalidation = true\n  setInCacheMap(\n    segmentCacheMap,\n    varyPathForRequest,\n    pendingEntry,\n    isRevalidation\n  )\n  return pendingEntry\n}\n\nexport function upsertSegmentEntry(\n  now: number,\n  varyPath: SegmentVaryPath,\n  candidateEntry: SegmentCacheEntry\n): SegmentCacheEntry | null {\n  // We have a new entry that has not yet been inserted into the cache. Before\n  // we do so, we need to confirm whether it takes precedence over the existing\n  // entry (if one exists).\n  // TODO: We should not upsert an entry if its key was invalidated in the time\n  // since the request was made. We can do that by passing the \"owner\" entry to\n  // this function and confirming it's the same as `existingEntry`.\n\n  if (isValueExpired(now, getCurrentSegmentCacheVersion(), candidateEntry)) {\n    // The entry is expired. We cannot upsert it.\n    return null\n  }\n\n  const existingEntry = readSegmentCacheEntry(now, varyPath)\n  if (existingEntry !== null) {\n    // Don't replace a more specific segment with a less-specific one. A case where this\n    // might happen is if the existing segment was fetched via\n    // `<Link prefetch={true}>`.\n    if (\n      // We fetched the new segment using a different, less specific fetch strategy\n      // than the segment we already have in the cache, so it can't have more content.\n      (candidateEntry.fetchStrategy !== existingEntry.fetchStrategy &&\n        !canNewFetchStrategyProvideMoreContent(\n          existingEntry.fetchStrategy,\n          candidateEntry.fetchStrategy\n        )) ||\n      // The existing entry isn't partial, but the new one is.\n      // (TODO: can this be true if `candidateEntry.fetchStrategy >= existingEntry.fetchStrategy`?)\n      (!existingEntry.isPartial && candidateEntry.isPartial)\n    ) {\n      // We're going to leave revalidating entry in the cache so that it doesn't\n      // get revalidated again unnecessarily. Downgrade the Fulfilled entry to\n      // Rejected and null out the data so it can be garbage collected. We leave\n      // `staleAt` intact to prevent subsequent revalidation attempts only until\n      // the entry expires.\n      const rejectedEntry: RejectedSegmentCacheEntry = candidateEntry as any\n      rejectedEntry.status = EntryStatus.Rejected\n      rejectedEntry.rsc = null\n      return null\n    }\n\n    // Evict the existing entry from the cache.\n    deleteFromCacheMap(existingEntry)\n  }\n\n  const isRevalidation = false\n  setInCacheMap(segmentCacheMap, varyPath, candidateEntry, isRevalidation)\n  return candidateEntry\n}\n\nexport function createDetachedSegmentCacheEntry(\n  now: number\n): EmptySegmentCacheEntry {\n  // Default stale time for pending segment cache entries. The actual stale time\n  // is set when the entry is fulfilled with data from the server response.\n  const staleAt = now + 30 * 1000\n  const emptyEntry: EmptySegmentCacheEntry = {\n    status: EntryStatus.Empty,\n    // Default to assuming the fetch strategy will be PPR. This will be updated\n    // when a fetch is actually initiated.\n    fetchStrategy: FetchStrategy.PPR,\n    rsc: null,\n    isPartial: true,\n    promise: null,\n\n    // Map-related fields\n    ref: null,\n    size: 0,\n    staleAt,\n    version: 0,\n  }\n  return emptyEntry\n}\n\nexport function upgradeToPendingSegment(\n  emptyEntry: EmptySegmentCacheEntry,\n  fetchStrategy: FetchStrategy\n): PendingSegmentCacheEntry {\n  const pendingEntry: PendingSegmentCacheEntry = emptyEntry as any\n  pendingEntry.status = EntryStatus.Pending\n  pendingEntry.fetchStrategy = fetchStrategy\n\n  if (fetchStrategy === FetchStrategy.Full) {\n    // We can assume the response will contain the full segment data. Set this\n    // to false so we know it's OK to omit this segment from any navigation\n    // requests that may happen while the data is still pending.\n    pendingEntry.isPartial = false\n  }\n\n  // Set the version here, since this is right before the request is initiated.\n  // The next time the segment cache version is incremented, the entry will\n  // effectively be evicted. This happens before initiating the request, rather\n  // than when receiving the response, because it's guaranteed to happen\n  // before the data is read on the server.\n  pendingEntry.version = getCurrentSegmentCacheVersion()\n  return pendingEntry\n}\n\nexport function attemptToFulfillDynamicSegmentFromBFCache(\n  now: number,\n  segment: EmptySegmentCacheEntry,\n  tree: RouteTree\n): FulfilledSegmentCacheEntry | null {\n  // Attempts to fulfill an empty segment cache entry using data from the\n  // bfcache. This is only valid during a Full prefetch (i.e. one that includes\n  // dynamic data), because the bfcache stores data from navigations which\n  // always include dynamic data.\n\n  // We always use the canonical vary path when checking the bfcache. This is\n  // the same operation we'd use to access the cache during a\n  // regular navigation.\n  const varyPath = tree.varyPath\n\n  // The stale time for dynamic prefetches (default: 5 mins) is different from\n  // the stale time for regular navigations (default: 0 secs). We adjust the\n  // current timestamp to account for the difference.\n  const adjustedCurrentTime = now - STATIC_STALETIME_MS + DYNAMIC_STALETIME_MS\n  const bfcacheEntry = readFromBFCacheDuringRegularNavigation(\n    adjustedCurrentTime,\n    varyPath\n  )\n  if (bfcacheEntry !== null) {\n    // Fulfill the prefetch using the bfcache entry.\n\n    // As explained above, the stale time of this prefetch entry is different\n    // than the one for the bfcache. Calculate when it was originally requested\n    // by subtracting the stale time used by the bfcache.\n    const requestedAt = bfcacheEntry.staleAt - DYNAMIC_STALETIME_MS\n    // Now add the stale time used by dynamic prefetches.\n    const dynamicPrefetchStaleAt = requestedAt + STATIC_STALETIME_MS\n\n    const pendingSegment = upgradeToPendingSegment(segment, FetchStrategy.Full)\n    const isPartial = false\n    return fulfillSegmentCacheEntry(\n      pendingSegment,\n      bfcacheEntry.rsc,\n      dynamicPrefetchStaleAt,\n      isPartial\n    )\n  }\n  return null\n}\n\nfunction pingBlockedTasks(entry: {\n  blockedTasks: Set<PrefetchTask> | null\n}): void {\n  const blockedTasks = entry.blockedTasks\n  if (blockedTasks !== null) {\n    for (const task of blockedTasks) {\n      pingPrefetchTask(task)\n    }\n    entry.blockedTasks = null\n  }\n}\n\nexport function createMetadataRouteTree(\n  metadataVaryPath: PageVaryPath\n): RouteTree {\n  // The Head is not actually part of the route tree, but other than that, it's\n  // fetched and cached like a segment. Some functions expect a RouteTree\n  // object, so rather than fork the logic in all those places, we use this\n  // \"fake\" one.\n  const metadata: RouteTree = {\n    requestKey: HEAD_REQUEST_KEY,\n    segment: HEAD_REQUEST_KEY,\n    refreshState: null,\n    varyPath: metadataVaryPath,\n    // The metadata isn't really a \"page\" (though it isn't really a \"segment\"\n    // either) but for the purposes of how this field is used, it behaves like\n    // one. If this logic ever gets more complex we can change this to an enum.\n    isPage: true,\n    slots: null,\n    isRootLayout: false,\n    hasLoadingBoundary: HasLoadingBoundary.SubtreeHasNoLoadingBoundary,\n    hasRuntimePrefetch: false,\n  }\n  return metadata\n}\n\nexport function fulfillRouteCacheEntry(\n  now: number,\n  entry: PendingRouteCacheEntry,\n  tree: RouteTree,\n  metadataVaryPath: PageVaryPath,\n  couldBeIntercepted: boolean,\n  canonicalUrl: string,\n  isPPREnabled: boolean\n): FulfilledRouteCacheEntry {\n  // Get the rendered search from the vary path\n  const renderedSearch =\n    getRenderedSearchFromVaryPath(metadataVaryPath) ?? ('' as NormalizedSearch)\n  const fulfilledEntry: FulfilledRouteCacheEntry = entry as any\n  fulfilledEntry.status = EntryStatus.Fulfilled\n  fulfilledEntry.tree = tree\n  fulfilledEntry.metadata = createMetadataRouteTree(metadataVaryPath)\n  // Route structure is essentially static — it only changes on deploy.\n  // Always use the static stale time.\n  // NOTE: An exception is rewrites/redirects in middleware or proxy, which can\n  // change routes dynamically. We have other strategies for handling those.\n  fulfilledEntry.staleAt = now + STATIC_STALETIME_MS\n  fulfilledEntry.couldBeIntercepted = couldBeIntercepted\n  fulfilledEntry.canonicalUrl = canonicalUrl\n  fulfilledEntry.renderedSearch = renderedSearch\n  fulfilledEntry.isPPREnabled = isPPREnabled\n  fulfilledEntry.hasDynamicRewrite = false\n  pingBlockedTasks(entry)\n  return fulfilledEntry\n}\n\nexport function writeRouteIntoCache(\n  now: number,\n  pathname: NormalizedPathname,\n  tree: RouteTree,\n  metadataVaryPath: PageVaryPath,\n  couldBeIntercepted: boolean,\n  canonicalUrl: string,\n  isPPREnabled: boolean\n): FulfilledRouteCacheEntry {\n  const pendingEntry = createDetachedRouteCacheEntry()\n  const fulfilledEntry = fulfillRouteCacheEntry(\n    now,\n    pendingEntry,\n    tree,\n    metadataVaryPath,\n    couldBeIntercepted,\n    canonicalUrl,\n    isPPREnabled\n  )\n  // nextUrl is always null here because we only write to the route cache for\n  // non-intercepted routes. Intercepted routes are deopted in attemptOptimisticRouting.\n  const renderedSearch = fulfilledEntry.renderedSearch\n  const varyPath = getRouteVaryPath(pathname, renderedSearch, null)\n  const isRevalidation = false\n  setInCacheMap(routeCacheMap, varyPath, fulfilledEntry, isRevalidation)\n  return fulfilledEntry\n}\n\n/**\n * Marks a route cache entry as having a dynamic rewrite. Called when we\n * discover that a route pattern has dynamic rewrite behavior - i.e., we used\n * an optimistic route tree for prediction, but the server responded with a\n * different rendered pathname.\n *\n * Once marked, attempts to use this entry as a template for prediction will\n * bail out to server resolution.\n */\nexport function markRouteEntryAsDynamicRewrite(\n  entry: FulfilledRouteCacheEntry\n): void {\n  entry.hasDynamicRewrite = true\n  // Note: The caller is responsible for also calling invalidateRouteCacheEntries\n  // to invalidate other entries that may have been derived from this template\n  // before we knew it had a dynamic rewrite.\n}\n\nfunction fulfillSegmentCacheEntry(\n  segmentCacheEntry: PendingSegmentCacheEntry,\n  rsc: React.ReactNode,\n  staleAt: number,\n  isPartial: boolean\n): FulfilledSegmentCacheEntry {\n  const fulfilledEntry: FulfilledSegmentCacheEntry = segmentCacheEntry as any\n  fulfilledEntry.status = EntryStatus.Fulfilled\n  fulfilledEntry.rsc = rsc\n  fulfilledEntry.staleAt = staleAt\n  fulfilledEntry.isPartial = isPartial\n  // Resolve any listeners that were waiting for this data.\n  if (segmentCacheEntry.promise !== null) {\n    segmentCacheEntry.promise.resolve(fulfilledEntry)\n    // Free the promise for garbage collection.\n    fulfilledEntry.promise = null\n  }\n  return fulfilledEntry\n}\n\nfunction rejectRouteCacheEntry(\n  entry: PendingRouteCacheEntry,\n  staleAt: number\n): void {\n  const rejectedEntry: RejectedRouteCacheEntry = entry as any\n  rejectedEntry.status = EntryStatus.Rejected\n  rejectedEntry.staleAt = staleAt\n  pingBlockedTasks(entry)\n}\n\nfunction rejectSegmentCacheEntry(\n  entry: PendingSegmentCacheEntry,\n  staleAt: number\n): void {\n  const rejectedEntry: RejectedSegmentCacheEntry = entry as any\n  rejectedEntry.status = EntryStatus.Rejected\n  rejectedEntry.staleAt = staleAt\n  if (entry.promise !== null) {\n    // NOTE: We don't currently propagate the reason the prefetch was canceled\n    // but we could by accepting a `reason` argument.\n    entry.promise.resolve(null)\n    entry.promise = null\n  }\n}\n\ntype RouteTreeAccumulator = {\n  metadataVaryPath: PageVaryPath | null\n}\n\nfunction convertRootTreePrefetchToRouteTree(\n  rootTree: RootTreePrefetch,\n  renderedPathname: string,\n  renderedSearch: NormalizedSearch,\n  acc: RouteTreeAccumulator\n) {\n  // Remove trailing and leading slashes\n  const pathnameParts = renderedPathname.split('/').filter((p) => p !== '')\n  const index = 0\n  const rootSegment = ROOT_SEGMENT_REQUEST_KEY\n  return convertTreePrefetchToRouteTree(\n    rootTree.tree,\n    rootSegment,\n    null,\n    ROOT_SEGMENT_REQUEST_KEY,\n    pathnameParts,\n    index,\n    renderedSearch,\n    acc\n  )\n}\n\nfunction convertTreePrefetchToRouteTree(\n  prefetch: TreePrefetch,\n  segment: FlightRouterStateSegment,\n  partialVaryPath: PartialSegmentVaryPath | null,\n  requestKey: SegmentRequestKey,\n  pathnameParts: Array<string>,\n  pathnamePartsIndex: number,\n  renderedSearch: NormalizedSearch,\n  acc: RouteTreeAccumulator\n): RouteTree {\n  // Converts the route tree sent by the server into the format used by the\n  // cache. The cached version of the tree includes additional fields, such as a\n  // cache key for each segment. Since this is frequently accessed, we compute\n  // it once instead of on every access. This same cache key is also used to\n  // request the segment from the server.\n\n  let slots: { [parallelRouteKey: string]: RouteTree } | null = null\n  let isPage: boolean\n  let varyPath: SegmentVaryPath\n  const prefetchSlots = prefetch.slots\n  if (prefetchSlots !== null) {\n    isPage = false\n    varyPath = finalizeLayoutVaryPath(requestKey, partialVaryPath)\n\n    slots = {}\n    for (let parallelRouteKey in prefetchSlots) {\n      const childPrefetch = prefetchSlots[parallelRouteKey]\n      const childSegmentName = childPrefetch.name\n      const childParam = childPrefetch.param\n\n      let childDoesAppearInURL: boolean\n      let childSegment: FlightRouterStateSegment\n      let childPartialVaryPath: PartialSegmentVaryPath | null\n      if (childParam !== null) {\n        // This segment is parameterized. Get the param from the pathname.\n        const childParamValue = parseDynamicParamFromURLPart(\n          childParam.type,\n          pathnameParts,\n          pathnamePartsIndex\n        )\n\n        // Assign a cache key to the segment, based on the param value. In the\n        // pre-Segment Cache implementation, the server computes this and sends\n        // it in the body of the response. In the Segment Cache implementation,\n        // the server sends an empty string and we fill it in here.\n\n        // TODO: We're intentionally not adding the search param to page\n        // segments here; it's tracked separately and added back during a read.\n        // This would clearer if we waited to construct the segment until it's\n        // read from the cache, since that's effectively what we're\n        // doing anyway.\n        const childParamKey =\n          // The server omits this field from the prefetch response when\n          // cacheComponents is enabled.\n          childParam.key !== null\n            ? childParam.key\n            : // If no param key was sent, use the value parsed on the client.\n              getCacheKeyForDynamicParam(\n                childParamValue,\n                '' as NormalizedSearch\n              )\n\n        childPartialVaryPath = appendLayoutVaryPath(\n          partialVaryPath,\n          childParamKey,\n          childSegmentName\n        )\n        childSegment = [\n          childSegmentName,\n          childParamKey,\n          childParam.type,\n          childParam.siblings,\n        ]\n        childDoesAppearInURL = true\n      } else {\n        // This segment does not have a param. Inherit the partial vary path of\n        // the parent.\n        childPartialVaryPath = partialVaryPath\n        childSegment = childSegmentName\n        childDoesAppearInURL = doesStaticSegmentAppearInURL(childSegmentName)\n      }\n\n      // Only increment the index if the segment appears in the URL. If it's a\n      // \"virtual\" segment, like a route group, it remains the same.\n      const childPathnamePartsIndex = childDoesAppearInURL\n        ? pathnamePartsIndex + 1\n        : pathnamePartsIndex\n\n      const childRequestKeyPart = createSegmentRequestKeyPart(childSegment)\n      const childRequestKey = appendSegmentRequestKeyPart(\n        requestKey,\n        parallelRouteKey,\n        childRequestKeyPart\n      )\n      slots[parallelRouteKey] = convertTreePrefetchToRouteTree(\n        childPrefetch,\n        childSegment,\n        childPartialVaryPath,\n        childRequestKey,\n        pathnameParts,\n        childPathnamePartsIndex,\n        renderedSearch,\n        acc\n      )\n    }\n  } else {\n    if (requestKey.endsWith(PAGE_SEGMENT_KEY)) {\n      // This is a page segment.\n      isPage = true\n      varyPath = finalizePageVaryPath(\n        requestKey,\n        renderedSearch,\n        partialVaryPath\n      )\n      // The metadata \"segment\" is not part the route tree, but it has the same\n      // conceptual params as a page segment. Write the vary path into the\n      // accumulator object. If there are multiple parallel pages, we use the\n      // first one. Which page we choose is arbitrary as long as it's\n      // consistently the same one every time every time. See\n      // finalizeMetadataVaryPath for more details.\n      if (acc.metadataVaryPath === null) {\n        acc.metadataVaryPath = finalizeMetadataVaryPath(\n          requestKey,\n          renderedSearch,\n          partialVaryPath\n        )\n      }\n    } else {\n      // This is a layout segment.\n      isPage = false\n      varyPath = finalizeLayoutVaryPath(requestKey, partialVaryPath)\n    }\n  }\n\n  return {\n    requestKey,\n    segment,\n    refreshState: null,\n    // TODO: Cheating the type system here a bit because TypeScript can't tell\n    // that the type of isPage and varyPath are consistent. The fix would be to\n    // create separate constructors and call the appropriate one from each of\n    // the branches above. Just seems a bit overkill only for one field so I'll\n    // leave it as-is for now. If isPage were wrong it would break the behavior\n    // and we'd catch it quickly, anyway.\n    varyPath: varyPath as any,\n    isPage: isPage as boolean as any,\n    slots,\n    isRootLayout: prefetch.isRootLayout,\n    // This field is only relevant to dynamic routes. For a PPR/static route,\n    // there's always some partial loading state we can fetch.\n    hasLoadingBoundary: HasLoadingBoundary.SegmentHasLoadingBoundary,\n    hasRuntimePrefetch: prefetch.hasRuntimePrefetch,\n  }\n}\n\nexport function convertRootFlightRouterStateToRouteTree(\n  flightRouterState: FlightRouterState,\n  renderedSearch: NormalizedSearch,\n  acc: RouteTreeAccumulator\n): RouteTree {\n  return convertFlightRouterStateToRouteTree(\n    flightRouterState,\n    ROOT_SEGMENT_REQUEST_KEY,\n    null,\n    renderedSearch,\n    acc\n  )\n}\n\nexport function convertReusedFlightRouterStateToRouteTree(\n  parentRouteTree: RouteTree,\n  parallelRouteKey: string,\n  flightRouterState: FlightRouterState,\n  renderedSearch: NormalizedSearch,\n  acc: RouteTreeAccumulator\n) {\n  // Create a RouteTree for a FlightRouterState that was reused from an older\n  // route. This happens during a navigation when a parallel route slot does not\n  // match the target route; we reuse whatever slot was already active.\n\n  // Unlike a FlightRouterState, the RouteTree type contains backreferences to\n  // the parent segments. Append the vary path to the parent's vary path.\n  const parentPartialVaryPath = parentRouteTree.isPage\n    ? getPartialPageVaryPath(parentRouteTree.varyPath)\n    : getPartialLayoutVaryPath(parentRouteTree.varyPath)\n  const segment = flightRouterState[0]\n  // And the request key.\n  const parentRequestKey = parentRouteTree.requestKey\n  const requestKeyPart = createSegmentRequestKeyPart(segment)\n  const requestKey = appendSegmentRequestKeyPart(\n    parentRequestKey,\n    parallelRouteKey,\n    requestKeyPart\n  )\n  return convertFlightRouterStateToRouteTree(\n    flightRouterState,\n    requestKey,\n    parentPartialVaryPath,\n    renderedSearch,\n    acc\n  )\n}\n\nfunction convertFlightRouterStateToRouteTree(\n  flightRouterState: FlightRouterState,\n  requestKey: SegmentRequestKey,\n  parentPartialVaryPath: PartialSegmentVaryPath | null,\n  parentRenderedSearch: NormalizedSearch,\n  acc: RouteTreeAccumulator\n): RouteTree {\n  const originalSegment = flightRouterState[0]\n\n  // If the FlightRouterState has a refresh state, then this segment is part of\n  // an inactive parallel route. It has a different rendered search query than\n  // the outer parent route. In order to construct the inactive route correctly,\n  // we must restore the query that was originally used to render it.\n  const compressedRefreshState = flightRouterState[2] ?? null\n  const refreshState =\n    compressedRefreshState !== null\n      ? {\n          canonicalUrl: compressedRefreshState[0] as string,\n          renderedSearch: compressedRefreshState[1] as NormalizedSearch,\n        }\n      : null\n  const renderedSearch =\n    refreshState !== null ? refreshState.renderedSearch : parentRenderedSearch\n\n  let segment: FlightRouterStateSegment\n  let partialVaryPath: PartialSegmentVaryPath | null\n  let isPage: boolean\n  let varyPath: SegmentVaryPath\n  if (Array.isArray(originalSegment)) {\n    isPage = false\n    const paramCacheKey = originalSegment[1]\n    const paramName = originalSegment[0]\n    partialVaryPath = appendLayoutVaryPath(\n      parentPartialVaryPath,\n      paramCacheKey,\n      paramName\n    )\n    varyPath = finalizeLayoutVaryPath(requestKey, partialVaryPath)\n    segment = originalSegment\n  } else {\n    // This segment does not have a param. Inherit the partial vary path of\n    // the parent.\n    partialVaryPath = parentPartialVaryPath\n    if (requestKey.endsWith(PAGE_SEGMENT_KEY)) {\n      // This is a page segment.\n      isPage = true\n\n      // The navigation implementation expects the search params to be included\n      // in the segment. However, in the case of a static response, the search\n      // params are omitted. So the client needs to add them back in when reading\n      // from the Segment Cache.\n      //\n      // For consistency, we'll do this for dynamic responses, too.\n      //\n      // TODO: We should move search params out of FlightRouterState and handle\n      // them entirely on the client, similar to our plan for dynamic params.\n      segment = PAGE_SEGMENT_KEY\n      varyPath = finalizePageVaryPath(\n        requestKey,\n        renderedSearch,\n        partialVaryPath\n      )\n      // The metadata \"segment\" is not part the route tree, but it has the same\n      // conceptual params as a page segment. Write the vary path into the\n      // accumulator object. If there are multiple parallel pages, we use the\n      // first one. Which page we choose is arbitrary as long as it's\n      // consistently the same one every time every time. See\n      // finalizeMetadataVaryPath for more details.\n      if (acc.metadataVaryPath === null) {\n        acc.metadataVaryPath = finalizeMetadataVaryPath(\n          requestKey,\n          renderedSearch,\n          partialVaryPath\n        )\n      }\n    } else {\n      // This is a layout segment.\n      isPage = false\n      segment = originalSegment\n      varyPath = finalizeLayoutVaryPath(requestKey, partialVaryPath)\n    }\n  }\n\n  let slots: { [parallelRouteKey: string]: RouteTree } | null = null\n\n  const parallelRoutes = flightRouterState[1]\n  for (let parallelRouteKey in parallelRoutes) {\n    const childRouterState = parallelRoutes[parallelRouteKey]\n    const childSegment = childRouterState[0]\n    // TODO: Eventually, the param values will not be included in the response\n    // from the server. We'll instead fill them in on the client by parsing\n    // the URL. This is where we'll do that.\n    const childRequestKeyPart = createSegmentRequestKeyPart(childSegment)\n    const childRequestKey = appendSegmentRequestKeyPart(\n      requestKey,\n      parallelRouteKey,\n      childRequestKeyPart\n    )\n    const childTree = convertFlightRouterStateToRouteTree(\n      childRouterState,\n      childRequestKey,\n      partialVaryPath,\n      renderedSearch,\n      acc\n    )\n    if (slots === null) {\n      slots = {\n        [parallelRouteKey]: childTree,\n      }\n    } else {\n      slots[parallelRouteKey] = childTree\n    }\n  }\n\n  return {\n    requestKey,\n    segment,\n    refreshState,\n    // TODO: Cheating the type system here a bit because TypeScript can't tell\n    // that the type of isPage and varyPath are consistent. The fix would be to\n    // create separate constructors and call the appropriate one from each of\n    // the branches above. Just seems a bit overkill only for one field so I'll\n    // leave it as-is for now. If isPage were wrong it would break the behavior\n    // and we'd catch it quickly, anyway.\n    varyPath: varyPath as any,\n    isPage: isPage as boolean as any,\n    slots,\n    isRootLayout: flightRouterState[4] === true,\n    hasLoadingBoundary:\n      flightRouterState[5] !== undefined\n        ? flightRouterState[5]\n        : HasLoadingBoundary.SubtreeHasNoLoadingBoundary,\n\n    // Non-static tree responses are only used by apps that haven't adopted\n    // Cache Components. So this is always false.\n    hasRuntimePrefetch: false,\n  }\n}\n\nexport function convertRouteTreeToFlightRouterState(\n  routeTree: RouteTree\n): FlightRouterState {\n  const parallelRoutes: Record<string, FlightRouterState> = {}\n  if (routeTree.slots !== null) {\n    for (const parallelRouteKey in routeTree.slots) {\n      parallelRoutes[parallelRouteKey] = convertRouteTreeToFlightRouterState(\n        routeTree.slots[parallelRouteKey]\n      )\n    }\n  }\n  const flightRouterState: FlightRouterState = [\n    routeTree.segment,\n    parallelRoutes,\n    null,\n    null,\n    routeTree.isRootLayout,\n  ]\n  return flightRouterState\n}\n\nexport async function fetchRouteOnCacheMiss(\n  entry: PendingRouteCacheEntry,\n  task: PrefetchTask,\n  key: RouteCacheKey\n): Promise<PrefetchSubtaskResult<null> | null> {\n  // This function is allowed to use async/await because it contains the actual\n  // fetch that gets issued on a cache miss. Notice it writes the result to the\n  // cache entry directly, rather than return data that is then written by\n  // the caller.\n  const pathname = key.pathname\n  const search = key.search\n  const nextUrl = key.nextUrl\n  const segmentPath = '/_tree' as SegmentRequestKey\n\n  const headers: RequestHeaders = {\n    [RSC_HEADER]: '1',\n    [NEXT_ROUTER_PREFETCH_HEADER]: '1',\n    [NEXT_ROUTER_SEGMENT_PREFETCH_HEADER]: segmentPath,\n  }\n  if (nextUrl !== null) {\n    headers[NEXT_URL] = nextUrl\n  }\n\n  try {\n    const url = new URL(pathname + search, location.origin)\n    let response\n    let urlAfterRedirects\n    if (isOutputExportMode) {\n      // In output: \"export\" mode, we can't use headers to request a particular\n      // segment. Instead, we encode the extra request information into the URL.\n      // This is not part of the \"public\" interface of the app; it's an internal\n      // Next.js implementation detail that the app developer should not need to\n      // concern themselves with.\n      //\n      // For example, to request a segment:\n      //\n      //   Path passed to <Link>:   /path/to/page\n      //   Path passed to fetch:    /path/to/page/__next-segments/_tree\n      //\n      //   (This is not the exact protocol, just an illustration.)\n      //\n      // Before we do that, though, we need to account for redirects. Even in\n      // output: \"export\" mode, a proxy might redirect the page to a different\n      // location, but we shouldn't assume or expect that they also redirect all\n      // the segment files, too.\n      //\n      // To check whether the page is redirected, previously we perform a range\n      // request of 64 bytes of the HTML document to check if the target page\n      // is part of this app (by checking if build id matches). Only if the target\n      // page is part of this app do we determine the final canonical URL.\n      //\n      // However, as mentioned in https://github.com/vercel/next.js/pull/85903,\n      // some popular static hosting providers (like Cloudflare Pages or Render.com)\n      // do not support range requests, in the worst case, the entire HTML instead\n      // of 64 bytes could be returned, which is wasteful.\n      //\n      // So instead, we drops the check for build id here, and simply perform\n      // a HEAD request to rejects 1xx/4xx/5xx responses, and then determine the\n      // final URL after redirects.\n      //\n      // NOTE: We could embed the route tree into the HTML document, to avoid\n      // a second request. We're not doing that currently because it would make\n      // the HTML document larger and affect normal page loads.\n      const headResponse = await fetch(url, {\n        method: 'HEAD',\n      })\n      if (headResponse.status < 200 || headResponse.status >= 400) {\n        // The target page responded w/o a successful status code\n        // Could be a WAF serving a 403, or a 5xx from a backend\n        //\n        // Note that we can't use headResponse.ok here, because\n        // Response#ok returns `false` with 3xx responses.\n        rejectRouteCacheEntry(entry, Date.now() + 10 * 1000)\n        return null\n      }\n\n      urlAfterRedirects = headResponse.redirected\n        ? new URL(headResponse.url)\n        : url\n\n      response = await fetchPrefetchResponse(\n        addSegmentPathToUrlInOutputExportMode(urlAfterRedirects, segmentPath),\n        headers\n      )\n    } else {\n      // \"Server\" mode. We can use request headers instead of the pathname.\n      // TODO: The eventual plan is to get rid of our custom request headers and\n      // encode everything into the URL, using a similar strategy to the\n      // \"output: export\" block above.\n      response = await fetchPrefetchResponse(url, headers)\n      urlAfterRedirects =\n        response !== null && response.redirected ? new URL(response.url) : url\n    }\n\n    if (\n      !response ||\n      !response.ok ||\n      // 204 is a Cache miss. Though theoretically this shouldn't happen when\n      // PPR is enabled, because we always respond to route tree requests, even\n      // if it needs to be blockingly generated on demand.\n      response.status === 204 ||\n      !response.body\n    ) {\n      // Server responded with an error, or with a miss. We should still cache\n      // the response, but we can try again after 10 seconds.\n      rejectRouteCacheEntry(entry, Date.now() + 10 * 1000)\n      return null\n    }\n\n    // TODO: The canonical URL is the href without the origin. I think\n    // historically the reason for this is because the initial canonical URL\n    // gets passed as a prop to the top-level React component, which means it\n    // needs to be computed during SSR. If it were to include the origin, it\n    // would need to always be same as location.origin on the client, to prevent\n    // a hydration mismatch. To sidestep this complexity, we omit the origin.\n    //\n    // However, since this is neither a native URL object nor a fully qualified\n    // URL string, we need to be careful about how we use it. To prevent subtle\n    // mistakes, we should create a special type for it, instead of just string.\n    // Or, we should just use a (readonly) URL object instead. The type of the\n    // prop that we pass to seed the initial state does not need to be the same\n    // type as the state itself.\n    const canonicalUrl = createHrefFromUrl(urlAfterRedirects)\n\n    // Check whether the response varies based on the Next-Url header.\n    const varyHeader = response.headers.get('vary')\n    const couldBeIntercepted =\n      varyHeader !== null && varyHeader.includes(NEXT_URL)\n\n    // Track when the network connection closes.\n    const closed = createPromiseWithResolvers<void>()\n\n    // This checks whether the response was served from the per-segment cache,\n    // rather than the old prefetching flow. If it fails, it implies that PPR\n    // is disabled on this route.\n    const routeIsPPREnabled =\n      response.headers.get(NEXT_DID_POSTPONE_HEADER) === '2' ||\n      // In output: \"export\" mode, we can't rely on response headers. But if we\n      // receive a well-formed response, we can assume it's a static response,\n      // because all data is static in this mode.\n      isOutputExportMode\n\n    if (routeIsPPREnabled) {\n      const prefetchStream = createPrefetchResponseStream(\n        response.body,\n        closed.resolve,\n        function onResponseSizeUpdate(size) {\n          setSizeInCacheMap(entry, size)\n        }\n      )\n      const serverData = await createFromNextReadableStream<RootTreePrefetch>(\n        prefetchStream,\n        headers\n      )\n      if (serverData.buildId !== getAppBuildId()) {\n        // The server build does not match the client. Treat as a 404. During\n        // an actual navigation, the router will trigger an MPA navigation.\n        // TODO: Consider moving the build ID to a response header so we can check\n        // it before decoding the response, and so there's one way of checking\n        // across all response types.\n        // TODO: We should cache the fact that this is an MPA navigation.\n        rejectRouteCacheEntry(entry, Date.now() + 10 * 1000)\n        return null\n      }\n\n      // Get the params that were used to render the target page. These may\n      // be different from the params in the request URL, if the page\n      // was rewritten.\n      const renderedPathname = getRenderedPathname(response)\n      const renderedSearch = getRenderedSearch(response)\n\n      // Convert the server-sent data into the RouteTree format used by the\n      // client cache.\n      //\n      // During this traversal, we accumulate additional data into this\n      // \"accumulator\" object.\n      const acc: RouteTreeAccumulator = { metadataVaryPath: null }\n      const routeTree = convertRootTreePrefetchToRouteTree(\n        serverData,\n        renderedPathname,\n        renderedSearch,\n        acc\n      )\n      const metadataVaryPath = acc.metadataVaryPath\n      if (metadataVaryPath === null) {\n        rejectRouteCacheEntry(entry, Date.now() + 10 * 1000)\n        return null\n      }\n\n      discoverKnownRoute(\n        Date.now(),\n        pathname,\n        entry,\n        routeTree,\n        metadataVaryPath,\n        couldBeIntercepted,\n        canonicalUrl,\n        routeIsPPREnabled,\n        false // hasDynamicRewrite\n      )\n    } else {\n      // PPR is not enabled for this route. The server responds with a\n      // different format (FlightRouterState) that we need to convert.\n      // TODO: We will unify the responses eventually. I'm keeping the types\n      // separate for now because FlightRouterState has so many\n      // overloaded concerns.\n      const prefetchStream = createPrefetchResponseStream(\n        response.body,\n        closed.resolve,\n        function onResponseSizeUpdate(size) {\n          setSizeInCacheMap(entry, size)\n        }\n      )\n      const serverData =\n        await createFromNextReadableStream<NavigationFlightResponse>(\n          prefetchStream,\n          headers\n        )\n      if (serverData.b !== getAppBuildId()) {\n        // The server build does not match the client. Treat as a 404. During\n        // an actual navigation, the router will trigger an MPA navigation.\n        // TODO: Consider moving the build ID to a response header so we can check\n        // it before decoding the response, and so there's one way of checking\n        // across all response types.\n        // TODO: We should cache the fact that this is an MPA navigation.\n        rejectRouteCacheEntry(entry, Date.now() + 10 * 1000)\n        return null\n      }\n\n      // Read head vary params synchronously. Individual segments carry their\n      // own thenables in CacheNodeSeedData.\n      const headVaryParamsThenable = serverData.h\n      const headVaryParams =\n        headVaryParamsThenable !== null\n          ? readVaryParams(headVaryParamsThenable)\n          : null\n      writeDynamicTreeResponseIntoCache(\n        Date.now(),\n        task,\n        // The non-PPR response format is what we'd get if we prefetched these segments\n        // using the LoadingBoundary fetch strategy, so mark their cache entries accordingly.\n        FetchStrategy.LoadingBoundary,\n        response as RSCResponse<NavigationFlightResponse>,\n        serverData,\n        entry,\n        couldBeIntercepted,\n        canonicalUrl,\n        routeIsPPREnabled,\n        headVaryParams,\n        pathname\n      )\n    }\n\n    if (!couldBeIntercepted) {\n      // This route will never be intercepted. So we can use this entry for all\n      // requests to this route, regardless of the Next-Url header. This works\n      // because when reading the cache we always check for a valid\n      // non-intercepted entry first.\n\n      // Re-key the entry. The `set` implementation handles removing it from\n      // its previous position in the cache. We don't need to do anything to\n      // update the LRU, because the entry is already in it.\n      // TODO: Treat this as an upsert — should check if an entry already\n      // exists at the new keypath, and if so, whether we should keep that\n      // one instead.\n      const fulfilledVaryPath: RouteVaryPath = getFulfilledRouteVaryPath(\n        pathname,\n        search,\n        nextUrl,\n        couldBeIntercepted\n      )\n      const isRevalidation = false\n      setInCacheMap(routeCacheMap, fulfilledVaryPath, entry, isRevalidation)\n    }\n    // Return a promise that resolves when the network connection closes, so\n    // the scheduler can track the number of concurrent network connections.\n    return { value: null, closed: closed.promise }\n  } catch (error) {\n    // Either the connection itself failed, or something bad happened while\n    // decoding the response.\n    rejectRouteCacheEntry(entry, Date.now() + 10 * 1000)\n    return null\n  }\n}\n\nexport async function fetchSegmentOnCacheMiss(\n  route: FulfilledRouteCacheEntry,\n  segmentCacheEntry: PendingSegmentCacheEntry,\n  routeKey: RouteCacheKey,\n  tree: RouteTree\n): Promise<PrefetchSubtaskResult<FulfilledSegmentCacheEntry> | null> {\n  // This function is allowed to use async/await because it contains the actual\n  // fetch that gets issued on a cache miss. Notice it writes the result to the\n  // cache entry directly, rather than return data that is then written by\n  // the caller.\n  //\n  // Segment fetches are non-blocking so we don't need to ping the scheduler\n  // on completion.\n\n  // Use the canonical URL to request the segment, not the original URL. These\n  // are usually the same, but the canonical URL will be different if the route\n  // tree response was redirected. To avoid an extra waterfall on every segment\n  // request, we pass the redirected URL instead of the original one.\n  const url = new URL(route.canonicalUrl, location.origin)\n  const nextUrl = routeKey.nextUrl\n\n  const requestKey = tree.requestKey\n  const normalizedRequestKey =\n    requestKey === ROOT_SEGMENT_REQUEST_KEY\n      ? // The root segment is a special case. To simplify the server-side\n        // handling of these requests, we encode the root segment path as\n        // `_index` instead of as an empty string. This should be treated as\n        // an implementation detail and not as a stable part of the protocol.\n        // It just needs to match the equivalent logic that happens when\n        // prerendering the responses. It should not leak outside of Next.js.\n        ('/_index' as SegmentRequestKey)\n      : requestKey\n\n  const headers: RequestHeaders = {\n    [RSC_HEADER]: '1',\n    [NEXT_ROUTER_PREFETCH_HEADER]: '1',\n    [NEXT_ROUTER_SEGMENT_PREFETCH_HEADER]: normalizedRequestKey,\n  }\n  if (nextUrl !== null) {\n    headers[NEXT_URL] = nextUrl\n  }\n\n  const requestUrl = isOutputExportMode\n    ? // In output: \"export\" mode, we need to add the segment path to the URL.\n      addSegmentPathToUrlInOutputExportMode(url, normalizedRequestKey)\n    : url\n  try {\n    const response = await fetchPrefetchResponse(requestUrl, headers)\n    if (\n      !response ||\n      !response.ok ||\n      response.status === 204 || // Cache miss\n      // This checks whether the response was served from the per-segment cache,\n      // rather than the old prefetching flow. If it fails, it implies that PPR\n      // is disabled on this route. Theoretically this should never happen\n      // because we only issue requests for segments once we've verified that\n      // the route supports PPR.\n      (response.headers.get(NEXT_DID_POSTPONE_HEADER) !== '2' &&\n        // In output: \"export\" mode, we can't rely on response headers. But if\n        // we receive a well-formed response, we can assume it's a static\n        // response, because all data is static in this mode.\n        !isOutputExportMode) ||\n      !response.body\n    ) {\n      // Server responded with an error, or with a miss. We should still cache\n      // the response, but we can try again after 10 seconds.\n      rejectSegmentCacheEntry(segmentCacheEntry, Date.now() + 10 * 1000)\n      return null\n    }\n\n    // Track when the network connection closes.\n    const closed = createPromiseWithResolvers<void>()\n\n    // Wrap the original stream in a new stream that never closes. That way the\n    // Flight client doesn't error if there's a hanging promise.\n    const prefetchStream = createPrefetchResponseStream(\n      response.body,\n      closed.resolve,\n      function onResponseSizeUpdate(size) {\n        setSizeInCacheMap(segmentCacheEntry, size)\n      }\n    )\n    const serverData = await (createFromNextReadableStream(\n      prefetchStream,\n      headers\n    ) as Promise<SegmentPrefetch>)\n    if (serverData.buildId !== getAppBuildId()) {\n      // The server build does not match the client. Treat as a 404. During\n      // an actual navigation, the router will trigger an MPA navigation.\n      // TODO: Consider moving the build ID to a response header so we can check\n      // it before decoding the response, and so there's one way of checking\n      // across all response types.\n      rejectSegmentCacheEntry(segmentCacheEntry, Date.now() + 10 * 1000)\n      return null\n    }\n    const staleAt = Date.now() + getStaleTimeMs(serverData.staleTime)\n    const fulfilledEntry = fulfillSegmentCacheEntry(\n      segmentCacheEntry,\n      serverData.rsc,\n      staleAt,\n      serverData.isPartial\n    )\n\n    // If the server tells us which params the segment varies by, we can re-key\n    // the entry to a more generic vary path. This allows the entry to be reused\n    // across different param values for params that the segment doesn't\n    // actually depend on.\n    const varyParams = serverData.varyParams\n    if (process.env.__NEXT_VARY_PARAMS && varyParams !== null) {\n      // Re-key the entry by storing it at a more generic vary path where\n      // unused params are replaced with Fallback.\n      const fulfilledVaryPath = getFulfilledSegmentVaryPath(\n        tree.varyPath,\n        varyParams\n      )\n      const isRevalidation = false\n      setInCacheMap(\n        segmentCacheMap,\n        fulfilledVaryPath,\n        fulfilledEntry,\n        isRevalidation\n      )\n    }\n\n    return {\n      value: fulfilledEntry,\n      // Return a promise that resolves when the network connection closes, so\n      // the scheduler can track the number of concurrent network connections.\n      closed: closed.promise,\n    }\n  } catch (error) {\n    // Either the connection itself failed, or something bad happened while\n    // decoding the response.\n    rejectSegmentCacheEntry(segmentCacheEntry, Date.now() + 10 * 1000)\n    return null\n  }\n}\n\nexport async function fetchSegmentPrefetchesUsingDynamicRequest(\n  task: PrefetchTask,\n  route: FulfilledRouteCacheEntry,\n  fetchStrategy:\n    | FetchStrategy.LoadingBoundary\n    | FetchStrategy.PPRRuntime\n    | FetchStrategy.Full,\n  dynamicRequestTree: FlightRouterState,\n  spawnedEntries: Map<SegmentRequestKey, PendingSegmentCacheEntry>\n): Promise<PrefetchSubtaskResult<null> | null> {\n  const key = task.key\n  const url = new URL(route.canonicalUrl, location.origin)\n  const nextUrl = key.nextUrl\n\n  if (\n    spawnedEntries.size === 1 &&\n    spawnedEntries.has(route.metadata.requestKey)\n  ) {\n    // The only thing pending is the head. Instruct the server to\n    // skip over everything else.\n    dynamicRequestTree = MetadataOnlyRequestTree\n  }\n\n  const headers: RequestHeaders = {\n    [RSC_HEADER]: '1',\n    [NEXT_ROUTER_STATE_TREE_HEADER]:\n      prepareFlightRouterStateForRequest(dynamicRequestTree),\n  }\n  if (nextUrl !== null) {\n    headers[NEXT_URL] = nextUrl\n  }\n  switch (fetchStrategy) {\n    case FetchStrategy.Full: {\n      // We omit the prefetch header from a full prefetch because it's essentially\n      // just a navigation request that happens ahead of time — it should include\n      // all the same data in the response.\n      break\n    }\n    case FetchStrategy.PPRRuntime: {\n      headers[NEXT_ROUTER_PREFETCH_HEADER] = '2'\n      break\n    }\n    case FetchStrategy.LoadingBoundary: {\n      headers[NEXT_ROUTER_PREFETCH_HEADER] = '1'\n      break\n    }\n    default: {\n      fetchStrategy satisfies never\n    }\n  }\n\n  try {\n    const response = await fetchPrefetchResponse(url, headers)\n    if (!response || !response.ok || !response.body) {\n      // Server responded with an error, or with a miss. We should still cache\n      // the response, but we can try again after 10 seconds.\n      rejectSegmentEntriesIfStillPending(spawnedEntries, Date.now() + 10 * 1000)\n      return null\n    }\n\n    const renderedSearch = getRenderedSearch(response)\n    if (renderedSearch !== route.renderedSearch) {\n      // The search params that were used to render the target page are\n      // different from the search params in the request URL. This only happens\n      // when there's a dynamic rewrite in between the tree prefetch and the\n      // data prefetch.\n      // TODO: For now, since this is an edge case, we reject the prefetch, but\n      // the proper way to handle this is to evict the stale route tree entry\n      // then fill the cache with the new response.\n      rejectSegmentEntriesIfStillPending(spawnedEntries, Date.now() + 10 * 1000)\n      return null\n    }\n\n    // Track when the network connection closes.\n    const closed = createPromiseWithResolvers<void>()\n\n    let fulfilledEntries: Array<FulfilledSegmentCacheEntry> | null = null\n    const prefetchStream = createPrefetchResponseStream(\n      response.body,\n      closed.resolve,\n      function onResponseSizeUpdate(totalBytesReceivedSoFar) {\n        // When processing a dynamic response, we don't know how large each\n        // individual segment is, so approximate by assiging each segment\n        // the average of the total response size.\n        if (fulfilledEntries === null) {\n          // Haven't received enough data yet to know which segments\n          // were included.\n          return\n        }\n        const averageSize = totalBytesReceivedSoFar / fulfilledEntries.length\n        for (const entry of fulfilledEntries) {\n          setSizeInCacheMap(entry, averageSize)\n        }\n      }\n    )\n    const serverData = await (createFromNextReadableStream(\n      prefetchStream,\n      headers\n    ) as Promise<NavigationFlightResponse>)\n\n    const isResponsePartial =\n      fetchStrategy === FetchStrategy.PPRRuntime\n        ? // A runtime prefetch may have holes.\n          serverData.rp?.[0] === true\n        : // Full and LoadingBoundary prefetches cannot have holes.\n          // (even if we did set the prefetch header, we only use this codepath for non-PPR-enabled routes)\n          false\n    // Read head vary params synchronously. Individual segments carry their\n    // own thenables in CacheNodeSeedData.\n    const headVaryParamsThenable = serverData.h\n    const headVaryParams =\n      headVaryParamsThenable !== null\n        ? readVaryParams(headVaryParamsThenable)\n        : null\n\n    // Aside from writing the data into the cache, this function also returns\n    // the entries that were fulfilled, so we can streamingly update their sizes\n    // in the LRU as more data comes in.\n    fulfilledEntries = writeDynamicRenderResponseIntoCache(\n      Date.now(),\n      task,\n      fetchStrategy,\n      response as RSCResponse<NavigationFlightResponse>,\n      serverData,\n      isResponsePartial,\n      headVaryParams,\n      route,\n      spawnedEntries\n    )\n\n    // Return a promise that resolves when the network connection closes, so\n    // the scheduler can track the number of concurrent network connections.\n    return { value: null, closed: closed.promise }\n  } catch (error) {\n    rejectSegmentEntriesIfStillPending(spawnedEntries, Date.now() + 10 * 1000)\n    return null\n  }\n}\n\nfunction writeDynamicTreeResponseIntoCache(\n  now: number,\n  task: PrefetchTask,\n  fetchStrategy:\n    | FetchStrategy.LoadingBoundary\n    | FetchStrategy.PPRRuntime\n    | FetchStrategy.Full,\n  response: RSCResponse<NavigationFlightResponse>,\n  serverData: NavigationFlightResponse,\n  entry: PendingRouteCacheEntry,\n  couldBeIntercepted: boolean,\n  canonicalUrl: string,\n  routeIsPPREnabled: boolean,\n  headVaryParams: VaryParams | null,\n  originalPathname: string\n): void {\n  const renderedSearch = getRenderedSearch(response)\n\n  const normalizedFlightDataResult = normalizeFlightData(serverData.f)\n  if (\n    // A string result means navigating to this route will result in an\n    // MPA navigation.\n    typeof normalizedFlightDataResult === 'string' ||\n    normalizedFlightDataResult.length !== 1\n  ) {\n    rejectRouteCacheEntry(entry, now + 10 * 1000)\n    return\n  }\n  const flightData = normalizedFlightDataResult[0]\n  if (!flightData.isRootRender) {\n    // Unexpected response format.\n    rejectRouteCacheEntry(entry, now + 10 * 1000)\n    return\n  }\n\n  const flightRouterState = flightData.tree\n  // If the response contains dynamic holes, then we must conservatively assume\n  // that any individual segment might contain dynamic holes, and also the\n  // head. If it did not contain dynamic holes, then we can assume every segment\n  // and the head is completely static.\n  const isResponsePartial =\n    response.headers.get(NEXT_DID_POSTPONE_HEADER) === '1'\n\n  // Convert the server-sent data into the RouteTree format used by the\n  // client cache.\n  //\n  // During this traversal, we accumulate additional data into this\n  // \"accumulator\" object.\n  const acc: RouteTreeAccumulator = { metadataVaryPath: null }\n  const routeTree = convertRootFlightRouterStateToRouteTree(\n    flightRouterState,\n    renderedSearch,\n    acc\n  )\n  const metadataVaryPath = acc.metadataVaryPath\n  if (metadataVaryPath === null) {\n    rejectRouteCacheEntry(entry, now + 10 * 1000)\n    return\n  }\n\n  const fulfilledEntry = discoverKnownRoute(\n    now,\n    originalPathname,\n    entry,\n    routeTree,\n    metadataVaryPath,\n    couldBeIntercepted,\n    canonicalUrl,\n    routeIsPPREnabled,\n    false // hasDynamicRewrite\n  )\n\n  // If the server sent segment data as part of the response, we should write\n  // it into the cache to prevent a second, redundant prefetch request.\n  //\n  // TODO: When `clientSegmentCache` is enabled, the server does not include\n  // segment data when responding to a route tree prefetch request. However,\n  // when `clientSegmentCache` is set to \"client-only\", and PPR is enabled (or\n  // the page is fully static), the normal check is bypassed and the server\n  // responds with the full page. This is a temporary situation until we can\n  // remove the \"client-only\" option. Then, we can delete this function call.\n  writeDynamicRenderResponseIntoCache(\n    now,\n    task,\n    fetchStrategy,\n    response,\n    serverData,\n    isResponsePartial,\n    headVaryParams,\n    fulfilledEntry,\n    null\n  )\n}\n\nfunction rejectSegmentEntriesIfStillPending(\n  entries: Map<SegmentRequestKey, SegmentCacheEntry>,\n  staleAt: number\n): Array<FulfilledSegmentCacheEntry> {\n  const fulfilledEntries = []\n  for (const entry of entries.values()) {\n    if (entry.status === EntryStatus.Pending) {\n      rejectSegmentCacheEntry(entry, staleAt)\n    } else if (entry.status === EntryStatus.Fulfilled) {\n      fulfilledEntries.push(entry)\n    }\n  }\n  return fulfilledEntries\n}\n\nfunction writeDynamicRenderResponseIntoCache(\n  now: number,\n  task: PrefetchTask,\n  fetchStrategy:\n    | FetchStrategy.LoadingBoundary\n    | FetchStrategy.PPRRuntime\n    | FetchStrategy.Full,\n  response: RSCResponse<NavigationFlightResponse>,\n  serverData: NavigationFlightResponse,\n  isResponsePartial: boolean,\n  headVaryParams: VaryParams | null,\n  route: FulfilledRouteCacheEntry,\n  spawnedEntries: Map<SegmentRequestKey, PendingSegmentCacheEntry> | null\n): Array<FulfilledSegmentCacheEntry> | null {\n  if (serverData.b !== getAppBuildId()) {\n    // The server build does not match the client. Treat as a 404. During\n    // an actual navigation, the router will trigger an MPA navigation.\n    // TODO: Consider moving the build ID to a response header so we can check\n    // it before decoding the response, and so there's one way of checking\n    // across all response types.\n    if (spawnedEntries !== null) {\n      rejectSegmentEntriesIfStillPending(spawnedEntries, now + 10 * 1000)\n    }\n    return null\n  }\n\n  const flightDatas = normalizeFlightData(serverData.f)\n  if (typeof flightDatas === 'string') {\n    // This means navigating to this route will result in an MPA navigation.\n    // TODO: We should cache this, too, so that the MPA navigation is immediate.\n    return null\n  }\n\n  // For runtime prefetches, stale time is in the payload at rp[1].\n  // For other responses, fall back to the header.\n  const staleTimeSeconds =\n    typeof serverData.rp?.[1] === 'number'\n      ? serverData.rp[1]\n      : parseInt(response.headers.get(NEXT_ROUTER_STALE_TIME_HEADER) ?? '', 10)\n  const staleTimeMs = !isNaN(staleTimeSeconds)\n    ? getStaleTimeMs(staleTimeSeconds)\n    : STATIC_STALETIME_MS\n  const staleAt = now + staleTimeMs\n\n  for (const flightData of flightDatas) {\n    const seedData = flightData.seedData\n    if (seedData !== null) {\n      // The data sent by the server represents only a subtree of the app. We\n      // need to find the part of the task tree that matches the response.\n      //\n      // segmentPath represents the parent path of subtree. It's a repeating\n      // pattern of parallel route key and segment:\n      //\n      //   [string, Segment, string, Segment, string, Segment, ...]\n      const segmentPath = flightData.segmentPath\n      let tree = route.tree\n      for (let i = 0; i < segmentPath.length; i += 2) {\n        const parallelRouteKey: string = segmentPath[i]\n        if (tree?.slots?.[parallelRouteKey] !== undefined) {\n          tree = tree.slots[parallelRouteKey]\n        } else {\n          if (spawnedEntries !== null) {\n            rejectSegmentEntriesIfStillPending(spawnedEntries, now + 10 * 1000)\n          }\n          return null\n        }\n      }\n\n      writeSeedDataIntoCache(\n        now,\n        task,\n        fetchStrategy,\n        tree,\n        staleAt,\n        seedData,\n        isResponsePartial,\n        spawnedEntries\n      )\n    }\n\n    const head = flightData.head\n    if (head !== null) {\n      // For head entries, use the head-specific vary params passed as parameter.\n      fulfillEntrySpawnedByRuntimePrefetch(\n        now,\n        fetchStrategy,\n        head,\n        flightData.isHeadPartial,\n        staleAt,\n        headVaryParams,\n        route.metadata,\n        spawnedEntries\n      )\n    }\n  }\n  // Any entry that's still pending was intentionally not rendered by the\n  // server, because it was inside the loading boundary. Mark them as rejected\n  // so we know not to fetch them again.\n  // TODO: If PPR is enabled on some routes but not others, then it's possible\n  // that a different page is able to do a per-segment prefetch of one of the\n  // segments we're marking as rejected here. We should mark on the segment\n  // somehow that the reason for the rejection is because of a non-PPR prefetch.\n  // That way a per-segment prefetch knows to disregard the rejection.\n  if (spawnedEntries !== null) {\n    const fulfilledEntries = rejectSegmentEntriesIfStillPending(\n      spawnedEntries,\n      now + 10 * 1000\n    )\n    return fulfilledEntries\n  }\n  return null\n}\n\nfunction writeSeedDataIntoCache(\n  now: number,\n  task: PrefetchTask,\n  fetchStrategy:\n    | FetchStrategy.LoadingBoundary\n    | FetchStrategy.PPRRuntime\n    | FetchStrategy.Full,\n  tree: RouteTree,\n  staleAt: number,\n  seedData: CacheNodeSeedData,\n  isResponsePartial: boolean,\n  entriesOwnedByCurrentTask: Map<\n    SegmentRequestKey,\n    PendingSegmentCacheEntry\n  > | null\n) {\n  // This function is used to write the result of a runtime server request\n  // (CacheNodeSeedData) into the prefetch cache.\n  const rsc = seedData[0]\n  const isPartial = rsc === null || isResponsePartial\n  const varyParamsThenable = seedData[5]\n  // Each segment carries its own vary params thenable in the seed data. The\n  // thenable resolves to the set of params the segment accessed during render.\n  // A null thenable means tracking was not enabled (not a prerender).\n  const varyParams =\n    varyParamsThenable !== null ? readVaryParams(varyParamsThenable) : null\n  fulfillEntrySpawnedByRuntimePrefetch(\n    now,\n    fetchStrategy,\n    rsc,\n    isPartial,\n    staleAt,\n    varyParams,\n    tree,\n    entriesOwnedByCurrentTask\n  )\n\n  // Recursively write the child data into the cache.\n  const slots = tree.slots\n  if (slots !== null) {\n    const seedDataChildren = seedData[1]\n    for (const parallelRouteKey in slots) {\n      const childTree = slots[parallelRouteKey]\n      const childSeedData: CacheNodeSeedData | null | void =\n        seedDataChildren[parallelRouteKey]\n      if (childSeedData !== null && childSeedData !== undefined) {\n        writeSeedDataIntoCache(\n          now,\n          task,\n          fetchStrategy,\n          childTree,\n          staleAt,\n          childSeedData,\n          isResponsePartial,\n          entriesOwnedByCurrentTask\n        )\n      }\n    }\n  }\n}\n\nfunction fulfillEntrySpawnedByRuntimePrefetch(\n  now: number,\n  fetchStrategy:\n    | FetchStrategy.LoadingBoundary\n    | FetchStrategy.PPRRuntime\n    | FetchStrategy.Full,\n  rsc: React.ReactNode,\n  isPartial: boolean,\n  staleAt: number,\n  segmentVaryParams: Set<string> | null,\n  tree: RouteTree,\n  entriesOwnedByCurrentTask: Map<\n    SegmentRequestKey,\n    PendingSegmentCacheEntry\n  > | null\n) {\n  // We should only write into cache entries that are owned by us. Or create\n  // a new one and write into that. We must never write over an entry that was\n  // created by a different task, because that causes data races.\n  const ownedEntry =\n    entriesOwnedByCurrentTask !== null\n      ? entriesOwnedByCurrentTask.get(tree.requestKey)\n      : undefined\n  if (ownedEntry !== undefined) {\n    const fulfilledEntry = fulfillSegmentCacheEntry(\n      ownedEntry,\n      rsc,\n      staleAt,\n      isPartial\n    )\n    // Re-key the entry based on which params the segment actually depends on.\n    if (process.env.__NEXT_VARY_PARAMS && segmentVaryParams !== null) {\n      const fulfilledVaryPath = getFulfilledSegmentVaryPath(\n        tree.varyPath,\n        segmentVaryParams\n      )\n      const isRevalidation = false\n      setInCacheMap(\n        segmentCacheMap,\n        fulfilledVaryPath,\n        fulfilledEntry,\n        isRevalidation\n      )\n    }\n  } else {\n    // There's no matching entry. Attempt to create a new one.\n    const possiblyNewEntry = readOrCreateSegmentCacheEntry(\n      now,\n      fetchStrategy,\n      tree\n    )\n    if (possiblyNewEntry.status === EntryStatus.Empty) {\n      // Confirmed this is a new entry. We can fulfill it.\n      const newEntry = possiblyNewEntry\n      const fulfilledEntry = fulfillSegmentCacheEntry(\n        upgradeToPendingSegment(newEntry, fetchStrategy),\n        rsc,\n        staleAt,\n        isPartial\n      )\n      // Re-key the entry based on which params the segment actually depends on.\n      if (process.env.__NEXT_VARY_PARAMS && segmentVaryParams !== null) {\n        const fulfilledVaryPath = getFulfilledSegmentVaryPath(\n          tree.varyPath,\n          segmentVaryParams\n        )\n        const isRevalidation = false\n        setInCacheMap(\n          segmentCacheMap,\n          fulfilledVaryPath,\n          fulfilledEntry,\n          isRevalidation\n        )\n      }\n    } else {\n      // There was already an entry in the cache. But we may be able to\n      // replace it with the new one from the server.\n      const newEntry = fulfillSegmentCacheEntry(\n        upgradeToPendingSegment(\n          createDetachedSegmentCacheEntry(now),\n          fetchStrategy\n        ),\n        rsc,\n        staleAt,\n        isPartial\n      )\n      // Use the fulfilled vary path if available, otherwise fall back to\n      // the request vary path.\n      const varyPath =\n        process.env.__NEXT_VARY_PARAMS && segmentVaryParams !== null\n          ? getFulfilledSegmentVaryPath(tree.varyPath, segmentVaryParams)\n          : getSegmentVaryPathForRequest(fetchStrategy, tree)\n      upsertSegmentEntry(now, varyPath, newEntry)\n    }\n  }\n}\n\nasync function fetchPrefetchResponse<T>(\n  url: URL,\n  headers: RequestHeaders\n): Promise<RSCResponse<T> | null> {\n  const fetchPriority = 'low'\n  // When issuing a prefetch request, don't immediately decode the response; we\n  // use the lower level `createFromResponse` API instead because we need to do\n  // some extra processing of the response stream. See\n  // `createPrefetchResponseStream` for more details.\n  const shouldImmediatelyDecode = false\n  const response = await createFetch<T>(\n    url,\n    headers,\n    fetchPriority,\n    shouldImmediatelyDecode\n  )\n  if (!response.ok) {\n    return null\n  }\n\n  // Check the content type\n  if (isOutputExportMode) {\n    // In output: \"export\" mode, we relaxed about the content type, since it's\n    // not Next.js that's serving the response. If the status is OK, assume the\n    // response is valid. If it's not a valid response, the Flight client won't\n    // be able to decode it, and we'll treat it as a miss.\n  } else {\n    const contentType = response.headers.get('content-type')\n    const isFlightResponse =\n      contentType && contentType.startsWith(RSC_CONTENT_TYPE_HEADER)\n    if (!isFlightResponse) {\n      return null\n    }\n  }\n  return response\n}\n\nfunction createPrefetchResponseStream(\n  originalFlightStream: ReadableStream<Uint8Array>,\n  onStreamClose: () => void,\n  onResponseSizeUpdate: (size: number) => void\n): ReadableStream<Uint8Array> {\n  // When PPR is enabled, prefetch streams may contain references that never\n  // resolve, because that's how we encode dynamic data access. In the decoded\n  // object returned by the Flight client, these are reified into hanging\n  // promises that suspend during render, which is effectively what we want.\n  // The UI resolves when it switches to the dynamic data stream\n  // (via useDeferredValue(dynamic, static)).\n  //\n  // However, the Flight implementation currently errors if the server closes\n  // the response before all the references are resolved. As a cheat to work\n  // around this, we wrap the original stream in a new stream that never closes,\n  // and therefore doesn't error.\n  //\n  // While processing the original stream, we also incrementally update the size\n  // of the cache entry in the LRU.\n  let totalByteLength = 0\n  const reader = originalFlightStream.getReader()\n  return new ReadableStream({\n    async pull(controller) {\n      while (true) {\n        const { done, value } = await reader.read()\n        if (!done) {\n          // Pass to the target stream and keep consuming the Flight response\n          // from the server.\n          controller.enqueue(value)\n\n          // Incrementally update the size of the cache entry in the LRU.\n          // NOTE: Since prefetch responses are delivered in a single chunk,\n          // it's not really necessary to do this streamingly, but I'm doing it\n          // anyway in case this changes in the future.\n          totalByteLength += value.byteLength\n          onResponseSizeUpdate(totalByteLength)\n          continue\n        }\n        // The server stream has closed. Exit, but intentionally do not close\n        // the target stream. We do notify the caller, though.\n        onStreamClose()\n        return\n      }\n    },\n  })\n}\n\nfunction addSegmentPathToUrlInOutputExportMode(\n  url: URL,\n  segmentPath: SegmentRequestKey\n): URL {\n  if (isOutputExportMode) {\n    // In output: \"export\" mode, we cannot use a header to encode the segment\n    // path. Instead, we append it to the end of the pathname.\n    const staticUrl = new URL(url)\n    const routeDir = staticUrl.pathname.endsWith('/')\n      ? staticUrl.pathname.slice(0, -1)\n      : staticUrl.pathname\n    const staticExportFilename =\n      convertSegmentPathToStaticExportFilename(segmentPath)\n    staticUrl.pathname = `${routeDir}/${staticExportFilename}`\n    return staticUrl\n  }\n  return url\n}\n\n/**\n * Checks whether the new fetch strategy is likely to provide more content than the old one.\n *\n * Generally, when an app uses dynamic data, a \"more specific\" fetch strategy is expected to provide more content:\n * - `LoadingBoundary` only provides static layouts\n * - `PPR` can provide shells for each segment (even for segments that use dynamic data)\n * - `PPRRuntime` can additionally include content that uses searchParams, params, or cookies\n * - `Full` includes all the content, even if it uses dynamic data\n *\n * However, it's possible that a more specific fetch strategy *won't* give us more content if:\n * - a segment is fully static\n *   (then, `PPR`/`PPRRuntime`/`Full` will all yield equivalent results)\n * - providing searchParams/params/cookies doesn't reveal any more content, e.g. because of an `await connection()`\n *   (then, `PPR` and `PPRRuntime` will yield equivalent results, only `Full` will give us more)\n * Because of this, when comparing two segments, we should also check if the existing segment is partial.\n * If it's not partial, then there's no need to prefetch it again, even using a \"more specific\" strategy.\n * There's currently no way to know if `PPRRuntime` will yield more data that `PPR`, so we have to assume it will.\n *\n * Also note that, in practice, we don't expect to be comparing `LoadingBoundary` to `PPR`/`PPRRuntime`,\n * because a non-PPR-enabled route wouldn't ever use the latter strategies. It might however use `Full`.\n */\nexport function canNewFetchStrategyProvideMoreContent(\n  currentStrategy: FetchStrategy,\n  newStrategy: FetchStrategy\n): boolean {\n  return currentStrategy < newStrategy\n}\n"],"names":["EntryStatus","attemptToFulfillDynamicSegmentFromBFCache","canNewFetchStrategyProvideMoreContent","convertReusedFlightRouterStateToRouteTree","convertRootFlightRouterStateToRouteTree","convertRouteTreeToFlightRouterState","createDetachedSegmentCacheEntry","createMetadataRouteTree","deprecated_requestOptimisticRouteCacheEntry","fetchRouteOnCacheMiss","fetchSegmentOnCacheMiss","fetchSegmentPrefetchesUsingDynamicRequest","fulfillRouteCacheEntry","getCurrentRouteCacheVersion","getCurrentSegmentCacheVersion","getStaleTimeMs","invalidateEntirePrefetchCache","invalidateRouteCacheEntries","invalidateSegmentCacheEntries","markRouteEntryAsDynamicRewrite","overwriteRevalidatingSegmentCacheEntry","pingInvalidationListeners","readOrCreateRevalidatingSegmentEntry","readOrCreateRouteCacheEntry","readOrCreateSegmentCacheEntry","readRouteCacheEntry","readSegmentCacheEntry","upgradeToPendingSegment","upsertSegmentEntry","waitForSegmentCacheEntry","writeRouteIntoCache","staleTimeSeconds","Math","max","isOutputExportMode","process","env","NODE_ENV","__NEXT_CONFIG_OUTPUT","MetadataOnlyRequestTree","routeCacheMap","createCacheMap","segmentCacheMap","invalidationListeners","currentRouteCacheVersion","currentSegmentCacheVersion","nextUrl","tree","pingVisibleLinks","attachInvalidationListener","task","onInvalidate","Set","add","notifyInvalidationListener","error","reportError","console","tasks","isPrefetchTaskDirty","now","key","varyPath","getRouteVaryPath","pathname","search","isRevalidation","existingEntry","getFromCacheMap","__NEXT_OPTIMISTIC_ROUTING","matchKnownRoute","readRevalidatingSegmentCacheEntry","pendingEntry","promiseWithResolvers","promise","createPromiseWithResolvers","createDetachedRouteCacheEntry","canonicalUrl","status","blockedTasks","metadata","couldBeIntercepted","isPPREnabled","renderedSearch","ref","size","staleAt","Infinity","version","setInCacheMap","requestedUrl","requestedSearch","urlWithoutSearchParams","URL","routeWithNoSearchParams","createPrefetchRequestKey","href","canonicalUrlForRouteWithNoSearchParams","origin","optimisticCanonicalSearch","optimisticRenderedSearch","optimisticUrl","location","optimisticCanonicalUrl","createHrefFromUrl","optimisticRouteTree","deprecated_createOptimisticRouteTree","optimisticMetadataTree","optimisticEntry","hasDynamicRewrite","newRenderedSearch","clonedSlots","originalSlots","slots","parallelRouteKey","childTree","isPage","requestKey","segment","refreshState","clonePageVaryPathWithNewSearchParams","isRootLayout","hasLoadingBoundary","hasRuntimePrefetch","fetchStrategy","varyPathForRequest","getSegmentVaryPathForRequest","candidateEntry","isValueExpired","isPartial","rejectedEntry","rsc","deleteFromCacheMap","emptyEntry","FetchStrategy","PPR","Full","adjustedCurrentTime","STATIC_STALETIME_MS","DYNAMIC_STALETIME_MS","bfcacheEntry","readFromBFCacheDuringRegularNavigation","requestedAt","dynamicPrefetchStaleAt","pendingSegment","fulfillSegmentCacheEntry","pingBlockedTasks","entry","pingPrefetchTask","metadataVaryPath","HEAD_REQUEST_KEY","HasLoadingBoundary","SubtreeHasNoLoadingBoundary","getRenderedSearchFromVaryPath","fulfilledEntry","segmentCacheEntry","resolve","rejectRouteCacheEntry","rejectSegmentCacheEntry","convertRootTreePrefetchToRouteTree","rootTree","renderedPathname","acc","pathnameParts","split","filter","p","index","rootSegment","ROOT_SEGMENT_REQUEST_KEY","convertTreePrefetchToRouteTree","prefetch","partialVaryPath","pathnamePartsIndex","prefetchSlots","finalizeLayoutVaryPath","childPrefetch","childSegmentName","name","childParam","param","childDoesAppearInURL","childSegment","childPartialVaryPath","childParamValue","parseDynamicParamFromURLPart","type","childParamKey","getCacheKeyForDynamicParam","appendLayoutVaryPath","siblings","doesStaticSegmentAppearInURL","childPathnamePartsIndex","childRequestKeyPart","createSegmentRequestKeyPart","childRequestKey","appendSegmentRequestKeyPart","endsWith","PAGE_SEGMENT_KEY","finalizePageVaryPath","finalizeMetadataVaryPath","SegmentHasLoadingBoundary","flightRouterState","convertFlightRouterStateToRouteTree","parentRouteTree","parentPartialVaryPath","getPartialPageVaryPath","getPartialLayoutVaryPath","parentRequestKey","requestKeyPart","parentRenderedSearch","originalSegment","compressedRefreshState","Array","isArray","paramCacheKey","paramName","parallelRoutes","childRouterState","undefined","routeTree","segmentPath","headers","RSC_HEADER","NEXT_ROUTER_PREFETCH_HEADER","NEXT_ROUTER_SEGMENT_PREFETCH_HEADER","NEXT_URL","url","response","urlAfterRedirects","headResponse","fetch","method","Date","redirected","fetchPrefetchResponse","addSegmentPathToUrlInOutputExportMode","ok","body","varyHeader","get","includes","closed","routeIsPPREnabled","NEXT_DID_POSTPONE_HEADER","prefetchStream","createPrefetchResponseStream","onResponseSizeUpdate","setSizeInCacheMap","serverData","createFromNextReadableStream","buildId","getAppBuildId","getRenderedPathname","getRenderedSearch","discoverKnownRoute","b","headVaryParamsThenable","h","headVaryParams","readVaryParams","writeDynamicTreeResponseIntoCache","LoadingBoundary","fulfilledVaryPath","getFulfilledRouteVaryPath","value","route","routeKey","normalizedRequestKey","requestUrl","staleTime","varyParams","__NEXT_VARY_PARAMS","getFulfilledSegmentVaryPath","dynamicRequestTree","spawnedEntries","has","NEXT_ROUTER_STATE_TREE_HEADER","prepareFlightRouterStateForRequest","PPRRuntime","rejectSegmentEntriesIfStillPending","fulfilledEntries","totalBytesReceivedSoFar","averageSize","length","isResponsePartial","rp","writeDynamicRenderResponseIntoCache","originalPathname","normalizedFlightDataResult","normalizeFlightData","f","flightData","isRootRender","entries","values","push","flightDatas","parseInt","NEXT_ROUTER_STALE_TIME_HEADER","staleTimeMs","isNaN","seedData","i","writeSeedDataIntoCache","head","fulfillEntrySpawnedByRuntimePrefetch","isHeadPartial","entriesOwnedByCurrentTask","varyParamsThenable","seedDataChildren","childSeedData","segmentVaryParams","ownedEntry","possiblyNewEntry","newEntry","fetchPriority","shouldImmediatelyDecode","createFetch","contentType","isFlightResponse","startsWith","RSC_CONTENT_TYPE_HEADER","originalFlightStream","onStreamClose","totalByteLength","reader","getReader","ReadableStream","pull","controller","done","read","enqueue","byteLength","staticUrl","routeDir","slice","staticExportFilename","convertSegmentPathToStaticExportFilename","currentStrategy","newStrategy"],"mappings":"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","ignoreList":[0]}