{"version":3,"sources":["../../../../src/client/components/segment-cache/optimistic-routes.ts"],"sourcesContent":["/**\n * Optimistic Routing (Known Routes)\n *\n * This module enables the client to predict route structure for URLs that\n * haven't been prefetched yet, based on previously learned route patterns.\n * When successful, this allows skipping the route tree prefetch request\n * entirely.\n *\n * The core idea is that many URLs map to the same route structure. For example,\n * /blog/post-1 and /blog/post-2 both resolve to /blog/[slug]. Once we've\n * prefetched one, we can predict the structure of the other.\n *\n * However, we can't always make this prediction. Static siblings (like\n * /blog/featured alongside /blog/[slug]) have different route structures.\n * When we learn a dynamic route, we also learn its static siblings so we\n * know when NOT to apply the prediction.\n *\n * Main entry points:\n *\n * 1. discoverKnownRoute: Called after receiving a route tree from the server.\n *    Traverses the route tree, compares URL parts to segments, and populates\n *    the known route tree if they match. Routes are always inserted into the\n *    cache.\n *\n * 2. matchKnownRoute: Called when looking up a route with no cache entry.\n *    Matches the candidate URL against learned patterns. Returns a synthetic\n *    cache entry if successful, or null to fall back to server resolution.\n *\n * Rewrite detection happens during traversal: if a URL path part doesn't match\n * the corresponding route segment, we stop populating the known route tree\n * (since the mapping is incorrect) but still insert the route into the cache.\n *\n * The known route tree is append-only with no eviction. Route patterns are\n * derived from the filesystem, so they don't become stale within a session.\n * Cache invalidation on deploy clears everything anyway.\n *\n * Current limitations (deopt to server resolution):\n * - Rewrites: Detected during traversal (tree not populated, but route cached)\n * - Intercepted routes: Routes using (.), (..), (...) patterns\n */\n\nimport type { DynamicParamTypesShort } from '../../../shared/lib/app-router-types'\nimport type { RouteTree, FulfilledRouteCacheEntry } from './cache'\nimport {\n  EntryStatus,\n  writeRouteIntoCache,\n  fulfillRouteCacheEntry,\n  type PendingRouteCacheEntry,\n  createMetadataRouteTree,\n} from './cache'\nimport { doesStaticSegmentAppearInURL } from '../../route-params'\nimport type { NormalizedPathname, NormalizedSearch } from './cache-key'\nimport {\n  appendLayoutVaryPath,\n  finalizeLayoutVaryPath,\n  finalizePageVaryPath,\n  finalizeMetadataVaryPath,\n  type PartialSegmentVaryPath,\n  type PageVaryPath,\n} from './vary-path'\n\n/**\n * The known route tree is analogous to a route table. A different routing\n * implementation might use regexes or URLPattern; ours uses a trie indexed\n * by URL path segments.\n *\n * Each node (KnownRoutePart) represents a position in the URL and can have:\n * - staticChildren: Map of literal segments to child nodes\n * - dynamicChild: A single dynamic segment node ([slug], [...params], etc.)\n * - pattern: A cache entry template for routes that terminate here\n *\n * This tree only contains segments that correspond to actual filesystem routes.\n * Route groups like (marketing) and parallel routes like @modal are not\n * included since they don't appear in URLs. Similarly, if a URL is rewritten\n * to a different filesystem path, the original URL segments don't appear here\n * — only the resolved filesystem route structure is stored.\n *\n * Example tree after learning /blog/[slug], /blog/featured, and /about:\n *\n *   ├── about\n *   └── blog\n *       ├── featured\n *       └── [slug]\n *\n * When matching /blog/hello:\n *   1. \"blog\" matches static child\n *   2. \"hello\" doesn't match \"featured\", falls through to [slug]\n *   3. Returns [slug]'s pattern with resolved param { slug: \"hello\" }\n */\ntype KnownRoutePartBase = {\n  // Known static paths at this level. The null vs Map distinction is\n  // semantically meaningful:\n  // - null: Static siblings are UNKNOWN at this level (e.g., webpack dev mode\n  //   where routes are compiled on-demand). If there's a dynamicChild, we\n  //   can't safely match it because the URL might be an unknown static sibling.\n  // - Map (even if empty): Static siblings are KNOWN. We can safely match a\n  //   dynamicChild if the URL doesn't match any entry in the Map.\n  staticChildren: Map<string, KnownRoutePart> | null\n\n  // The cache entry that serves as a pattern for this route.\n  // When a URL matches, we clone this and substitute param values.\n  // null means we know this path exists (from static siblings) but haven't\n  // learned its structure yet.\n  pattern: FulfilledRouteCacheEntry | null\n\n  // TODO: For prefix rewrite support. When true, this part may not appear in\n  // the candidate URL because it was injected by a rewrite.\n  // mayBeSkippedInURL: boolean\n}\n\n// The dynamic child fields are structured as a union so that narrowing on\n// dynamicChild also narrows dynamicChildParamName and dynamicChildParamType.\ntype KnownRoutePartWithoutDynamicChild = KnownRoutePartBase & {\n  dynamicChild: null\n  dynamicChildParamName: null\n  dynamicChildParamType: null\n}\n\ntype KnownRoutePartWithDynamicChild = KnownRoutePartBase & {\n  dynamicChild: KnownRoutePart\n  dynamicChildParamName: string\n  dynamicChildParamType: DynamicParamTypesShort\n}\n\ntype KnownRoutePart =\n  | KnownRoutePartWithoutDynamicChild\n  | KnownRoutePartWithDynamicChild\n\n/**\n * Param values extracted during URL matching. Used to reify the template.\n * - string for regular dynamic [param]\n * - string[] for catch-all [...param] and optional catch-all [[...param]]\n */\ntype ResolvedParams = Map<string, string | string[]>\n\nfunction createEmptyPart(): KnownRoutePart {\n  return {\n    staticChildren: null,\n    dynamicChild: null,\n    dynamicChildParamName: null,\n    dynamicChildParamType: null,\n    pattern: null,\n  }\n}\n\n// The root of the known route tree.\nlet knownRouteTreeRoot: KnownRoutePart = createEmptyPart()\n\n/**\n * Learns a route pattern from a server response and inserts it into the cache.\n *\n * Called after receiving a route tree from the server (initial load, navigation,\n * or prefetch). Traverses the route tree, compares URL parts to segments, and\n * populates the known route tree if they match. Routes are always inserted into\n * the cache regardless of whether the URL matches the route structure.\n *\n * When pendingEntry is provided, it's fulfilled and used. When null, an entry\n * is created and inserted into the route cache map.\n *\n * When hasDynamicRewrite is true, the route entry is marked as having a\n * dynamic rewrite, which prevents it from being used as a template for future\n * predictions. This is set when we detect a mismatch between what we predicted\n * and what the server returned.\n *\n * Returns the fulfilled route cache entry.\n */\nexport function discoverKnownRoute(\n  now: number,\n  pathname: string,\n  pendingEntry: PendingRouteCacheEntry | null,\n  routeTree: RouteTree,\n  metadataVaryPath: PageVaryPath,\n  couldBeIntercepted: boolean,\n  canonicalUrl: string,\n  isPPREnabled: boolean,\n  hasDynamicRewrite: boolean\n): FulfilledRouteCacheEntry {\n  const tree = routeTree\n\n  const pathnameParts = pathname.split('/').filter((p) => p !== '')\n  const firstPart = pathnameParts.length > 0 ? pathnameParts[0] : null\n  const remainingParts = pathnameParts.length > 0 ? pathnameParts.slice(1) : []\n\n  if (pendingEntry !== null) {\n    // Fulfill the pending entry first\n    const fulfilledEntry = fulfillRouteCacheEntry(\n      now,\n      pendingEntry,\n      tree,\n      metadataVaryPath,\n      couldBeIntercepted,\n      canonicalUrl,\n      isPPREnabled\n    )\n    if (hasDynamicRewrite) {\n      fulfilledEntry.hasDynamicRewrite = true\n    }\n    // Populate the known route tree (handles rewrite detection internally).\n    // The entry is already in the cache; this just stores it as a pattern\n    // if the URL matches the route structure.\n    discoverKnownRoutePart(\n      knownRouteTreeRoot,\n      tree,\n      firstPart,\n      remainingParts,\n      fulfilledEntry,\n      now,\n      pathname,\n      tree,\n      metadataVaryPath,\n      couldBeIntercepted,\n      canonicalUrl,\n      isPPREnabled,\n      hasDynamicRewrite\n    )\n    return fulfilledEntry\n  }\n\n  // No pending entry - discoverKnownRoutePart will create one and insert it\n  // into the cache, or return an existing pattern if one exists.\n  return discoverKnownRoutePart(\n    knownRouteTreeRoot,\n    tree,\n    firstPart,\n    remainingParts,\n    null,\n    now,\n    pathname,\n    tree,\n    metadataVaryPath,\n    couldBeIntercepted,\n    canonicalUrl,\n    isPPREnabled,\n    hasDynamicRewrite\n  )\n}\n\n/**\n * Gets or creates the dynamic child node for a KnownRoutePart.\n * A node can have at most one dynamic child (you can't have both [slug] and\n * [id] at the same route level), so we either return existing or create new.\n */\nfunction discoverDynamicChild(\n  part: KnownRoutePart,\n  paramName: string,\n  paramType: DynamicParamTypesShort\n): KnownRoutePart {\n  if (part.dynamicChild !== null) {\n    return part.dynamicChild\n  }\n  const newChild = createEmptyPart()\n  // Type assertion needed because we're converting from \"without\" to \"with\"\n  // dynamic child variant.\n  const mutablePart = part as unknown as KnownRoutePartWithDynamicChild\n  mutablePart.dynamicChild = newChild\n  mutablePart.dynamicChildParamName = paramName\n  mutablePart.dynamicChildParamType = paramType\n  return newChild\n}\n\n/**\n * Recursive workhorse for discoverKnownRoute.\n *\n * Walks the route tree and URL parts in parallel, building out the known\n * route tree as it goes. At each step:\n * 1. Determines if the current segment appears in the URL (dynamic/static)\n * 2. Validates URL matches route structure (detects rewrites)\n * 3. Creates/updates the corresponding KnownRoutePart node\n * 4. Records static siblings for future matching\n * 5. Recurses into child slots (parallel routes)\n *\n * If a URL/route mismatch is detected (rewrite), we stop building the known\n * route tree but still cache the route entry for direct lookup.\n */\nfunction discoverKnownRoutePart(\n  parentKnownRoutePart: KnownRoutePart,\n  routeTree: RouteTree,\n  urlPart: string | null,\n  remainingParts: string[],\n  existingEntry: FulfilledRouteCacheEntry | null,\n  // These are passed through unchanged for entry creation at the leaf\n  now: number,\n  pathname: string,\n  fullTree: RouteTree,\n  metadataVaryPath: PageVaryPath,\n  couldBeIntercepted: boolean,\n  canonicalUrl: string,\n  isPPREnabled: boolean,\n  hasDynamicRewrite: boolean\n): FulfilledRouteCacheEntry {\n  const segment = routeTree.segment\n\n  let segmentAppearsInURL: boolean\n  let paramName: string | null = null\n  let paramType: DynamicParamTypesShort | null = null\n  let staticSiblings: readonly string[] | null = null\n\n  if (typeof segment === 'string') {\n    segmentAppearsInURL = doesStaticSegmentAppearInURL(segment)\n  } else {\n    // Dynamic segment tuple: [paramName, paramCacheKey, paramType, staticSiblings]\n    paramName = segment[0]\n    paramType = segment[2]\n    staticSiblings = segment[3]\n    segmentAppearsInURL = true\n  }\n\n  let knownRoutePart: KnownRoutePart = parentKnownRoutePart\n  let nextUrlPart: string | null = urlPart\n  let nextRemainingParts: string[] = remainingParts\n\n  if (segmentAppearsInURL) {\n    // Check for mismatch: if this is a static segment, the URL part must match\n    if (paramName === null && urlPart !== segment) {\n      // URL doesn't match route structure (likely a rewrite).\n      // Don't populate the known route tree, just write the route into the\n      // cache and return immediately.\n      if (existingEntry !== null) {\n        return existingEntry\n      }\n      return writeRouteIntoCache(\n        now,\n        pathname as NormalizedPathname,\n        fullTree,\n        metadataVaryPath,\n        couldBeIntercepted,\n        canonicalUrl,\n        isPPREnabled\n      )\n    }\n\n    // URL matches route structure. Build the known route tree.\n    if (paramName !== null && paramType !== null) {\n      // Dynamic segment\n      knownRoutePart = discoverDynamicChild(\n        parentKnownRoutePart,\n        paramName,\n        paramType\n      )\n\n      // Record static siblings as placeholder parts.\n      // IMPORTANT: We use the null vs Map distinction to track whether\n      // siblings are known at this level:\n      // - staticChildren: null = siblings unknown (can't safely match dynamic)\n      // - staticChildren: Map = siblings known (even if empty)\n      // This matters in dev mode where webpack may not know all siblings yet.\n      if (staticSiblings !== null) {\n        // Siblings are known - ensure we have a Map (even if empty)\n        if (parentKnownRoutePart.staticChildren === null) {\n          parentKnownRoutePart.staticChildren = new Map()\n        }\n        for (const sibling of staticSiblings) {\n          if (!parentKnownRoutePart.staticChildren.has(sibling)) {\n            parentKnownRoutePart.staticChildren.set(sibling, createEmptyPart())\n          }\n        }\n      }\n    } else {\n      // Static segment\n      if (parentKnownRoutePart.staticChildren === null) {\n        parentKnownRoutePart.staticChildren = new Map()\n      }\n      let existingChild = parentKnownRoutePart.staticChildren.get(urlPart!)\n      if (existingChild === undefined) {\n        existingChild = createEmptyPart()\n        parentKnownRoutePart.staticChildren.set(urlPart!, existingChild)\n      }\n      knownRoutePart = existingChild\n    }\n\n    // Advance to next URL part\n    nextUrlPart = remainingParts.length > 0 ? remainingParts[0] : null\n    nextRemainingParts =\n      remainingParts.length > 0 ? remainingParts.slice(1) : []\n  }\n  // else: Transparent segment (route group, __PAGE__, etc.)\n  // Stay at the same known route part, don't advance URL parts\n\n  // Recurse into child routes. A route tree can have multiple parallel routes\n  // (e.g., @modal alongside children). Each parallel route is a separate\n  // branch, but they all share the same URL - we just need to traverse all\n  // branches to build out the known route tree.\n  const slots = routeTree.slots\n  let resultFromChildren: FulfilledRouteCacheEntry | null = null\n  if (slots !== null) {\n    for (const parallelRouteKey in slots) {\n      const childRouteTree = slots[parallelRouteKey]\n      // Skip branches with refreshState set - these were reused from a\n      // different route (e.g., a \"default\" parallel slot) and don't represent\n      // the actual route structure for this URL.\n      if (childRouteTree.refreshState !== null) {\n        continue\n      }\n      const result = discoverKnownRoutePart(\n        knownRoutePart,\n        childRouteTree,\n        nextUrlPart,\n        nextRemainingParts,\n        existingEntry,\n        now,\n        pathname,\n        fullTree,\n        metadataVaryPath,\n        couldBeIntercepted,\n        canonicalUrl,\n        isPPREnabled,\n        hasDynamicRewrite\n      )\n      // All parallel route branches share the same URL, so they should all\n      // reach compatible leaf nodes. We capture any result.\n      resultFromChildren = result\n    }\n    if (resultFromChildren !== null) {\n      return resultFromChildren\n    }\n    // Defensive fallback: no children returned a result. This shouldn't happen\n    // for valid route trees, but handle it gracefully.\n    if (existingEntry !== null) {\n      return existingEntry\n    }\n    return writeRouteIntoCache(\n      now,\n      pathname as NormalizedPathname,\n      fullTree,\n      metadataVaryPath,\n      couldBeIntercepted,\n      canonicalUrl,\n      isPPREnabled\n    )\n  }\n\n  // Reached a page node. Create/get the route cache entry and store as a\n  // pattern. First, check if there's already a pattern for this route.\n  if (knownRoutePart.pattern !== null) {\n    // If this route has a dynamic rewrite, mark the existing pattern.\n    if (hasDynamicRewrite) {\n      knownRoutePart.pattern.hasDynamicRewrite = true\n    }\n    return knownRoutePart.pattern\n  }\n\n  // Get or create the entry\n  let entry: FulfilledRouteCacheEntry\n  if (existingEntry !== null) {\n    // Already have a fulfilled entry, use it directly. It's already in the\n    // route cache map.\n    entry = existingEntry\n  } else {\n    // Create the entry and insert it into the route cache map.\n    entry = writeRouteIntoCache(\n      now,\n      pathname as NormalizedPathname,\n      fullTree,\n      metadataVaryPath,\n      couldBeIntercepted,\n      canonicalUrl,\n      isPPREnabled\n    )\n  }\n\n  if (hasDynamicRewrite) {\n    entry.hasDynamicRewrite = true\n  }\n\n  // Store as pattern\n  knownRoutePart.pattern = entry\n  return entry\n}\n\n/**\n * Attempts to match a URL against learned route patterns.\n *\n * Returns a synthetic FulfilledRouteCacheEntry if the URL matches a known\n * pattern, or null if no match is found (fall back to server resolution).\n */\nexport function matchKnownRoute(\n  pathname: string,\n  search: NormalizedSearch\n): FulfilledRouteCacheEntry | null {\n  const pathnameParts = pathname.split('/').filter((p) => p !== '')\n  const resolvedParams: ResolvedParams = new Map()\n  const match = matchKnownRoutePart(\n    knownRouteTreeRoot,\n    pathnameParts,\n    0,\n    resolvedParams\n  )\n\n  if (match === null) {\n    return null\n  }\n\n  const matchedPart = match.part\n  const pattern = match.pattern\n\n  // If the pattern could be intercepted, we can't safely use it for prediction\n  // because the route structure may vary based on the Next-Url header.\n  if (pattern.couldBeIntercepted) {\n    return null\n  }\n\n  // \"Reify\" the pattern: clone the template tree with concrete param values.\n  // This substitutes resolved params (e.g., slug: \"hello\") into dynamic\n  // segments and recomputes vary paths for correct segment cache keying.\n  const acc: ReifyAccumulator = { metadataVaryPath: null }\n  const reifiedTree = reifyRouteTree(\n    pattern.tree,\n    resolvedParams,\n    search,\n    null, // Start with null partial vary path at the root\n    acc\n  )\n\n  // The metadata tree is a flat page node without the intermediate layout\n  // structure. Clone it with the updated metadata vary path collected during\n  // the main tree traversal.\n  const metadataVaryPath = acc.metadataVaryPath\n  if (metadataVaryPath === null) {\n    // This shouldn't be reachable for a valid route tree.\n    return null\n  }\n  const reifiedMetadata = createMetadataRouteTree(metadataVaryPath)\n\n  // Create a synthetic (predicted) entry and store it as the new pattern.\n  //\n  // Why replace the pattern? We intentionally update the pattern with this\n  // synthetic entry so that if our prediction was wrong (server returns a\n  // different pathname due to dynamic rewrite), the entry gets marked with\n  // hasDynamicRewrite. Future predictions for this route will see the flag\n  // and bail out to server resolution instead of making the same mistake.\n  const syntheticEntry: FulfilledRouteCacheEntry = {\n    canonicalUrl: pathname + search,\n    status: EntryStatus.Fulfilled,\n    blockedTasks: null,\n    tree: reifiedTree,\n    metadata: reifiedMetadata,\n    couldBeIntercepted: pattern.couldBeIntercepted,\n    isPPREnabled: pattern.isPPREnabled,\n    hasDynamicRewrite: false,\n    renderedSearch: search,\n    ref: null,\n    size: pattern.size,\n    staleAt: pattern.staleAt,\n    version: pattern.version,\n  }\n\n  matchedPart.pattern = syntheticEntry\n\n  return syntheticEntry\n}\n\n/**\n * Result of a successful match: the matched tree node and its pattern.\n * We return both because the caller needs to update the pattern after\n * creating a synthetic entry (for dynamic rewrite detection).\n */\ntype KnownRouteMatch = {\n  part: KnownRoutePart\n  pattern: FulfilledRouteCacheEntry\n} | null\n\n/**\n * Recursively matches a URL against the known route tree.\n *\n * Matching priority (most specific first):\n * 1. Static children - exact path segment match\n * 2. Dynamic child - [param], [...param], [[...param]]\n * 3. Direct pattern - when no more URL parts remain\n *\n * Collects resolved param values in resolvedParams as it traverses.\n * Returns null if no match found (caller should fall back to server).\n */\nfunction matchKnownRoutePart(\n  part: KnownRoutePart,\n  pathnameParts: string[],\n  partIndex: number,\n  resolvedParams: ResolvedParams\n): KnownRouteMatch {\n  const urlPart =\n    partIndex < pathnameParts.length ? pathnameParts[partIndex] : null\n\n  // If staticChildren is null, we don't know what static routes exist at this\n  // level. This happens in webpack dev mode where routes are compiled\n  // on-demand. We can't safely match a dynamicChild because the URL part might\n  // be a static sibling we haven't discovered yet. Example: We know\n  // /blog/[slug] exists, but haven't compiled /blog/featured. A request for\n  // /blog/featured would incorrectly match /blog/[slug].\n  if (part.staticChildren === null) {\n    // The only safe match is a direct pattern when no URL parts remain.\n    if (urlPart === null) {\n      const pattern = part.pattern\n      if (pattern !== null && !pattern.hasDynamicRewrite) {\n        return { part, pattern }\n      }\n    }\n    return null\n  }\n\n  // Static children take priority over dynamic. This ensures /blog/featured\n  // matches its own route rather than /blog/[slug].\n  if (urlPart !== null) {\n    const staticChild = part.staticChildren.get(urlPart)\n    if (staticChild !== undefined) {\n      // Check if this is an \"unknown\" placeholder part. These are created when\n      // we learn about static siblings (from the route tree's staticSiblings\n      // field) but haven't prefetched them yet. We know the path exists but\n      // don't know its structure, so we can't predict it.\n      if (\n        staticChild.pattern === null &&\n        staticChild.dynamicChild === null &&\n        staticChild.staticChildren === null\n      ) {\n        // Bail out - server must resolve this route.\n        return null\n      }\n      const match = matchKnownRoutePart(\n        staticChild,\n        pathnameParts,\n        partIndex + 1,\n        resolvedParams\n      )\n      if (match !== null) {\n        return match\n      }\n      // Static child exists but didn't match (e.g., wrong depth).\n      // Fall through to try dynamic.\n    }\n  }\n\n  // Try dynamic child\n  if (part.dynamicChild !== null) {\n    const dynamicPart = part.dynamicChild\n    const paramName = part.dynamicChildParamName\n    const paramType = part.dynamicChildParamType\n    const dynamicPattern = dynamicPart.pattern\n\n    switch (paramType) {\n      case 'c':\n        // Required catch-all [...param]: consumes 1+ URL parts\n        if (\n          dynamicPattern !== null &&\n          !dynamicPattern.hasDynamicRewrite &&\n          urlPart !== null\n        ) {\n          resolvedParams.set(paramName, pathnameParts.slice(partIndex))\n          return { part: dynamicPart, pattern: dynamicPattern }\n        }\n        break\n      case 'oc':\n        // Optional catch-all [[...param]]: consumes 0+ URL parts\n        if (dynamicPattern !== null && !dynamicPattern.hasDynamicRewrite) {\n          if (urlPart !== null) {\n            resolvedParams.set(paramName, pathnameParts.slice(partIndex))\n            return { part: dynamicPart, pattern: dynamicPattern }\n          }\n          // urlPart is null - can match with zero parts, but a direct pattern\n          // (e.g., page.tsx alongside [[...param]]) takes precedence.\n          if (part.pattern === null || part.pattern.hasDynamicRewrite) {\n            resolvedParams.set(paramName, [])\n            return { part: dynamicPart, pattern: dynamicPattern }\n          }\n        }\n        break\n      case 'd':\n        // Regular dynamic [param]: consumes exactly 1 URL part.\n        // Unlike catch-all which terminates here, regular dynamic must\n        // continue recursing to find the leaf pattern.\n        if (urlPart !== null) {\n          resolvedParams.set(paramName, urlPart)\n          return matchKnownRoutePart(\n            dynamicPart,\n            pathnameParts,\n            partIndex + 1,\n            resolvedParams\n          )\n        }\n        break\n      // Intercepted routes use relative path markers like (.), (..), (...)\n      // Their behavior depends on navigation context (soft vs hard nav),\n      // so we can't predict them client-side. Defer to server.\n      case 'ci(..)(..)':\n      case 'ci(.)':\n      case 'ci(..)':\n      case 'ci(...)':\n      case 'di(..)(..)':\n      case 'di(.)':\n      case 'di(..)':\n      case 'di(...)':\n        return null\n      default:\n        paramType satisfies never\n    }\n  }\n\n  // No children matched. If we've consumed all URL parts, check for a direct\n  // pattern at this node (the route terminates here).\n  if (urlPart === null) {\n    const pattern = part.pattern\n    if (pattern !== null && !pattern.hasDynamicRewrite) {\n      return { part, pattern }\n    }\n  }\n\n  return null\n}\n\n/**\n * Accumulator for collecting data during reifyRouteTree traversal.\n * metadataVaryPath is collected from the first page node encountered\n * (parallel routes may have multiple pages, but metadata uses the first).\n */\ntype ReifyAccumulator = {\n  metadataVaryPath: PageVaryPath | null\n}\n\n/**\n * \"Reify\" means to make concrete - we take an abstract pattern (the template\n * route tree) and produce a concrete instance with actual param values.\n *\n * This function clones a RouteTree, substituting dynamic segment values from\n * resolvedParams and computing new vary paths. The vary path encodes param\n * values so segment cache entries can be correctly keyed.\n *\n * Example: Pattern for /blog/[slug] with resolvedParams { slug: \"hello\" }\n * produces a tree where segment [slug] has cacheKey \"hello\".\n */\nfunction reifyRouteTree(\n  pattern: RouteTree,\n  resolvedParams: ResolvedParams,\n  search: NormalizedSearch,\n  parentPartialVaryPath: PartialSegmentVaryPath | null,\n  acc: ReifyAccumulator\n): RouteTree {\n  const originalSegment = pattern.segment\n\n  let newSegment = originalSegment\n  let partialVaryPath: PartialSegmentVaryPath | null\n\n  if (typeof originalSegment !== 'string') {\n    // Dynamic segment: compute new cache key and append to partial vary path\n    const paramName = originalSegment[0]\n    const paramType = originalSegment[2]\n    const staticSiblings = originalSegment[3]\n    const newValue = resolvedParams.get(paramName)\n    if (newValue !== undefined) {\n      const newCacheKey = Array.isArray(newValue)\n        ? newValue.join('/')\n        : newValue\n      newSegment = [paramName, newCacheKey, paramType, staticSiblings]\n      partialVaryPath = appendLayoutVaryPath(\n        parentPartialVaryPath,\n        newCacheKey,\n        paramName\n      )\n    } else {\n      // Param not found in resolvedParams - keep original and inherit partial\n      // TODO: This should never happen. Bail out with null.\n      partialVaryPath = parentPartialVaryPath\n    }\n  } else {\n    // Static segment: inherit partial vary path from parent\n    partialVaryPath = parentPartialVaryPath\n  }\n\n  // Recurse into children with the (possibly updated) partial vary path\n  let newSlots: Record<string, RouteTree> | null = null\n  if (pattern.slots !== null) {\n    newSlots = {}\n    for (const key in pattern.slots) {\n      newSlots[key] = reifyRouteTree(\n        pattern.slots[key],\n        resolvedParams,\n        search,\n        partialVaryPath,\n        acc\n      )\n    }\n  }\n\n  if (pattern.isPage) {\n    // Page segment: finalize with search params\n    const newVaryPath = finalizePageVaryPath(\n      pattern.requestKey,\n      search,\n      partialVaryPath\n    )\n    // Collect metadata vary path (first page wins, same as original algorithm)\n    if (acc.metadataVaryPath === null) {\n      acc.metadataVaryPath = finalizeMetadataVaryPath(\n        pattern.requestKey,\n        search,\n        partialVaryPath\n      )\n    }\n    return {\n      requestKey: pattern.requestKey,\n      segment: newSegment,\n      refreshState: pattern.refreshState,\n      slots: newSlots,\n      isRootLayout: pattern.isRootLayout,\n      hasLoadingBoundary: pattern.hasLoadingBoundary,\n      hasRuntimePrefetch: pattern.hasRuntimePrefetch,\n      isPage: true,\n      varyPath: newVaryPath,\n    }\n  } else {\n    // Layout segment: finalize without search params\n    const newVaryPath = finalizeLayoutVaryPath(\n      pattern.requestKey,\n      partialVaryPath\n    )\n    return {\n      requestKey: pattern.requestKey,\n      segment: newSegment,\n      refreshState: pattern.refreshState,\n      slots: newSlots,\n      isRootLayout: pattern.isRootLayout,\n      hasLoadingBoundary: pattern.hasLoadingBoundary,\n      hasRuntimePrefetch: pattern.hasRuntimePrefetch,\n      isPage: false,\n      varyPath: newVaryPath,\n    }\n  }\n}\n\n/**\n * Resets the known route tree. Called during development when routes may\n * change due to hot reloading.\n */\nexport function resetKnownRoutes(): void {\n  knownRouteTreeRoot = createEmptyPart()\n}\n"],"names":["discoverKnownRoute","matchKnownRoute","resetKnownRoutes","createEmptyPart","staticChildren","dynamicChild","dynamicChildParamName","dynamicChildParamType","pattern","knownRouteTreeRoot","now","pathname","pendingEntry","routeTree","metadataVaryPath","couldBeIntercepted","canonicalUrl","isPPREnabled","hasDynamicRewrite","tree","pathnameParts","split","filter","p","firstPart","length","remainingParts","slice","fulfilledEntry","fulfillRouteCacheEntry","discoverKnownRoutePart","discoverDynamicChild","part","paramName","paramType","newChild","mutablePart","parentKnownRoutePart","urlPart","existingEntry","fullTree","segment","segmentAppearsInURL","staticSiblings","doesStaticSegmentAppearInURL","knownRoutePart","nextUrlPart","nextRemainingParts","writeRouteIntoCache","Map","sibling","has","set","existingChild","get","undefined","slots","resultFromChildren","parallelRouteKey","childRouteTree","refreshState","result","entry","search","resolvedParams","match","matchKnownRoutePart","matchedPart","acc","reifiedTree","reifyRouteTree","reifiedMetadata","createMetadataRouteTree","syntheticEntry","status","EntryStatus","Fulfilled","blockedTasks","metadata","renderedSearch","ref","size","staleAt","version","partIndex","staticChild","dynamicPart","dynamicPattern","parentPartialVaryPath","originalSegment","newSegment","partialVaryPath","newValue","newCacheKey","Array","isArray","join","appendLayoutVaryPath","newSlots","key","isPage","newVaryPath","finalizePageVaryPath","requestKey","finalizeMetadataVaryPath","isRootLayout","hasLoadingBoundary","hasRuntimePrefetch","varyPath","finalizeLayoutVaryPath"],"mappings":"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","ignoreList":[0]}