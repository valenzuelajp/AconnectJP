{"version":3,"sources":["../../../../src/client/components/segment-cache/vary-path.ts"],"sourcesContent":["import { FetchStrategy } from './types'\nimport type {\n  NormalizedPathname,\n  NormalizedSearch,\n  NormalizedNextUrl,\n} from './cache-key'\nimport type { RouteTree } from './cache'\nimport { Fallback, type FallbackType } from './cache-map'\nimport { HEAD_REQUEST_KEY } from '../../../shared/lib/segment-cache/segment-value-encoding'\n\ntype Opaque<T, K> = T & { __brand: K }\n\n/**\n * A linked-list of all the params (or other param-like) inputs that a cache\n * entry may vary by. This is used by the CacheMap module to reuse cache entries\n * across different param values. If a param has a value of Fallback, it means\n * the cache entry is reusable for all possible values of that param. See\n * cache-map.ts for details.\n *\n * A segment's vary path is a pure function of a segment's position in a\n * particular route tree and the (post-rewrite) URL that is being queried. More\n * concretely, successive queries of the cache for the same segment always use\n * the same vary path.\n *\n * A route's vary path is simpler: it's comprised of the pathname, search\n * string, and Next-URL header.\n */\nexport type VaryPath = {\n  /**\n   * Identifies which param this vary path node corresponds to. Used by\n   * getFulfilledSegmentVaryPath to determine which params to replace with\n   * Fallback based on the varyParams set from the server.\n   *\n   * - For path params: the param name (e.g., 'slug')\n   * - For search params: '?'\n   * - For non-param nodes (request keys, etc.): null\n   */\n  id: string | null\n  value: string | null | FallbackType\n  parent: VaryPath | null\n}\n\n// Because it's so important for vary paths to line up across cache accesses,\n// we use opaque type aliases to ensure these are only created within\n// this module.\n\n// requestKey -> searchParams -> nextUrl\nexport type RouteVaryPath = Opaque<\n  {\n    id: null\n    value: NormalizedPathname\n    parent: {\n      id: '?'\n      value: NormalizedSearch\n      parent: {\n        id: null\n        value: NormalizedNextUrl | null | FallbackType\n        parent: null\n      }\n    }\n  },\n  'RouteVaryPath'\n>\n\n// requestKey -> pathParams\nexport type LayoutVaryPath = Opaque<\n  {\n    id: null\n    value: string\n    parent: PartialSegmentVaryPath | null\n  },\n  'LayoutVaryPath'\n>\n\n// requestKey -> searchParams -> pathParams\nexport type PageVaryPath = Opaque<\n  {\n    id: null\n    value: string\n    parent: {\n      id: '?'\n      value: NormalizedSearch | FallbackType\n      parent: PartialSegmentVaryPath | null\n    }\n  },\n  'PageVaryPath'\n>\n\nexport type SegmentVaryPath = LayoutVaryPath | PageVaryPath\n\n// Intermediate type used when building a vary path during a recursive traversal\n// of the route tree.\nexport type PartialSegmentVaryPath = Opaque<VaryPath, 'PartialSegmentVaryPath'>\n\nexport function getRouteVaryPath(\n  pathname: NormalizedPathname,\n  search: NormalizedSearch,\n  nextUrl: NormalizedNextUrl | null\n): RouteVaryPath {\n  // requestKey -> searchParams -> nextUrl\n  const varyPath: VaryPath = {\n    id: null,\n    value: pathname,\n    parent: {\n      id: '?',\n      value: search,\n      parent: {\n        id: null,\n        value: nextUrl,\n        parent: null,\n      },\n    },\n  }\n  return varyPath as RouteVaryPath\n}\n\nexport function getFulfilledRouteVaryPath(\n  pathname: NormalizedPathname,\n  search: NormalizedSearch,\n  nextUrl: NormalizedNextUrl | null,\n  couldBeIntercepted: boolean\n): RouteVaryPath {\n  // This is called when a route's data is fulfilled. The cache entry will be\n  // re-keyed based on which inputs the response varies by.\n  // requestKey -> searchParams -> nextUrl\n  const varyPath: VaryPath = {\n    id: null,\n    value: pathname,\n    parent: {\n      id: '?',\n      value: search,\n      parent: {\n        id: null,\n        value: couldBeIntercepted ? nextUrl : Fallback,\n        parent: null,\n      },\n    },\n  }\n  return varyPath as RouteVaryPath\n}\n\nexport function appendLayoutVaryPath(\n  parentPath: PartialSegmentVaryPath | null,\n  cacheKey: string,\n  paramName: string\n): PartialSegmentVaryPath {\n  const varyPathPart: VaryPath = {\n    id: paramName,\n    value: cacheKey,\n    parent: parentPath,\n  }\n  return varyPathPart as PartialSegmentVaryPath\n}\n\nexport function finalizeLayoutVaryPath(\n  requestKey: string,\n  varyPath: PartialSegmentVaryPath | null\n): LayoutVaryPath {\n  const layoutVaryPath: VaryPath = {\n    id: null,\n    value: requestKey,\n    parent: varyPath,\n  }\n  return layoutVaryPath as LayoutVaryPath\n}\n\nexport function getPartialLayoutVaryPath(\n  finalizedVaryPath: LayoutVaryPath\n): PartialSegmentVaryPath | null {\n  // This is the inverse of finalizeLayoutVaryPath.\n  return finalizedVaryPath.parent\n}\n\nexport function finalizePageVaryPath(\n  requestKey: string,\n  renderedSearch: NormalizedSearch,\n  varyPath: PartialSegmentVaryPath | null\n): PageVaryPath {\n  // Unlike layouts, a page segment's vary path also includes the search string.\n  // requestKey -> searchParams -> pathParams\n  const pageVaryPath: VaryPath = {\n    id: null,\n    value: requestKey,\n    parent: {\n      id: '?',\n      value: renderedSearch,\n      parent: varyPath,\n    },\n  }\n  return pageVaryPath as PageVaryPath\n}\n\nexport function getPartialPageVaryPath(\n  finalizedVaryPath: PageVaryPath\n): PartialSegmentVaryPath | null {\n  // This is the inverse of finalizePageVaryPath.\n  return finalizedVaryPath.parent.parent\n}\n\nexport function finalizeMetadataVaryPath(\n  pageRequestKey: string,\n  renderedSearch: NormalizedSearch,\n  varyPath: PartialSegmentVaryPath | null\n): PageVaryPath {\n  // The metadata \"segment\" is not a real segment because it doesn't exist in\n  // the normal structure of the route tree, but in terms of caching, it\n  // behaves like a page segment because it varies by all the same params as\n  // a page.\n  //\n  // To keep the protocol for querying the server simple, the request key for\n  // the metadata does not include any path information. It's unnecessary from\n  // the server's perspective, because unlike page segments, there's only one\n  // metadata response per URL, i.e. there's no need to distinguish multiple\n  // parallel pages.\n  //\n  // However, this means the metadata request key is insufficient for\n  // caching the the metadata in the client cache, because on the client we\n  // use the request key to distinguish the metadata entry from all other\n  // page's metadata entries.\n  //\n  // So instead we create a simulated request key based on the page segment.\n  // Conceptually this is equivalent to the request key the server would have\n  // assigned the metadata segment if it treated it as part of the actual\n  // route structure.\n\n  // If there are multiple parallel pages, we use whichever is the first one.\n  // This is fine because the only difference between request keys for\n  // different parallel pages are things like route groups and parallel\n  // route slots. As long as it's always the same one, it doesn't matter.\n  const pageVaryPath: VaryPath = {\n    id: null,\n    // Append the actual metadata request key to the page request key. Note\n    // that we're not using a separate vary path part; it's unnecessary because\n    // these are not conceptually separate inputs.\n    value: pageRequestKey + HEAD_REQUEST_KEY,\n    parent: {\n      id: '?',\n      value: renderedSearch,\n      parent: varyPath,\n    },\n  }\n  return pageVaryPath as PageVaryPath\n}\n\nexport function getSegmentVaryPathForRequest(\n  fetchStrategy: FetchStrategy,\n  tree: RouteTree\n): SegmentVaryPath {\n  // This is used for storing pending requests in the cache. We want to choose\n  // the most generic vary path based on the strategy used to fetch it, i.e.\n  // static/PPR versus runtime prefetching, so that it can be reused as much\n  // as possible.\n  //\n  // We may be able to re-key the response to something even more generic once\n  // we receive it — for example, if the server tells us that the response\n  // doesn't vary on a particular param — but even before we send the request,\n  // we know some params are reusable based on the fetch strategy alone. For\n  // example, a static prefetch will never vary on search params.\n  //\n  // The original vary path with all the params filled in is stored on the\n  // route tree object. We will clone this one to create a new vary path\n  // where certain params are replaced with Fallback.\n  //\n  // This result of this function is not stored anywhere. It's only used to\n  // access the cache a single time.\n  //\n  // TODO: Rather than create a new list object just to access the cache, the\n  // plan is to add the concept of a \"vary mask\". This will represent all the\n  // params that can be treated as Fallback. (Or perhaps the inverse.)\n  const originalVaryPath = tree.varyPath\n\n  // Only page segments (and the special \"metadata\" segment, which is treated\n  // like a page segment for the purposes of caching) may contain search\n  // params. There's no reason to include them in the vary path otherwise.\n  if (tree.isPage) {\n    // Only a runtime prefetch will include search params in the vary path.\n    // Static prefetches never include search params, so they can be reused\n    // across all possible search param values.\n    const doesVaryOnSearchParams =\n      fetchStrategy === FetchStrategy.Full ||\n      fetchStrategy === FetchStrategy.PPRRuntime\n\n    if (!doesVaryOnSearchParams) {\n      // The response from the the server will not vary on search params. Clone\n      // the end of the original vary path to replace the search params\n      // with Fallback.\n      //\n      // requestKey -> searchParams -> pathParams\n      //               ^ This part gets replaced with Fallback\n      const searchParamsVaryPath = (originalVaryPath as PageVaryPath).parent\n      const pathParamsVaryPath = searchParamsVaryPath.parent\n      const patchedVaryPath: VaryPath = {\n        id: null,\n        value: originalVaryPath.value,\n        parent: {\n          id: '?',\n          value: Fallback,\n          parent: pathParamsVaryPath,\n        },\n      }\n      return patchedVaryPath as SegmentVaryPath\n    }\n  }\n\n  // The request does vary on search params. We don't need to modify anything.\n  return originalVaryPath as SegmentVaryPath\n}\n\nexport function clonePageVaryPathWithNewSearchParams(\n  originalVaryPath: PageVaryPath,\n  newSearch: NormalizedSearch\n): PageVaryPath {\n  // requestKey -> searchParams -> pathParams\n  //               ^ This part gets replaced with newSearch\n  const searchParamsVaryPath = originalVaryPath.parent\n  const clonedVaryPath: VaryPath = {\n    id: null,\n    value: originalVaryPath.value,\n    parent: {\n      id: '?',\n      value: newSearch,\n      parent: searchParamsVaryPath.parent,\n    },\n  }\n  return clonedVaryPath as PageVaryPath\n}\n\nexport function getRenderedSearchFromVaryPath(\n  varyPath: PageVaryPath\n): NormalizedSearch | null {\n  const searchParams = varyPath.parent.value\n  return typeof searchParams === 'string'\n    ? (searchParams as NormalizedSearch)\n    : null\n}\n\nexport function getFulfilledSegmentVaryPath(\n  original: VaryPath,\n  varyParams: Set<string>\n): SegmentVaryPath {\n  // Re-keys a segment's vary path based on which params the segment actually\n  // depends on. Params that are NOT in the varyParams set are replaced with\n  // Fallback, allowing the cache entry to be reused across different values of\n  // those params.\n\n  // This is called when a segment is fulfilled with data from the server. The\n  // varyParams set comes from the server and indicates which params were\n  // accessed during rendering.\n  const clone: VaryPath = {\n    id: original.id,\n    // If the id is null, this node is not a param (e.g., it's a request key).\n    // If the id is in the varyParams set, keep the original value.\n    // Otherwise, replace with Fallback to make it reusable.\n    value:\n      original.id === null || varyParams.has(original.id)\n        ? original.value\n        : Fallback,\n    parent:\n      original.parent === null\n        ? null\n        : getFulfilledSegmentVaryPath(original.parent, varyParams),\n  }\n  return clone as SegmentVaryPath\n}\n"],"names":["appendLayoutVaryPath","clonePageVaryPathWithNewSearchParams","finalizeLayoutVaryPath","finalizeMetadataVaryPath","finalizePageVaryPath","getFulfilledRouteVaryPath","getFulfilledSegmentVaryPath","getPartialLayoutVaryPath","getPartialPageVaryPath","getRenderedSearchFromVaryPath","getRouteVaryPath","getSegmentVaryPathForRequest","pathname","search","nextUrl","varyPath","id","value","parent","couldBeIntercepted","Fallback","parentPath","cacheKey","paramName","varyPathPart","requestKey","layoutVaryPath","finalizedVaryPath","renderedSearch","pageVaryPath","pageRequestKey","HEAD_REQUEST_KEY","fetchStrategy","tree","originalVaryPath","isPage","doesVaryOnSearchParams","FetchStrategy","Full","PPRRuntime","searchParamsVaryPath","pathParamsVaryPath","patchedVaryPath","newSearch","clonedVaryPath","searchParams","original","varyParams","clone","has"],"mappings":"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","ignoreList":[0]}