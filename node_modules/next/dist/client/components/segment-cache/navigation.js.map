{"version":3,"sources":["../../../../src/client/components/segment-cache/navigation.ts"],"sourcesContent":["import type {\n  CacheNodeSeedData,\n  FlightRouterState,\n  FlightSegmentPath,\n} from '../../../shared/lib/app-router-types'\nimport type { CacheNode } from '../../../shared/lib/app-router-types'\nimport type { HeadData } from '../../../shared/lib/app-router-types'\nimport type { NormalizedFlightData } from '../../flight-data-helpers'\nimport { fetchServerResponse } from '../router-reducer/fetch-server-response'\nimport {\n  startPPRNavigation,\n  spawnDynamicRequests,\n  FreshnessPolicy,\n  type NavigationRequestAccumulation,\n} from '../router-reducer/ppr-navigations'\nimport { createHrefFromUrl } from '../router-reducer/create-href-from-url'\nimport {\n  EntryStatus,\n  readRouteCacheEntry,\n  deprecated_requestOptimisticRouteCacheEntry,\n  convertRootFlightRouterStateToRouteTree,\n  type RouteTree,\n  type FulfilledRouteCacheEntry,\n} from './cache'\nimport { discoverKnownRoute } from './optimistic-routes'\nimport { createCacheKey, type NormalizedSearch } from './cache-key'\nimport type { PageVaryPath } from './vary-path'\nimport type { AppRouterState } from '../router-reducer/router-reducer-types'\nimport { computeChangedPath } from '../router-reducer/compute-changed-path'\nimport { isJavaScriptURLString } from '../../lib/javascript-url'\n\n/**\n * Navigate to a new URL, using the Segment Cache to construct a response.\n *\n * To allow for synchronous navigations whenever possible, this is not an async\n * function. It returns a promise only if there's no matching prefetch in\n * the cache. Otherwise it returns an immediate result and uses Suspense/RSC to\n * stream in any missing data.\n */\nexport function navigate(\n  state: AppRouterState,\n  url: URL,\n  currentUrl: URL,\n  currentRenderedSearch: string,\n  currentCacheNode: CacheNode | null,\n  currentFlightRouterState: FlightRouterState,\n  nextUrl: string | null,\n  freshnessPolicy: FreshnessPolicy,\n  shouldScroll: boolean,\n  navigateType: 'push' | 'replace'\n): AppRouterState | Promise<AppRouterState> {\n  const now = Date.now()\n  const href = url.href\n\n  const cacheKey = createCacheKey(href, nextUrl)\n  const route = readRouteCacheEntry(now, cacheKey)\n  if (route !== null && route.status === EntryStatus.Fulfilled) {\n    // We have a matching prefetch.\n    return navigateUsingPrefetchedRouteTree(\n      now,\n      state,\n      url,\n      currentUrl,\n      currentRenderedSearch,\n      nextUrl,\n      currentCacheNode,\n      currentFlightRouterState,\n      freshnessPolicy,\n      shouldScroll,\n      navigateType,\n      route\n    )\n  }\n\n  // There was no matching route tree in the cache. Let's see if we can\n  // construct an \"optimistic\" route tree using the deprecated search-params\n  // based matching. This is only used when the new optimisticRouting flag is\n  // disabled.\n  //\n  // Do not construct an optimistic route tree if there was a cache hit, but\n  // the entry has a rejected status, since it may have been rejected due to a\n  // rewrite or redirect based on the search params.\n  //\n  // TODO: There are multiple reasons a prefetch might be rejected; we should\n  // track them explicitly and choose what to do here based on that.\n  if (!process.env.__NEXT_OPTIMISTIC_ROUTING) {\n    if (route === null || route.status !== EntryStatus.Rejected) {\n      const optimisticRoute = deprecated_requestOptimisticRouteCacheEntry(\n        now,\n        url,\n        nextUrl\n      )\n      if (optimisticRoute !== null) {\n        // We have an optimistic route tree. Proceed with the normal flow.\n        return navigateUsingPrefetchedRouteTree(\n          now,\n          state,\n          url,\n          currentUrl,\n          currentRenderedSearch,\n          nextUrl,\n          currentCacheNode,\n          currentFlightRouterState,\n          freshnessPolicy,\n          shouldScroll,\n          navigateType,\n          optimisticRoute\n        )\n      }\n    }\n  }\n\n  // There's no matching prefetch for this route in the cache. We must lazily\n  // fetch it from the server before we can perform the navigation.\n  // TODO: If this is an gesture navigation, instead of performing a\n  // dynamic request, we should do a runtime prefetch.\n  return navigateToUnknownRoute(\n    now,\n    state,\n    url,\n    currentUrl,\n    currentRenderedSearch,\n    nextUrl,\n    currentCacheNode,\n    currentFlightRouterState,\n    freshnessPolicy,\n    shouldScroll,\n    navigateType\n  ).catch(() => {\n    // If the navigation fails, return the current state\n    return state\n  })\n}\n\nexport function navigateToKnownRoute(\n  now: number,\n  state: AppRouterState,\n  url: URL,\n  canonicalUrl: string,\n  navigationSeed: NavigationSeed,\n  currentUrl: URL,\n  currentRenderedSearch: string,\n  currentCacheNode: CacheNode | null,\n  currentFlightRouterState: FlightRouterState,\n  freshnessPolicy: FreshnessPolicy,\n  nextUrl: string | null,\n  shouldScroll: boolean,\n  navigateType: 'push' | 'replace',\n  debugInfo: Array<unknown> | null,\n  // The route cache entry used for this navigation, if it came from route\n  // prediction. Passed through so it can be marked as having a dynamic rewrite\n  // if the server returns a different pathname (indicating dynamic rewrite\n  // behavior).\n  //\n  // When null, the navigation did not use route prediction - either because\n  // the route was already fully cached, or it's a navigation that doesn't\n  // involve prediction (refresh, history traversal, server action, etc.).\n  // In these cases, if a mismatch occurs, we still mark the route as having a\n  // dynamic rewrite by traversing the known route tree (see\n  // dispatchRetryDueToTreeMismatch).\n  routeCacheEntry: FulfilledRouteCacheEntry | null\n): AppRouterState {\n  // A version of navigate() that accepts the target route tree as an argument\n  // rather than reading it from the prefetch cache.\n  const accumulation: NavigationRequestAccumulation = {\n    scrollableSegments: null,\n    separateRefreshUrls: null,\n  }\n  // We special case navigations to the exact same URL as the current location.\n  // It's a common UI pattern for apps to refresh when you click a link to the\n  // current page. So when this happens, we refresh the dynamic data in the page\n  // segments.\n  //\n  // Note that this does not apply if the any part of the hash or search query\n  // has changed. This might feel a bit weird but it makes more sense when you\n  // consider that the way to trigger this behavior is to click the same link\n  // multiple times.\n  //\n  // TODO: We should probably refresh the *entire* route when this case occurs,\n  // not just the page segments. Essentially treating it the same as a refresh()\n  // triggered by an action, which is the more explicit way of modeling the UI\n  // pattern described above.\n  //\n  // Also note that this only refreshes the dynamic data, not static/ cached\n  // data. If the page segment is fully static and prefetched, the request is\n  // skipped. (This is also how refresh() works.)\n  const isSamePageNavigation = url.href === currentUrl.href\n  const task = startPPRNavigation(\n    now,\n    currentUrl,\n    currentRenderedSearch,\n    currentCacheNode,\n    currentFlightRouterState,\n    navigationSeed.routeTree,\n    navigationSeed.metadataVaryPath,\n    freshnessPolicy,\n    navigationSeed.data,\n    navigationSeed.head,\n    isSamePageNavigation,\n    accumulation\n  )\n  if (task !== null) {\n    if (freshnessPolicy !== FreshnessPolicy.Gesture) {\n      spawnDynamicRequests(\n        task,\n        url,\n        nextUrl,\n        freshnessPolicy,\n        accumulation,\n        routeCacheEntry\n      )\n    }\n    return completeSoftNavigation(\n      state,\n      url,\n      nextUrl,\n      task.route,\n      task.node,\n      navigationSeed.renderedSearch,\n      canonicalUrl,\n      navigateType,\n      shouldScroll,\n      accumulation.scrollableSegments,\n      debugInfo\n    )\n  }\n  // Could not perform a SPA navigation. Revert to a full-page (MPA) navigation.\n  return completeHardNavigation(state, url, navigateType)\n}\n\nfunction navigateUsingPrefetchedRouteTree(\n  now: number,\n  state: AppRouterState,\n  url: URL,\n  currentUrl: URL,\n  currentRenderedSearch: string,\n  nextUrl: string | null,\n  currentCacheNode: CacheNode | null,\n  currentFlightRouterState: FlightRouterState,\n  freshnessPolicy: FreshnessPolicy,\n  shouldScroll: boolean,\n  navigateType: 'push' | 'replace',\n  route: FulfilledRouteCacheEntry\n): AppRouterState {\n  const routeTree = route.tree\n  const canonicalUrl = route.canonicalUrl + url.hash\n  const renderedSearch = route.renderedSearch\n  const prefetchSeed: NavigationSeed = {\n    renderedSearch,\n    routeTree,\n    metadataVaryPath: route.metadata.varyPath as any,\n    data: null,\n    head: null,\n  }\n  return navigateToKnownRoute(\n    now,\n    state,\n    url,\n    canonicalUrl,\n    prefetchSeed,\n    currentUrl,\n    currentRenderedSearch,\n    currentCacheNode,\n    currentFlightRouterState,\n    freshnessPolicy,\n    nextUrl,\n    shouldScroll,\n    navigateType,\n    null,\n    route\n  )\n}\n\n// Used to request all the dynamic data for a route, rather than just a subset,\n// e.g. during a refresh or a revalidation. Typically this gets constructed\n// during the normal flow when diffing the route tree, but for an unprefetched\n// navigation, where we don't know the structure of the target route, we use\n// this instead.\nconst DynamicRequestTreeForEntireRoute: FlightRouterState = [\n  '',\n  {},\n  null,\n  'refetch',\n]\n\nasync function navigateToUnknownRoute(\n  now: number,\n  state: AppRouterState,\n  url: URL,\n  currentUrl: URL,\n  currentRenderedSearch: string,\n  nextUrl: string | null,\n  currentCacheNode: CacheNode | null,\n  currentFlightRouterState: FlightRouterState,\n  freshnessPolicy: FreshnessPolicy,\n  shouldScroll: boolean,\n  navigateType: 'push' | 'replace'\n): Promise<AppRouterState> {\n  // Runs when a navigation happens but there's no cached prefetch we can use.\n  // Don't bother to wait for a prefetch response; go straight to a full\n  // navigation that contains both static and dynamic data in a single stream.\n  // (This is unlike the old navigation implementation, which instead blocks\n  // the dynamic request until a prefetch request is received.)\n  //\n  // To avoid duplication of logic, we're going to pretend that the tree\n  // returned by the dynamic request is, in fact, a prefetch tree. Then we can\n  // use the same server response to write the actual data into the CacheNode\n  // tree. So it's the same flow as the \"happy path\" (prefetch, then\n  // navigation), except we use a single server response for both stages.\n\n  let dynamicRequestTree: FlightRouterState\n  switch (freshnessPolicy) {\n    case FreshnessPolicy.Default:\n    case FreshnessPolicy.HistoryTraversal:\n    case FreshnessPolicy.Gesture:\n      dynamicRequestTree = currentFlightRouterState\n      break\n    case FreshnessPolicy.Hydration: // <- shouldn't happen during client nav\n    case FreshnessPolicy.RefreshAll:\n    case FreshnessPolicy.HMRRefresh:\n      dynamicRequestTree = DynamicRequestTreeForEntireRoute\n      break\n    default:\n      freshnessPolicy satisfies never\n      dynamicRequestTree = currentFlightRouterState\n      break\n  }\n\n  const promiseForDynamicServerResponse = fetchServerResponse(url, {\n    flightRouterState: dynamicRequestTree,\n    nextUrl,\n  })\n  const result = await promiseForDynamicServerResponse\n  if (typeof result === 'string') {\n    // This is an MPA navigation.\n    const redirectUrl = new URL(result, location.origin)\n    return completeHardNavigation(state, redirectUrl, navigateType)\n  }\n\n  const {\n    flightData,\n    canonicalUrl,\n    renderedSearch,\n    couldBeIntercepted,\n    prerendered,\n    debugInfo,\n  } = result\n\n  // Since the response format of dynamic requests and prefetches is slightly\n  // different, we'll need to massage the data a bit. Create FlightRouterState\n  // tree that simulates what we'd receive as the result of a prefetch.\n  const navigationSeed = convertServerPatchToFullTree(\n    currentFlightRouterState,\n    flightData,\n    renderedSearch\n  )\n\n  // Learn the route pattern so we can predict it for future navigations.\n  // hasDynamicRewrite is false because this is a fresh navigation to an\n  // unknown route - any rewrite detection happens during the traversal inside\n  // discoverKnownRoute. The hasDynamicRewrite param is only set to true when\n  // retrying after a tree mismatch (see dispatchRetryDueToTreeMismatch).\n  const metadataVaryPath = navigationSeed.metadataVaryPath\n  if (metadataVaryPath !== null) {\n    discoverKnownRoute(\n      now,\n      url.pathname,\n      null, // No pending entry\n      navigationSeed.routeTree,\n      metadataVaryPath,\n      couldBeIntercepted,\n      createHrefFromUrl(canonicalUrl),\n      prerendered,\n      false // hasDynamicRewrite - not a retry, rewrite detection happens during traversal\n    )\n  }\n\n  return navigateToKnownRoute(\n    now,\n    state,\n    url,\n    createHrefFromUrl(canonicalUrl),\n    navigationSeed,\n    currentUrl,\n    currentRenderedSearch,\n    currentCacheNode,\n    currentFlightRouterState,\n    freshnessPolicy,\n    nextUrl,\n    shouldScroll,\n    navigateType,\n    debugInfo,\n    // Unknown route navigations don't use route prediction - the route tree\n    // came directly from the server. If a mismatch occurs during dynamic data\n    // fetch, the retry handler will traverse the known route tree to mark the\n    // entry as having a dynamic rewrite.\n    null\n  )\n}\n\nexport function completeHardNavigation(\n  state: AppRouterState,\n  url: URL,\n  navigateType: 'push' | 'replace'\n): AppRouterState {\n  if (isJavaScriptURLString(url.href)) {\n    console.error(\n      'Next.js has blocked a javascript: URL as a security precaution.'\n    )\n    return state\n  }\n  const newState: AppRouterState = {\n    canonicalUrl:\n      url.origin === location.origin ? createHrefFromUrl(url) : url.href,\n    pushRef: {\n      pendingPush: navigateType === 'push',\n      mpaNavigation: true,\n      preserveCustomHistoryState: false,\n    },\n    // TODO: None of the rest of these values are consistent with the incoming\n    // navigation. We rely on the fact that AppRouter will suspend and trigger\n    // a hard navigation before it accesses any of these values. But instead\n    // we should trigger the hard navigation and blocking any subsequent\n    // router updates without updating React.\n    renderedSearch: state.renderedSearch,\n    focusAndScrollRef: state.focusAndScrollRef,\n    cache: state.cache,\n    tree: state.tree,\n    nextUrl: state.nextUrl,\n    previousNextUrl: state.previousNextUrl,\n    debugInfo: null,\n  }\n  return newState\n}\n\nexport function completeSoftNavigation(\n  oldState: AppRouterState,\n  url: URL,\n  referringNextUrl: string | null,\n  tree: FlightRouterState,\n  cache: CacheNode,\n  renderedSearch: string,\n  canonicalUrl: string,\n  navigateType: 'push' | 'replace',\n  shouldScroll: boolean,\n  scrollableSegments: Array<FlightSegmentPath> | null,\n  collectedDebugInfo: Array<unknown> | null\n) {\n  // The \"Next-Url\" is a special representation of the URL that Next.js\n  // uses to implement interception routes.\n  // TODO: Get rid of this extra traversal by computing this during the\n  // same traversal that computes the tree itself. We should also figure out\n  // what is the minimum information needed for the server to correctly\n  // intercept the route.\n  const changedPath = computeChangedPath(oldState.tree, tree)\n  const nextUrlForNewRoute = changedPath ? changedPath : oldState.nextUrl\n\n  // This value is stored on the state as `previousNextUrl`; the naming is\n  // confusing. What it represents is the \"Next-Url\" header that was used to\n  // fetch the incoming route. It's essentially the refererer URL, but in a\n  // Next.js specific format. During refreshes, this is sent back to the server\n  // instead of the current route's \"Next-Url\" so that the same interception\n  // logic is applied as during the original navigation.\n  const previousNextUrl = referringNextUrl\n\n  // Check if the only thing that changed was the hash fragment.\n  const oldUrl = new URL(oldState.canonicalUrl, url)\n  const onlyHashChange =\n    // We don't need to compare the origins, because client-driven\n    // navigations are always same-origin.\n    url.pathname === oldUrl.pathname &&\n    url.search === oldUrl.search &&\n    url.hash !== oldUrl.hash\n\n  // During a hash-only change, setting scrollableSegments to an empty\n  // array triggers a scroll for all new and updated segments. See\n  // `ScrollAndFocusHandler` for more details.\n  //\n  // TODO: Given the previous comment, I don't know why shouldScroll =\n  // false sets this to an empty array. Seems like an accident. I'm just\n  // preserving the logic that was already here. Clean this up when we\n  // move the per-segment scroll state to the CacheNode.\n  const segmentPathsToScrollTo =\n    onlyHashChange || !shouldScroll\n      ? []\n      : scrollableSegments !== null\n        ? scrollableSegments\n        : oldState.focusAndScrollRef.segmentPaths\n\n  const newState: AppRouterState = {\n    canonicalUrl,\n    renderedSearch,\n    pushRef: {\n      pendingPush: navigateType === 'push',\n      mpaNavigation: false,\n      preserveCustomHistoryState: false,\n    },\n    focusAndScrollRef: {\n      // TODO: We should track all the per-segment scroll state on the CacheNode\n      // instead of using the paths.\n      apply: shouldScroll\n        ? segmentPathsToScrollTo !== null\n          ? true\n          : oldState.focusAndScrollRef.apply\n        : oldState.focusAndScrollRef.apply,\n      onlyHashChange,\n      hashFragment:\n        // Remove leading # and decode hash to make non-latin hashes work.\n        //\n        // Empty hash should trigger default behavior of scrolling layout into\n        // view. #top is handled in layout-router.\n        //\n        // Refer to `ScrollAndFocusHandler` for details on how this is used.\n        shouldScroll && url.hash !== ''\n          ? decodeURIComponent(url.hash.slice(1))\n          : oldState.focusAndScrollRef.hashFragment,\n      segmentPaths: segmentPathsToScrollTo,\n    },\n    cache,\n    tree,\n    nextUrl: nextUrlForNewRoute,\n    previousNextUrl,\n    debugInfo: collectedDebugInfo,\n  }\n  return newState\n}\n\nexport function completeTraverseNavigation(\n  state: AppRouterState,\n  url: URL,\n  renderedSearch: string,\n  cache: CacheNode,\n  tree: FlightRouterState,\n  nextUrl: string | null\n) {\n  return {\n    // Set canonical url\n    canonicalUrl: createHrefFromUrl(url),\n    renderedSearch,\n    pushRef: {\n      pendingPush: false,\n      mpaNavigation: false,\n      // Ensures that the custom history state that was set is preserved when applying this update.\n      preserveCustomHistoryState: true,\n    },\n    focusAndScrollRef: state.focusAndScrollRef,\n    cache,\n    // Restore provided tree\n    tree,\n    nextUrl,\n    // TODO: We need to restore previousNextUrl, too, which represents the\n    // Next-Url that was used to fetch the data. Anywhere we fetch using the\n    // canonical URL, there should be a corresponding Next-Url.\n    previousNextUrl: null,\n    debugInfo: null,\n  }\n}\n\n// TODO: The rest of this file is related to converting the server response into\n// the data structures used by the client. Probably should move to a\n// separate module.\n\nexport type NavigationSeed = {\n  renderedSearch: string\n  routeTree: RouteTree\n  metadataVaryPath: PageVaryPath | null\n  data: CacheNodeSeedData | null\n  head: HeadData | null\n}\n\nexport function convertServerPatchToFullTree(\n  currentTree: FlightRouterState,\n  flightData: Array<NormalizedFlightData> | null,\n  renderedSearch: string\n): NavigationSeed {\n  // During a client navigation or prefetch, the server sends back only a patch\n  // for the parts of the tree that have changed.\n  //\n  // This applies the patch to the base tree to create a full representation of\n  // the resulting tree.\n  //\n  // The return type includes a full FlightRouterState tree and a full\n  // CacheNodeSeedData tree. (Conceptually these are the same tree, and should\n  // eventually be unified, but there's still lots of existing code that\n  // operates on FlightRouterState trees alone without the CacheNodeSeedData.)\n  //\n  // TODO: This similar to what apply-router-state-patch-to-tree does. It\n  // will eventually fully replace it. We should get rid of all the remaining\n  // places where we iterate over the server patch format. This should also\n  // eventually replace normalizeFlightData.\n\n  let baseTree: FlightRouterState = currentTree\n  let baseData: CacheNodeSeedData | null = null\n  let head: HeadData | null = null\n  if (flightData !== null) {\n    for (const {\n      segmentPath,\n      tree: treePatch,\n      seedData: dataPatch,\n      head: headPatch,\n    } of flightData) {\n      const result = convertServerPatchToFullTreeImpl(\n        baseTree,\n        baseData,\n        treePatch,\n        dataPatch,\n        segmentPath,\n        renderedSearch,\n        0\n      )\n      baseTree = result.tree\n      baseData = result.data\n      // This is the same for all patches per response, so just pick an\n      // arbitrary one\n      head = headPatch\n    }\n  }\n\n  const finalFlightRouterState = baseTree\n\n  // Convert the final FlightRouterState into a RouteTree type.\n  //\n  // TODO: Eventually, FlightRouterState will evolve to being a transport format\n  // only. The RouteTree type will become the main type used for dealing with\n  // routes on the client, and we'll store it in the state directly.\n  const acc = { metadataVaryPath: null }\n  const routeTree = convertRootFlightRouterStateToRouteTree(\n    finalFlightRouterState,\n    renderedSearch as NormalizedSearch,\n    acc\n  )\n\n  return {\n    routeTree,\n    metadataVaryPath: acc.metadataVaryPath,\n    data: baseData,\n    renderedSearch,\n    head,\n  }\n}\n\nfunction convertServerPatchToFullTreeImpl(\n  baseRouterState: FlightRouterState,\n  baseData: CacheNodeSeedData | null,\n  treePatch: FlightRouterState,\n  dataPatch: CacheNodeSeedData | null,\n  segmentPath: FlightSegmentPath,\n  renderedSearch: string,\n  index: number\n): { tree: FlightRouterState; data: CacheNodeSeedData | null } {\n  if (index === segmentPath.length) {\n    // We reached the part of the tree that we need to patch.\n    return {\n      tree: treePatch,\n      data: dataPatch,\n    }\n  }\n\n  // segmentPath represents the parent path of subtree. It's a repeating\n  // pattern of parallel route key and segment:\n  //\n  //   [string, Segment, string, Segment, string, Segment, ...]\n  //\n  // This path tells us which part of the base tree to apply the tree patch.\n  //\n  // NOTE: We receive the FlightRouterState patch in the same request as the\n  // seed data patch. Therefore we don't need to worry about diffing the segment\n  // values; we can assume the server sent us a correct result.\n  const updatedParallelRouteKey: string = segmentPath[index]\n  // const segment: Segment = segmentPath[index + 1] <-- Not used, see note above\n\n  const baseTreeChildren = baseRouterState[1]\n  const baseSeedDataChildren = baseData !== null ? baseData[1] : null\n  const newTreeChildren: Record<string, FlightRouterState> = {}\n  const newSeedDataChildren: Record<string, CacheNodeSeedData | null> = {}\n  for (const parallelRouteKey in baseTreeChildren) {\n    const childBaseRouterState = baseTreeChildren[parallelRouteKey]\n    const childBaseSeedData =\n      baseSeedDataChildren !== null\n        ? (baseSeedDataChildren[parallelRouteKey] ?? null)\n        : null\n    if (parallelRouteKey === updatedParallelRouteKey) {\n      const result = convertServerPatchToFullTreeImpl(\n        childBaseRouterState,\n        childBaseSeedData,\n        treePatch,\n        dataPatch,\n        segmentPath,\n        renderedSearch,\n        // Advance the index by two and keep cloning until we reach\n        // the end of the segment path.\n        index + 2\n      )\n\n      newTreeChildren[parallelRouteKey] = result.tree\n      newSeedDataChildren[parallelRouteKey] = result.data\n    } else {\n      // This child is not being patched. Copy it over as-is.\n      newTreeChildren[parallelRouteKey] = childBaseRouterState\n      newSeedDataChildren[parallelRouteKey] = childBaseSeedData\n    }\n  }\n\n  let clonedTree: FlightRouterState\n  let clonedSeedData: CacheNodeSeedData\n  // Clone all the fields except the children.\n\n  // Clone the FlightRouterState tree. Based on equivalent logic in\n  // apply-router-state-patch-to-tree, but should confirm whether we need to\n  // copy all of these fields. Not sure the server ever sends, e.g. the\n  // refetch marker.\n  clonedTree = [baseRouterState[0], newTreeChildren]\n  if (2 in baseRouterState) {\n    const compressedRefreshState = baseRouterState[2]\n    if (\n      compressedRefreshState !== undefined &&\n      compressedRefreshState !== null\n    ) {\n      // Since this part of the tree was patched with new data, any parent\n      // refresh states should be updated to reflect the new rendered search\n      // value. (The refresh state acts like a \"context provider\".) All pages\n      // within the same server response share the same renderedSearch value,\n      // but the same RouteTree could be composed from multiple different\n      // routes, and multiple responses.\n      clonedTree[2] = [compressedRefreshState[0], renderedSearch]\n    }\n  }\n  if (3 in baseRouterState) {\n    clonedTree[3] = baseRouterState[3]\n  }\n  if (4 in baseRouterState) {\n    clonedTree[4] = baseRouterState[4]\n  }\n\n  // Clone the CacheNodeSeedData tree.\n  const isEmptySeedDataPartial = true\n  clonedSeedData = [\n    null,\n    newSeedDataChildren,\n    null,\n    isEmptySeedDataPartial,\n    false,\n    null,\n  ]\n\n  return {\n    tree: clonedTree,\n    data: clonedSeedData,\n  }\n}\n"],"names":["completeHardNavigation","completeSoftNavigation","completeTraverseNavigation","convertServerPatchToFullTree","navigate","navigateToKnownRoute","state","url","currentUrl","currentRenderedSearch","currentCacheNode","currentFlightRouterState","nextUrl","freshnessPolicy","shouldScroll","navigateType","now","Date","href","cacheKey","createCacheKey","route","readRouteCacheEntry","status","EntryStatus","Fulfilled","navigateUsingPrefetchedRouteTree","process","env","__NEXT_OPTIMISTIC_ROUTING","Rejected","optimisticRoute","deprecated_requestOptimisticRouteCacheEntry","navigateToUnknownRoute","catch","canonicalUrl","navigationSeed","debugInfo","routeCacheEntry","accumulation","scrollableSegments","separateRefreshUrls","isSamePageNavigation","task","startPPRNavigation","routeTree","metadataVaryPath","data","head","FreshnessPolicy","Gesture","spawnDynamicRequests","node","renderedSearch","tree","hash","prefetchSeed","metadata","varyPath","DynamicRequestTreeForEntireRoute","dynamicRequestTree","Default","HistoryTraversal","Hydration","RefreshAll","HMRRefresh","promiseForDynamicServerResponse","fetchServerResponse","flightRouterState","result","redirectUrl","URL","location","origin","flightData","couldBeIntercepted","prerendered","discoverKnownRoute","pathname","createHrefFromUrl","isJavaScriptURLString","console","error","newState","pushRef","pendingPush","mpaNavigation","preserveCustomHistoryState","focusAndScrollRef","cache","previousNextUrl","oldState","referringNextUrl","collectedDebugInfo","changedPath","computeChangedPath","nextUrlForNewRoute","oldUrl","onlyHashChange","search","segmentPathsToScrollTo","segmentPaths","apply","hashFragment","decodeURIComponent","slice","currentTree","baseTree","baseData","segmentPath","treePatch","seedData","dataPatch","headPatch","convertServerPatchToFullTreeImpl","finalFlightRouterState","acc","convertRootFlightRouterStateToRouteTree","baseRouterState","index","length","updatedParallelRouteKey","baseTreeChildren","baseSeedDataChildren","newTreeChildren","newSeedDataChildren","parallelRouteKey","childBaseRouterState","childBaseSeedData","clonedTree","clonedSeedData","compressedRefreshState","undefined","isEmptySeedDataPartial"],"mappings":"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","ignoreList":[0]}