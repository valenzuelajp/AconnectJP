{"version":3,"sources":["../../../../src/server/lib/cpu-profile.ts"],"sourcesContent":["const privateCpuProfileName = process.env.__NEXT_PRIVATE_CPU_PROFILE\nconst isCpuProfileEnabled = process.env.NEXT_CPU_PROF || privateCpuProfileName\nconst cpuProfileDir = process.env.NEXT_CPU_PROF_DIR\n\nlet session: import('inspector').Session | null = null\nlet profileSaved = false\n\nif (isCpuProfileEnabled) {\n  const { Session } = require('inspector') as typeof import('inspector')\n\n  session = new Session()\n  session.connect()\n\n  session.post('Profiler.enable')\n  session.post('Profiler.start')\n\n  process.on('exit', () => {\n    saveCpuProfile()\n  })\n}\n\n/**\n * Save the CPU profile to disk.\n *\n * This is synchronous despite the callback-based API because inspector's\n * session.post() executes its callback synchronously when connected to\n * the same process (via session.connect()).\n */\nexport function saveCpuProfile(): void {\n  if (!session || profileSaved || !isCpuProfileEnabled) {\n    return\n  }\n  profileSaved = true\n\n  const fs = require('fs') as typeof import('fs')\n  const path = require('path') as typeof import('path')\n\n  session!.post('Profiler.stop', (error, param) => {\n    if (error) {\n      console.error('Cannot generate CPU profiling:', error)\n      return\n    }\n\n    const timestamp = new Date()\n      .toISOString()\n      .replace(/[:.]/g, '-')\n      .slice(0, 19)\n    const baseName = privateCpuProfileName || 'cpu-profile'\n    const filename = `${baseName}-${timestamp}.cpuprofile`\n\n    let outputPath: string\n    if (cpuProfileDir) {\n      if (!fs.existsSync(cpuProfileDir)) {\n        fs.mkdirSync(cpuProfileDir, { recursive: true })\n      }\n      outputPath = path.join(cpuProfileDir, filename)\n    } else {\n      outputPath = `./${filename}`\n    }\n\n    fs.writeFileSync(outputPath, JSON.stringify(param.profile))\n    const { green } =\n      require('../../lib/picocolors') as typeof import('../../lib/picocolors')\n    console.log(`\\n${green('CPU profile saved:')} ${outputPath}`)\n    console.log('Open in Chrome DevTools → Performance tab → Load profile')\n  })\n}\n"],"names":["privateCpuProfileName","process","env","__NEXT_PRIVATE_CPU_PROFILE","isCpuProfileEnabled","NEXT_CPU_PROF","cpuProfileDir","NEXT_CPU_PROF_DIR","session","profileSaved","Session","require","connect","post","on","saveCpuProfile","fs","path","error","param","console","timestamp","Date","toISOString","replace","slice","baseName","filename","outputPath","existsSync","mkdirSync","recursive","join","writeFileSync","JSON","stringify","profile","green","log"],"mappings":"AAAA,MAAMA,wBAAwBC,QAAQC,GAAG,CAACC,0BAA0B;AACpE,MAAMC,sBAAsBH,QAAQC,GAAG,CAACG,aAAa,IAAIL;AACzD,MAAMM,gBAAgBL,QAAQC,GAAG,CAACK,iBAAiB;AAEnD,IAAIC,UAA8C;AAClD,IAAIC,eAAe;AAEnB,IAAIL,qBAAqB;IACvB,MAAM,EAAEM,OAAO,EAAE,GAAGC,QAAQ;IAE5BH,UAAU,IAAIE;IACdF,QAAQI,OAAO;IAEfJ,QAAQK,IAAI,CAAC;IACbL,QAAQK,IAAI,CAAC;IAEbZ,QAAQa,EAAE,CAAC,QAAQ;QACjBC;IACF;AACF;AAEA;;;;;;CAMC,GACD,OAAO,SAASA;IACd,IAAI,CAACP,WAAWC,gBAAgB,CAACL,qBAAqB;QACpD;IACF;IACAK,eAAe;IAEf,MAAMO,KAAKL,QAAQ;IACnB,MAAMM,OAAON,QAAQ;IAErBH,QAASK,IAAI,CAAC,iBAAiB,CAACK,OAAOC;QACrC,IAAID,OAAO;YACTE,QAAQF,KAAK,CAAC,kCAAkCA;YAChD;QACF;QAEA,MAAMG,YAAY,IAAIC,OACnBC,WAAW,GACXC,OAAO,CAAC,SAAS,KACjBC,KAAK,CAAC,GAAG;QACZ,MAAMC,WAAW1B,yBAAyB;QAC1C,MAAM2B,WAAW,GAAGD,SAAS,CAAC,EAAEL,UAAU,WAAW,CAAC;QAEtD,IAAIO;QACJ,IAAItB,eAAe;YACjB,IAAI,CAACU,GAAGa,UAAU,CAACvB,gBAAgB;gBACjCU,GAAGc,SAAS,CAACxB,eAAe;oBAAEyB,WAAW;gBAAK;YAChD;YACAH,aAAaX,KAAKe,IAAI,CAAC1B,eAAeqB;QACxC,OAAO;YACLC,aAAa,CAAC,EAAE,EAAED,UAAU;QAC9B;QAEAX,GAAGiB,aAAa,CAACL,YAAYM,KAAKC,SAAS,CAAChB,MAAMiB,OAAO;QACzD,MAAM,EAAEC,KAAK,EAAE,GACb1B,QAAQ;QACVS,QAAQkB,GAAG,CAAC,CAAC,EAAE,EAAED,MAAM,sBAAsB,CAAC,EAAET,YAAY;QAC5DR,QAAQkB,GAAG,CAAC;IACd;AACF","ignoreList":[0]}