{"version":3,"sources":["../../../../../src/server/mcp/tools/get-routes.ts"],"sourcesContent":["/**\n * MCP tool for getting all routes that become entry points in a Next.js application.\n *\n * This tool discovers routes by scanning the filesystem directly. It finds all route\n * files in the app/ and pages/ directories and converts them to route paths.\n *\n * Returns routes grouped by router type:\n * - appRouter: App Router pages and route handlers\n * - pagesRouter: Pages Router pages and API routes\n *\n * Dynamic route segments appear as [id], [slug], or [...slug] patterns. This tool\n * does NOT expand getStaticParams - it only shows the route patterns as defined in\n * the filesystem.\n */\nimport type { McpServer } from 'next/dist/compiled/@modelcontextprotocol/sdk/server/mcp'\nimport { mcpTelemetryTracker } from '../mcp-telemetry-tracker'\nimport {\n  collectAppFiles,\n  collectPagesFiles,\n  processAppRoutes,\n  processPageRoutes,\n  createPagesMapping,\n} from '../../../build/entries'\nimport { createValidFileMatcher } from '../../lib/find-page-file'\nimport { PAGE_TYPES } from '../../../lib/page-types'\nimport type { NextConfigComplete } from '../../../server/config-shared'\nimport z from 'next/dist/compiled/zod'\n\ninterface RouteInfo {\n  route: string\n  type: 'app' | 'page' | 'api'\n}\n\nexport function registerGetRoutesTool(\n  server: McpServer,\n  options: {\n    projectPath: string\n    nextConfig: NextConfigComplete\n    pagesDir: string | undefined\n    appDir: string | undefined\n  }\n) {\n  server.registerTool(\n    'get_routes',\n    {\n      description:\n        'Get all routes that will become entry points in the Next.js application by scanning the filesystem. Returns routes grouped by router type (appRouter, pagesRouter). Dynamic segments appear as [param] or [...slug] patterns. API routes are included in their respective routers (e.g., /api/* routes from pages/ are in pagesRouter). Optional parameter: routerType (\"app\" | \"pages\") - filter by specific router type, omit to get all routes.',\n      inputSchema: {\n        routerType: z.union([z.literal('app'), z.literal('pages')]).optional(),\n      },\n    },\n    async (request) => {\n      // Track telemetry\n      mcpTelemetryTracker.recordToolCall('mcp/get_routes')\n\n      try {\n        const routerType =\n          request.routerType === 'app' || request.routerType === 'pages'\n            ? request.routerType\n            : undefined\n\n        const routes: RouteInfo[] = []\n\n        const { projectPath, nextConfig, pagesDir, appDir } = options\n\n        // Check if we have any directories to scan\n        if (!pagesDir && !appDir) {\n          return {\n            content: [\n              {\n                type: 'text',\n                text: JSON.stringify({\n                  error: 'No pages or app directory found in the project.',\n                }),\n              },\n            ],\n          }\n        }\n\n        const isSrcDir =\n          (pagesDir && pagesDir.includes('/src/')) ||\n          (appDir && appDir.includes('/src/'))\n\n        // Create valid file matcher for filtering\n        const validFileMatcher = createValidFileMatcher(\n          nextConfig.pageExtensions,\n          appDir\n        )\n\n        // Collect and process App Router routes if requested\n        if (appDir && (!routerType || routerType === 'app')) {\n          try {\n            const { appPaths } = await collectAppFiles(appDir, validFileMatcher)\n\n            if (appPaths.length > 0) {\n              const mappedAppPages = await createPagesMapping({\n                pagePaths: appPaths,\n                isDev: true,\n                pagesType: PAGE_TYPES.APP,\n                pageExtensions: nextConfig.pageExtensions,\n                pagesDir,\n                appDir,\n                appDirOnly: pagesDir ? false : true,\n              })\n\n              const { appRoutes, appRouteHandlers } = processAppRoutes(\n                mappedAppPages,\n                validFileMatcher,\n                projectPath,\n                isSrcDir || false\n              )\n\n              // Add app page routes\n              for (const { route } of appRoutes) {\n                routes.push({\n                  route,\n                  type: 'app',\n                })\n              }\n\n              // Add app route handlers\n              for (const { route } of appRouteHandlers) {\n                routes.push({\n                  route,\n                  type: 'app',\n                })\n              }\n            }\n          } catch (error) {\n            // Error collecting app routes - continue anyway\n          }\n        }\n\n        // Collect and process Pages Router routes if requested\n        if (pagesDir && (!routerType || routerType === 'pages')) {\n          try {\n            const pagePaths = await collectPagesFiles(\n              pagesDir,\n              validFileMatcher\n            )\n\n            if (pagePaths.length > 0) {\n              const mappedPages = await createPagesMapping({\n                pagePaths,\n                isDev: true,\n                pagesType: PAGE_TYPES.PAGES,\n                pageExtensions: nextConfig.pageExtensions,\n                pagesDir,\n                appDir,\n                appDirOnly: false,\n              })\n\n              const { pageRoutes, pageApiRoutes } = processPageRoutes(\n                mappedPages,\n                projectPath,\n                isSrcDir || false\n              )\n\n              // Add page routes\n              for (const { route } of pageRoutes) {\n                routes.push({\n                  route,\n                  type: 'page',\n                })\n              }\n\n              // Add API routes (always included as part of pages router)\n              for (const { route } of pageApiRoutes) {\n                routes.push({\n                  route,\n                  type: 'api',\n                })\n              }\n            }\n          } catch (error) {\n            // Error collecting pages routes - continue anyway\n          }\n        }\n\n        if (routes.length === 0) {\n          return {\n            content: [\n              {\n                type: 'text',\n                text: JSON.stringify({\n                  appRouter: [],\n                  pagesRouter: [],\n                }),\n              },\n            ],\n          }\n        }\n\n        // Group routes by router type\n        const appRoutes = routes\n          .filter((r) => r.type === 'app')\n          .map((r) => r.route)\n          .sort()\n        const pageRoutes = routes\n          .filter((r) => r.type === 'page' || r.type === 'api')\n          .map((r) => r.route)\n          .sort()\n\n        // Format the output with grouped routes\n        const output = {\n          appRouter: appRoutes.length > 0 ? appRoutes : undefined,\n          pagesRouter: pageRoutes.length > 0 ? pageRoutes : undefined,\n        }\n\n        return {\n          content: [\n            {\n              type: 'text',\n              text: JSON.stringify(output, null, 2),\n            },\n          ],\n        }\n      } catch (error) {\n        return {\n          content: [\n            {\n              type: 'text',\n              text: JSON.stringify({\n                error: error instanceof Error ? error.message : String(error),\n              }),\n            },\n          ],\n        }\n      }\n    }\n  )\n}\n"],"names":["mcpTelemetryTracker","collectAppFiles","collectPagesFiles","processAppRoutes","processPageRoutes","createPagesMapping","createValidFileMatcher","PAGE_TYPES","z","registerGetRoutesTool","server","options","registerTool","description","inputSchema","routerType","union","literal","optional","request","recordToolCall","undefined","routes","projectPath","nextConfig","pagesDir","appDir","content","type","text","JSON","stringify","error","isSrcDir","includes","validFileMatcher","pageExtensions","appPaths","length","mappedAppPages","pagePaths","isDev","pagesType","APP","appDirOnly","appRoutes","appRouteHandlers","route","push","mappedPages","PAGES","pageRoutes","pageApiRoutes","appRouter","pagesRouter","filter","r","map","sort","output","Error","message","String"],"mappings":"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","ignoreList":[0]}