{"version":3,"sources":["../../../../../../src/server/mcp/tools/utils/format-errors.ts"],"sourcesContent":["import type { OverlayState } from '../../../../next-devtools/dev-overlay/shared'\nimport type { SupportedErrorEvent } from '../../../../next-devtools/dev-overlay/container/runtime-error/render-error'\nimport { getErrorSource } from '../../../../shared/lib/error-source'\nimport type {\n  OriginalStackFramesRequest,\n  OriginalStackFramesResponse,\n} from '../../../../next-devtools/server/shared'\n\ntype StackFrameForFormatting = {\n  file: string | null\n  methodName: string\n  line1: number | null\n  column1: number | null\n}\n\ntype StackFrameResolver = (\n  request: OriginalStackFramesRequest\n) => Promise<OriginalStackFramesResponse>\n\n// Dependency injection for stack frame resolver\nlet stackFrameResolver: StackFrameResolver | undefined\n\nexport function setStackFrameResolver(fn: StackFrameResolver) {\n  stackFrameResolver = fn\n}\n\nasync function resolveStackFrames(\n  request: OriginalStackFramesRequest\n): Promise<OriginalStackFramesResponse> {\n  if (!stackFrameResolver) {\n    throw new Error(\n      'Stack frame resolver not initialized. This is a bug in Next.js.'\n    )\n  }\n  return stackFrameResolver(request)\n}\n\ninterface StackFrame {\n  file: string\n  methodName: string\n  line: number | null\n  column: number | null\n}\n\ninterface FormattedRuntimeError {\n  type: string\n  errorName: string\n  message: string\n  stack: StackFrame[]\n}\n\ninterface FormattedSessionError {\n  url: string\n  buildError: string | null\n  runtimeErrors: FormattedRuntimeError[]\n}\n\ninterface FormattedConfigError {\n  name: string\n  message: string\n  stack: string | null\n}\n\nexport interface FormattedErrorsOutput {\n  configErrors: FormattedConfigError[]\n  sessionErrors: FormattedSessionError[]\n}\n\nconst formatStackFrameToObject = (\n  frame: StackFrameForFormatting\n): StackFrame => {\n  return {\n    file: frame.file || '<unknown>',\n    methodName: frame.methodName || '<anonymous>',\n    line: frame.line1,\n    column: frame.column1,\n  }\n}\n\nconst resolveErrorFrames = async (\n  frames: readonly StackFrameForFormatting[],\n  context: {\n    isServer: boolean\n    isEdgeServer: boolean\n    isAppDirectory: boolean\n  }\n): Promise<StackFrame[]> => {\n  try {\n    const resolvedFrames = await resolveStackFrames({\n      frames: frames.map((frame) => ({\n        file: frame.file || null,\n        methodName: frame.methodName || '<anonymous>',\n        arguments: [],\n        line1: frame.line1 || null,\n        column1: frame.column1 || null,\n      })),\n      isServer: context.isServer,\n      isEdgeServer: context.isEdgeServer,\n      isAppDirectory: context.isAppDirectory,\n    })\n\n    return resolvedFrames\n      .filter(\n        (resolvedFrame) =>\n          !(\n            resolvedFrame.status === 'fulfilled' &&\n            resolvedFrame.value.originalStackFrame?.ignored\n          )\n      )\n      .map((resolvedFrame, j) =>\n        resolvedFrame.status === 'fulfilled' &&\n        resolvedFrame.value.originalStackFrame\n          ? formatStackFrameToObject(resolvedFrame.value.originalStackFrame)\n          : formatStackFrameToObject(frames[j])\n      )\n  } catch {\n    return frames.map(formatStackFrameToObject)\n  }\n}\n\nasync function formatRuntimeErrorsToObjects(\n  errors: readonly SupportedErrorEvent[],\n  isAppDirectory: boolean\n): Promise<FormattedRuntimeError[]> {\n  const formattedErrors: FormattedRuntimeError[] = []\n\n  for (const error of errors) {\n    const errorName = error.error?.name || 'Error'\n    const errorMsg = error.error?.message || 'Unknown error'\n\n    let stack: StackFrame[] = []\n    if (error.frames?.length) {\n      const errorSource = getErrorSource(error.error)\n      stack = await resolveErrorFrames(error.frames, {\n        isServer: errorSource === 'server',\n        isEdgeServer: errorSource === 'edge-server',\n        isAppDirectory,\n      })\n    }\n\n    formattedErrors.push({\n      type: error.type,\n      errorName,\n      message: errorMsg,\n      stack,\n    })\n  }\n\n  return formattedErrors\n}\n\nexport async function formatErrors(\n  errorsByUrl: Map<string, OverlayState>,\n  nextInstanceErrors: { nextConfig: unknown[] } = { nextConfig: [] }\n): Promise<FormattedErrorsOutput> {\n  const output: FormattedErrorsOutput = {\n    configErrors: [],\n    sessionErrors: [],\n  }\n\n  // Format Next.js instance errors first (e.g., next.config.js errors)\n  for (const error of nextInstanceErrors.nextConfig) {\n    if (error instanceof Error) {\n      output.configErrors.push({\n        name: error.name,\n        message: error.message,\n        stack: error.stack || null,\n      })\n    } else {\n      output.configErrors.push({\n        name: 'Error',\n        message: String(error),\n        stack: null,\n      })\n    }\n  }\n\n  // Format browser session errors\n  for (const [url, overlayState] of errorsByUrl) {\n    const totalErrorCount =\n      overlayState.errors.length + (overlayState.buildError ? 1 : 0)\n\n    if (totalErrorCount === 0) continue\n\n    let displayUrl = url\n    try {\n      const urlObj = new URL(url)\n      displayUrl = urlObj.pathname + urlObj.search + urlObj.hash\n    } catch {\n      // If URL parsing fails, use the original URL\n    }\n\n    const runtimeErrors = await formatRuntimeErrorsToObjects(\n      overlayState.errors,\n      overlayState.routerType === 'app'\n    )\n\n    output.sessionErrors.push({\n      url: displayUrl,\n      buildError: overlayState.buildError || null,\n      runtimeErrors,\n    })\n  }\n\n  return output\n}\n"],"names":["getErrorSource","stackFrameResolver","setStackFrameResolver","fn","resolveStackFrames","request","Error","formatStackFrameToObject","frame","file","methodName","line","line1","column","column1","resolveErrorFrames","frames","context","resolvedFrames","map","arguments","isServer","isEdgeServer","isAppDirectory","filter","resolvedFrame","status","value","originalStackFrame","ignored","j","formatRuntimeErrorsToObjects","errors","formattedErrors","error","errorName","name","errorMsg","message","stack","length","errorSource","push","type","formatErrors","errorsByUrl","nextInstanceErrors","nextConfig","output","configErrors","sessionErrors","String","url","overlayState","totalErrorCount","buildError","displayUrl","urlObj","URL","pathname","search","hash","runtimeErrors","routerType"],"mappings":"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","ignoreList":[0]}