{"version":3,"sources":["../../../../../src/server/mcp/tools/get-errors.ts"],"sourcesContent":["/**\n * MCP tool for retrieving error state from Next.js dev server.\n *\n * This tool provides comprehensive error reporting including:\n * - Next.js global errors (e.g., next.config validation errors)\n * - Browser runtime errors with source-mapped stack traces\n * - Build errors from webpack/turbopack compilation\n *\n * For browser errors, it leverages the HMR infrastructure for server-to-browser communication.\n *\n * Flow:\n *   MCP client → server generates request ID → HMR message to browser →\n *   browser queries error overlay state → HMR response back → server performs source mapping →\n *   combined with global errors → formatted output.\n */\nimport type { McpServer } from 'next/dist/compiled/@modelcontextprotocol/sdk/server/mcp'\nimport type { OverlayState } from '../../../next-devtools/dev-overlay/shared'\nimport {\n  HMR_MESSAGE_SENT_TO_BROWSER,\n  type HmrMessageSentToBrowser,\n} from '../../dev/hot-reloader-types'\nimport { formatErrors } from './utils/format-errors'\nimport {\n  createBrowserRequest,\n  handleBrowserPageResponse,\n  DEFAULT_BROWSER_REQUEST_TIMEOUT_MS,\n} from './utils/browser-communication'\nimport { NextInstanceErrorState } from './next-instance-error-state'\nimport { mcpTelemetryTracker } from '../mcp-telemetry-tracker'\n\nexport function registerGetErrorsTool(\n  server: McpServer,\n  sendHmrMessage: (message: HmrMessageSentToBrowser) => void,\n  getActiveConnectionCount: () => number\n) {\n  server.registerTool(\n    'get_errors',\n    {\n      description:\n        'Get the current error state from the Next.js dev server, including Next.js global errors (e.g., next.config validation), browser runtime errors, and build errors with source-mapped stack traces',\n      inputSchema: {},\n    },\n    async (_request) => {\n      // Track telemetry\n      mcpTelemetryTracker.recordToolCall('mcp/get_errors')\n\n      try {\n        const connectionCount = getActiveConnectionCount()\n        if (connectionCount === 0) {\n          return {\n            content: [\n              {\n                type: 'text',\n                text: JSON.stringify({\n                  error:\n                    'No browser sessions connected. Please open your application in a browser to retrieve error state.',\n                }),\n              },\n            ],\n          }\n        }\n\n        const responses = await createBrowserRequest<OverlayState>(\n          HMR_MESSAGE_SENT_TO_BROWSER.REQUEST_CURRENT_ERROR_STATE,\n          sendHmrMessage,\n          getActiveConnectionCount,\n          DEFAULT_BROWSER_REQUEST_TIMEOUT_MS\n        )\n\n        // The error state for each route\n        // key is the route path, value is the error state\n        const routesErrorState = new Map<string, OverlayState>()\n        for (const response of responses) {\n          if (response.data) {\n            routesErrorState.set(response.url, response.data)\n          }\n        }\n\n        const hasRouteErrors = Array.from(routesErrorState.values()).some(\n          (state) => state.errors.length > 0 || !!state.buildError\n        )\n        const hasInstanceErrors = NextInstanceErrorState.nextConfig.length > 0\n\n        if (!hasRouteErrors && !hasInstanceErrors) {\n          return {\n            content: [\n              {\n                type: 'text',\n                text: JSON.stringify({\n                  configErrors: [],\n                  sessionErrors: [],\n                }),\n              },\n            ],\n          }\n        }\n\n        const output = await formatErrors(\n          routesErrorState,\n          NextInstanceErrorState\n        )\n\n        return {\n          content: [\n            {\n              type: 'text',\n              text: JSON.stringify(output),\n            },\n          ],\n        }\n      } catch (error) {\n        return {\n          content: [\n            {\n              type: 'text',\n              text: JSON.stringify({\n                error: error instanceof Error ? error.message : String(error),\n              }),\n            },\n          ],\n        }\n      }\n    }\n  )\n}\n\n// Browser will first receive an HMR message from server to send back its error state.\n// The actual state is sent back in a subsequent HMR message, which is handled by this function\n// on the server.\nexport function handleErrorStateResponse(\n  requestId: string,\n  errorState: OverlayState | null,\n  url: string | undefined\n) {\n  handleBrowserPageResponse<OverlayState | null>(\n    requestId,\n    errorState,\n    url || ''\n  )\n}\n"],"names":["HMR_MESSAGE_SENT_TO_BROWSER","formatErrors","createBrowserRequest","handleBrowserPageResponse","DEFAULT_BROWSER_REQUEST_TIMEOUT_MS","NextInstanceErrorState","mcpTelemetryTracker","registerGetErrorsTool","server","sendHmrMessage","getActiveConnectionCount","registerTool","description","inputSchema","_request","recordToolCall","connectionCount","content","type","text","JSON","stringify","error","responses","REQUEST_CURRENT_ERROR_STATE","routesErrorState","Map","response","data","set","url","hasRouteErrors","Array","from","values","some","state","errors","length","buildError","hasInstanceErrors","nextConfig","configErrors","sessionErrors","output","Error","message","String","handleErrorStateResponse","requestId","errorState"],"mappings":"AAAA;;;;;;;;;;;;;;CAcC,GAGD,SACEA,2BAA2B,QAEtB,+BAA8B;AACrC,SAASC,YAAY,QAAQ,wBAAuB;AACpD,SACEC,oBAAoB,EACpBC,yBAAyB,EACzBC,kCAAkC,QAC7B,gCAA+B;AACtC,SAASC,sBAAsB,QAAQ,8BAA6B;AACpE,SAASC,mBAAmB,QAAQ,2BAA0B;AAE9D,OAAO,SAASC,sBACdC,MAAiB,EACjBC,cAA0D,EAC1DC,wBAAsC;IAEtCF,OAAOG,YAAY,CACjB,cACA;QACEC,aACE;QACFC,aAAa,CAAC;IAChB,GACA,OAAOC;QACL,kBAAkB;QAClBR,oBAAoBS,cAAc,CAAC;QAEnC,IAAI;YACF,MAAMC,kBAAkBN;YACxB,IAAIM,oBAAoB,GAAG;gBACzB,OAAO;oBACLC,SAAS;wBACP;4BACEC,MAAM;4BACNC,MAAMC,KAAKC,SAAS,CAAC;gCACnBC,OACE;4BACJ;wBACF;qBACD;gBACH;YACF;YAEA,MAAMC,YAAY,MAAMrB,qBACtBF,4BAA4BwB,2BAA2B,EACvDf,gBACAC,0BACAN;YAGF,iCAAiC;YACjC,kDAAkD;YAClD,MAAMqB,mBAAmB,IAAIC;YAC7B,KAAK,MAAMC,YAAYJ,UAAW;gBAChC,IAAII,SAASC,IAAI,EAAE;oBACjBH,iBAAiBI,GAAG,CAACF,SAASG,GAAG,EAAEH,SAASC,IAAI;gBAClD;YACF;YAEA,MAAMG,iBAAiBC,MAAMC,IAAI,CAACR,iBAAiBS,MAAM,IAAIC,IAAI,CAC/D,CAACC,QAAUA,MAAMC,MAAM,CAACC,MAAM,GAAG,KAAK,CAAC,CAACF,MAAMG,UAAU;YAE1D,MAAMC,oBAAoBnC,uBAAuBoC,UAAU,CAACH,MAAM,GAAG;YAErE,IAAI,CAACP,kBAAkB,CAACS,mBAAmB;gBACzC,OAAO;oBACLvB,SAAS;wBACP;4BACEC,MAAM;4BACNC,MAAMC,KAAKC,SAAS,CAAC;gCACnBqB,cAAc,EAAE;gCAChBC,eAAe,EAAE;4BACnB;wBACF;qBACD;gBACH;YACF;YAEA,MAAMC,SAAS,MAAM3C,aACnBwB,kBACApB;YAGF,OAAO;gBACLY,SAAS;oBACP;wBACEC,MAAM;wBACNC,MAAMC,KAAKC,SAAS,CAACuB;oBACvB;iBACD;YACH;QACF,EAAE,OAAOtB,OAAO;YACd,OAAO;gBACLL,SAAS;oBACP;wBACEC,MAAM;wBACNC,MAAMC,KAAKC,SAAS,CAAC;4BACnBC,OAAOA,iBAAiBuB,QAAQvB,MAAMwB,OAAO,GAAGC,OAAOzB;wBACzD;oBACF;iBACD;YACH;QACF;IACF;AAEJ;AAEA,sFAAsF;AACtF,+FAA+F;AAC/F,iBAAiB;AACjB,OAAO,SAAS0B,yBACdC,SAAiB,EACjBC,UAA+B,EAC/BpB,GAAuB;IAEvB3B,0BACE8C,WACAC,YACApB,OAAO;AAEX","ignoreList":[0]}