{"version":3,"sources":["../../../../src/server/request/params.ts"],"sourcesContent":["import {\n  workAsyncStorage,\n  type WorkStore,\n} from '../app-render/work-async-storage.external'\nimport type { OpaqueFallbackRouteParams } from './fallback-params'\nimport type { VaryParamsAccumulator } from '../app-render/vary-params'\nimport {\n  createVaryingParams,\n  getMetadataVaryParamsAccumulator,\n} from '../app-render/vary-params'\n\nimport { ReflectAdapter } from '../web/spec-extension/adapters/reflect'\nimport {\n  throwToInterruptStaticGeneration,\n  postponeWithTracking,\n  delayUntilRuntimeStage,\n} from '../app-render/dynamic-rendering'\n\nimport {\n  workUnitAsyncStorage,\n  type PrerenderStorePPR,\n  type PrerenderStoreLegacy,\n  type StaticPrerenderStoreModern,\n  type StaticPrerenderStore,\n  throwInvariantForMissingStore,\n  type PrerenderStoreModernRuntime,\n  type RequestStore,\n} from '../app-render/work-unit-async-storage.external'\nimport { InvariantError } from '../../shared/lib/invariant-error'\nimport {\n  describeStringPropertyAccess,\n  wellKnownProperties,\n} from '../../shared/lib/utils/reflect-utils'\nimport {\n  makeDevtoolsIOAwarePromise,\n  makeHangingPromise,\n} from '../dynamic-rendering-utils'\nimport { createDedupedByCallsiteServerErrorLoggerDev } from '../create-deduped-by-callsite-server-error-logger'\nimport { dynamicAccessAsyncStorage } from '../app-render/dynamic-access-async-storage.external'\nimport { RenderStage } from '../app-render/staged-rendering'\n\nexport type ParamValue = string | Array<string> | undefined\nexport type Params = Record<string, ParamValue>\n\nexport function createParamsFromClient(\n  underlyingParams: Params,\n  workStore: WorkStore\n): Promise<Params> {\n  const workUnitStore = workUnitAsyncStorage.getStore()\n  if (workUnitStore) {\n    switch (workUnitStore.type) {\n      case 'prerender':\n      case 'prerender-client':\n      case 'prerender-ppr':\n      case 'prerender-legacy':\n        // Client params don't need additional vary tracking because by the\n        // time they reach the client, the access would have already been\n        // tracked by the server.\n        const varyParamsAccumulator = null\n        return createStaticPrerenderParams(\n          underlyingParams,\n          workStore,\n          workUnitStore,\n          varyParamsAccumulator\n        )\n      case 'cache':\n      case 'private-cache':\n      case 'unstable-cache':\n        throw new InvariantError(\n          'createParamsFromClient should not be called in cache contexts.'\n        )\n      case 'prerender-runtime':\n        throw new InvariantError(\n          'createParamsFromClient should not be called in a runtime prerender.'\n        )\n      case 'request':\n        if (process.env.NODE_ENV === 'development') {\n          // Semantically we only need the dev tracking when running in `next dev`\n          // but since you would never use next dev with production NODE_ENV we use this\n          // as a proxy so we can statically exclude this code from production builds.\n          const devFallbackParams = workUnitStore.devFallbackParams\n          return createRenderParamsInDev(\n            underlyingParams,\n            devFallbackParams,\n            workStore,\n            workUnitStore\n          )\n        } else {\n          return createRenderParamsInProd(underlyingParams)\n        }\n      default:\n        workUnitStore satisfies never\n    }\n  }\n  throwInvariantForMissingStore()\n}\n\n// generateMetadata always runs in RSC context so it is equivalent to a Server Page Component\nexport type CreateServerParamsForMetadata = typeof createServerParamsForMetadata\nexport function createServerParamsForMetadata(\n  underlyingParams: Params,\n  workStore: WorkStore\n): Promise<Params> {\n  const metadataVaryParamsAccumulator = getMetadataVaryParamsAccumulator()\n  return createServerParamsForServerSegment(\n    underlyingParams,\n    workStore,\n    metadataVaryParamsAccumulator\n  )\n}\n\n// routes always runs in RSC context so it is equivalent to a Server Page Component\nexport function createServerParamsForRoute(\n  underlyingParams: Params,\n  workStore: WorkStore,\n  varyParamsAccumulator: VaryParamsAccumulator | null = null\n): Promise<Params> {\n  const workUnitStore = workUnitAsyncStorage.getStore()\n  if (workUnitStore) {\n    switch (workUnitStore.type) {\n      case 'prerender':\n      case 'prerender-client':\n      case 'prerender-ppr':\n      case 'prerender-legacy':\n        return createStaticPrerenderParams(\n          underlyingParams,\n          workStore,\n          workUnitStore,\n          varyParamsAccumulator\n        )\n      case 'cache':\n      case 'private-cache':\n      case 'unstable-cache':\n        throw new InvariantError(\n          'createServerParamsForRoute should not be called in cache contexts.'\n        )\n      case 'prerender-runtime':\n        return createRuntimePrerenderParams(\n          underlyingParams,\n          workUnitStore,\n          varyParamsAccumulator\n        )\n      case 'request':\n        if (process.env.NODE_ENV === 'development') {\n          // Semantically we only need the dev tracking when running in `next dev`\n          // but since you would never use next dev with production NODE_ENV we use this\n          // as a proxy so we can statically exclude this code from production builds.\n          const devFallbackParams = workUnitStore.devFallbackParams\n          return createRenderParamsInDev(\n            underlyingParams,\n            devFallbackParams,\n            workStore,\n            workUnitStore\n          )\n        } else {\n          return createRenderParamsInProd(underlyingParams)\n        }\n      default:\n        workUnitStore satisfies never\n    }\n  }\n  throwInvariantForMissingStore()\n}\n\nexport function createServerParamsForServerSegment(\n  underlyingParams: Params,\n  workStore: WorkStore,\n  varyParamsAccumulator: VaryParamsAccumulator | null = null\n): Promise<Params> {\n  const workUnitStore = workUnitAsyncStorage.getStore()\n  if (workUnitStore) {\n    switch (workUnitStore.type) {\n      case 'prerender':\n      case 'prerender-client':\n      case 'prerender-ppr':\n      case 'prerender-legacy':\n        return createStaticPrerenderParams(\n          underlyingParams,\n          workStore,\n          workUnitStore,\n          varyParamsAccumulator\n        )\n      case 'cache':\n      case 'private-cache':\n      case 'unstable-cache':\n        throw new InvariantError(\n          'createServerParamsForServerSegment should not be called in cache contexts.'\n        )\n      case 'prerender-runtime':\n        return createRuntimePrerenderParams(\n          underlyingParams,\n          workUnitStore,\n          varyParamsAccumulator\n        )\n      case 'request':\n        if (process.env.NODE_ENV === 'development') {\n          // Semantically we only need the dev tracking when running in `next dev`\n          // but since you would never use next dev with production NODE_ENV we use this\n          // as a proxy so we can statically exclude this code from production builds.\n          const devFallbackParams = workUnitStore.devFallbackParams\n          return createRenderParamsInDev(\n            underlyingParams,\n            devFallbackParams,\n            workStore,\n            workUnitStore\n          )\n        } else {\n          return createRenderParamsInProd(underlyingParams)\n        }\n      default:\n        workUnitStore satisfies never\n    }\n  }\n  throwInvariantForMissingStore()\n}\n\nexport function createPrerenderParamsForClientSegment(\n  underlyingParams: Params\n): Promise<Params> {\n  const workStore = workAsyncStorage.getStore()\n  if (!workStore) {\n    throw new InvariantError(\n      'Missing workStore in createPrerenderParamsForClientSegment'\n    )\n  }\n\n  const workUnitStore = workUnitAsyncStorage.getStore()\n  if (workUnitStore) {\n    switch (workUnitStore.type) {\n      case 'prerender':\n      case 'prerender-client':\n        const fallbackParams = workUnitStore.fallbackRouteParams\n        if (fallbackParams) {\n          for (let key in underlyingParams) {\n            if (fallbackParams.has(key)) {\n              // This params object has one or more fallback params, so we need\n              // to consider the awaiting of this params object \"dynamic\". Since\n              // we are in cacheComponents mode we encode this as a promise that never\n              // resolves.\n              return makeHangingPromise(\n                workUnitStore.renderSignal,\n                workStore.route,\n                '`params`'\n              )\n            }\n          }\n        }\n        break\n      case 'cache':\n      case 'private-cache':\n      case 'unstable-cache':\n        throw new InvariantError(\n          'createPrerenderParamsForClientSegment should not be called in cache contexts.'\n        )\n      case 'prerender-ppr':\n      case 'prerender-legacy':\n      case 'prerender-runtime':\n      case 'request':\n        break\n      default:\n        workUnitStore satisfies never\n    }\n  }\n  // We're prerendering in a mode that does not abort. We resolve the promise without\n  // any tracking because we're just transporting a value from server to client where the tracking\n  // will be applied.\n  return Promise.resolve(underlyingParams)\n}\n\nfunction createStaticPrerenderParams(\n  underlyingParams: Params,\n  workStore: WorkStore,\n  prerenderStore: StaticPrerenderStore,\n  varyParamsAccumulator: VaryParamsAccumulator | null\n): Promise<Params> {\n  const underlyingParamsWithVarying =\n    varyParamsAccumulator !== null\n      ? createVaryingParams(varyParamsAccumulator, underlyingParams)\n      : underlyingParams\n\n  switch (prerenderStore.type) {\n    case 'prerender':\n    case 'prerender-client': {\n      const fallbackParams = prerenderStore.fallbackRouteParams\n      if (fallbackParams) {\n        for (const key in underlyingParams) {\n          if (fallbackParams.has(key)) {\n            // This params object has one or more fallback params, so we need\n            // to consider the awaiting of this params object \"dynamic\". Since\n            // we are in cacheComponents mode we encode this as a promise that never\n            // resolves.\n            return makeHangingParams(\n              underlyingParamsWithVarying,\n              workStore,\n              prerenderStore\n            )\n          }\n        }\n      }\n      break\n    }\n    case 'prerender-ppr': {\n      const fallbackParams = prerenderStore.fallbackRouteParams\n      if (fallbackParams) {\n        for (const key in underlyingParams) {\n          if (fallbackParams.has(key)) {\n            return makeErroringParams(\n              underlyingParamsWithVarying,\n              fallbackParams,\n              workStore,\n              prerenderStore\n            )\n          }\n        }\n      }\n      break\n    }\n    case 'prerender-legacy':\n      break\n    default:\n      prerenderStore satisfies never\n  }\n\n  return makeUntrackedParams(underlyingParamsWithVarying)\n}\n\nfunction createRuntimePrerenderParams(\n  underlyingParams: Params,\n  workUnitStore: PrerenderStoreModernRuntime,\n  varyParamsAccumulator: VaryParamsAccumulator | null\n): Promise<Params> {\n  const underlyingParamsWithVarying =\n    varyParamsAccumulator !== null\n      ? createVaryingParams(varyParamsAccumulator, underlyingParams)\n      : underlyingParams\n\n  return delayUntilRuntimeStage(\n    workUnitStore,\n    makeUntrackedParams(underlyingParamsWithVarying)\n  )\n}\n\nfunction createRenderParamsInProd(underlyingParams: Params): Promise<Params> {\n  return makeUntrackedParams(underlyingParams)\n}\n\nfunction createRenderParamsInDev(\n  underlyingParams: Params,\n  devFallbackParams: OpaqueFallbackRouteParams | null | undefined,\n  workStore: WorkStore,\n  requestStore: RequestStore\n): Promise<Params> {\n  let hasFallbackParams = false\n  if (devFallbackParams) {\n    for (let key in underlyingParams) {\n      if (devFallbackParams.has(key)) {\n        hasFallbackParams = true\n        break\n      }\n    }\n  }\n\n  return makeDynamicallyTrackedParamsWithDevWarnings(\n    underlyingParams,\n    hasFallbackParams,\n    workStore,\n    requestStore\n  )\n}\n\ninterface CacheLifetime {}\nconst CachedParams = new WeakMap<CacheLifetime, Promise<Params>>()\n\nconst fallbackParamsProxyHandler: ProxyHandler<Promise<Params>> = {\n  get: function get(target, prop, receiver) {\n    if (prop === 'then' || prop === 'catch' || prop === 'finally') {\n      const originalMethod = ReflectAdapter.get(target, prop, receiver)\n\n      return {\n        [prop]: (...args: unknown[]) => {\n          const store = dynamicAccessAsyncStorage.getStore()\n\n          if (store) {\n            store.abortController.abort(\n              new Error(`Accessed fallback \\`params\\` during prerendering.`)\n            )\n          }\n\n          return new Proxy(\n            originalMethod.apply(target, args),\n            fallbackParamsProxyHandler\n          )\n        },\n      }[prop]\n    }\n\n    return ReflectAdapter.get(target, prop, receiver)\n  },\n}\n\nfunction makeHangingParams(\n  underlyingParams: Params,\n  workStore: WorkStore,\n  prerenderStore: StaticPrerenderStoreModern\n): Promise<Params> {\n  const cachedParams = CachedParams.get(underlyingParams)\n  if (cachedParams) {\n    return cachedParams\n  }\n\n  const promise = new Proxy(\n    makeHangingPromise<Params>(\n      prerenderStore.renderSignal,\n      workStore.route,\n      '`params`'\n    ),\n    fallbackParamsProxyHandler\n  )\n\n  CachedParams.set(underlyingParams, promise)\n\n  return promise\n}\n\nfunction makeErroringParams(\n  underlyingParams: Params,\n  fallbackParams: OpaqueFallbackRouteParams,\n  workStore: WorkStore,\n  prerenderStore: PrerenderStorePPR | PrerenderStoreLegacy\n): Promise<Params> {\n  const cachedParams = CachedParams.get(underlyingParams)\n  if (cachedParams) {\n    return cachedParams\n  }\n\n  const augmentedUnderlying = { ...underlyingParams }\n\n  // We don't use makeResolvedReactPromise here because params\n  // supports copying with spread and we don't want to unnecessarily\n  // instrument the promise with spreadable properties of ReactPromise.\n  const promise = Promise.resolve(augmentedUnderlying)\n  CachedParams.set(underlyingParams, promise)\n\n  Object.keys(underlyingParams).forEach((prop) => {\n    if (wellKnownProperties.has(prop)) {\n      // These properties cannot be shadowed because they need to be the\n      // true underlying value for Promises to work correctly at runtime\n    } else {\n      if (fallbackParams.has(prop)) {\n        Object.defineProperty(augmentedUnderlying, prop, {\n          get() {\n            const expression = describeStringPropertyAccess('params', prop)\n            // In most dynamic APIs we also throw if `dynamic = \"error\"` however\n            // for params is only dynamic when we're generating a fallback shell\n            // and even when `dynamic = \"error\"` we still support generating dynamic\n            // fallback shells\n            // TODO remove this comment when cacheComponents is the default since there\n            // will be no `dynamic = \"error\"`\n            if (prerenderStore.type === 'prerender-ppr') {\n              // PPR Prerender (no cacheComponents)\n              postponeWithTracking(\n                workStore.route,\n                expression,\n                prerenderStore.dynamicTracking\n              )\n            } else {\n              // Legacy Prerender\n              throwToInterruptStaticGeneration(\n                expression,\n                workStore,\n                prerenderStore\n              )\n            }\n          },\n          enumerable: true,\n        })\n      }\n    }\n  })\n\n  return promise\n}\n\nfunction makeUntrackedParams(underlyingParams: Params): Promise<Params> {\n  const cachedParams = CachedParams.get(underlyingParams)\n  if (cachedParams) {\n    return cachedParams\n  }\n\n  const promise = Promise.resolve(underlyingParams)\n  CachedParams.set(underlyingParams, promise)\n\n  return promise\n}\n\nfunction makeDynamicallyTrackedParamsWithDevWarnings(\n  underlyingParams: Params,\n  hasFallbackParams: boolean,\n  workStore: WorkStore,\n  requestStore: RequestStore\n): Promise<Params> {\n  if (requestStore.asyncApiPromises && hasFallbackParams) {\n    // We wrap each instance of params in a `new Promise()`, because deduping\n    // them across requests doesn't work anyway and this let us show each\n    // await a different set of values. This is important when all awaits\n    // are in third party which would otherwise track all the way to the\n    // internal params.\n    const sharedParamsParent = requestStore.asyncApiPromises.sharedParamsParent\n    const promise: Promise<Params> = new Promise((resolve, reject) => {\n      sharedParamsParent.then(() => resolve(underlyingParams), reject)\n    })\n    // @ts-expect-error\n    promise.displayName = 'params'\n    return instrumentParamsPromiseWithDevWarnings(\n      underlyingParams,\n      promise,\n      workStore\n    )\n  }\n\n  const cachedParams = CachedParams.get(underlyingParams)\n  if (cachedParams) {\n    return cachedParams\n  }\n\n  // We don't use makeResolvedReactPromise here because params\n  // supports copying with spread and we don't want to unnecessarily\n  // instrument the promise with spreadable properties of ReactPromise.\n  const promise = hasFallbackParams\n    ? makeDevtoolsIOAwarePromise(\n        underlyingParams,\n        requestStore,\n        RenderStage.Runtime\n      )\n    : // We don't want to force an environment transition when this params is not part of the fallback params set\n      Promise.resolve(underlyingParams)\n\n  const proxiedPromise = instrumentParamsPromiseWithDevWarnings(\n    underlyingParams,\n    promise,\n    workStore\n  )\n  CachedParams.set(underlyingParams, proxiedPromise)\n  return proxiedPromise\n}\n\nfunction instrumentParamsPromiseWithDevWarnings(\n  underlyingParams: Params,\n  promise: Promise<Params>,\n  workStore: WorkStore\n): Promise<Params> {\n  // Track which properties we should warn for.\n  const proxiedProperties = new Set<string>()\n\n  Object.keys(underlyingParams).forEach((prop) => {\n    if (wellKnownProperties.has(prop)) {\n      // These properties cannot be shadowed because they need to be the\n      // true underlying value for Promises to work correctly at runtime\n    } else {\n      proxiedProperties.add(prop)\n    }\n  })\n\n  return new Proxy(promise, {\n    get(target, prop, receiver) {\n      if (typeof prop === 'string') {\n        if (\n          // We are accessing a property that was proxied to the promise instance\n          proxiedProperties.has(prop)\n        ) {\n          const expression = describeStringPropertyAccess('params', prop)\n          warnForSyncAccess(workStore.route, expression)\n        }\n      }\n      return ReflectAdapter.get(target, prop, receiver)\n    },\n    set(target, prop, value, receiver) {\n      if (typeof prop === 'string') {\n        proxiedProperties.delete(prop)\n      }\n      return ReflectAdapter.set(target, prop, value, receiver)\n    },\n    ownKeys(target) {\n      const expression = '`...params` or similar expression'\n      warnForSyncAccess(workStore.route, expression)\n      return Reflect.ownKeys(target)\n    },\n  })\n}\n\nconst warnForSyncAccess = createDedupedByCallsiteServerErrorLoggerDev(\n  createParamsAccessError\n)\n\nfunction createParamsAccessError(\n  route: string | undefined,\n  expression: string\n) {\n  const prefix = route ? `Route \"${route}\" ` : 'This route '\n  return new Error(\n    `${prefix}used ${expression}. ` +\n      `\\`params\\` is a Promise and must be unwrapped with \\`await\\` or \\`React.use()\\` before accessing its properties. ` +\n      `Learn more: https://nextjs.org/docs/messages/sync-dynamic-apis`\n  )\n}\n"],"names":["workAsyncStorage","createVaryingParams","getMetadataVaryParamsAccumulator","ReflectAdapter","throwToInterruptStaticGeneration","postponeWithTracking","delayUntilRuntimeStage","workUnitAsyncStorage","throwInvariantForMissingStore","InvariantError","describeStringPropertyAccess","wellKnownProperties","makeDevtoolsIOAwarePromise","makeHangingPromise","createDedupedByCallsiteServerErrorLoggerDev","dynamicAccessAsyncStorage","RenderStage","createParamsFromClient","underlyingParams","workStore","workUnitStore","getStore","type","varyParamsAccumulator","createStaticPrerenderParams","process","env","NODE_ENV","devFallbackParams","createRenderParamsInDev","createRenderParamsInProd","createServerParamsForMetadata","metadataVaryParamsAccumulator","createServerParamsForServerSegment","createServerParamsForRoute","createRuntimePrerenderParams","createPrerenderParamsForClientSegment","fallbackParams","fallbackRouteParams","key","has","renderSignal","route","Promise","resolve","prerenderStore","underlyingParamsWithVarying","makeHangingParams","makeErroringParams","makeUntrackedParams","requestStore","hasFallbackParams","makeDynamicallyTrackedParamsWithDevWarnings","CachedParams","WeakMap","fallbackParamsProxyHandler","get","target","prop","receiver","originalMethod","args","store","abortController","abort","Error","Proxy","apply","cachedParams","promise","set","augmentedUnderlying","Object","keys","forEach","defineProperty","expression","dynamicTracking","enumerable","asyncApiPromises","sharedParamsParent","reject","then","displayName","instrumentParamsPromiseWithDevWarnings","Runtime","proxiedPromise","proxiedProperties","Set","add","warnForSyncAccess","value","delete","ownKeys","Reflect","createParamsAccessError","prefix"],"mappings":"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","ignoreList":[0]}