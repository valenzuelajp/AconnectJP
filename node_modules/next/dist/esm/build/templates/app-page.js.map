{"version":3,"sources":["../../../../src/build/templates/app-page.ts"],"sourcesContent":["import type { LoaderTree } from '../../server/lib/app-dir-module'\nimport type { IncomingMessage, ServerResponse } from 'node:http'\n\nimport {\n  AppPageRouteModule,\n  type AppPageRouteHandlerContext,\n} from '../../server/route-modules/app-page/module.compiled' with { 'turbopack-transition': 'next-ssr' }\n\nimport { RouteKind } from '../../server/route-kind' with { 'turbopack-transition': 'next-server-utility' }\n\nimport { getRevalidateReason } from '../../server/instrumentation/utils'\nimport { getTracer, SpanKind, type Span } from '../../server/lib/trace/tracer'\nimport type { RequestMeta } from '../../server/request-meta'\nimport {\n  addRequestMeta,\n  getRequestMeta,\n  setRequestMeta,\n} from '../../server/request-meta'\nimport { BaseServerSpan } from '../../server/lib/trace/constants'\nimport { interopDefault } from '../../server/app-render/interop-default'\nimport { stripFlightHeaders } from '../../server/app-render/strip-flight-headers'\nimport { NodeNextRequest, NodeNextResponse } from '../../server/base-http/node'\nimport { checkIsAppPPREnabled } from '../../server/lib/experimental/ppr'\nimport {\n  getFallbackRouteParams,\n  createOpaqueFallbackRouteParams,\n  type OpaqueFallbackRouteParams,\n} from '../../server/request/fallback-params'\nimport { setManifestsSingleton } from '../../server/app-render/manifests-singleton'\nimport {\n  isHtmlBotRequest,\n  shouldServeStreamingMetadata,\n} from '../../server/lib/streaming-metadata'\nimport { normalizeAppPath } from '../../shared/lib/router/utils/app-paths'\nimport { getIsPossibleServerAction } from '../../server/lib/server-action-request-meta'\nimport {\n  RSC_HEADER,\n  NEXT_ROUTER_PREFETCH_HEADER,\n  NEXT_IS_PRERENDER_HEADER,\n  NEXT_DID_POSTPONE_HEADER,\n  RSC_CONTENT_TYPE_HEADER,\n} from '../../client/components/app-router-headers'\nimport { getBotType, isBot } from '../../shared/lib/router/utils/is-bot'\nimport {\n  CachedRouteKind,\n  IncrementalCacheKind,\n  type CachedAppPageValue,\n  type CachedPageValue,\n  type ResponseCacheEntry,\n  type ResponseGenerator,\n} from '../../server/response-cache'\nimport { FallbackMode, parseFallbackField } from '../../lib/fallback'\nimport RenderResult from '../../server/render-result'\nimport {\n  CACHE_ONE_YEAR,\n  HTML_CONTENT_TYPE_HEADER,\n  NEXT_CACHE_TAGS_HEADER,\n  NEXT_RESUME_HEADER,\n  NEXT_RESUME_STATE_LENGTH_HEADER,\n} from '../../lib/constants'\nimport type { CacheControl } from '../../server/lib/cache-control'\nimport { ENCODED_TAGS } from '../../server/stream-utils/encoded-tags'\nimport { sendRenderResult } from '../../server/send-payload'\nimport { NoFallbackError } from '../../shared/lib/no-fallback-error.external'\nimport {\n  DEFAULT_MAX_POSTPONED_STATE_SIZE,\n  parseMaxPostponedStateSize,\n} from '../../shared/lib/size-limit'\n\n// These are injected by the loader afterwards.\n\n/**\n * The tree created in next-app-loader that holds component segments and modules\n * and I've updated it.\n */\ndeclare const tree: LoaderTree\n\n// These are injected by the loader afterwards.\ndeclare const __next_app_require__: (id: string | number) => unknown\ndeclare const __next_app_load_chunk__: (id: string | number) => Promise<unknown>\n\n// We inject the tree and pages here so that we can use them in the route\n// module.\n// INJECT:tree\n// INJECT:__next_app_require__\n// INJECT:__next_app_load_chunk__\n\nexport const __next_app__ = {\n  require: __next_app_require__,\n  loadChunk: __next_app_load_chunk__,\n}\n\nimport * as entryBase from '../../server/app-render/entry-base' with { 'turbopack-transition': 'next-server-utility' }\nimport { RedirectStatusCode } from '../../client/components/redirect-status-code'\nimport { InvariantError } from '../../shared/lib/invariant-error'\nimport { scheduleOnNextTick } from '../../lib/scheduler'\nimport { isInterceptionRouteAppPath } from '../../shared/lib/router/utils/interception-routes'\n\nexport * from '../../server/app-render/entry-base' with { 'turbopack-transition': 'next-server-utility' }\n\n// Create and export the route module that will be consumed.\nexport const routeModule = new AppPageRouteModule({\n  definition: {\n    kind: RouteKind.APP_PAGE,\n    page: 'VAR_DEFINITION_PAGE',\n    pathname: 'VAR_DEFINITION_PATHNAME',\n    // The following aren't used in production.\n    bundlePath: '',\n    filename: '',\n    appPaths: [],\n  },\n  userland: {\n    loaderTree: tree,\n  },\n  distDir: process.env.__NEXT_RELATIVE_DIST_DIR || '',\n  relativeProjectDir: process.env.__NEXT_RELATIVE_PROJECT_DIR || '',\n})\n\nexport async function handler(\n  req: IncomingMessage,\n  res: ServerResponse,\n  ctx: {\n    waitUntil?: (prom: Promise<void>) => void\n    requestMeta?: RequestMeta\n  }\n) {\n  if (ctx.requestMeta) {\n    setRequestMeta(req, ctx.requestMeta)\n  }\n\n  if (routeModule.isDev) {\n    addRequestMeta(req, 'devRequestTimingInternalsEnd', process.hrtime.bigint())\n  }\n  const isMinimalMode = Boolean(getRequestMeta(req, 'minimalMode'))\n\n  let srcPage = 'VAR_DEFINITION_PAGE'\n\n  // turbopack doesn't normalize `/index` in the page name\n  // so we need to to process dynamic routes properly\n  // TODO: fix turbopack providing differing value from webpack\n  if (process.env.TURBOPACK) {\n    srcPage = srcPage.replace(/\\/index$/, '') || '/'\n  } else if (srcPage === '/index') {\n    // we always normalize /index specifically\n    srcPage = '/'\n  }\n  const multiZoneDraftMode = process.env\n    .__NEXT_MULTI_ZONE_DRAFT_MODE as any as boolean\n\n  const prepareResult = await routeModule.prepare(req, res, {\n    srcPage,\n    multiZoneDraftMode,\n  })\n\n  if (!prepareResult) {\n    res.statusCode = 400\n    res.end('Bad Request')\n    ctx.waitUntil?.(Promise.resolve())\n    return null\n  }\n\n  const {\n    buildId,\n    query,\n    params,\n    pageIsDynamic,\n    buildManifest,\n    nextFontManifest,\n    reactLoadableManifest,\n    serverActionsManifest,\n    clientReferenceManifest,\n    subresourceIntegrityManifest,\n    prerenderManifest,\n    isDraftMode,\n    resolvedPathname,\n    revalidateOnlyGenerated,\n    routerServerContext,\n    nextConfig,\n    parsedUrl,\n    interceptionRoutePatterns,\n    deploymentId,\n  } = prepareResult\n\n  const normalizedSrcPage = normalizeAppPath(srcPage)\n\n  let { isOnDemandRevalidate } = prepareResult\n\n  // We use the resolvedPathname instead of the parsedUrl.pathname because it\n  // is not rewritten as resolvedPathname is. This will ensure that the correct\n  // prerender info is used instead of using the original pathname as the\n  // source. If however PPR is enabled and cacheComponents is disabled, we\n  // treat the pathname as dynamic. Currently, there's a bug in the PPR\n  // implementation that incorrectly leaves %%drp placeholders in the output of\n  // parallel routes. This is addressed with cacheComponents.\n  const prerenderInfo =\n    nextConfig.experimental.ppr &&\n    !nextConfig.cacheComponents &&\n    isInterceptionRouteAppPath(resolvedPathname)\n      ? null\n      : routeModule.match(resolvedPathname, prerenderManifest)\n\n  const isPrerendered = !!prerenderManifest.routes[resolvedPathname]\n\n  const userAgent = req.headers['user-agent'] || ''\n  const botType = getBotType(userAgent)\n  const isHtmlBot = isHtmlBotRequest(req)\n\n  /**\n   * If true, this indicates that the request being made is for an app\n   * prefetch request.\n   */\n  const isPrefetchRSCRequest =\n    getRequestMeta(req, 'isPrefetchRSCRequest') ??\n    req.headers[NEXT_ROUTER_PREFETCH_HEADER] === '1' // exclude runtime prefetches, which use '2'\n\n  // NOTE: Don't delete headers[RSC] yet, it still needs to be used in renderToHTML later\n\n  const isRSCRequest =\n    getRequestMeta(req, 'isRSCRequest') ?? Boolean(req.headers[RSC_HEADER])\n\n  const isPossibleServerAction = getIsPossibleServerAction(req)\n\n  /**\n   * If the route being rendered is an app page, and the ppr feature has been\n   * enabled, then the given route _could_ support PPR.\n   */\n  const couldSupportPPR: boolean = checkIsAppPPREnabled(\n    nextConfig.experimental.ppr\n  )\n\n  // Stash postponed state for server actions when in minimal mode.\n  // We extract it here so the RDC is available for the re-render after the action completes.\n  const resumeStateLengthHeader = req.headers[NEXT_RESUME_STATE_LENGTH_HEADER]\n  if (\n    !getRequestMeta(req, 'postponed') &&\n    isMinimalMode &&\n    couldSupportPPR &&\n    isPossibleServerAction &&\n    resumeStateLengthHeader &&\n    typeof resumeStateLengthHeader === 'string'\n  ) {\n    const stateLength = parseInt(resumeStateLengthHeader, 10)\n    const maxPostponedStateSize =\n      nextConfig.experimental.maxPostponedStateSize ??\n      DEFAULT_MAX_POSTPONED_STATE_SIZE\n    const maxPostponedStateSizeBytes = parseMaxPostponedStateSize(\n      nextConfig.experimental.maxPostponedStateSize\n    )\n\n    if (!isNaN(stateLength) && stateLength > 0) {\n      if (\n        maxPostponedStateSizeBytes === undefined ||\n        stateLength > maxPostponedStateSizeBytes\n      ) {\n        res.statusCode = 413\n        res.end(\n          `Postponed state exceeded ${maxPostponedStateSize} limit. ` +\n            `To configure the limit, see: https://nextjs.org/docs/app/api-reference/config/next-config-js/max-postponed-state-size`\n        )\n        ctx.waitUntil?.(Promise.resolve())\n        return null\n      }\n\n      // Calculate max total body size to prevent buffering excessively large\n      // payloads before the action handler checks. We use stateLength (not\n      // maxPostponedStateSizeBytes) so the postponed state doesn't eat into\n      // the action body budget - it's already validated above.\n      const defaultActionBodySizeLimit = '1 MB'\n      const actionBodySizeLimit =\n        nextConfig.experimental.serverActions?.bodySizeLimit ??\n        defaultActionBodySizeLimit\n      const actionBodySizeLimitBytes =\n        actionBodySizeLimit !== defaultActionBodySizeLimit\n          ? (\n              require('next/dist/compiled/bytes') as typeof import('next/dist/compiled/bytes')\n            ).parse(actionBodySizeLimit)\n          : 1024 * 1024 // 1 MB\n      const maxTotalBodySize = stateLength + actionBodySizeLimitBytes\n\n      // Read the entire body, checking size as we go.\n      const bodyChunks: Array<Buffer> = []\n      let size = 0\n      for await (const chunk of req) {\n        const buffer = Buffer.isBuffer(chunk) ? chunk : Buffer.from(chunk)\n        size += buffer.byteLength\n        if (size > maxTotalBodySize) {\n          res.statusCode = 413\n          res.end(\n            `Request body exceeded limit. ` +\n              `To configure the body size limit for Server Actions, see: https://nextjs.org/docs/app/api-reference/next-config-js/serverActions#bodysizelimit`\n          )\n          ctx.waitUntil?.(Promise.resolve())\n          return null\n        }\n        bodyChunks.push(buffer)\n      }\n      const fullBody = Buffer.concat(bodyChunks)\n\n      if (fullBody.length >= stateLength) {\n        // Extract postponed state from the beginning\n        const postponedState = fullBody\n          .subarray(0, stateLength)\n          .toString('utf8')\n        addRequestMeta(req, 'postponed', postponedState)\n\n        // Store the remaining action body for the action handler\n        const actionBody = fullBody.subarray(stateLength)\n        addRequestMeta(req, 'actionBody', actionBody)\n      } else {\n        throw new Error(\n          `invariant: expected ${stateLength} bytes of postponed state but only received ${fullBody.length} bytes`\n        )\n      }\n    }\n  }\n\n  if (\n    !getRequestMeta(req, 'postponed') &&\n    couldSupportPPR &&\n    req.headers[NEXT_RESUME_HEADER] === '1' &&\n    req.method === 'POST'\n  ) {\n    // Decode the postponed state from the request body, it will come as\n    // an array of buffers, so collect them and then concat them to form\n    // the string.\n\n    const body: Array<Buffer> = []\n    for await (const chunk of req) {\n      body.push(chunk)\n    }\n    const postponed = Buffer.concat(body).toString('utf8')\n\n    addRequestMeta(req, 'postponed', postponed)\n  }\n\n  // When enabled, this will allow the use of the `?__nextppronly` query to\n  // enable debugging of the static shell.\n  const hasDebugStaticShellQuery =\n    process.env.__NEXT_EXPERIMENTAL_STATIC_SHELL_DEBUGGING === '1' &&\n    typeof query.__nextppronly !== 'undefined' &&\n    couldSupportPPR\n\n  // When enabled, this will allow the use of the `?__nextppronly` query\n  // to enable debugging of the fallback shell.\n  const hasDebugFallbackShellQuery =\n    hasDebugStaticShellQuery && query.__nextppronly === 'fallback'\n\n  // This page supports PPR if it is marked as being `PARTIALLY_STATIC` in the\n  // prerender manifest and this is an app page.\n  const isRoutePPREnabled: boolean =\n    couldSupportPPR &&\n    ((\n      prerenderManifest.routes[normalizedSrcPage] ??\n      prerenderManifest.dynamicRoutes[normalizedSrcPage]\n    )?.renderingMode === 'PARTIALLY_STATIC' ||\n      // Ideally we'd want to check the appConfig to see if this page has PPR\n      // enabled or not, but that would require plumbing the appConfig through\n      // to the server during development. We assume that the page supports it\n      // but only during development.\n      (hasDebugStaticShellQuery &&\n        (routeModule.isDev === true ||\n          routerServerContext?.experimentalTestProxy === true)))\n\n  const isDebugStaticShell: boolean =\n    hasDebugStaticShellQuery && isRoutePPREnabled\n\n  // We should enable debugging dynamic accesses when the static shell\n  // debugging has been enabled and we're also in development mode.\n  const isDebugDynamicAccesses =\n    isDebugStaticShell && routeModule.isDev === true\n\n  const isDebugFallbackShell = hasDebugFallbackShellQuery && isRoutePPREnabled\n\n  // If we're in minimal mode, then try to get the postponed information from\n  // the request metadata. If available, use it for resuming the postponed\n  // render.\n  const minimalPostponed = isRoutePPREnabled\n    ? getRequestMeta(req, 'postponed')\n    : undefined\n\n  // If PPR is enabled, and this is a RSC request (but not a prefetch), then\n  // we can use this fact to only generate the flight data for the request\n  // because we can't cache the HTML (as it's also dynamic).\n  const staticPrefetchDataRoute =\n    prerenderManifest.routes[resolvedPathname]?.prefetchDataRoute\n\n  let isDynamicRSCRequest =\n    isRoutePPREnabled &&\n    isRSCRequest &&\n    !isPrefetchRSCRequest &&\n    // If generated at build time, treat the RSC request as static\n    // so we can serve the prebuilt .rsc without a dynamic render.\n    // Only do this for routes that have a concrete prefetchDataRoute.\n    !staticPrefetchDataRoute\n\n  // During a PPR revalidation, the RSC request is not dynamic if we do not have the postponed data.\n  // We only attach the postponed data during a resume. If there's no postponed data, then it must be a revalidation.\n  // This is to ensure that we don't bypass the cache during a revalidation.\n  if (isMinimalMode) {\n    isDynamicRSCRequest = isDynamicRSCRequest && !!minimalPostponed\n  }\n\n  // Need to read this before it's stripped by stripFlightHeaders. We don't\n  // need to transfer it to the request meta because it's only read\n  // within this function; the static segment data should have already been\n  // generated, so we will always either return a static response or a 404.\n  const segmentPrefetchHeader = getRequestMeta(req, 'segmentPrefetchRSCRequest')\n\n  // TODO: investigate existing bug with shouldServeStreamingMetadata always\n  // being true for a revalidate due to modifying the base-server this.renderOpts\n  // when fixing this to correct logic it causes hydration issue since we set\n  // serveStreamingMetadata to true during export\n  const serveStreamingMetadata =\n    botType && isRoutePPREnabled\n      ? false\n      : !userAgent\n        ? true\n        : shouldServeStreamingMetadata(userAgent, nextConfig.htmlLimitedBots)\n\n  const isSSG = Boolean(\n    (prerenderInfo ||\n      isPrerendered ||\n      prerenderManifest.routes[normalizedSrcPage]) &&\n      // If this is a bot request and PPR is enabled, then we don't want\n      // to serve a static response. This applies to both DOM bots (like Googlebot)\n      // and HTML-limited bots.\n      !(botType && isRoutePPREnabled)\n  )\n\n  // When a page supports cacheComponents, we can support RDC for Navigations\n  const supportsRDCForNavigations =\n    isRoutePPREnabled && nextConfig.cacheComponents === true\n\n  // In development, we always want to generate dynamic HTML.\n  const supportsDynamicResponse: boolean =\n    // If we're in development, we always support dynamic HTML, unless it's\n    // a data request, in which case we only produce static HTML.\n    routeModule.isDev === true ||\n    // If this is not SSG or does not have static paths, then it supports\n    // dynamic HTML.\n    !isSSG ||\n    // If this request has provided postponed data, it supports dynamic\n    // HTML.\n    typeof minimalPostponed === 'string' ||\n    // If this handler supports onCacheEntryV2, then we can only support\n    // dynamic responses if it's a dynamic RSC request and not in minimal mode. If it\n    // doesn't support it we must fallback to the default behavior.\n    (supportsRDCForNavigations && getRequestMeta(req, 'onCacheEntryV2')\n      ? // In minimal mode, we'll always want to generate a static response\n        // which will generate the RDC for the route. When resuming a Dynamic\n        // RSC request, we'll pass the minimal postponed data to the render\n        // which will trigger the `supportsDynamicResponse` to be true.\n        isDynamicRSCRequest && !isMinimalMode\n      : // Otherwise, we can support dynamic responses if it's a dynamic RSC request.\n        isDynamicRSCRequest)\n\n  // When bots request PPR page, perform the full dynamic rendering.\n  // This applies to both DOM bots (like Googlebot) and HTML-limited bots.\n  const shouldWaitOnAllReady = Boolean(botType) && isRoutePPREnabled\n\n  let ssgCacheKey: string | null = null\n  if (\n    !isDraftMode &&\n    isSSG &&\n    !supportsDynamicResponse &&\n    !isPossibleServerAction &&\n    !minimalPostponed &&\n    !isDynamicRSCRequest\n  ) {\n    ssgCacheKey = resolvedPathname\n  }\n\n  // the staticPathKey differs from ssgCacheKey since\n  // ssgCacheKey is null in dev since we're always in \"dynamic\"\n  // mode in dev to bypass the cache, but we still need to honor\n  // dynamicParams = false in dev mode\n  let staticPathKey = ssgCacheKey\n  if (!staticPathKey && routeModule.isDev) {\n    staticPathKey = resolvedPathname\n  }\n\n  // If this is a request for an app path that should be statically generated\n  // and we aren't in the edge runtime, strip the flight headers so it will\n  // generate the static response.\n  if (\n    !routeModule.isDev &&\n    !isDraftMode &&\n    isSSG &&\n    isRSCRequest &&\n    !isDynamicRSCRequest\n  ) {\n    stripFlightHeaders(req.headers)\n  }\n\n  const ComponentMod = {\n    ...entryBase,\n    tree,\n    handler,\n    routeModule,\n    __next_app__,\n  }\n\n  // Before rendering (which initializes component tree modules), we have to\n  // set the reference manifests to our global store so Server Action's\n  // encryption util can access to them at the top level of the page module.\n  if (serverActionsManifest && clientReferenceManifest) {\n    setManifestsSingleton({\n      page: srcPage,\n      clientReferenceManifest,\n      serverActionsManifest,\n    })\n  }\n\n  const method = req.method || 'GET'\n  const tracer = getTracer()\n  const activeSpan = tracer.getActiveScopeSpan()\n\n  const render404 = async () => {\n    // TODO: should route-module itself handle rendering the 404\n    if (routerServerContext?.render404) {\n      await routerServerContext.render404(req, res, parsedUrl, false)\n    } else {\n      res.end('This page could not be found')\n    }\n    return null\n  }\n\n  try {\n    const varyHeader = routeModule.getVaryHeader(\n      resolvedPathname,\n      interceptionRoutePatterns\n    )\n    res.setHeader('Vary', varyHeader)\n    const invokeRouteModule = async (\n      span: Span | undefined,\n      context: AppPageRouteHandlerContext\n    ) => {\n      const nextReq = new NodeNextRequest(req)\n      const nextRes = new NodeNextResponse(res)\n\n      return routeModule.render(nextReq, nextRes, context).finally(() => {\n        if (!span) return\n\n        span.setAttributes({\n          'http.status_code': res.statusCode,\n          'next.rsc': false,\n        })\n\n        const rootSpanAttributes = tracer.getRootSpanAttributes()\n        // We were unable to get attributes, probably OTEL is not enabled\n        if (!rootSpanAttributes) {\n          return\n        }\n\n        if (\n          rootSpanAttributes.get('next.span_type') !==\n          BaseServerSpan.handleRequest\n        ) {\n          console.warn(\n            `Unexpected root span type '${rootSpanAttributes.get(\n              'next.span_type'\n            )}'. Please report this Next.js issue https://github.com/vercel/next.js`\n          )\n          return\n        }\n\n        const route = rootSpanAttributes.get('next.route')\n        if (route) {\n          const name = `${method} ${route}`\n\n          span.setAttributes({\n            'next.route': route,\n            'http.route': route,\n            'next.span_name': name,\n          })\n          span.updateName(name)\n        } else {\n          span.updateName(`${method} ${srcPage}`)\n        }\n      })\n    }\n\n    const incrementalCache =\n      getRequestMeta(req, 'incrementalCache') ||\n      (await routeModule.getIncrementalCache(\n        req,\n        nextConfig,\n        prerenderManifest,\n        isMinimalMode\n      ))\n\n    incrementalCache?.resetRequestCache()\n    ;(globalThis as any).__incrementalCache = incrementalCache\n\n    const doRender = async ({\n      span,\n      postponed,\n      fallbackRouteParams,\n      forceStaticRender,\n    }: {\n      span?: Span\n\n      /**\n       * The postponed data for this render. This is only provided when resuming\n       * a render that has been postponed.\n       */\n      postponed: string | undefined\n\n      /**\n       * The unknown route params for this render.\n       */\n      fallbackRouteParams: OpaqueFallbackRouteParams | null\n\n      /**\n       * When true, this indicates that the response generator is being called\n       * in a context where the response must be generated statically.\n       *\n       * CRITICAL: This should only currently be used when revalidating due to a\n       * dynamic RSC request.\n       */\n      forceStaticRender: boolean\n    }): Promise<ResponseCacheEntry> => {\n      const context: AppPageRouteHandlerContext = {\n        query,\n        params,\n        page: normalizedSrcPage,\n        sharedContext: {\n          buildId,\n          deploymentId,\n        },\n        serverComponentsHmrCache: getRequestMeta(\n          req,\n          'serverComponentsHmrCache'\n        ),\n        fallbackRouteParams,\n        renderOpts: {\n          App: () => null,\n          Document: () => null,\n          pageConfig: {},\n          ComponentMod,\n          Component: interopDefault(ComponentMod),\n\n          params,\n          routeModule,\n          page: srcPage,\n          postponed,\n          shouldWaitOnAllReady,\n          serveStreamingMetadata,\n          supportsDynamicResponse:\n            typeof postponed === 'string' || supportsDynamicResponse,\n          buildManifest,\n          nextFontManifest,\n          reactLoadableManifest,\n          subresourceIntegrityManifest,\n          setCacheStatus: routerServerContext?.setCacheStatus,\n          setIsrStatus: routerServerContext?.setIsrStatus,\n          setReactDebugChannel: routerServerContext?.setReactDebugChannel,\n          sendErrorsToBrowser: routerServerContext?.sendErrorsToBrowser,\n\n          dir:\n            process.env.NEXT_RUNTIME === 'nodejs'\n              ? (require('path') as typeof import('path')).join(\n                  /* turbopackIgnore: true */\n                  process.cwd(),\n                  routeModule.relativeProjectDir\n                )\n              : `${process.cwd()}/${routeModule.relativeProjectDir}`,\n          isDraftMode,\n          botType,\n          isOnDemandRevalidate,\n          isPossibleServerAction,\n          assetPrefix: nextConfig.assetPrefix,\n          nextConfigOutput: nextConfig.output,\n          crossOrigin: nextConfig.crossOrigin,\n          trailingSlash: nextConfig.trailingSlash,\n          images: nextConfig.images,\n          previewProps: prerenderManifest.preview,\n          enableTainting: nextConfig.experimental.taint,\n          htmlLimitedBots: nextConfig.htmlLimitedBots,\n          reactMaxHeadersLength: nextConfig.reactMaxHeadersLength,\n\n          multiZoneDraftMode,\n          incrementalCache,\n          cacheLifeProfiles: nextConfig.cacheLife,\n          basePath: nextConfig.basePath,\n          serverActions: nextConfig.experimental.serverActions,\n\n          ...(isDebugStaticShell ||\n          isDebugDynamicAccesses ||\n          isDebugFallbackShell\n            ? {\n                isBuildTimePrerendering: true,\n                supportsDynamicResponse: false,\n                isStaticGeneration: true,\n                isDebugDynamicAccesses: isDebugDynamicAccesses,\n              }\n            : {}),\n          cacheComponents: Boolean(nextConfig.cacheComponents),\n          experimental: {\n            isRoutePPREnabled,\n            expireTime: nextConfig.expireTime,\n            staleTimes: nextConfig.experimental.staleTimes,\n            dynamicOnHover: Boolean(nextConfig.experimental.dynamicOnHover),\n            optimisticRouting: Boolean(\n              nextConfig.experimental.optimisticRouting\n            ),\n            inlineCss: Boolean(nextConfig.experimental.inlineCss),\n            authInterrupts: Boolean(nextConfig.experimental.authInterrupts),\n            clientTraceMetadata:\n              nextConfig.experimental.clientTraceMetadata || ([] as any),\n            clientParamParsingOrigins:\n              nextConfig.experimental.clientParamParsingOrigins,\n            maxPostponedStateSizeBytes: parseMaxPostponedStateSize(\n              nextConfig.experimental.maxPostponedStateSize\n            ),\n          },\n\n          waitUntil: ctx.waitUntil,\n          onClose: (cb) => {\n            res.on('close', cb)\n          },\n          onAfterTaskError: () => {},\n\n          onInstrumentationRequestError: (\n            error,\n            _request,\n            errorContext,\n            silenceLog\n          ) =>\n            routeModule.onRequestError(\n              req,\n              error,\n              errorContext,\n              silenceLog,\n              routerServerContext\n            ),\n          err: getRequestMeta(req, 'invokeError'),\n          dev: routeModule.isDev,\n        },\n      }\n\n      // When we're revalidating in the background, we should not allow dynamic\n      // responses.\n      if (forceStaticRender) {\n        context.renderOpts.supportsDynamicResponse = false\n      }\n\n      const result = await invokeRouteModule(span, context)\n\n      const { metadata } = result\n\n      const {\n        cacheControl,\n        headers = {},\n        // Add any fetch tags that were on the page to the response headers.\n        fetchTags: cacheTags,\n        fetchMetrics,\n      } = metadata\n\n      if (cacheTags) {\n        headers[NEXT_CACHE_TAGS_HEADER] = cacheTags\n      }\n\n      // Pull any fetch metrics from the render onto the request.\n      ;(req as any).fetchMetrics = fetchMetrics\n\n      // we don't throw static to dynamic errors in dev as isSSG\n      // is a best guess in dev since we don't have the prerender pass\n      // to know whether the path is actually static or not\n      if (\n        isSSG &&\n        cacheControl?.revalidate === 0 &&\n        !routeModule.isDev &&\n        !isRoutePPREnabled\n      ) {\n        const staticBailoutInfo = metadata.staticBailoutInfo\n\n        const err = new Error(\n          `Page changed from static to dynamic at runtime ${resolvedPathname}${\n            staticBailoutInfo?.description\n              ? `, reason: ${staticBailoutInfo.description}`\n              : ``\n          }` +\n            `\\nsee more here https://nextjs.org/docs/messages/app-static-to-dynamic-error`\n        )\n\n        if (staticBailoutInfo?.stack) {\n          const stack = staticBailoutInfo.stack\n          err.stack = err.message + stack.substring(stack.indexOf('\\n'))\n        }\n\n        throw err\n      }\n\n      return {\n        value: {\n          kind: CachedRouteKind.APP_PAGE,\n          html: result,\n          headers,\n          rscData: metadata.flightData,\n          postponed: metadata.postponed,\n          status: metadata.statusCode,\n          segmentData: metadata.segmentData,\n        } satisfies CachedAppPageValue,\n        cacheControl,\n      } satisfies ResponseCacheEntry\n    }\n\n    const responseGenerator: ResponseGenerator = async ({\n      hasResolved,\n      previousCacheEntry: previousIncrementalCacheEntry,\n      isRevalidating,\n      span,\n      forceStaticRender = false,\n    }) => {\n      const isProduction = routeModule.isDev === false\n      const didRespond = hasResolved || res.writableEnded\n\n      // skip on-demand revalidate if cache is not present and\n      // revalidate-if-generated is set\n      if (\n        isOnDemandRevalidate &&\n        revalidateOnlyGenerated &&\n        !previousIncrementalCacheEntry &&\n        !isMinimalMode\n      ) {\n        if (routerServerContext?.render404) {\n          await routerServerContext.render404(req, res)\n        } else {\n          res.statusCode = 404\n          res.end('This page could not be found')\n        }\n        return null\n      }\n\n      let fallbackMode: FallbackMode | undefined\n\n      if (prerenderInfo) {\n        fallbackMode = parseFallbackField(prerenderInfo.fallback)\n      }\n\n      // When serving a HTML bot request, we want to serve a blocking render and\n      // not the prerendered page. This ensures that the correct content is served\n      // to the bot in the head.\n      if (fallbackMode === FallbackMode.PRERENDER && isBot(userAgent)) {\n        if (!isRoutePPREnabled || isHtmlBot) {\n          fallbackMode = FallbackMode.BLOCKING_STATIC_RENDER\n        }\n      }\n\n      if (previousIncrementalCacheEntry?.isStale === -1) {\n        isOnDemandRevalidate = true\n      }\n\n      // TODO: adapt for PPR\n      // only allow on-demand revalidate for fallback: true/blocking\n      // or for prerendered fallback: false paths\n      if (\n        isOnDemandRevalidate &&\n        (fallbackMode !== FallbackMode.NOT_FOUND ||\n          previousIncrementalCacheEntry)\n      ) {\n        fallbackMode = FallbackMode.BLOCKING_STATIC_RENDER\n      }\n\n      if (\n        !isMinimalMode &&\n        fallbackMode !== FallbackMode.BLOCKING_STATIC_RENDER &&\n        staticPathKey &&\n        !didRespond &&\n        !isDraftMode &&\n        pageIsDynamic &&\n        (isProduction || !isPrerendered)\n      ) {\n        // if the page has dynamicParams: false and this pathname wasn't\n        // prerendered trigger the no fallback handling\n        if (\n          // In development, fall through to render to handle missing\n          // getStaticPaths.\n          (isProduction || prerenderInfo) &&\n          // When fallback isn't present, abort this render so we 404\n          fallbackMode === FallbackMode.NOT_FOUND\n        ) {\n          if (nextConfig.experimental.adapterPath) {\n            return await render404()\n          }\n          throw new NoFallbackError()\n        }\n\n        // When cacheComponents is enabled, we can use the fallback\n        // response if the request is not a dynamic RSC request because the\n        // RSC data when this feature flag is enabled does not contain any\n        // param references. Without this feature flag enabled, the RSC data\n        // contains param references, and therefore we can't use the fallback.\n        if (\n          isRoutePPREnabled &&\n          (nextConfig.cacheComponents ? !isDynamicRSCRequest : !isRSCRequest)\n        ) {\n          const cacheKey =\n            isProduction && typeof prerenderInfo?.fallback === 'string'\n              ? prerenderInfo.fallback\n              : normalizedSrcPage\n\n          const fallbackRouteParams =\n            // If we're in production and we have fallback route params, then we\n            // can use the manifest fallback route params.\n            isProduction && prerenderInfo?.fallbackRouteParams\n              ? createOpaqueFallbackRouteParams(\n                  prerenderInfo.fallbackRouteParams\n                )\n              : // Otherwise, if we're debugging the fallback shell, then we\n                // have to manually generate the fallback route params.\n                isDebugFallbackShell\n                ? getFallbackRouteParams(normalizedSrcPage, routeModule)\n                : null\n\n          // We use the response cache here to handle the revalidation and\n          // management of the fallback shell.\n          const fallbackResponse = await routeModule.handleResponse({\n            cacheKey,\n            req,\n            nextConfig,\n            routeKind: RouteKind.APP_PAGE,\n            isFallback: true,\n            prerenderManifest,\n            isRoutePPREnabled,\n            responseGenerator: async () =>\n              doRender({\n                span,\n                // We pass `undefined` as rendering a fallback isn't resumed\n                // here.\n                postponed: undefined,\n                fallbackRouteParams,\n                forceStaticRender: false,\n              }),\n            waitUntil: ctx.waitUntil,\n            isMinimalMode,\n          })\n\n          // If the fallback response was set to null, then we should return null.\n          if (fallbackResponse === null) return null\n\n          // Otherwise, if we did get a fallback response, we should return it.\n          if (fallbackResponse) {\n            // Remove the cache control from the response to prevent it from being\n            // used in the surrounding cache.\n            delete fallbackResponse.cacheControl\n\n            return fallbackResponse\n          }\n        }\n      }\n\n      // Only requests that aren't revalidating can be resumed. If we have the\n      // minimal postponed data, then we should resume the render with it.\n      let postponed =\n        !isOnDemandRevalidate && !isRevalidating && minimalPostponed\n          ? minimalPostponed\n          : undefined\n\n      // If this is a dynamic RSC request or a server action request, we should\n      // use the postponed data from the static render (if available). This\n      // ensures that we can utilize the resume data cache (RDC) from the static\n      // render to ensure that the data is consistent between the static and\n      // dynamic renders (for navigations) or when re-rendering after a server\n      // action.\n      if (\n        // Only enable RDC for Navigations if the feature is enabled.\n        supportsRDCForNavigations &&\n        process.env.NEXT_RUNTIME !== 'edge' &&\n        !isMinimalMode &&\n        incrementalCache &&\n        // Include both dynamic RSC requests (navigations) and server actions\n        (isDynamicRSCRequest || isPossibleServerAction) &&\n        // We don't typically trigger an on-demand revalidation for dynamic RSC\n        // requests, as we're typically revalidating the page in the background\n        // instead. However, if the cache entry is stale, we should trigger a\n        // background revalidation on dynamic RSC requests. This prevents us\n        // from entering an infinite loop of revalidations.\n        !forceStaticRender\n      ) {\n        const incrementalCacheEntry = await incrementalCache.get(\n          resolvedPathname,\n          {\n            kind: IncrementalCacheKind.APP_PAGE,\n            isRoutePPREnabled: true,\n            isFallback: false,\n          }\n        )\n\n        // If the cache entry is found, we should use the postponed data from\n        // the cache.\n        if (\n          incrementalCacheEntry &&\n          incrementalCacheEntry.value &&\n          incrementalCacheEntry.value.kind === CachedRouteKind.APP_PAGE\n        ) {\n          // CRITICAL: we're assigning the postponed data from the cache entry\n          // here as we're using the RDC to resume the render.\n          postponed = incrementalCacheEntry.value.postponed\n\n          // If the cache entry is stale, we should trigger a background\n          // revalidation so that subsequent requests will get a fresh response.\n          if (\n            incrementalCacheEntry &&\n            // We want to trigger this flow if the cache entry is stale and if\n            // the requested revalidation flow is either foreground or\n            // background.\n            (incrementalCacheEntry.isStale === -1 ||\n              incrementalCacheEntry.isStale === true)\n          ) {\n            // We want to schedule this on the next tick to ensure that the\n            // render is not blocked on it.\n            scheduleOnNextTick(async () => {\n              const responseCache = routeModule.getResponseCache(req)\n\n              try {\n                await responseCache.revalidate(\n                  resolvedPathname,\n                  incrementalCache,\n                  isRoutePPREnabled,\n                  false,\n                  (c) =>\n                    responseGenerator({\n                      ...c,\n                      // CRITICAL: we need to set this to true as we're\n                      // revalidating in the background and typically this dynamic\n                      // RSC request is not treated as static.\n                      forceStaticRender: true,\n                    }),\n                  // CRITICAL: we need to pass null here because passing the\n                  // previous cache entry here (which is stale) will switch on\n                  // isOnDemandRevalidate and break the prerendering.\n                  null,\n                  hasResolved,\n                  ctx.waitUntil\n                )\n              } catch (err) {\n                console.error(\n                  'Error revalidating the page in the background',\n                  err\n                )\n              }\n            })\n          }\n        }\n      }\n\n      // When we're in minimal mode, if we're trying to debug the static shell,\n      // we should just return nothing instead of resuming the dynamic render.\n      if (\n        (isDebugStaticShell || isDebugDynamicAccesses) &&\n        typeof postponed !== 'undefined'\n      ) {\n        return {\n          cacheControl: { revalidate: 1, expire: undefined },\n          value: {\n            kind: CachedRouteKind.PAGES,\n            html: RenderResult.EMPTY,\n            pageData: {},\n            headers: undefined,\n            status: undefined,\n          } satisfies CachedPageValue,\n        }\n      }\n\n      const fallbackRouteParams =\n        // If we're in production and we have fallback route params, then we\n        // can use the manifest fallback route params if we need to render the\n        // fallback shell.\n        isProduction &&\n        prerenderInfo?.fallbackRouteParams &&\n        getRequestMeta(req, 'renderFallbackShell')\n          ? createOpaqueFallbackRouteParams(prerenderInfo.fallbackRouteParams)\n          : // Otherwise, if we're debugging the fallback shell, then we have to\n            // manually generate the fallback route params.\n            isDebugFallbackShell\n            ? getFallbackRouteParams(normalizedSrcPage, routeModule)\n            : null\n\n      // Perform the render.\n      return doRender({\n        span,\n        postponed,\n        fallbackRouteParams,\n        forceStaticRender,\n      })\n    }\n\n    const handleResponse = async (span?: Span): Promise<null | void> => {\n      const cacheEntry = await routeModule.handleResponse({\n        cacheKey: ssgCacheKey,\n        responseGenerator: (c) =>\n          responseGenerator({\n            span,\n            ...c,\n          }),\n        routeKind: RouteKind.APP_PAGE,\n        isOnDemandRevalidate,\n        isRoutePPREnabled,\n        req,\n        nextConfig,\n        prerenderManifest,\n        waitUntil: ctx.waitUntil,\n        isMinimalMode,\n      })\n\n      if (isDraftMode) {\n        res.setHeader(\n          'Cache-Control',\n          'private, no-cache, no-store, max-age=0, must-revalidate'\n        )\n      }\n\n      // In dev, we should not cache pages for any reason.\n      if (routeModule.isDev) {\n        res.setHeader(\n          'Cache-Control',\n          nextConfig.experimental.devCacheControlNoCache\n            ? 'no-cache, must-revalidate'\n            : 'no-store, must-revalidate'\n        )\n      }\n\n      if (!cacheEntry) {\n        if (ssgCacheKey) {\n          // A cache entry might not be generated if a response is written\n          // in `getInitialProps` or `getServerSideProps`, but those shouldn't\n          // have a cache key. If we do have a cache key but we don't end up\n          // with a cache entry, then either Next.js or the application has a\n          // bug that needs fixing.\n          throw new Error('invariant: cache entry required but not generated')\n        }\n        return null\n      }\n\n      if (cacheEntry.value?.kind !== CachedRouteKind.APP_PAGE) {\n        throw new Error(\n          `Invariant app-page handler received invalid cache entry ${cacheEntry.value?.kind}`\n        )\n      }\n\n      const didPostpone = typeof cacheEntry.value.postponed === 'string'\n\n      if (\n        isSSG &&\n        // We don't want to send a cache header for requests that contain dynamic\n        // data. If this is a Dynamic RSC request or wasn't a Prefetch RSC\n        // request, then we should set the cache header.\n        !isDynamicRSCRequest &&\n        (!didPostpone || isPrefetchRSCRequest)\n      ) {\n        if (!isMinimalMode) {\n          // set x-nextjs-cache header to match the header\n          // we set for the image-optimizer\n          res.setHeader(\n            'x-nextjs-cache',\n            isOnDemandRevalidate\n              ? 'REVALIDATED'\n              : cacheEntry.isMiss\n                ? 'MISS'\n                : cacheEntry.isStale\n                  ? 'STALE'\n                  : 'HIT'\n          )\n        }\n        // Set a header used by the client router to signal the response is static\n        // and should respect the `static` cache staleTime value.\n        res.setHeader(NEXT_IS_PRERENDER_HEADER, '1')\n      }\n      const { value: cachedData } = cacheEntry\n\n      // Coerce the cache control parameter from the render.\n      let cacheControl: CacheControl | undefined\n\n      // If this is a resume request in minimal mode it is streamed with dynamic\n      // content and should not be cached.\n      if (minimalPostponed) {\n        cacheControl = { revalidate: 0, expire: undefined }\n      }\n\n      // If this is in minimal mode and this is a flight request that isn't a\n      // prefetch request while PPR is enabled, it cannot be cached as it contains\n      // dynamic content.\n      else if (isDynamicRSCRequest) {\n        cacheControl = { revalidate: 0, expire: undefined }\n      } else if (!routeModule.isDev) {\n        // If this is a preview mode request, we shouldn't cache it\n        if (isDraftMode) {\n          cacheControl = { revalidate: 0, expire: undefined }\n        }\n\n        // If this isn't SSG, then we should set change the header only if it is\n        // not set already.\n        else if (!isSSG) {\n          if (!res.getHeader('Cache-Control')) {\n            cacheControl = { revalidate: 0, expire: undefined }\n          }\n        } else if (cacheEntry.cacheControl) {\n          // If the cache entry has a cache control with a revalidate value that's\n          // a number, use it.\n          if (typeof cacheEntry.cacheControl.revalidate === 'number') {\n            if (cacheEntry.cacheControl.revalidate < 1) {\n              throw new Error(\n                `Invalid revalidate configuration provided: ${cacheEntry.cacheControl.revalidate} < 1`\n              )\n            }\n\n            cacheControl = {\n              revalidate: cacheEntry.cacheControl.revalidate,\n              expire: cacheEntry.cacheControl?.expire ?? nextConfig.expireTime,\n            }\n          }\n          // Otherwise if the revalidate value is false, then we should use the\n          // cache time of one year.\n          else {\n            cacheControl = { revalidate: CACHE_ONE_YEAR, expire: undefined }\n          }\n        }\n      }\n\n      cacheEntry.cacheControl = cacheControl\n\n      if (\n        typeof segmentPrefetchHeader === 'string' &&\n        cachedData?.kind === CachedRouteKind.APP_PAGE &&\n        cachedData.segmentData\n      ) {\n        // This is a prefetch request issued by the client Segment Cache. These\n        // should never reach the application layer (lambda). We should either\n        // respond from the cache (HIT) or respond with 204 No Content (MISS).\n\n        // Set a header to indicate that PPR is enabled for this route. This\n        // lets the client distinguish between a regular cache miss and a cache\n        // miss due to PPR being disabled. In other contexts this header is used\n        // to indicate that the response contains dynamic data, but here we're\n        // only using it to indicate that the feature is enabled â€” the segment\n        // response itself contains whether the data is dynamic.\n        res.setHeader(NEXT_DID_POSTPONE_HEADER, '2')\n\n        // Add the cache tags header to the response if it exists and we're in\n        // minimal mode while rendering a static page.\n        const tags = cachedData.headers?.[NEXT_CACHE_TAGS_HEADER]\n        if (isMinimalMode && isSSG && tags && typeof tags === 'string') {\n          res.setHeader(NEXT_CACHE_TAGS_HEADER, tags)\n        }\n\n        const matchedSegment = cachedData.segmentData.get(segmentPrefetchHeader)\n        if (matchedSegment !== undefined) {\n          // Cache hit\n          return sendRenderResult({\n            req,\n            res,\n            generateEtags: nextConfig.generateEtags,\n            poweredByHeader: nextConfig.poweredByHeader,\n            result: RenderResult.fromStatic(\n              matchedSegment,\n              RSC_CONTENT_TYPE_HEADER\n            ),\n            cacheControl: cacheEntry.cacheControl,\n          })\n        }\n\n        // Cache miss. Either a cache entry for this route has not been generated\n        // (which technically should not be possible when PPR is enabled, because\n        // at a minimum there should always be a fallback entry) or there's no\n        // match for the requested segment. Respond with a 204 No Content. We\n        // don't bother to respond with 404, because these requests are only\n        // issued as part of a prefetch.\n        res.statusCode = 204\n        return sendRenderResult({\n          req,\n          res,\n          generateEtags: nextConfig.generateEtags,\n          poweredByHeader: nextConfig.poweredByHeader,\n          result: RenderResult.EMPTY,\n          cacheControl: cacheEntry.cacheControl,\n        })\n      }\n\n      // If there's a callback for `onCacheEntry`, call it with the cache entry\n      // and the revalidate options. If we support RDC for Navigations, we\n      // prefer the `onCacheEntryV2` callback. Once RDC for Navigations is the\n      // default, we can remove the fallback to `onCacheEntry` as\n      // `onCacheEntryV2` is now fully supported.\n      const onCacheEntry = supportsRDCForNavigations\n        ? (getRequestMeta(req, 'onCacheEntryV2') ??\n          getRequestMeta(req, 'onCacheEntry'))\n        : getRequestMeta(req, 'onCacheEntry')\n      if (onCacheEntry) {\n        const finished = await onCacheEntry(cacheEntry, {\n          url: getRequestMeta(req, 'initURL') ?? req.url,\n        })\n        if (finished) return null\n      }\n\n      if (cachedData.headers) {\n        const headers = { ...cachedData.headers }\n\n        if (!isMinimalMode || !isSSG) {\n          delete headers[NEXT_CACHE_TAGS_HEADER]\n        }\n\n        for (let [key, value] of Object.entries(headers)) {\n          if (typeof value === 'undefined') continue\n\n          if (Array.isArray(value)) {\n            for (const v of value) {\n              res.appendHeader(key, v)\n            }\n          } else if (typeof value === 'number') {\n            value = value.toString()\n            res.appendHeader(key, value)\n          } else {\n            res.appendHeader(key, value)\n          }\n        }\n      }\n\n      // Add the cache tags header to the response if it exists and we're in\n      // minimal mode while rendering a static page.\n      const tags = cachedData.headers?.[NEXT_CACHE_TAGS_HEADER]\n      if (isMinimalMode && isSSG && tags && typeof tags === 'string') {\n        res.setHeader(NEXT_CACHE_TAGS_HEADER, tags)\n      }\n\n      // If the request is a data request, then we shouldn't set the status code\n      // from the response because it should always be 200. This should be gated\n      // behind the experimental PPR flag.\n      if (cachedData.status && (!isRSCRequest || !isRoutePPREnabled)) {\n        res.statusCode = cachedData.status\n      }\n\n      // Redirect information is encoded in RSC payload, so we don't need to use redirect status codes\n      if (\n        !isMinimalMode &&\n        cachedData.status &&\n        RedirectStatusCode[cachedData.status] &&\n        isRSCRequest\n      ) {\n        res.statusCode = 200\n      }\n\n      // Mark that the request did postpone.\n      if (didPostpone && !isDynamicRSCRequest) {\n        res.setHeader(NEXT_DID_POSTPONE_HEADER, '1')\n      }\n\n      // we don't go through this block when preview mode is true\n      // as preview mode is a dynamic request (bypasses cache) and doesn't\n      // generate both HTML and payloads in the same request so continue to just\n      // return the generated payload\n      if (isRSCRequest && !isDraftMode) {\n        // If this is a dynamic RSC request, then stream the response.\n        if (typeof cachedData.rscData === 'undefined') {\n          // If the response is not an RSC response, then we can't serve it.\n          if (cachedData.html.contentType !== RSC_CONTENT_TYPE_HEADER) {\n            if (nextConfig.cacheComponents) {\n              res.statusCode = 404\n              return sendRenderResult({\n                req,\n                res,\n                generateEtags: nextConfig.generateEtags,\n                poweredByHeader: nextConfig.poweredByHeader,\n                result: RenderResult.EMPTY,\n                cacheControl: cacheEntry.cacheControl,\n              })\n            } else {\n              // Otherwise this case is not expected.\n              throw new InvariantError(\n                `Expected RSC response, got ${cachedData.html.contentType}`\n              )\n            }\n          }\n\n          return sendRenderResult({\n            req,\n            res,\n            generateEtags: nextConfig.generateEtags,\n            poweredByHeader: nextConfig.poweredByHeader,\n            result: cachedData.html,\n            cacheControl: cacheEntry.cacheControl,\n          })\n        }\n\n        // As this isn't a prefetch request, we should serve the static flight\n        // data.\n        return sendRenderResult({\n          req,\n          res,\n          generateEtags: nextConfig.generateEtags,\n          poweredByHeader: nextConfig.poweredByHeader,\n          result: RenderResult.fromStatic(\n            cachedData.rscData,\n            RSC_CONTENT_TYPE_HEADER\n          ),\n          cacheControl: cacheEntry.cacheControl,\n        })\n      }\n\n      // This is a request for HTML data.\n      const body = cachedData.html\n\n      // If there's no postponed state, we should just serve the HTML. This\n      // should also be the case for a resume request because it's completed\n      // as a server render (rather than a static render).\n      if (!didPostpone || isMinimalMode || isRSCRequest) {\n        // If we're in test mode, we should add a sentinel chunk to the response\n        // that's between the static and dynamic parts so we can compare the\n        // chunks and add assertions.\n        if (\n          process.env.__NEXT_TEST_MODE &&\n          isMinimalMode &&\n          isRoutePPREnabled &&\n          body.contentType === HTML_CONTENT_TYPE_HEADER\n        ) {\n          // As we're in minimal mode, the static part would have already been\n          // streamed first. The only part that this streams is the dynamic part\n          // so we should FIRST stream the sentinel and THEN the dynamic part.\n          body.unshift(createPPRBoundarySentinel())\n        }\n\n        return sendRenderResult({\n          req,\n          res,\n          generateEtags: nextConfig.generateEtags,\n          poweredByHeader: nextConfig.poweredByHeader,\n          result: body,\n          cacheControl: cacheEntry.cacheControl,\n        })\n      }\n\n      // If we're debugging the static shell or the dynamic API accesses, we\n      // should just serve the HTML without resuming the render. The returned\n      // HTML will be the static shell so all the Dynamic API's will be used\n      // during static generation.\n      if (isDebugStaticShell || isDebugDynamicAccesses) {\n        // Since we're not resuming the render, we need to at least add the\n        // closing body and html tags to create valid HTML.\n        body.push(\n          new ReadableStream({\n            start(controller) {\n              controller.enqueue(ENCODED_TAGS.CLOSED.BODY_AND_HTML)\n              controller.close()\n            },\n          })\n        )\n\n        return sendRenderResult({\n          req,\n          res,\n          generateEtags: nextConfig.generateEtags,\n          poweredByHeader: nextConfig.poweredByHeader,\n          result: body,\n          cacheControl: { revalidate: 0, expire: undefined },\n        })\n      }\n\n      // If we're in test mode, we should add a sentinel chunk to the response\n      // that's between the static and dynamic parts so we can compare the\n      // chunks and add assertions.\n      if (process.env.__NEXT_TEST_MODE) {\n        body.push(createPPRBoundarySentinel())\n      }\n\n      // This request has postponed, so let's create a new transformer that the\n      // dynamic data can pipe to that will attach the dynamic data to the end\n      // of the response.\n      const transformer = new TransformStream<Uint8Array, Uint8Array>()\n      body.push(transformer.readable)\n\n      // Perform the render again, but this time, provide the postponed state.\n      // We don't await because we want the result to start streaming now, and\n      // we've already chained the transformer's readable to the render result.\n      doRender({\n        span,\n        postponed: cachedData.postponed,\n        // This is a resume render, not a fallback render, so we don't need to\n        // set this.\n        fallbackRouteParams: null,\n        forceStaticRender: false,\n      })\n        .then(async (result) => {\n          if (!result) {\n            throw new Error('Invariant: expected a result to be returned')\n          }\n\n          if (result.value?.kind !== CachedRouteKind.APP_PAGE) {\n            throw new Error(\n              `Invariant: expected a page response, got ${result.value?.kind}`\n            )\n          }\n\n          // Pipe the resume result to the transformer.\n          await result.value.html.pipeTo(transformer.writable)\n        })\n        .catch((err) => {\n          // An error occurred during piping or preparing the render, abort\n          // the transformers writer so we can terminate the stream.\n          transformer.writable.abort(err).catch((e) => {\n            console.error(\"couldn't abort transformer\", e)\n          })\n        })\n\n      return sendRenderResult({\n        req,\n        res,\n        generateEtags: nextConfig.generateEtags,\n        poweredByHeader: nextConfig.poweredByHeader,\n        result: body,\n        // We don't want to cache the response if it has postponed data because\n        // the response being sent to the client it's dynamic parts are streamed\n        // to the client on the same request.\n        cacheControl: { revalidate: 0, expire: undefined },\n      })\n    }\n\n    // TODO: activeSpan code path is for when wrapped by\n    // next-server can be removed when this is no longer used\n    if (activeSpan) {\n      await handleResponse(activeSpan)\n    } else {\n      return await tracer.withPropagatedContext(req.headers, () =>\n        tracer.trace(\n          BaseServerSpan.handleRequest,\n          {\n            spanName: `${method} ${srcPage}`,\n            kind: SpanKind.SERVER,\n            attributes: {\n              'http.method': method,\n              'http.target': req.url,\n            },\n          },\n          handleResponse\n        )\n      )\n    }\n  } catch (err) {\n    if (!(err instanceof NoFallbackError)) {\n      const silenceLog = false\n      await routeModule.onRequestError(\n        req,\n        err,\n        {\n          routerKind: 'App Router',\n          routePath: srcPage,\n          routeType: 'render',\n          revalidateReason: getRevalidateReason({\n            isStaticGeneration: isSSG,\n            isOnDemandRevalidate,\n          }),\n        },\n        silenceLog,\n        routerServerContext\n      )\n    }\n\n    // rethrow so that we can handle serving error page\n    throw err\n  }\n}\n\n// TODO: omit this from production builds, only test builds should include it\n/**\n * Creates a readable stream that emits a PPR boundary sentinel.\n *\n * @returns A readable stream that emits a PPR boundary sentinel.\n */\nfunction createPPRBoundarySentinel() {\n  return new ReadableStream({\n    start(controller) {\n      controller.enqueue(\n        new TextEncoder().encode('<!-- PPR_BOUNDARY_SENTINEL -->')\n      )\n      controller.close()\n    },\n  })\n}\n"],"names":["AppPageRouteModule","RouteKind","getRevalidateReason","getTracer","SpanKind","addRequestMeta","getRequestMeta","setRequestMeta","BaseServerSpan","interopDefault","stripFlightHeaders","NodeNextRequest","NodeNextResponse","checkIsAppPPREnabled","getFallbackRouteParams","createOpaqueFallbackRouteParams","setManifestsSingleton","isHtmlBotRequest","shouldServeStreamingMetadata","normalizeAppPath","getIsPossibleServerAction","RSC_HEADER","NEXT_ROUTER_PREFETCH_HEADER","NEXT_IS_PRERENDER_HEADER","NEXT_DID_POSTPONE_HEADER","RSC_CONTENT_TYPE_HEADER","getBotType","isBot","CachedRouteKind","IncrementalCacheKind","FallbackMode","parseFallbackField","RenderResult","CACHE_ONE_YEAR","HTML_CONTENT_TYPE_HEADER","NEXT_CACHE_TAGS_HEADER","NEXT_RESUME_HEADER","NEXT_RESUME_STATE_LENGTH_HEADER","ENCODED_TAGS","sendRenderResult","NoFallbackError","DEFAULT_MAX_POSTPONED_STATE_SIZE","parseMaxPostponedStateSize","__next_app__","require","__next_app_require__","loadChunk","__next_app_load_chunk__","entryBase","RedirectStatusCode","InvariantError","scheduleOnNextTick","isInterceptionRouteAppPath","routeModule","definition","kind","APP_PAGE","page","pathname","bundlePath","filename","appPaths","userland","loaderTree","tree","distDir","process","env","__NEXT_RELATIVE_DIST_DIR","relativeProjectDir","__NEXT_RELATIVE_PROJECT_DIR","handler","req","res","ctx","prerenderManifest","requestMeta","isDev","hrtime","bigint","isMinimalMode","Boolean","srcPage","TURBOPACK","replace","multiZoneDraftMode","__NEXT_MULTI_ZONE_DRAFT_MODE","prepareResult","prepare","statusCode","end","waitUntil","Promise","resolve","buildId","query","params","pageIsDynamic","buildManifest","nextFontManifest","reactLoadableManifest","serverActionsManifest","clientReferenceManifest","subresourceIntegrityManifest","isDraftMode","resolvedPathname","revalidateOnlyGenerated","routerServerContext","nextConfig","parsedUrl","interceptionRoutePatterns","deploymentId","normalizedSrcPage","isOnDemandRevalidate","prerenderInfo","experimental","ppr","cacheComponents","match","isPrerendered","routes","userAgent","headers","botType","isHtmlBot","isPrefetchRSCRequest","isRSCRequest","isPossibleServerAction","couldSupportPPR","resumeStateLengthHeader","stateLength","parseInt","maxPostponedStateSize","maxPostponedStateSizeBytes","isNaN","undefined","defaultActionBodySizeLimit","actionBodySizeLimit","serverActions","bodySizeLimit","actionBodySizeLimitBytes","parse","maxTotalBodySize","bodyChunks","size","chunk","buffer","Buffer","isBuffer","from","byteLength","push","fullBody","concat","length","postponedState","subarray","toString","actionBody","Error","method","body","postponed","hasDebugStaticShellQuery","__NEXT_EXPERIMENTAL_STATIC_SHELL_DEBUGGING","__nextppronly","hasDebugFallbackShellQuery","isRoutePPREnabled","dynamicRoutes","renderingMode","experimentalTestProxy","isDebugStaticShell","isDebugDynamicAccesses","isDebugFallbackShell","minimalPostponed","staticPrefetchDataRoute","prefetchDataRoute","isDynamicRSCRequest","segmentPrefetchHeader","serveStreamingMetadata","htmlLimitedBots","isSSG","supportsRDCForNavigations","supportsDynamicResponse","shouldWaitOnAllReady","ssgCacheKey","staticPathKey","ComponentMod","tracer","activeSpan","getActiveScopeSpan","render404","varyHeader","getVaryHeader","setHeader","invokeRouteModule","span","context","nextReq","nextRes","render","finally","setAttributes","rootSpanAttributes","getRootSpanAttributes","get","handleRequest","console","warn","route","name","updateName","incrementalCache","getIncrementalCache","resetRequestCache","globalThis","__incrementalCache","doRender","fallbackRouteParams","forceStaticRender","sharedContext","serverComponentsHmrCache","renderOpts","App","Document","pageConfig","Component","setCacheStatus","setIsrStatus","setReactDebugChannel","sendErrorsToBrowser","dir","NEXT_RUNTIME","join","cwd","assetPrefix","nextConfigOutput","output","crossOrigin","trailingSlash","images","previewProps","preview","enableTainting","taint","reactMaxHeadersLength","cacheLifeProfiles","cacheLife","basePath","isBuildTimePrerendering","isStaticGeneration","expireTime","staleTimes","dynamicOnHover","optimisticRouting","inlineCss","authInterrupts","clientTraceMetadata","clientParamParsingOrigins","onClose","cb","on","onAfterTaskError","onInstrumentationRequestError","error","_request","errorContext","silenceLog","onRequestError","err","dev","result","metadata","cacheControl","fetchTags","cacheTags","fetchMetrics","revalidate","staticBailoutInfo","description","stack","message","substring","indexOf","value","html","rscData","flightData","status","segmentData","responseGenerator","hasResolved","previousCacheEntry","previousIncrementalCacheEntry","isRevalidating","isProduction","didRespond","writableEnded","fallbackMode","fallback","PRERENDER","BLOCKING_STATIC_RENDER","isStale","NOT_FOUND","adapterPath","cacheKey","fallbackResponse","handleResponse","routeKind","isFallback","incrementalCacheEntry","responseCache","getResponseCache","c","expire","PAGES","EMPTY","pageData","cacheEntry","cachedData","devCacheControlNoCache","didPostpone","isMiss","getHeader","tags","matchedSegment","generateEtags","poweredByHeader","fromStatic","onCacheEntry","finished","url","key","Object","entries","Array","isArray","v","appendHeader","contentType","__NEXT_TEST_MODE","unshift","createPPRBoundarySentinel","ReadableStream","start","controller","enqueue","CLOSED","BODY_AND_HTML","close","transformer","TransformStream","readable","then","pipeTo","writable","catch","abort","e","withPropagatedContext","trace","spanName","SERVER","attributes","routerKind","routePath","routeType","revalidateReason","TextEncoder","encode"],"mappings":"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","ignoreList":[0]}