{"version":3,"sources":["../../../../src/build/adapter/build-complete.ts"],"sourcesContent":["import path from 'path'\nimport fs from 'fs/promises'\nimport { pathToFileURL } from 'url'\nimport * as Log from '../output/log'\nimport { isMiddlewareFilename } from '../utils'\nimport { RenderingMode } from '../rendering-mode'\nimport { interopDefault } from '../../lib/interop-default'\nimport type { RouteHas } from '../../lib/load-custom-routes'\nimport { recursiveReadDir } from '../../lib/recursive-readdir'\nimport { isDynamicRoute } from '../../shared/lib/router/utils'\nimport type { Revalidate } from '../../server/lib/cache-control'\nimport type { NextConfigComplete } from '../../server/config-shared'\nimport { normalizeAppPath } from '../../shared/lib/router/utils/app-paths'\nimport { AdapterOutputType, type PHASE_TYPE } from '../../shared/lib/constants'\nimport { normalizePagePath } from '../../shared/lib/page-path/normalize-page-path'\nimport {\n  convertRedirects,\n  convertRewrites,\n  convertHeaders,\n} from 'next/dist/compiled/@vercel/routing-utils'\n\nimport type {\n  MiddlewareManifest,\n  EdgeFunctionDefinition,\n} from '../webpack/plugins/middleware-plugin'\n\nimport type {\n  RoutesManifest,\n  PrerenderManifest,\n  ManifestRewriteRoute,\n  FunctionsConfigManifest,\n  DynamicPrerenderManifestRoute,\n} from '..'\n\nimport {\n  CACHE_ONE_YEAR,\n  HTML_CONTENT_TYPE_HEADER,\n  JSON_CONTENT_TYPE_HEADER,\n  NEXT_RESUME_HEADER,\n} from '../../lib/constants'\n\nimport { normalizeLocalePath } from '../../shared/lib/i18n/normalize-locale-path'\nimport { addPathPrefix } from '../../shared/lib/router/utils/add-path-prefix'\nimport { getRedirectStatus, modifyRouteRegex } from '../../lib/redirect-status'\nimport { getNamedRouteRegex } from '../../shared/lib/router/utils/route-regex'\nimport { escapeStringRegexp } from '../../shared/lib/escape-regexp'\nimport { sortSortableRoutes } from '../../shared/lib/router/utils/sortable-routes'\nimport { generateRoutesManifest } from '../generate-routes-manifest'\n\ninterface SharedRouteFields {\n  /**\n   * id is the unique identifier of the output\n   */\n  id: string\n  /**\n   * filePath is the location on disk of the built entrypoint asset\n   */\n  filePath: string\n  /**\n   * pathname is the URL pathname the asset should be served at\n   */\n  pathname: string\n\n  /**\n   * sourcePage is the original source in the app or pages folder\n   */\n  sourcePage: string\n\n  /**\n   * runtime is which runtime the entrypoint is built for\n   */\n  runtime: 'nodejs' | 'edge'\n  /**\n   * assets are all necessary traced assets that could be\n   * loaded by the output to handle a request e.g. traced\n   * node_modules or necessary manifests for Next.js.\n   * The key is the relative path from the repo root and the value\n   * is the absolute path to the file\n   */\n  assets: Record<string, string>\n\n  /**\n   * wasmAssets are bundled wasm files with mapping of name\n   * to filePath on disk\n   */\n  wasmAssets?: Record<string, string>\n\n  /**\n   * config related to the route\n   */\n  config: {\n    /**\n     * maxDuration is a segment config to signal the max\n     * execution duration a route should be allowed before\n     * it's timed out\n     */\n    maxDuration?: number\n    /**\n     * preferredRegion is a segment config to signal deployment\n     * region preferences to the provider being used\n     */\n    preferredRegion?: string | string[]\n\n    /**\n     * env is the environment variables to expose, this is only\n     * populated for edge runtime currently\n     */\n    env?: Record<string, string>\n  }\n}\n\nexport interface AdapterOutput {\n  /**\n   * `PAGES` represents all the React pages that are under `pages/`.\n   */\n  PAGES: SharedRouteFields & {\n    type: AdapterOutputType.PAGES\n  }\n\n  /**\n   * `PAGES_API` represents all the API routes under `pages/api/`.\n   */\n  PAGES_API: SharedRouteFields & {\n    type: AdapterOutputType.PAGES_API\n  }\n  /**\n   * `APP_PAGE` represents all the React pages that are under `app/` with the\n   * filename of `page.{j,t}s{,x}`.\n   */\n  APP_PAGE: SharedRouteFields & {\n    type: AdapterOutputType.APP_PAGE\n  }\n\n  /**\n   * `APP_ROUTE` represents all the API routes and metadata routes that are under `app/` with the\n   * filename of `route.{j,t}s{,x}`.\n   */\n  APP_ROUTE: SharedRouteFields & {\n    type: AdapterOutputType.APP_ROUTE\n  }\n\n  /**\n   * `PRERENDER` represents an ISR enabled route that might\n   * have a seeded cache entry or fallback generated during build\n   */\n  PRERENDER: {\n    id: string\n    pathname: string\n    type: AdapterOutputType.PRERENDER\n\n    /**\n     * For prerenders the parent output is the originating\n     * page that the prerender is created from\n     */\n    parentOutputId: string\n\n    /**\n     * groupId is the identifier for a group of prerenders that should be\n     * revalidated together\n     */\n    groupId: number\n\n    pprChain?: {\n      headers: Record<string, string>\n    }\n\n    /**\n     * parentFallbackMode signals whether additional routes can be generated\n     * e.g. fallback: false or 'blocking' in getStaticPaths in pages router\n     */\n    parentFallbackMode?: DynamicPrerenderManifestRoute['fallback']\n\n    /**\n     * fallback is initial cache data generated during build for a prerender\n     */\n    fallback?: {\n      /**\n       * path to the fallback file can be HTML/JSON/RSC,\n       */\n      filePath: string | undefined\n      /**\n       * initialStatus is the status code that should be applied\n       * when serving the fallback\n       */\n      initialStatus?: number\n      /**\n       * initialHeaders are the headers that should be sent when\n       * serving the fallback\n       */\n      initialHeaders?: Record<string, string | string[]>\n      /**\n       * initial expiration is how long until the fallback entry\n       * is considered expired and no longer valid to serve\n       */\n      initialExpiration?: number\n      /**\n       * initial revalidate is how long until the fallback is\n       * considered stale and should be revalidated\n       */\n      initialRevalidate?: Revalidate\n\n      /**\n       * postponedState is the PPR state when it postponed and is used for resuming\n       */\n      postponedState: string | undefined\n    }\n\n    /**\n     * config related to the route\n     */\n    config: {\n      /**\n       * allowQuery is the allowed query values to be passed\n       * to an ISR function and what should be considered for the cacheKey\n       * e.g. for /blog/[slug], \"slug\" is the only allowQuery\n       */\n      allowQuery?: string[]\n      /**\n       * allowHeader is the allowed headers to be passed to an\n       * ISR function to prevent accidentally poisoning the cache\n       * from leaking additional information that can impact the render\n       */\n      allowHeader?: string[]\n      /**\n       * bypass for is a list of has conditions the cache\n       * should be bypassed and invoked directly e.g. action header\n       */\n      bypassFor?: RouteHas[]\n      /**\n       * renderingMode signals PPR or not for a prerender\n       */\n      renderingMode?: RenderingMode\n\n      /**\n       * bypassToken is the generated token that signals a prerender cache\n       * should be bypassed\n       */\n      bypassToken?: string\n    }\n  }\n\n  /**\n   * `STATIC_FILE` represents a static file (ie /_next/static) or a purely\n   * static HTML asset e.g. an automatically statically optimized page\n   * that does not use ISR\n   */\n  STATIC_FILE: {\n    id: string\n    filePath: string\n    pathname: string\n    type: AdapterOutputType.STATIC_FILE\n  }\n\n  /**\n   * `MIDDLEWARE` represents the middleware output if present\n   */\n  MIDDLEWARE: SharedRouteFields & {\n    type: AdapterOutputType.MIDDLEWARE\n    /**\n     * config related to the route\n     */\n    config: SharedRouteFields['config'] & {\n      /**\n       * matchers are the configured matchers for middleware\n       */\n      matchers?: Array<{\n        source: string\n        sourceRegex: string\n        has: RouteHas[] | undefined\n        missing: RouteHas[] | undefined\n      }>\n    }\n  }\n}\n\nexport interface AdapterOutputs {\n  pages: Array<AdapterOutput['PAGES']>\n  middleware?: AdapterOutput['MIDDLEWARE']\n  appPages: Array<AdapterOutput['APP_PAGE']>\n  pagesApi: Array<AdapterOutput['PAGES_API']>\n  appRoutes: Array<AdapterOutput['APP_ROUTE']>\n  prerenders: Array<AdapterOutput['PRERENDER']>\n  staticFiles: Array<AdapterOutput['STATIC_FILE']>\n}\n\ntype RewriteItem = {\n  source: string\n  sourceRegex: string\n  destination: string\n  has: RouteHas[] | undefined\n  missing: RouteHas[] | undefined\n}\n\ntype DynamicRouteItem = {\n  source: string\n  sourceRegex: string\n  destination: string\n  has: RouteHas[] | undefined\n  missing: RouteHas[] | undefined\n}\n\ntype Route = {\n  // regex as string can have named or un-named matches\n  source?: string\n  sourceRegex: string\n  // destination can have matches to replace in destination\n  // keyed by $1 for un-named and $name for named\n  destination?: string\n  headers?: Record<string, string>\n  has?: RouteHas[]\n  missing?: RouteHas[]\n  status?: number\n  priority?: boolean\n}\n\nexport interface NextAdapter {\n  name: string\n  /**\n   * modifyConfig is called for any CLI command that loads the next.config\n   * to only apply for specific commands the \"phase\" should be used\n   * @param config\n   * @param ctx\n   * @returns\n   */\n  modifyConfig?: (\n    config: NextConfigComplete,\n    ctx: {\n      phase: PHASE_TYPE\n    }\n  ) => Promise<NextConfigComplete> | NextConfigComplete\n  onBuildComplete?: (ctx: {\n    routing: {\n      beforeMiddleware: Array<Route>\n      beforeFiles: Array<Route>\n      afterFiles: Array<Route>\n      dynamicRoutes: Array<Route>\n      onMatch: Array<Route>\n      fallback: Array<Route>\n      /**\n       * shouldNormalizeNextData indicates whether Next.js data URLs\n       * (e.g., /_next/data/BUILD_ID/page.json) should be normalized\n       * during route resolution. This is true when middleware is present\n       * and there are pages router items to resolve.\n       */\n      shouldNormalizeNextData: boolean\n      rsc: RoutesManifest['rsc']\n    }\n    outputs: AdapterOutputs\n    /**\n     * projectDir is the absolute directory the Next.js application is in\n     */\n    projectDir: string\n    /**\n     * repoRoot is the absolute path of the detected root of the repo\n     */\n    repoRoot: string\n    /**\n     * distDir is the absolute path to the dist directory\n     */\n    distDir: string\n    /**\n     * config is the loaded next.config (has modifyConfig applied)\n     */\n    config: NextConfigComplete\n    /**\n     * nextVersion is the current version of Next.js being used\n     */\n    nextVersion: string\n    /**\n     * buildId is the current unique ID for the build, this can be\n     * influenced by NextConfig.generateBuildId\n     */\n    buildId: string\n  }) => Promise<void> | void\n}\n\nfunction normalizePathnames(\n  config: NextConfigComplete,\n  outputs: AdapterOutputs\n) {\n  // normalize pathname field with basePath\n  if (config.basePath) {\n    for (const output of [\n      ...outputs.pages,\n      ...outputs.pagesApi,\n      ...outputs.appPages,\n      ...outputs.appRoutes,\n      ...outputs.prerenders,\n      ...outputs.staticFiles,\n    ]) {\n      output.pathname =\n        addPathPrefix(output.pathname, config.basePath).replace(/\\/$/, '') ||\n        '/'\n    }\n  }\n}\n\nexport async function handleBuildComplete({\n  dir,\n  config,\n  appType,\n  buildId,\n  configOutDir,\n  distDir,\n  pageKeys,\n  tracingRoot,\n  adapterPath,\n  appPageKeys,\n  staticPages,\n  nextVersion,\n  hasStatic404,\n  hasStatic500,\n  routesManifest,\n  serverPropsPages,\n  hasNodeMiddleware,\n  prerenderManifest,\n  middlewareManifest,\n  requiredServerFiles,\n  hasInstrumentationHook,\n  functionsConfigManifest,\n}: {\n  dir: string\n  appType: 'app' | 'pages' | 'hybrid'\n  distDir: string\n  buildId: string\n  configOutDir: string\n  adapterPath: string\n  tracingRoot: string\n  nextVersion: string\n  hasStatic404: boolean\n  hasStatic500: boolean\n  staticPages: Set<string>\n  hasNodeMiddleware: boolean\n  config: NextConfigComplete\n  pageKeys: readonly string[]\n  serverPropsPages: Set<string>\n  requiredServerFiles: string[]\n  routesManifest: RoutesManifest\n  hasInstrumentationHook: boolean\n  prerenderManifest: PrerenderManifest\n  middlewareManifest: MiddlewareManifest\n  appPageKeys?: readonly string[] | undefined\n  functionsConfigManifest: FunctionsConfigManifest\n}) {\n  const adapterMod = interopDefault(\n    await import(pathToFileURL(require.resolve(adapterPath)).href)\n  ) as NextAdapter\n\n  if (typeof adapterMod.onBuildComplete === 'function') {\n    const outputs: AdapterOutputs = {\n      pages: [],\n      pagesApi: [],\n      appPages: [],\n      appRoutes: [],\n      prerenders: [],\n      staticFiles: [],\n    }\n\n    if (config.output === 'export') {\n      // collect export assets and provide as static files\n      const exportFiles = await recursiveReadDir(configOutDir)\n\n      for (const file of exportFiles) {\n        let pathname = (\n          file.endsWith('.html') ? file.replace(/\\.html$/, '') : file\n        ).replace(/\\\\/g, '/')\n\n        pathname = pathname.startsWith('/') ? pathname : `/${pathname}`\n\n        outputs.staticFiles.push({\n          id: file,\n          pathname,\n          filePath: path.join(configOutDir, file),\n          type: AdapterOutputType.STATIC_FILE,\n        } satisfies AdapterOutput['STATIC_FILE'])\n      }\n    } else {\n      const staticFiles = await recursiveReadDir(path.join(distDir, 'static'))\n\n      for (const file of staticFiles) {\n        const pathname = path.posix.join('/_next/static', file)\n        const filePath = path.join(distDir, 'static', file)\n        outputs.staticFiles.push({\n          type: AdapterOutputType.STATIC_FILE,\n          id: path.join('static', file),\n          pathname,\n          filePath,\n        })\n      }\n\n      const sharedNodeAssets: Record<string, string> = {}\n\n      for (const file of requiredServerFiles) {\n        // add to shared node assets\n        const filePath = path.join(dir, file)\n        const fileOutputPath = path.relative(tracingRoot, filePath)\n        sharedNodeAssets[fileOutputPath] = filePath\n      }\n      // add \"next/setup-node-env\" stub so it can be required via\n      // TODO: should we make this always available without adapters\n      const setupNodeStubPath = path.join(\n        path.dirname(require.resolve('next/package.json')),\n        'setup-node-env.js'\n      )\n      sharedNodeAssets[path.relative(tracingRoot, setupNodeStubPath)] =\n        require.resolve('next/dist/build/adapter/setup-node-env.external')\n\n      if (hasInstrumentationHook) {\n        const assets = await handleTraceFiles(\n          path.join(distDir, 'server', 'instrumentation.js.nft.json')\n        )\n        const fileOutputPath = path.relative(\n          tracingRoot,\n          path.join(distDir, 'server', 'instrumentation.js')\n        )\n        sharedNodeAssets[fileOutputPath] = path.join(\n          distDir,\n          'server',\n          'instrumentation.js'\n        )\n        Object.assign(sharedNodeAssets, assets)\n      }\n\n      async function handleTraceFiles(\n        traceFilePath: string\n      ): Promise<Record<string, string>> {\n        const assets: Record<string, string> = Object.assign(\n          {},\n          sharedNodeAssets\n        )\n        const traceData = JSON.parse(\n          await fs.readFile(traceFilePath, 'utf8')\n        ) as {\n          files: string[]\n        }\n        const traceFileDir = path.dirname(traceFilePath)\n\n        for (const relativeFile of traceData.files) {\n          const tracedFilePath = path.join(traceFileDir, relativeFile)\n          const fileOutputPath = path.relative(tracingRoot, tracedFilePath)\n          assets[fileOutputPath] = tracedFilePath\n        }\n        return assets\n      }\n\n      async function handleEdgeFunction(\n        page: EdgeFunctionDefinition,\n        isMiddleware: boolean = false\n      ) {\n        let type: AdapterOutputType = AdapterOutputType.PAGES\n        const isAppPrefix = page.name.startsWith('app/')\n        const isAppPage = isAppPrefix && page.name.endsWith('/page')\n        const isAppRoute = isAppPrefix && page.name.endsWith('/route')\n        let currentOutputs: Array<\n          | AdapterOutput['PAGES']\n          | AdapterOutput['PAGES_API']\n          | AdapterOutput['APP_PAGE']\n          | AdapterOutput['APP_ROUTE']\n        > = outputs.pages\n\n        if (isMiddleware) {\n          type = AdapterOutputType.MIDDLEWARE\n        } else if (isAppPage) {\n          currentOutputs = outputs.appPages\n          type = AdapterOutputType.APP_PAGE\n        } else if (isAppRoute) {\n          currentOutputs = outputs.appRoutes\n          type = AdapterOutputType.APP_ROUTE\n        } else if (page.page.startsWith('/api')) {\n          currentOutputs = outputs.pagesApi\n          type = AdapterOutputType.PAGES_API\n        }\n\n        const route = page.page.replace(/^(app|pages)\\//, '')\n\n        const output: Omit<AdapterOutput[typeof type], 'type'> & {\n          type: any\n        } = {\n          type,\n          id: page.name,\n          runtime: 'edge',\n          sourcePage: route,\n          pathname: isAppPrefix ? normalizeAppPath(route) : route,\n          filePath: path.join(\n            distDir,\n            page.files.find(\n              (item) =>\n                item.startsWith('server/app') || item.startsWith('server/pages')\n            ) ||\n              // TODO: turbopack build doesn't name the main entry chunk\n              // identifiably so we don't know which to mark here but\n              // technically edge needs all chunks to load always so\n              // should this field even be provided?\n              page.files[0] ||\n              ''\n          ),\n          assets: {},\n          wasmAssets: {},\n          config: {\n            env: page.env,\n          },\n        }\n\n        function handleFile(file: string) {\n          const originalPath = path.join(distDir, file)\n          const fileOutputPath = path.relative(\n            config.distDir,\n            path.join(path.relative(tracingRoot, distDir), file)\n          )\n          if (!output.assets) {\n            output.assets = {}\n          }\n          output.assets[fileOutputPath] = originalPath\n        }\n        for (const file of page.files) {\n          handleFile(file)\n        }\n        for (const item of [...(page.assets || [])]) {\n          if (!output.assets) {\n            output.assets = {}\n          }\n          output.assets[item.name] = path.join(distDir, item.filePath)\n        }\n        for (const item of page.wasm || []) {\n          if (!output.wasmAssets) {\n            output.wasmAssets = {}\n          }\n          output.wasmAssets[item.name] = path.join(distDir, item.filePath)\n        }\n\n        if (type === AdapterOutputType.MIDDLEWARE) {\n          ;(output as AdapterOutput['MIDDLEWARE']).config.matchers =\n            page.matchers.map((item) => {\n              return {\n                source: item.originalSource,\n                sourceRegex: item.regexp,\n                has: item.has,\n                missing: [\n                  ...(item.missing || []),\n                  // always skip middleware for on-demand revalidate\n                  {\n                    type: 'header',\n                    key: 'x-prerender-revalidate',\n                    value: prerenderManifest.preview.previewModeId,\n                  },\n                ],\n              }\n            })\n          output.pathname = '/_middleware'\n          output.id = page.name\n          outputs.middleware = output\n        } else {\n          currentOutputs.push(output)\n        }\n\n        // need to add matching .rsc output\n        if (isAppPage) {\n          const rscPathname = normalizePagePath(output.pathname) + '.rsc'\n          outputs.appPages.push({\n            ...output,\n            pathname: rscPathname,\n            id: page.name + '.rsc',\n          })\n        } else if (serverPropsPages.has(route === '/index' ? '/' : route)) {\n          const nextDataPath = path.posix.join(\n            '/_next/data/',\n            buildId,\n            normalizePagePath(output.pathname) + '.json'\n          )\n          outputs.appPages.push({\n            ...output,\n            pathname: nextDataPath,\n            id: page.name,\n          })\n        }\n      }\n\n      const edgeFunctionHandlers: Promise<any>[] = []\n\n      for (const middleware of Object.values(middlewareManifest.middleware)) {\n        if (isMiddlewareFilename(middleware.name)) {\n          edgeFunctionHandlers.push(handleEdgeFunction(middleware, true))\n        }\n      }\n\n      for (const page of Object.values(middlewareManifest.functions)) {\n        edgeFunctionHandlers.push(handleEdgeFunction(page))\n      }\n      const pagesDistDir = path.join(distDir, 'server', 'pages')\n      const pageOutputMap: Record<\n        string,\n        AdapterOutput['PAGES'] | AdapterOutput['PAGES_API']\n      > = {}\n\n      const rscFallbackPath = path.join(distDir, 'server', 'rsc-fallback.json')\n\n      if (appPageKeys && appPageKeys.length > 0 && pageKeys.length > 0) {\n        await fs.writeFile(rscFallbackPath, '{}')\n      }\n\n      for (const page of pageKeys) {\n        if (page === '/_app' || page === '/_document') {\n          continue\n        }\n\n        if (middlewareManifest.functions.hasOwnProperty(page)) {\n          continue\n        }\n\n        const route = normalizePagePath(page)\n        const pageFile = path.join(pagesDistDir, `${route}.js`)\n\n        // if it's an auto static optimized page it's just\n        // a static file\n        if (staticPages.has(page)) {\n          if (config.i18n) {\n            for (const locale of config.i18n.locales || []) {\n              const localePage =\n                page === '/' ? `/${locale}` : addPathPrefix(page, `/${locale}`)\n\n              const localeOutput = {\n                id: localePage,\n                pathname: localePage,\n                type: AdapterOutputType.STATIC_FILE,\n                filePath: path.join(\n                  pagesDistDir,\n                  `${normalizePagePath(localePage)}.html`\n                ),\n              } satisfies AdapterOutput['STATIC_FILE']\n\n              outputs.staticFiles.push(localeOutput)\n\n              if (appPageKeys && appPageKeys.length > 0) {\n                outputs.staticFiles.push({\n                  id: `${localePage}.rsc`,\n                  pathname: `${localePage}.rsc`,\n                  type: AdapterOutputType.STATIC_FILE,\n                  filePath: rscFallbackPath,\n                })\n              }\n            }\n          } else {\n            const staticOutput = {\n              id: page,\n              pathname: route,\n              type: AdapterOutputType.STATIC_FILE,\n              filePath: pageFile.replace(/\\.js$/, '.html'),\n            } satisfies AdapterOutput['STATIC_FILE']\n\n            outputs.staticFiles.push(staticOutput)\n\n            if (appPageKeys && appPageKeys.length > 0) {\n              outputs.staticFiles.push({\n                id: `${page}.rsc`,\n                pathname: `${route}.rsc`,\n                type: AdapterOutputType.STATIC_FILE,\n                filePath: rscFallbackPath,\n              })\n            }\n          }\n          // if was a static file output don't create page output as well\n          continue\n        }\n\n        const pageTraceFile = `${pageFile}.nft.json`\n        const assets = await handleTraceFiles(pageTraceFile).catch((err) => {\n          if (err.code !== 'ENOENT' || (page !== '/404' && page !== '/500')) {\n            Log.warn(`Failed to locate traced assets for ${pageFile}`, err)\n          }\n          return {} as Record<string, string>\n        })\n        const functionConfig = functionsConfigManifest.functions[route] || {}\n        let sourcePage = route.replace(/^\\//, '')\n\n        sourcePage = sourcePage === 'api' ? 'api/index' : sourcePage\n\n        const output: AdapterOutput['PAGES'] | AdapterOutput['PAGES_API'] = {\n          id: route,\n          type: page.startsWith('/api')\n            ? AdapterOutputType.PAGES_API\n            : AdapterOutputType.PAGES,\n          filePath: pageTraceFile.replace(/\\.nft\\.json$/, ''),\n          pathname: route,\n          sourcePage,\n          assets,\n          runtime: 'nodejs',\n          config: {\n            maxDuration: functionConfig.maxDuration,\n            preferredRegion: functionConfig.regions,\n          },\n        }\n        pageOutputMap[page] = output\n\n        if (output.type === AdapterOutputType.PAGES) {\n          outputs.pages.push(output)\n\n          // if page is get server side props we need to create\n          // the _next/data output as well\n          if (serverPropsPages.has(page)) {\n            const dataPathname = path.posix.join(\n              '/_next/data',\n              buildId,\n              normalizePagePath(page) + '.json'\n            )\n            outputs.pages.push({\n              ...output,\n              pathname: dataPathname,\n              id: dataPathname,\n            })\n\n            if (appPageKeys && appPageKeys.length > 0) {\n              const rscPage = `${page === '/' ? '/index' : page}.rsc`\n              outputs.staticFiles.push({\n                id: rscPage,\n                pathname: rscPage,\n                type: AdapterOutputType.STATIC_FILE,\n                filePath: rscFallbackPath,\n              })\n            }\n          }\n\n          for (const locale of config.i18n?.locales || []) {\n            const localePage =\n              page === '/' ? `/${locale}` : addPathPrefix(page, `/${locale}`)\n\n            outputs.pages.push({\n              ...output,\n              id: localePage,\n              pathname: localePage,\n            })\n\n            if (serverPropsPages.has(page)) {\n              const dataPathname = path.posix.join(\n                '/_next/data',\n                buildId,\n                localePage + '.json'\n              )\n              outputs.pages.push({\n                ...output,\n                pathname: dataPathname,\n                id: dataPathname,\n              })\n              if (appPageKeys && appPageKeys.length > 0) {\n                outputs.staticFiles.push({\n                  id: `${localePage}.rsc`,\n                  pathname: `${localePage}.rsc`,\n                  type: AdapterOutputType.STATIC_FILE,\n                  filePath: rscFallbackPath,\n                })\n              }\n            }\n          }\n        } else {\n          outputs.pagesApi.push(output)\n        }\n      }\n\n      if (hasNodeMiddleware) {\n        const middlewareFile = path.join(distDir, 'server', 'middleware.js')\n        const middlewareTrace = `${middlewareFile}.nft.json`\n        const assets = await handleTraceFiles(middlewareTrace)\n        const functionConfig =\n          functionsConfigManifest.functions['/_middleware'] || {}\n\n        outputs.middleware = {\n          pathname: '/_middleware',\n          id: '/_middleware',\n          sourcePage: 'middleware',\n          assets,\n          type: AdapterOutputType.MIDDLEWARE,\n          runtime: 'nodejs',\n          filePath: middlewareFile,\n          config: {\n            matchers:\n              functionConfig.matchers?.map((item) => {\n                return {\n                  source: item.originalSource,\n                  sourceRegex: item.regexp,\n                  has: item.has,\n                  missing: [\n                    ...(item.missing || []),\n                    // always skip middleware for on-demand revalidate\n                    {\n                      type: 'header',\n                      key: 'x-prerender-revalidate',\n                      value: prerenderManifest.preview.previewModeId,\n                    },\n                  ],\n                }\n              }) || [],\n          },\n        } satisfies AdapterOutput['MIDDLEWARE']\n      }\n      const appOutputMap: Record<\n        string,\n        AdapterOutput['APP_PAGE'] | AdapterOutput['APP_ROUTE']\n      > = {}\n      const appDistDir = path.join(distDir, 'server', 'app')\n\n      if (appPageKeys) {\n        for (const page of appPageKeys) {\n          if (middlewareManifest.functions.hasOwnProperty(page)) {\n            continue\n          }\n          const normalizedPage = normalizeAppPath(page)\n          const pageFile = path.join(appDistDir, `${page}.js`)\n          const pageTraceFile = `${pageFile}.nft.json`\n          const assets = await handleTraceFiles(pageTraceFile).catch((err) => {\n            Log.warn(`Failed to copy traced files for ${pageFile}`, err)\n            return {} as Record<string, string>\n          })\n\n          // If this is a parallel route we just need to merge\n          // the assets as they share the same pathname\n          const existingOutput = appOutputMap[normalizedPage]\n          if (existingOutput) {\n            Object.assign(existingOutput.assets, assets)\n            existingOutput.assets[path.relative(tracingRoot, pageFile)] =\n              pageFile\n\n            continue\n          }\n\n          const functionConfig =\n            functionsConfigManifest.functions[normalizedPage] || {}\n\n          const output: AdapterOutput['APP_PAGE'] | AdapterOutput['APP_ROUTE'] =\n            {\n              pathname: normalizedPage,\n              id: normalizedPage,\n              sourcePage: page,\n              assets,\n              type: page.endsWith('/route')\n                ? AdapterOutputType.APP_ROUTE\n                : AdapterOutputType.APP_PAGE,\n              runtime: 'nodejs',\n              filePath: pageFile,\n              config: {\n                maxDuration: functionConfig.maxDuration,\n                preferredRegion: functionConfig.regions,\n              },\n            }\n          appOutputMap[normalizedPage] = output\n\n          if (output.type === AdapterOutputType.APP_PAGE) {\n            outputs.appPages.push({\n              ...output,\n              pathname: normalizePagePath(output.pathname) + '.rsc',\n              id: normalizePagePath(output.pathname) + '.rsc',\n            })\n            outputs.appPages.push(output)\n          } else {\n            outputs.appRoutes.push(output)\n            outputs.appRoutes.push({\n              ...output,\n              pathname: normalizePagePath(output.pathname) + '.rsc',\n              id: normalizePagePath(output.pathname) + '.rsc',\n            })\n          }\n        }\n      }\n\n      const getParentOutput = (\n        srcRoute: string,\n        childRoute: string,\n        allowMissing?: boolean\n      ) => {\n        const normalizedSrcRoute = normalizeLocalePath(\n          srcRoute,\n          config.i18n?.locales || []\n        ).pathname\n        const parentOutput =\n          pageOutputMap[normalizedSrcRoute] || appOutputMap[normalizedSrcRoute]\n\n        if (!parentOutput && !allowMissing) {\n          console.error({\n            appOutputs: Object.keys(appOutputMap),\n            pageOutputs: Object.keys(pageOutputMap),\n          })\n          throw new Error(\n            `Invariant: failed to find source route ${srcRoute} for prerender ${childRoute}`\n          )\n        }\n        return parentOutput\n      }\n\n      const {\n        prefetchSegmentDirSuffix,\n        prefetchSegmentSuffix,\n        varyHeader,\n        didPostponeHeader,\n        contentTypeHeader: rscContentTypeHeader,\n      } = routesManifest.rsc\n\n      const handleAppMeta = async (\n        route: string,\n        initialOutput: AdapterOutput['PRERENDER'],\n        meta: AppRouteMeta,\n        ctx: {\n          htmlAllowQuery?: string[]\n          dataAllowQuery?: string[]\n        }\n      ) => {\n        if (meta.postponed && initialOutput.fallback) {\n          initialOutput.fallback.postponedState = meta.postponed\n        }\n\n        if (meta?.segmentPaths) {\n          const normalizedRoute = normalizePagePath(route)\n          const segmentsDir = path.join(\n            appDistDir,\n            `${normalizedRoute}${prefetchSegmentDirSuffix}`\n          )\n\n          // If client param parsing is enabled, we follow the same logic as\n          // the HTML allowQuery as it's already going to vary based on if\n          // there's a static shell generated or if there's fallback root\n          // params. If there are fallback root params, and we can serve a\n          // fallback, then we should follow the same logic for the segment\n          // prerenders.\n          //\n          // If client param parsing is not enabled, we have to use the\n          // allowQuery because the segment payloads will contain dynamic\n          // segment values.\n          const segmentAllowQuery = routesManifest.rsc.clientParamParsing\n            ? ctx.htmlAllowQuery\n            : ctx.dataAllowQuery\n\n          for (const segmentPath of meta.segmentPaths) {\n            const outputSegmentPath =\n              path.join(\n                normalizedRoute + prefetchSegmentDirSuffix,\n                segmentPath\n              ) + prefetchSegmentSuffix\n\n            // Only use the fallback value when the allowQuery is defined and\n            // either: (1) it is empty, meaning segments do not vary by params,\n            // or (2) client param parsing is enabled, meaning the segment\n            // payloads are safe to reuse across params.\n            const shouldAttachSegmentFallback =\n              segmentAllowQuery &&\n              (segmentAllowQuery.length === 0 ||\n                routesManifest.rsc.clientParamParsing)\n\n            const fallbackPathname = shouldAttachSegmentFallback\n              ? path.join(segmentsDir, segmentPath + prefetchSegmentSuffix)\n              : undefined\n\n            outputs.prerenders.push({\n              id: outputSegmentPath,\n              pathname: outputSegmentPath,\n              type: AdapterOutputType.PRERENDER,\n              parentOutputId: initialOutput.parentOutputId,\n              groupId: initialOutput.groupId,\n\n              config: {\n                ...initialOutput.config,\n                bypassFor: undefined,\n              },\n\n              fallback: {\n                filePath: fallbackPathname,\n                postponedState: undefined,\n                initialExpiration: initialOutput.fallback?.initialExpiration,\n                initialRevalidate: initialOutput.fallback?.initialRevalidate,\n\n                initialHeaders: {\n                  ...meta.headers,\n                  ...initialOutput.fallback?.initialHeaders,\n                  vary: varyHeader,\n                  'content-type': rscContentTypeHeader,\n                  [didPostponeHeader]: '2',\n                },\n              },\n            } satisfies AdapterOutput['PRERENDER'])\n          }\n        }\n      }\n\n      let prerenderGroupId = 1\n\n      type AppRouteMeta = {\n        segmentPaths?: string[]\n        postponed?: string\n        headers?: Record<string, string>\n        status?: number\n      }\n\n      const getAppRouteMeta = async (\n        route: string,\n        isAppPage: boolean\n      ): Promise<AppRouteMeta> => {\n        const basename = route.endsWith('/') ? `${route}index` : route\n        const meta: AppRouteMeta = isAppPage\n          ? JSON.parse(\n              await fs\n                .readFile(path.join(appDistDir, `${basename}.meta`), 'utf8')\n                .catch(() => '{}')\n            )\n          : {}\n\n        if (meta.headers) {\n          // normalize these for consistency\n          for (const key of Object.keys(meta.headers)) {\n            const keyLower = key.toLowerCase()\n            let value = meta.headers[key]\n\n            // normalize values to strings (e.g. set-cookie can be an array)\n            if (Array.isArray(value)) {\n              value = value.join(', ')\n            } else if (typeof value !== 'string') {\n              value = String(value)\n            }\n\n            if (keyLower !== key) {\n              delete meta.headers[key]\n            }\n            meta.headers[keyLower] = value\n          }\n        }\n\n        return meta\n      }\n\n      const filePathCache = new Map<string, Promise<boolean>>()\n      const cachedFilePathCheck = async (filePath: string) => {\n        if (filePathCache.has(filePath)) {\n          return filePathCache.get(filePath)\n        }\n        const newCheck = fs\n          .access(filePath)\n          .then(() => true)\n          .catch(() => false)\n        filePathCache.set(filePath, newCheck)\n\n        return newCheck\n      }\n\n      for (const route in prerenderManifest.routes) {\n        const {\n          initialExpireSeconds: initialExpiration,\n          initialRevalidateSeconds: initialRevalidate,\n          initialHeaders,\n          initialStatus,\n          dataRoute,\n          prefetchDataRoute,\n          renderingMode,\n          allowHeader,\n          experimentalBypassFor,\n        } = prerenderManifest.routes[route]\n\n        const srcRoute = prerenderManifest.routes[route].srcRoute || route\n        const srcRouteInfo = prerenderManifest.dynamicRoutes[srcRoute]\n\n        const isAppPage =\n          Boolean(appOutputMap[srcRoute]) || srcRoute === '/_not-found'\n\n        // if we already have 404.html favor that instead of\n        // _not-found prerender\n        if (srcRoute === '/_not-found' && hasStatic404) {\n          continue\n        }\n\n        const isNotFoundTrue = prerenderManifest.notFoundRoutes.includes(route)\n\n        let allowQuery: string[] | undefined\n        const routeKeys = routesManifest.dynamicRoutes.find(\n          (item) => item.page === srcRoute\n        )?.routeKeys\n\n        if (!isDynamicRoute(route)) {\n          // for non-dynamic routes we use an empty array since\n          // no query values bust the cache for non-dynamic prerenders\n          // prerendered paths also do not pass allowQuery as they match\n          // during handle: 'filesystem' so should not cache differently\n          // by query values\n          allowQuery = []\n        } else if (routeKeys) {\n          // if we have routeKeys in the routes-manifest we use those\n          // for allowQuery for dynamic routes\n          allowQuery = Object.values(routeKeys)\n        }\n\n        let filePath = path.join(\n          isAppPage ? appDistDir : pagesDistDir,\n          `${normalizePagePath(route)}.${isAppPage && !dataRoute ? 'body' : 'html'}`\n        )\n\n        // we use the static 404 for notFound: true if available\n        // if not we do a blocking invoke on first request\n        if (isNotFoundTrue && hasStatic404) {\n          const locale =\n            config.i18n &&\n            normalizeLocalePath(route, config.i18n?.locales).detectedLocale\n\n          for (const currentFilePath of [\n            path.join(pagesDistDir, locale || '', '404.html'),\n            path.join(pagesDistDir, '404.html'),\n          ]) {\n            if (await cachedFilePathCheck(currentFilePath)) {\n              filePath = currentFilePath\n              break\n            }\n          }\n        }\n\n        const meta = await getAppRouteMeta(route, isAppPage)\n\n        let htmlAllowQuery = allowQuery\n        let dataAllowQuery = allowQuery\n        const dataInitialHeaders: Record<string, string> = {}\n\n        // We additionally vary based on if there's a postponed prerender\n        // because if there isn't, then that means that we generated an\n        // empty shell, and producing an empty RSC shell would be a waste.\n        // If there is a postponed prerender, then the RSC shell would be\n        // non-empty, and it would be valuable to also generate an empty\n        // RSC shell.\n        if (meta.postponed) {\n          htmlAllowQuery = []\n\n          if (routesManifest.rsc.dynamicRSCPrerender) {\n            // If client param parsing is enabled, we follow the same logic as the\n            // HTML allowQuery as it's already going to vary based on if there's a\n            // static shell generated or if there's fallback root params. If there\n            // are fallback root params, and we can serve a fallback, then we\n            // should follow the same logic for the dynamic RSC routes.\n            //\n            // If client param parsing is not enabled, we have to use the\n            // allowQuery because the RSC payloads will contain dynamic segment\n            // values.\n            if (routesManifest.rsc.clientParamParsing) {\n              dataAllowQuery = htmlAllowQuery\n            }\n          }\n        }\n\n        if (renderingMode === RenderingMode.PARTIALLY_STATIC) {\n          // Dynamic RSC requests cannot be cached, so we explicity set it\n          // here to ensure that the response is not cached by the browser.\n          dataInitialHeaders['cache-control'] =\n            'private, no-store, no-cache, max-age=0, must-revalidate'\n        }\n\n        const initialOutput: AdapterOutput['PRERENDER'] = {\n          id: route,\n          type: AdapterOutputType.PRERENDER,\n          pathname: route,\n          parentOutputId:\n            srcRoute === '/_not-found'\n              ? srcRoute\n              : getParentOutput(srcRoute, route).id,\n          groupId: prerenderGroupId,\n\n          pprChain:\n            isAppPage && renderingMode === RenderingMode.PARTIALLY_STATIC\n              ? {\n                  headers: {\n                    [NEXT_RESUME_HEADER]: '1',\n                  },\n                }\n              : undefined,\n\n          parentFallbackMode: srcRouteInfo?.fallback,\n\n          fallback:\n            !isNotFoundTrue || (isNotFoundTrue && hasStatic404)\n              ? {\n                  filePath,\n                  postponedState: undefined,\n                  initialStatus:\n                    initialStatus ??\n                    meta.status ??\n                    (isNotFoundTrue ? 404 : undefined),\n                  initialHeaders: {\n                    ...initialHeaders,\n                    vary: varyHeader,\n                    'content-type': HTML_CONTENT_TYPE_HEADER,\n                    ...meta.headers,\n                  },\n                  initialExpiration,\n                  initialRevalidate:\n                    typeof initialRevalidate === 'undefined'\n                      ? 1\n                      : initialRevalidate,\n                }\n              : undefined,\n          config: {\n            allowQuery,\n            allowHeader,\n            renderingMode,\n            bypassFor:\n              isAppPage && srcRoute !== '/_not-found'\n                ? experimentalBypassFor\n                : undefined,\n            bypassToken: prerenderManifest.preview.previewModeId,\n          },\n        }\n        outputs.prerenders.push(initialOutput)\n\n        if (!isAppPage && appPageKeys && appPageKeys.length > 0) {\n          const rscPage = `${route === '/' ? '/index' : route}.rsc`\n          outputs.staticFiles.push({\n            id: rscPage,\n            pathname: rscPage,\n            type: AdapterOutputType.STATIC_FILE,\n            filePath: rscFallbackPath,\n          })\n        }\n\n        if (dataRoute) {\n          let dataFilePath: string | undefined = path.join(\n            pagesDistDir,\n            `${normalizePagePath(route)}.json`\n          )\n          let postponed = meta.postponed\n\n          const dataRouteToUse =\n            renderingMode === RenderingMode.PARTIALLY_STATIC &&\n            prefetchDataRoute\n              ? prefetchDataRoute\n              : dataRoute\n\n          if (isAppPage) {\n            // When experimental PPR is enabled, we expect that the data\n            // that should be served as a part of the prerender should\n            // be from the prefetch data route. If this isn't enabled\n            // for ppr, the only way to get the data is from the data\n            // route.\n            dataFilePath = path.join(\n              appDistDir,\n              (dataRouteToUse ?? dataRoute)?.replace(/^\\//, '')\n            )\n          }\n\n          if (\n            renderingMode === RenderingMode.PARTIALLY_STATIC &&\n            !(await cachedFilePathCheck(dataFilePath))\n          ) {\n            outputs.prerenders.push({\n              ...initialOutput,\n              id: dataRoute,\n              pathname: dataRoute,\n              fallback: {\n                ...initialOutput.fallback,\n                postponedState: postponed,\n                initialStatus: undefined,\n                initialHeaders: {\n                  ...initialOutput.fallback?.initialHeaders,\n                  ...dataInitialHeaders,\n                  'content-type': isAppPage\n                    ? rscContentTypeHeader\n                    : JSON_CONTENT_TYPE_HEADER,\n                },\n                filePath: undefined,\n              },\n            })\n          } else {\n            outputs.prerenders.push({\n              ...initialOutput,\n              id: dataRoute,\n              pathname: dataRoute,\n              fallback: isNotFoundTrue\n                ? undefined\n                : {\n                    ...initialOutput.fallback,\n                    initialStatus: undefined,\n                    initialHeaders: {\n                      ...initialOutput.fallback?.initialHeaders,\n                      ...dataInitialHeaders,\n                      'content-type': isAppPage\n                        ? rscContentTypeHeader\n                        : JSON_CONTENT_TYPE_HEADER,\n                    },\n                    postponedState: undefined,\n                    filePath: dataFilePath,\n                  },\n            })\n          }\n        }\n\n        if (isAppPage) {\n          await handleAppMeta(route, initialOutput, meta, {\n            htmlAllowQuery,\n            dataAllowQuery,\n          })\n        }\n        prerenderGroupId += 1\n      }\n\n      for (const dynamicRoute in prerenderManifest.dynamicRoutes) {\n        const {\n          fallback,\n          fallbackExpire,\n          fallbackRevalidate,\n          fallbackHeaders,\n          fallbackStatus,\n          fallbackSourceRoute,\n          fallbackRootParams,\n          allowHeader,\n          dataRoute,\n          renderingMode,\n          experimentalBypassFor,\n        } = prerenderManifest.dynamicRoutes[dynamicRoute]\n\n        const srcRoute = fallbackSourceRoute || dynamicRoute\n        const parentOutput = getParentOutput(srcRoute, dynamicRoute)\n        const isAppPage = Boolean(appOutputMap[srcRoute])\n\n        const meta = await getAppRouteMeta(dynamicRoute, isAppPage)\n        const allowQuery = Object.values(\n          routesManifest.dynamicRoutes.find(\n            (item) => item.page === dynamicRoute\n          )?.routeKeys || {}\n        )\n        let htmlAllowQuery = allowQuery\n\n        // We only want to vary on the shell contents if there is a fallback\n        // present and able to be served.\n        if (typeof fallback === 'string') {\n          if (fallbackRootParams && fallbackRootParams.length > 0) {\n            htmlAllowQuery = fallbackRootParams as string[]\n          } // We additionally vary based on if there's a postponed prerender\n          // because if there isn't, then that means that we generated an\n          // empty shell, and producing an empty RSC shell would be a waste.\n          // If there is a postponed prerender, then the RSC shell would be\n          // non-empty, and it would be valuable to also generate an empty\n          // RSC shell.\n          else if (meta.postponed) {\n            htmlAllowQuery = []\n          }\n        }\n\n        const initialOutput: AdapterOutput['PRERENDER'] = {\n          id: dynamicRoute,\n          type: AdapterOutputType.PRERENDER,\n          pathname: dynamicRoute,\n          parentOutputId: parentOutput.id,\n          groupId: prerenderGroupId,\n\n          pprChain:\n            isAppPage && renderingMode === RenderingMode.PARTIALLY_STATIC\n              ? {\n                  headers: {\n                    [NEXT_RESUME_HEADER]: '1',\n                  },\n                }\n              : undefined,\n\n          fallback:\n            typeof fallback === 'string'\n              ? {\n                  filePath: path.join(\n                    isAppPage ? appDistDir : pagesDistDir,\n                    // app router dynamic route fallbacks don't have the\n                    // extension so ensure it's added here\n                    fallback.endsWith('.html') ? fallback : `${fallback}.html`\n                  ),\n                  postponedState: undefined,\n                  initialStatus: fallbackStatus ?? meta.status,\n                  initialHeaders: {\n                    ...fallbackHeaders,\n                    ...(appPageKeys?.length ? { vary: varyHeader } : {}),\n                    'content-type': HTML_CONTENT_TYPE_HEADER,\n                    ...meta.headers,\n                  },\n                  initialExpiration: fallbackExpire,\n                  initialRevalidate: fallbackRevalidate ?? 1,\n                }\n              : undefined,\n          config: {\n            allowQuery: htmlAllowQuery,\n            allowHeader,\n            renderingMode,\n            bypassFor: isAppPage ? experimentalBypassFor : undefined,\n            bypassToken: prerenderManifest.preview.previewModeId,\n          },\n        }\n\n        if (!config.i18n || isAppPage) {\n          outputs.prerenders.push(initialOutput)\n\n          if (\n            !isAppPage &&\n            fallback !== false &&\n            appPageKeys &&\n            appPageKeys.length > 0\n          ) {\n            const rscPage = `${srcRoute === '/' ? '/index' : srcRoute}.rsc`\n            outputs.staticFiles.push({\n              id: rscPage,\n              pathname: rscPage,\n              type: AdapterOutputType.STATIC_FILE,\n              filePath: rscFallbackPath,\n            })\n          }\n\n          let dataAllowQuery = allowQuery\n          const dataInitialHeaders: Record<string, string> = {}\n\n          if (meta.postponed && routesManifest.rsc.dynamicRSCPrerender) {\n            // If client param parsing is enabled, we follow the same logic as the\n            // HTML allowQuery as it's already going to vary based on if there's a\n            // static shell generated or if there's fallback root params. If there\n            // are fallback root params, and we can serve a fallback, then we\n            // should follow the same logic for the dynamic RSC routes.\n            //\n            // If client param parsing is not enabled, we have to use the\n            // allowQuery because the RSC payloads will contain dynamic segment\n            // values.\n            if (routesManifest.rsc.clientParamParsing) {\n              dataAllowQuery = htmlAllowQuery\n            }\n          }\n\n          if (renderingMode === RenderingMode.PARTIALLY_STATIC) {\n            // Dynamic RSC requests cannot be cached, so we explicity set it\n            // here to ensure that the response is not cached by the browser.\n            dataInitialHeaders['cache-control'] =\n              'private, no-store, no-cache, max-age=0, must-revalidate'\n          }\n\n          if (isAppPage) {\n            await handleAppMeta(dynamicRoute, initialOutput, meta, {\n              htmlAllowQuery,\n              dataAllowQuery,\n            })\n          }\n\n          if (renderingMode === RenderingMode.PARTIALLY_STATIC) {\n            outputs.prerenders.push({\n              ...initialOutput,\n              id: `${dynamicRoute}.rsc`,\n              pathname: `${dynamicRoute}.rsc`,\n              fallback: {\n                ...initialOutput.fallback,\n                filePath: undefined,\n                postponedState: meta.postponed,\n                initialStatus: undefined,\n                initialHeaders: {\n                  ...initialOutput.fallback?.initialHeaders,\n                  ...dataInitialHeaders,\n                  'content-type': isAppPage\n                    ? rscContentTypeHeader\n                    : JSON_CONTENT_TYPE_HEADER,\n                },\n              },\n\n              config: {\n                ...initialOutput.config,\n                allowQuery: dataAllowQuery,\n              },\n            })\n          } else if (dataRoute) {\n            outputs.prerenders.push({\n              ...initialOutput,\n              id: dataRoute,\n              pathname: dataRoute,\n              fallback: undefined,\n            })\n          }\n          prerenderGroupId += 1\n        } else {\n          for (const locale of config.i18n.locales) {\n            const currentOutput: AdapterOutput['PRERENDER'] = {\n              ...initialOutput,\n              pathname: path.posix.join(`/${locale}`, initialOutput.pathname),\n              id: path.posix.join(`/${locale}`, initialOutput.id),\n              fallback:\n                typeof fallback === 'string'\n                  ? {\n                      ...initialOutput.fallback,\n                      initialStatus: undefined,\n                      postponedState: undefined,\n                      filePath: path.join(\n                        pagesDistDir,\n                        locale,\n                        // app router dynamic route fallbacks don't have the\n                        // extension so ensure it's added here\n                        fallback.endsWith('.html')\n                          ? fallback\n                          : `${fallback}.html`\n                      ),\n                    }\n                  : undefined,\n              groupId: prerenderGroupId,\n            }\n            outputs.prerenders.push(currentOutput)\n\n            if (\n              !isAppPage &&\n              fallback !== false &&\n              appPageKeys &&\n              appPageKeys.length > 0\n            ) {\n              const rscPage = `${path.posix.join(`/${locale}`, initialOutput.pathname)}.rsc`\n              outputs.staticFiles.push({\n                id: rscPage,\n                pathname: rscPage,\n                type: AdapterOutputType.STATIC_FILE,\n                filePath: rscFallbackPath,\n              })\n            }\n\n            if (dataRoute) {\n              const dataPathname = path.posix.join(\n                `/_next/data`,\n                buildId,\n                locale,\n                dynamicRoute + '.json'\n              )\n              outputs.prerenders.push({\n                ...initialOutput,\n                id: dataPathname,\n                pathname: dataPathname,\n                // data route doesn't have skeleton fallback\n                fallback: undefined,\n                groupId: prerenderGroupId,\n              })\n            }\n            prerenderGroupId += 1\n          }\n        }\n      }\n\n      // ensure 404\n      const staticErrorDocs = [\n        ...(hasStatic404 ? ['/404'] : []),\n        ...(hasStatic500 ? ['/500'] : []),\n      ]\n\n      for (const errorDoc of staticErrorDocs) {\n        const errorDocPath = path.posix.join(\n          '/',\n          config.i18n?.defaultLocale || '',\n          errorDoc\n        )\n\n        if (!prerenderManifest.routes[errorDocPath]) {\n          for (const currentDocPath of [\n            errorDocPath,\n            ...(config.i18n?.locales?.map((locale) =>\n              path.posix.join('/', locale, errorDoc)\n            ) || []),\n          ]) {\n            const currentFilePath = path.join(\n              pagesDistDir,\n              `${currentDocPath}.html`\n            )\n            if (await cachedFilePathCheck(currentFilePath)) {\n              outputs.staticFiles.push({\n                pathname: currentDocPath,\n                id: currentDocPath,\n                type: AdapterOutputType.STATIC_FILE,\n                filePath: currentFilePath,\n              })\n            }\n          }\n        }\n      }\n    }\n\n    normalizePathnames(config, outputs)\n\n    const dynamicRoutes: DynamicRouteItem[] = []\n    const dynamicDataRoutes: DynamicRouteItem[] = []\n    const dynamicSegmentRoutes: DynamicRouteItem[] = []\n\n    const getDestinationQuery = (routeKeys: Record<string, string>) => {\n      const items = Object.entries(routeKeys ?? {})\n      if (items.length === 0) return ''\n\n      return '?' + items.map(([key, value]) => `${value}=$${key}`).join('&')\n    }\n\n    const fallbackFalseHasCondition: RouteHas[] = [\n      {\n        type: 'cookie',\n        key: '__prerender_bypass',\n        value: prerenderManifest.preview.previewModeId,\n      },\n      {\n        type: 'cookie',\n        key: '__next_preview_data',\n      },\n    ]\n\n    for (const route of routesManifest.dynamicRoutes) {\n      const shouldLocalize = config.i18n\n\n      const routeRegex = getNamedRouteRegex(route.page, {\n        prefixRouteKeys: true,\n      })\n\n      const isFallbackFalse =\n        prerenderManifest.dynamicRoutes[route.page]?.fallback === false\n\n      const { hasFallbackRootParams } = route\n\n      const sourceRegex = routeRegex.namedRegex.replace(\n        '^',\n        `^${config.basePath && config.basePath !== '/' ? path.posix.join('/', config.basePath || '') : ''}[/]?${shouldLocalize ? '(?<nextLocale>[^/]{1,})' : ''}`\n      )\n      const destination =\n        path.posix.join(\n          '/',\n          config.basePath,\n          shouldLocalize ? '/$nextLocale' : '',\n          route.page\n        ) + getDestinationQuery(route.routeKeys)\n\n      if (appPageKeys && appPageKeys.length > 0) {\n        // If we have fallback root params (implying we've already\n        // emitted a rewrite for the /_tree request), or if the route\n        // has PPR enabled and client param parsing is enabled, then\n        // we don't need to include any other suffixes.\n        const shouldSkipSuffixes = hasFallbackRootParams\n\n        dynamicRoutes.push({\n          source: route.page + '.rsc',\n          sourceRegex: sourceRegex.replace(\n            new RegExp(escapeStringRegexp('(?:/)?$')),\n            // Now than the upstream issues has been resolved, we can safely\n            // add the suffix back, this resolves a bug related to segment\n            // rewrites not capturing the correct suffix values when\n            // enabled.\n            shouldSkipSuffixes\n              ? '(?<rscSuffix>\\\\.rsc|\\\\.segments/.+\\\\.segment\\\\.rsc)(?:/)?$'\n              : '(?<rscSuffix>\\\\.rsc|\\\\.segments/.+\\\\.segment\\\\.rsc)(?:/)?$'\n          ),\n          destination: destination?.replace(/($|\\?)/, '$rscSuffix$1'),\n          has:\n            isFallbackFalse && !pageKeys.includes(route.page)\n              ? fallbackFalseHasCondition\n              : undefined,\n          missing: undefined,\n        })\n      }\n\n      // needs basePath and locale handling if pages router\n      dynamicRoutes.push({\n        source: route.page,\n        sourceRegex,\n        destination,\n        has: isFallbackFalse ? fallbackFalseHasCondition : undefined,\n        missing: undefined,\n      })\n\n      for (const segmentRoute of route.prefetchSegmentDataRoutes || []) {\n        dynamicSegmentRoutes.push({\n          source: route.page,\n          sourceRegex: segmentRoute.source.replace(\n            '^',\n            `^${config.basePath && config.basePath !== '/' ? path.posix.join('/', config.basePath || '') : ''}[/]?`\n          ),\n          destination: path.posix.join(\n            '/',\n            config.basePath,\n            segmentRoute.destination +\n              getDestinationQuery(segmentRoute.routeKeys)\n          ),\n          has: undefined,\n          missing: undefined,\n        })\n      }\n    }\n\n    const needsMiddlewareResolveRoutes =\n      outputs.middleware && outputs.pages.length > 0\n\n    const dataRoutePages = new Set([\n      ...routesManifest.dataRoutes.map((item) => item.page),\n    ])\n    const sortedDataPages = sortSortableRoutes([\n      ...(needsMiddlewareResolveRoutes\n        ? [...staticPages].map((page) => ({ sourcePage: page, page }))\n        : []),\n      ...routesManifest.dataRoutes.map((item) => ({\n        sourcePage: item.page,\n        page: item.page,\n      })),\n    ])\n\n    for (const { page } of sortedDataPages) {\n      if (needsMiddlewareResolveRoutes || isDynamicRoute(page)) {\n        const shouldLocalize = config.i18n\n        const isFallbackFalse =\n          prerenderManifest.dynamicRoutes[page]?.fallback === false\n\n        const routeRegex = getNamedRouteRegex(page + '.json', {\n          prefixRouteKeys: true,\n          includeSuffix: true,\n        })\n        const isDataRoute = dataRoutePages.has(page)\n\n        const destination = path.posix.join(\n          '/',\n          config.basePath,\n          ...(isDataRoute ? [`_next/data`, buildId] : ''),\n          ...(page === '/'\n            ? [shouldLocalize ? '$nextLocale.json' : 'index.json']\n            : [\n                shouldLocalize ? '$nextLocale' : '',\n                page +\n                  (isDataRoute ? '.json' : '') +\n                  getDestinationQuery(routeRegex.routeKeys || {}),\n              ])\n        )\n\n        dynamicDataRoutes.push({\n          source: page,\n          sourceRegex:\n            shouldLocalize && page === '/'\n              ? '^' +\n                path.posix.join(\n                  '/',\n                  config.basePath,\n                  '_next/data',\n                  escapeStringRegexp(buildId),\n                  '(?<nextLocale>[^/]{1,}).json'\n                )\n              : routeRegex.namedRegex.replace(\n                  '^',\n                  `^${path.posix.join(\n                    '/',\n                    config.basePath,\n                    `_next/data`,\n                    escapeStringRegexp(buildId)\n                  )}[/]?${shouldLocalize ? '(?<nextLocale>[^/]{1,})' : ''}`\n                ),\n          destination,\n          has: isFallbackFalse ? fallbackFalseHasCondition : undefined,\n          missing: undefined,\n        })\n      }\n    }\n\n    const buildRewriteItem = (route: ManifestRewriteRoute): RewriteItem => {\n      const converted = convertRewrites([route], ['nextInternalLocale'])[0]\n      const regex = converted.src || route.regex\n\n      return {\n        source: route.source,\n        sourceRegex: route.internal ? regex : modifyRouteRegex(regex),\n        destination: converted.dest || route.destination,\n        has: route.has,\n        missing: route.missing,\n      } satisfies Route\n    }\n\n    try {\n      Log.info(`Running onBuildComplete from ${adapterMod.name}`)\n\n      const combinedDynamicRoutes = [\n        ...dynamicDataRoutes,\n        ...dynamicSegmentRoutes,\n        ...dynamicRoutes,\n      ] satisfies Route[]\n\n      const rewrites = {\n        beforeFiles: routesManifest.rewrites.beforeFiles.map(buildRewriteItem),\n        afterFiles: routesManifest.rewrites.afterFiles.map(buildRewriteItem),\n        fallback: routesManifest.rewrites.fallback.map(buildRewriteItem),\n      }\n\n      const redirects = routesManifest.redirects.map((route) => {\n        const converted = convertRedirects([route], 307)[0]\n        const regex = converted.src || route.regex\n\n        return {\n          source: route.source,\n          sourceRegex: route.internal ? regex : modifyRouteRegex(regex),\n          headers: 'headers' in converted ? converted.headers || {} : {},\n          status: converted.status || getRedirectStatus(route),\n          has: route.has,\n          missing: route.missing,\n          priority: route.internal || undefined,\n        } satisfies Route\n      })\n\n      const headers = routesManifest.headers.map((route) => {\n        const converted = convertHeaders([route])[0]\n        const regex = converted.src || route.regex\n\n        return {\n          source: route.source,\n          sourceRegex: route.internal ? regex : modifyRouteRegex(regex),\n          headers: 'headers' in converted ? converted.headers || {} : {},\n          has: route.has,\n          missing: route.missing,\n          priority: route.internal || undefined,\n        } satisfies Route\n      })\n\n      await adapterMod.onBuildComplete({\n        routing: {\n          beforeMiddleware: [...headers, ...redirects],\n          beforeFiles: rewrites.beforeFiles,\n          afterFiles: rewrites.afterFiles,\n          dynamicRoutes: combinedDynamicRoutes,\n          onMatch: [\n            {\n              // This ensures we only match known emitted-by-Next.js files and not\n              // user-emitted files which may be missing a hash in their filename.\n              sourceRegex: `${path.posix.join(config.basePath || '/', '_next/static', `/(?:[^/]+/pages|pages|chunks|runtime|css|image|media|${escapeStringRegexp(buildId)})/.+`)}`,\n              // Next.js assets contain a hash or entropy in their filenames, so they\n              // are guaranteed to be unique and cacheable indefinitely.\n              headers: {\n                'cache-control': `public,max-age=${CACHE_ONE_YEAR},immutable`,\n              },\n            },\n          ],\n          fallback: rewrites.fallback,\n          shouldNormalizeNextData: !!needsMiddlewareResolveRoutes,\n          rsc: generateRoutesManifest({\n            appType,\n            pageKeys: {\n              pages: pageKeys as string[],\n              app: appPageKeys as string[],\n            },\n            config,\n            redirects: [],\n            headers: [],\n            rewrites,\n            restrictedRedirectPaths: [],\n            isAppPPREnabled: config.cacheComponents,\n          }).routesManifest.rsc,\n        },\n        outputs,\n\n        config,\n        distDir,\n        buildId,\n        nextVersion,\n        projectDir: dir,\n        repoRoot: tracingRoot,\n      })\n    } catch (err) {\n      Log.error(`Failed to run onBuildComplete from ${adapterMod.name}`)\n      throw err\n    }\n  }\n}\n"],"names":["path","fs","pathToFileURL","Log","isMiddlewareFilename","RenderingMode","interopDefault","recursiveReadDir","isDynamicRoute","normalizeAppPath","AdapterOutputType","normalizePagePath","convertRedirects","convertRewrites","convertHeaders","CACHE_ONE_YEAR","HTML_CONTENT_TYPE_HEADER","JSON_CONTENT_TYPE_HEADER","NEXT_RESUME_HEADER","normalizeLocalePath","addPathPrefix","getRedirectStatus","modifyRouteRegex","getNamedRouteRegex","escapeStringRegexp","sortSortableRoutes","generateRoutesManifest","normalizePathnames","config","outputs","basePath","output","pages","pagesApi","appPages","appRoutes","prerenders","staticFiles","pathname","replace","handleBuildComplete","dir","appType","buildId","configOutDir","distDir","pageKeys","tracingRoot","adapterPath","appPageKeys","staticPages","nextVersion","hasStatic404","hasStatic500","routesManifest","serverPropsPages","hasNodeMiddleware","prerenderManifest","middlewareManifest","requiredServerFiles","hasInstrumentationHook","functionsConfigManifest","adapterMod","require","resolve","href","onBuildComplete","exportFiles","file","endsWith","startsWith","push","id","filePath","join","type","STATIC_FILE","posix","sharedNodeAssets","fileOutputPath","relative","setupNodeStubPath","dirname","assets","handleTraceFiles","Object","assign","traceFilePath","traceData","JSON","parse","readFile","traceFileDir","relativeFile","files","tracedFilePath","handleEdgeFunction","page","isMiddleware","PAGES","isAppPrefix","name","isAppPage","isAppRoute","currentOutputs","MIDDLEWARE","APP_PAGE","APP_ROUTE","PAGES_API","route","runtime","sourcePage","find","item","wasmAssets","env","handleFile","originalPath","wasm","matchers","map","source","originalSource","sourceRegex","regexp","has","missing","key","value","preview","previewModeId","middleware","rscPathname","nextDataPath","edgeFunctionHandlers","values","functions","pagesDistDir","pageOutputMap","rscFallbackPath","length","writeFile","hasOwnProperty","pageFile","i18n","locale","locales","localePage","localeOutput","staticOutput","pageTraceFile","catch","err","code","warn","functionConfig","maxDuration","preferredRegion","regions","dataPathname","rscPage","middlewareFile","middlewareTrace","appOutputMap","appDistDir","normalizedPage","existingOutput","getParentOutput","srcRoute","childRoute","allowMissing","normalizedSrcRoute","parentOutput","console","error","appOutputs","keys","pageOutputs","Error","prefetchSegmentDirSuffix","prefetchSegmentSuffix","varyHeader","didPostponeHeader","contentTypeHeader","rscContentTypeHeader","rsc","handleAppMeta","initialOutput","meta","ctx","postponed","fallback","postponedState","segmentPaths","normalizedRoute","segmentsDir","segmentAllowQuery","clientParamParsing","htmlAllowQuery","dataAllowQuery","segmentPath","outputSegmentPath","shouldAttachSegmentFallback","fallbackPathname","undefined","PRERENDER","parentOutputId","groupId","bypassFor","initialExpiration","initialRevalidate","initialHeaders","headers","vary","prerenderGroupId","getAppRouteMeta","basename","keyLower","toLowerCase","Array","isArray","String","filePathCache","Map","cachedFilePathCheck","get","newCheck","access","then","set","routes","initialExpireSeconds","initialRevalidateSeconds","initialStatus","dataRoute","prefetchDataRoute","renderingMode","allowHeader","experimentalBypassFor","srcRouteInfo","dynamicRoutes","Boolean","isNotFoundTrue","notFoundRoutes","includes","allowQuery","routeKeys","detectedLocale","currentFilePath","dataInitialHeaders","dynamicRSCPrerender","PARTIALLY_STATIC","pprChain","parentFallbackMode","status","bypassToken","dataFilePath","dataRouteToUse","dynamicRoute","fallbackExpire","fallbackRevalidate","fallbackHeaders","fallbackStatus","fallbackSourceRoute","fallbackRootParams","currentOutput","staticErrorDocs","errorDoc","errorDocPath","defaultLocale","currentDocPath","dynamicDataRoutes","dynamicSegmentRoutes","getDestinationQuery","items","entries","fallbackFalseHasCondition","shouldLocalize","routeRegex","prefixRouteKeys","isFallbackFalse","hasFallbackRootParams","namedRegex","destination","shouldSkipSuffixes","RegExp","segmentRoute","prefetchSegmentDataRoutes","needsMiddlewareResolveRoutes","dataRoutePages","Set","dataRoutes","sortedDataPages","includeSuffix","isDataRoute","buildRewriteItem","converted","regex","src","internal","dest","info","combinedDynamicRoutes","rewrites","beforeFiles","afterFiles","redirects","priority","routing","beforeMiddleware","onMatch","shouldNormalizeNextData","app","restrictedRedirectPaths","isAppPPREnabled","cacheComponents","projectDir","repoRoot"],"mappings":"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","ignoreList":[0]}