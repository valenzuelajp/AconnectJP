{"version":3,"sources":["../../../src/build/lockfile.ts"],"sourcesContent":["import fs from 'fs'\nimport nodePath from 'path'\nimport { bold, cyan } from '../lib/picocolors'\nimport * as Log from './output/log'\nimport { getBindingsSync } from './swc'\n\nimport type { Binding, Lockfile as NativeLockfile } from './swc/types'\n\nconst RETRY_DELAY_MS = 10\nconst MAX_RETRY_MS = 1000\n\n/**\n * Information about a running dev server, stored inside the lock file itself.\n * This is a common pattern in Unix applications (e.g., storing PID in a lockfile).\n */\nexport interface DevServerInfo {\n  pid: number\n  port: number\n  hostname: string\n  appUrl: string\n  startedAt: number\n}\n\n/**\n * Reads dev server info from a lockfile.\n * Returns undefined if the file doesn't exist or can't be parsed.\n *\n * Uses Node's fs.readFileSync which works on both Unix (with advisory flock)\n * and Windows (with FILE_SHARE_READ flag set by the lock holder).\n */\nexport function readLockfileContent(lockfilePath: string): string | undefined {\n  try {\n    return fs.readFileSync(lockfilePath, 'utf-8')\n  } catch {\n    return undefined\n  }\n}\n\n/**\n * Parses dev server info from lockfile content.\n */\nexport function parseDevServerInfo(content: string): DevServerInfo | undefined {\n  try {\n    return JSON.parse(content) as DevServerInfo\n  } catch {\n    return undefined\n  }\n}\n\n/**\n * A cross-platform on-disk best-effort advisory exclusive lockfile\n * implementation.\n *\n * On Windows, this opens a file in write mode with the `FILE_SHARE_WRITE` flag\n * unset, so it still allows reading the lockfile. This avoids breaking tools\n * that read the contents of `.next`.\n *\n * On POSIX platforms, this uses `flock()` via `std::fs::File::try_lock`:\n * https://doc.rust-lang.org/std/fs/struct.File.html#method.try_lock\n *\n * On WASM, a dummy implementation is used which always \"succeeds\" in acquiring\n * the lock.\n *\n * This provides a more idiomatic wrapper around the lockfile APIs exposed on\n * the native bindings object.\n *\n * If this lock is not explicitly closed with `unlock`, we will:\n * - If `unlockOnExit` is set (the default), it will make a best-effort attempt\n *   to unlock the lockfile using `process.on('exit', ...)`. This is preferrable\n *   on Windows where it may take some time after process exit for the operating\n *   system to clean up locks that are not explicitly released by the process.\n * - If we fail to ever release the lockfile, the operating system will clean up\n *   the lock and file descriptor upon process exit.\n */\nexport class Lockfile {\n  /**\n   * The underlying `Lockfile` object returned by the native bindings.\n   *\n   * This can be `undefined` on wasm, where we don't acquire a real lockfile.\n   */\n  private bindings: Binding\n  private nativeLockfile: NativeLockfile | undefined\n  private listener: NodeJS.ExitListener | undefined\n\n  private constructor(\n    bindings: Binding,\n    nativeLockfile: NativeLockfile | undefined\n  ) {\n    this.bindings = bindings\n    this.nativeLockfile = nativeLockfile\n  }\n\n  /**\n   * Attempts to create or acquire an exclusive lockfile on disk. Lockfiles are\n   * best-effort, depending on the platform.\n   *\n   * - If we fail to acquire the lock, we return `undefined`.\n   * - If we're on wasm, this always returns a dummy `Lockfile` object.\n   *\n   * @param path - Path to the lock file\n   * @param unlockOnExit - Whether to unlock the file on process exit\n   * @param content - Optional content to write to the lockfile (e.g., JSON with server info)\n   */\n  static tryAcquire(\n    path: string,\n    unlockOnExit: boolean = true,\n    content?: string\n  ): Lockfile | undefined {\n    const bindings = getBindingsSync()\n    if (bindings.isWasm) {\n      Log.info(\n        `Skipping creating a lockfile at ${cyan(path)} because we're using WASM bindings`\n      )\n      return new Lockfile(bindings, undefined)\n    } else {\n      let nativeLockfile\n      try {\n        nativeLockfile = bindings.lockfileTryAcquireSync(path, content)\n      } catch (e) {\n        // this happens if there's an IO error (e.g. `ENOENT`), which is\n        // different than if we just didn't acquire the lock\n        throw new Error(\n          'An IO error occurred while attempting to create and acquire the lockfile',\n          { cause: e }\n        )\n      }\n      if (nativeLockfile != null) {\n        const jsLockfile = new Lockfile(bindings, nativeLockfile)\n        if (unlockOnExit) {\n          const exitListener = () => {\n            // Best-Effort: If we don't do this, the operating system will\n            // release the lock for us. This gives an opportunity to delete the\n            // unlocked lockfile (which is not otherwise deleted on POSIX).\n            //\n            // This must be synchronous because `process.on('exit', ...)` is\n            // synchronous.\n            jsLockfile.unlockSync()\n          }\n          process.on('exit', exitListener)\n          jsLockfile.listener = exitListener\n        }\n        return jsLockfile\n      } else {\n        return undefined\n      }\n    }\n  }\n\n  /**\n   * Attempts to create or acquire a lockfile using `Lockfile.tryAcquire`. If\n   * that returns `undefined`, indicating that another process or caller has the\n   * lockfile, then this will output an error message and exit the process with\n   * a non-zero exit code.\n   *\n   * This will retry a small number of times. This can be useful when running\n   * processes in a loop, e.g. if cleanup isn't fully synchronous due to child\n   * parent/processes.\n   *\n   * @param path - Path to the lock file\n   * @param processName - Name of the process for error messages (e.g., 'next dev')\n   * @param unlockOnExit - Whether to unlock the file on process exit\n   * @param content - Optional content to write to the lockfile (e.g., JSON with server info)\n   * @param projectDir - Optional project directory for enhanced error messages\n   * @param relativeDistDir - Optional relative dist directory path (e.g., '.next/dev')\n   */\n  static async acquireWithRetriesOrExit(\n    path: string,\n    processName: string,\n    unlockOnExit: boolean = true,\n    content?: string,\n    projectDir?: string,\n    relativeDistDir?: string\n  ): Promise<Lockfile> {\n    const startMs = Date.now()\n    let lockfile\n    while (Date.now() - startMs < MAX_RETRY_MS) {\n      lockfile = Lockfile.tryAcquire(path, unlockOnExit, content)\n      if (lockfile !== undefined) break\n      await new Promise((resolve) => setTimeout(resolve, RETRY_DELAY_MS))\n    }\n    if (lockfile === undefined) {\n      const isDev = processName === 'next dev'\n\n      if (isDev) {\n        // For dev server, try to read server info from the lockfile itself\n        const lockfileContent = readLockfileContent(path)\n        const serverInfo = lockfileContent\n          ? parseDevServerInfo(lockfileContent)\n          : undefined\n\n        if (serverInfo) {\n          Log.error(`Another ${cyan(processName)} server is already running.`)\n          console.error()\n          console.error(`- Local:        ${cyan(serverInfo.appUrl)}`)\n          console.error(`- PID:          ${serverInfo.pid}`)\n          if (projectDir) {\n            console.error(`- Dir:          ${projectDir}`)\n          }\n          if (relativeDistDir) {\n            console.error(\n              `- Log:          ${nodePath.join(relativeDistDir, 'logs', 'next-development.log')}`\n            )\n          }\n          console.error()\n          // Use platform-appropriate kill command\n          const killCommand =\n            process.platform === 'win32'\n              ? `taskkill /PID ${serverInfo.pid} /F`\n              : `kill ${serverInfo.pid}`\n          console.error(`Run ${cyan(killCommand)} to stop it.`)\n        } else {\n          // Fallback when we can't read server info from the lockfile\n          Log.error(\n            `Another ${cyan(processName)} server is already running in this directory.`\n          )\n          console.error(`Stop the other server before starting a new one.`)\n        }\n      } else {\n        // For build, show that a build is in progress\n        Log.error(`Another ${cyan(processName)} process is already running.`)\n        console.error()\n        console.error(`  This could be:`)\n        console.error(`  - A ${cyan('next build')} still in progress`)\n        console.error(`  - A previous build that didn't exit cleanly`)\n        console.error()\n        Log.info(`${bold('Suggestion:')} Wait for the build to complete.`)\n      }\n      process.exit(1)\n    }\n    return lockfile\n  }\n\n  /**\n   * Releases the lockfile and closes the file descriptor.\n   *\n   * If this is not called, the lock will be released by the operating system\n   * when the file handle is closed during process exit.\n   */\n  async unlock(): Promise<void> {\n    const { nativeLockfile, listener } = this\n    if (nativeLockfile !== undefined) {\n      await this.bindings.lockfileUnlock(nativeLockfile)\n    }\n    if (listener !== undefined) {\n      process.off('exit', listener)\n    }\n  }\n\n  /**\n   * A blocking version of `unlock`.\n   */\n  unlockSync(): void {\n    const { nativeLockfile, listener } = this\n    if (nativeLockfile !== undefined) {\n      this.bindings.lockfileUnlockSync(nativeLockfile)\n    }\n    if (listener !== undefined) {\n      process.off('exit', listener)\n    }\n  }\n}\n"],"names":["fs","nodePath","bold","cyan","Log","getBindingsSync","RETRY_DELAY_MS","MAX_RETRY_MS","readLockfileContent","lockfilePath","readFileSync","undefined","parseDevServerInfo","content","JSON","parse","Lockfile","bindings","nativeLockfile","tryAcquire","path","unlockOnExit","isWasm","info","lockfileTryAcquireSync","e","Error","cause","jsLockfile","exitListener","unlockSync","process","on","listener","acquireWithRetriesOrExit","processName","projectDir","relativeDistDir","startMs","Date","now","lockfile","Promise","resolve","setTimeout","isDev","lockfileContent","serverInfo","error","console","appUrl","pid","join","killCommand","platform","exit","unlock","lockfileUnlock","off","lockfileUnlockSync"],"mappings":"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","ignoreList":[0]}