{"version":3,"sources":["../../../src/client/route-loader.ts"],"sourcesContent":["import type { ComponentType } from 'react'\nimport type { ProxyMatcher } from '../build/analysis/get-page-static-info'\nimport type { RequiredServerFilesManifest } from '../build'\nimport getAssetPathFromRoute from '../shared/lib/router/utils/get-asset-path-from-route'\nimport { __unsafeCreateTrustedScriptURL } from './trusted-types'\nimport { requestIdleCallback } from './request-idle-callback'\nimport { getDeploymentIdQueryOrEmptyString } from '../shared/lib/deployment-id'\nimport { encodeURIPath } from '../shared/lib/encode-uri-path'\nimport { resolvePromiseWithTimeout } from './lib/promise'\n\ndeclare global {\n  interface Window {\n    __BUILD_MANIFEST?: Record<string, string[]>\n    __BUILD_MANIFEST_CB?: Function\n    __SERVER_FILES_MANIFEST?: RequiredServerFilesManifest\n    __MIDDLEWARE_MATCHERS?: ProxyMatcher[]\n    __MIDDLEWARE_MATCHERS_CB?: Function\n    __REACT_LOADABLE_MANIFEST?: any\n    __DYNAMIC_CSS_MANIFEST?: any\n    __RSC_MANIFEST?: any\n    __RSC_SERVER_MANIFEST?: any\n    __NEXT_FONT_MANIFEST?: any\n    __SUBRESOURCE_INTEGRITY_MANIFEST?: string\n    __INTERCEPTION_ROUTE_REWRITE_MANIFEST?: string\n  }\n}\n\ninterface LoadedEntrypointSuccess {\n  component: ComponentType\n  exports: any\n}\ninterface LoadedEntrypointFailure {\n  error: unknown\n}\ntype RouteEntrypoint = LoadedEntrypointSuccess | LoadedEntrypointFailure\n\ninterface RouteStyleSheet {\n  href: string\n  content: string\n}\n\ninterface LoadedRouteSuccess extends LoadedEntrypointSuccess {\n  styles: RouteStyleSheet[]\n}\ninterface LoadedRouteFailure {\n  error: unknown\n}\ntype RouteLoaderEntry = LoadedRouteSuccess | LoadedRouteFailure\n\ninterface Future<V> {\n  resolve: (entrypoint: V) => void\n  future: Promise<V>\n}\nfunction withFuture<T extends object>(\n  key: string,\n  map: Map<string, Future<T> | T>,\n  generator?: () => Promise<T>\n): Promise<T> {\n  let entry = map.get(key)\n  if (entry) {\n    if ('future' in entry) {\n      return entry.future\n    }\n    return Promise.resolve(entry)\n  }\n  let resolver: (entrypoint: T) => void\n  const prom: Promise<T> = new Promise<T>((resolve) => {\n    resolver = resolve\n  })\n  map.set(key, { resolve: resolver!, future: prom })\n  return generator\n    ? generator()\n        .then((value) => {\n          resolver(value)\n          return value\n        })\n        .catch((err) => {\n          map.delete(key)\n          throw err\n        })\n    : prom\n}\n\nexport interface RouteLoader {\n  whenEntrypoint(route: string): Promise<RouteEntrypoint>\n  onEntrypoint(route: string, execute: () => unknown): void\n  loadRoute(route: string, prefetch?: boolean): Promise<RouteLoaderEntry>\n  prefetch(route: string): Promise<void>\n}\n\nconst ASSET_LOAD_ERROR = Symbol('ASSET_LOAD_ERROR')\n// TODO: unexport\nexport function markAssetError(err: Error): Error {\n  return Object.defineProperty(err, ASSET_LOAD_ERROR, {})\n}\n\nexport function isAssetError(err?: Error): boolean | undefined {\n  return err && ASSET_LOAD_ERROR in err\n}\n\nfunction hasPrefetch(link?: HTMLLinkElement): boolean {\n  try {\n    link = document.createElement('link')\n    return (\n      // detect IE11 since it supports prefetch but isn't detected\n      // with relList.support\n      (!!window.MSInputMethodContext && !!(document as any).documentMode) ||\n      link.relList.supports('prefetch')\n    )\n  } catch {\n    return false\n  }\n}\n\nconst canPrefetch: boolean = hasPrefetch()\n\nconst getAssetQueryString = () => {\n  return getDeploymentIdQueryOrEmptyString()\n}\n\nfunction prefetchViaDom(\n  href: string,\n  as: string,\n  link?: HTMLLinkElement\n): Promise<any> {\n  return new Promise<void>((resolve, reject) => {\n    const selector = `\n      link[rel=\"prefetch\"][href^=\"${href}\"],\n      link[rel=\"preload\"][href^=\"${href}\"],\n      script[src^=\"${href}\"]`\n    if (document.querySelector(selector)) {\n      return resolve()\n    }\n\n    link = document.createElement('link')\n\n    // The order of property assignment here is intentional:\n    if (as) link!.as = as\n    link!.rel = `prefetch`\n    link!.crossOrigin = process.env.__NEXT_CROSS_ORIGIN!\n    link!.onload = resolve as any\n    link!.onerror = () =>\n      reject(markAssetError(new Error(`Failed to prefetch: ${href}`)))\n\n    // `href` should always be last:\n    link!.href = href\n\n    document.head.appendChild(link)\n  })\n}\n\nfunction appendScript(\n  src: TrustedScriptURL | string,\n  script?: HTMLScriptElement\n): Promise<unknown> {\n  return new Promise((resolve, reject) => {\n    script = document.createElement('script')\n\n    // The order of property assignment here is intentional.\n    // 1. Setup success/failure hooks in case the browser synchronously\n    //    executes when `src` is set.\n    script.onload = resolve\n    script.onerror = () =>\n      reject(markAssetError(new Error(`Failed to load script: ${src}`)))\n\n    // 2. Configure the cross-origin attribute before setting `src` in case the\n    //    browser begins to fetch.\n    script.crossOrigin = process.env.__NEXT_CROSS_ORIGIN!\n\n    // 3. Finally, set the source and inject into the DOM in case the child\n    //    must be appended for fetching to start.\n    script.src = src as string\n    document.body.appendChild(script)\n  })\n}\n\n// We wait for pages to be built in dev before we start the route transition\n// timeout to prevent an un-necessary hard navigation in development.\nlet devBuildPromise: Promise<void> | undefined\n\n// TODO: stop exporting or cache the failure\n// It'd be best to stop exporting this. It's an implementation detail. We're\n// only exporting it for backwards compatibility with the `page-loader`.\n// Only cache this response as a last resort if we cannot eliminate all other\n// code branches that use the Build Manifest Callback and push them through\n// the Route Loader interface.\nexport function getClientBuildManifest() {\n  if (self.__BUILD_MANIFEST) {\n    return Promise.resolve(self.__BUILD_MANIFEST)\n  }\n\n  const onBuildManifest = new Promise<Record<string, string[]>>((resolve) => {\n    // Mandatory because this is not concurrent safe:\n    const cb = self.__BUILD_MANIFEST_CB\n    self.__BUILD_MANIFEST_CB = () => {\n      resolve(self.__BUILD_MANIFEST!)\n      cb && cb()\n    }\n  })\n\n  return resolvePromiseWithTimeout(\n    onBuildManifest,\n    markAssetError(new Error('Failed to load client build manifest')),\n    devBuildPromise\n  )\n}\n\ninterface RouteFiles {\n  scripts: (TrustedScriptURL | string)[]\n  css: string[]\n}\nfunction getFilesForRoute(\n  assetPrefix: string,\n  route: string\n): Promise<RouteFiles> {\n  if (process.env.NODE_ENV === 'development') {\n    const scriptUrl =\n      assetPrefix +\n      '/_next/static/chunks/pages' +\n      encodeURIPath(getAssetPathFromRoute(route, '.js')) +\n      getAssetQueryString()\n    return Promise.resolve({\n      scripts: [__unsafeCreateTrustedScriptURL(scriptUrl)],\n      // Styles are handled by `style-loader` in development:\n      css: [],\n    })\n  }\n  return getClientBuildManifest().then((manifest) => {\n    if (!(route in manifest)) {\n      throw markAssetError(new Error(`Failed to lookup route: ${route}`))\n    }\n    const allFiles = manifest[route].map(\n      (entry) => assetPrefix + '/_next/' + encodeURIPath(entry)\n    )\n    return {\n      scripts: allFiles\n        .filter((v) => v.endsWith('.js'))\n        .map((v) => __unsafeCreateTrustedScriptURL(v) + getAssetQueryString()),\n      css: allFiles\n        .filter((v) => v.endsWith('.css'))\n        .map((v) => v + getAssetQueryString()),\n    }\n  })\n}\n\nexport function createRouteLoader(assetPrefix: string): RouteLoader {\n  const entrypoints: Map<string, Future<RouteEntrypoint> | RouteEntrypoint> =\n    new Map()\n  const loadedScripts: Map<string, Promise<unknown>> = new Map()\n  const styleSheets: Map<string, Promise<RouteStyleSheet>> = new Map()\n  const routes: Map<string, Future<RouteLoaderEntry> | RouteLoaderEntry> =\n    new Map()\n\n  function maybeExecuteScript(\n    src: TrustedScriptURL | string\n  ): Promise<unknown> {\n    // With HMR we might need to \"reload\" scripts when they are\n    // disposed and readded. Executing scripts twice has no functional\n    // differences\n    if (process.env.NODE_ENV !== 'development') {\n      let prom: Promise<unknown> | undefined = loadedScripts.get(src.toString())\n      if (prom) {\n        return prom\n      }\n\n      // Skip executing script if it's already in the DOM:\n      if (document.querySelector(`script[src^=\"${src}\"]`)) {\n        return Promise.resolve()\n      }\n\n      loadedScripts.set(src.toString(), (prom = appendScript(src)))\n      return prom\n    } else {\n      return appendScript(src)\n    }\n  }\n\n  function fetchStyleSheet(href: string): Promise<RouteStyleSheet> {\n    let prom: Promise<RouteStyleSheet> | undefined = styleSheets.get(href)\n    if (prom) {\n      return prom\n    }\n\n    styleSheets.set(\n      href,\n      (prom = fetch(href, { credentials: 'same-origin' })\n        .then((res) => {\n          if (!res.ok) {\n            throw new Error(`Failed to load stylesheet: ${href}`)\n          }\n          return res.text().then((text) => ({ href: href, content: text }))\n        })\n        .catch((err) => {\n          throw markAssetError(err)\n        }))\n    )\n    return prom\n  }\n\n  return {\n    whenEntrypoint(route: string) {\n      return withFuture(route, entrypoints)\n    },\n    onEntrypoint(route: string, execute: undefined | (() => unknown)) {\n      ;(execute\n        ? Promise.resolve()\n            .then(() => execute())\n            .then(\n              (exports: any) => ({\n                component: (exports && exports.default) || exports,\n                exports: exports,\n              }),\n              (err) => ({ error: err })\n            )\n        : Promise.resolve(undefined)\n      ).then((input: RouteEntrypoint | undefined) => {\n        const old = entrypoints.get(route)\n        if (old && 'resolve' in old) {\n          if (input) {\n            entrypoints.set(route, input)\n            old.resolve(input)\n          }\n        } else {\n          if (input) {\n            entrypoints.set(route, input)\n          } else {\n            entrypoints.delete(route)\n          }\n          // when this entrypoint has been resolved before\n          // the route is outdated and we want to invalidate\n          // this cache entry\n          routes.delete(route)\n        }\n      })\n    },\n    loadRoute(route: string, prefetch?: boolean) {\n      return withFuture<RouteLoaderEntry>(route, routes, () => {\n        let devBuildPromiseResolve: () => void\n\n        if (process.env.NODE_ENV === 'development') {\n          devBuildPromise = new Promise<void>((resolve) => {\n            devBuildPromiseResolve = resolve\n          })\n        }\n\n        return resolvePromiseWithTimeout(\n          getFilesForRoute(assetPrefix, route)\n            .then(({ scripts, css }) => {\n              return Promise.all([\n                entrypoints.has(route)\n                  ? []\n                  : Promise.all(scripts.map(maybeExecuteScript)),\n                Promise.all(css.map(fetchStyleSheet)),\n              ] as const)\n            })\n            .then((res) => {\n              return this.whenEntrypoint(route).then((entrypoint) => ({\n                entrypoint,\n                styles: res[1],\n              }))\n            }),\n          markAssetError(new Error(`Route did not complete loading: ${route}`)),\n          devBuildPromise\n        )\n          .then(({ entrypoint, styles }) => {\n            const res: RouteLoaderEntry = Object.assign<\n              { styles: RouteStyleSheet[] },\n              RouteEntrypoint\n            >({ styles: styles! }, entrypoint)\n            return 'error' in entrypoint ? entrypoint : res\n          })\n          .catch((err) => {\n            if (prefetch) {\n              // we don't want to cache errors during prefetch\n              throw err\n            }\n            return { error: err }\n          })\n          .finally(() => devBuildPromiseResolve?.())\n      })\n    },\n    prefetch(route: string): Promise<void> {\n      // https://github.com/GoogleChromeLabs/quicklink/blob/453a661fa1fa940e2d2e044452398e38c67a98fb/src/index.mjs#L115-L118\n      // License: Apache 2.0\n      let cn\n      if ((cn = (navigator as any).connection)) {\n        // Don't prefetch if using 2G or if Save-Data is enabled.\n        if (cn.saveData || /2g/.test(cn.effectiveType)) return Promise.resolve()\n      }\n      return getFilesForRoute(assetPrefix, route)\n        .then((output) =>\n          Promise.all(\n            canPrefetch\n              ? output.scripts.map((script) =>\n                  prefetchViaDom(script.toString(), 'script')\n                )\n              : []\n          )\n        )\n        .then(() => {\n          requestIdleCallback(() => this.loadRoute(route, true).catch(() => {}))\n        })\n        .catch(\n          // swallow prefetch errors\n          () => {}\n        )\n    },\n  }\n}\n"],"names":["getAssetPathFromRoute","__unsafeCreateTrustedScriptURL","requestIdleCallback","getDeploymentIdQueryOrEmptyString","encodeURIPath","resolvePromiseWithTimeout","withFuture","key","map","generator","entry","get","future","Promise","resolve","resolver","prom","set","then","value","catch","err","delete","ASSET_LOAD_ERROR","Symbol","markAssetError","Object","defineProperty","isAssetError","hasPrefetch","link","document","createElement","window","MSInputMethodContext","documentMode","relList","supports","canPrefetch","getAssetQueryString","prefetchViaDom","href","as","reject","selector","querySelector","rel","crossOrigin","process","env","__NEXT_CROSS_ORIGIN","onload","onerror","Error","head","appendChild","appendScript","src","script","body","devBuildPromise","getClientBuildManifest","self","__BUILD_MANIFEST","onBuildManifest","cb","__BUILD_MANIFEST_CB","getFilesForRoute","assetPrefix","route","NODE_ENV","scriptUrl","scripts","css","manifest","allFiles","filter","v","endsWith","createRouteLoader","entrypoints","Map","loadedScripts","styleSheets","routes","maybeExecuteScript","toString","fetchStyleSheet","fetch","credentials","res","ok","text","content","whenEntrypoint","onEntrypoint","execute","exports","component","default","error","undefined","input","old","loadRoute","prefetch","devBuildPromiseResolve","all","has","entrypoint","styles","assign","finally","cn","navigator","connection","saveData","test","effectiveType","output"],"mappings":"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","ignoreList":[0]}