{"version":3,"sources":["../../../../src/client/components/layout-router.tsx"],"sourcesContent":["'use client'\n\nimport type { CacheNode } from '../../shared/lib/app-router-types'\nimport type { LoadingModuleData } from '../../shared/lib/app-router-types'\nimport type {\n  FlightRouterState,\n  FlightSegmentPath,\n  Segment,\n} from '../../shared/lib/app-router-types'\nimport type { ErrorComponent } from './error-boundary'\nimport type { FocusAndScrollRef } from './router-reducer/router-reducer-types'\n\nimport React, {\n  Activity,\n  useContext,\n  use,\n  Suspense,\n  useDeferredValue,\n  type JSX,\n  type ActivityProps,\n} from 'react'\nimport ReactDOM from 'react-dom'\nimport {\n  LayoutRouterContext,\n  GlobalLayoutRouterContext,\n  TemplateContext,\n} from '../../shared/lib/app-router-context.shared-runtime'\nimport { unresolvedThenable } from './unresolved-thenable'\nimport { ErrorBoundary } from './error-boundary'\nimport { matchSegment } from './match-segments'\nimport { disableSmoothScrollDuringRouteTransition } from '../../shared/lib/router/utils/disable-smooth-scroll'\nimport { RedirectBoundary } from './redirect-boundary'\nimport { HTTPAccessFallbackBoundary } from './http-access-fallback/error-boundary'\nimport { createRouterCacheKey } from './router-reducer/create-router-cache-key'\nimport {\n  useRouterBFCache,\n  type RouterBFCacheEntry,\n} from './bfcache-state-manager'\nimport { normalizeAppPath } from '../../shared/lib/router/utils/app-paths'\nimport {\n  NavigationPromisesContext,\n  type NavigationPromises,\n} from '../../shared/lib/hooks-client-context.shared-runtime'\nimport { getParamValueFromCacheKey } from '../route-params'\nimport type { Params } from '../../server/request/params'\nimport { isDeferredRsc } from './router-reducer/ppr-navigations'\n\nconst __DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = (\n  ReactDOM as any\n).__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE\n\n// TODO-APP: Replace with new React API for finding dom nodes without a `ref` when available\n/**\n * Wraps ReactDOM.findDOMNode with additional logic to hide React Strict Mode warning\n */\nfunction findDOMNode(\n  instance: React.ReactInstance | null | undefined\n): Element | Text | null {\n  // Tree-shake for server bundle\n  if (typeof window === 'undefined') return null\n\n  // __DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE.findDOMNode is null during module init.\n  // We need to lazily reference it.\n  const internal_reactDOMfindDOMNode =\n    __DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE.findDOMNode\n  return internal_reactDOMfindDOMNode(instance)\n}\n\nconst rectProperties = [\n  'bottom',\n  'height',\n  'left',\n  'right',\n  'top',\n  'width',\n  'x',\n  'y',\n] as const\n/**\n * Check if a HTMLElement is hidden or fixed/sticky position\n */\nfunction shouldSkipElement(element: HTMLElement) {\n  // we ignore fixed or sticky positioned elements since they'll likely pass the \"in-viewport\" check\n  // and will result in a situation we bail on scroll because of something like a fixed nav,\n  // even though the actual page content is offscreen\n  if (['sticky', 'fixed'].includes(getComputedStyle(element).position)) {\n    return true\n  }\n\n  // Uses `getBoundingClientRect` to check if the element is hidden instead of `offsetParent`\n  // because `offsetParent` doesn't consider document/body\n  const rect = element.getBoundingClientRect()\n  return rectProperties.every((item) => rect[item] === 0)\n}\n\n/**\n * Check if the top corner of the HTMLElement is in the viewport.\n */\nfunction topOfElementInViewport(element: HTMLElement, viewportHeight: number) {\n  const rect = element.getBoundingClientRect()\n  return rect.top >= 0 && rect.top <= viewportHeight\n}\n\n/**\n * Find the DOM node for a hash fragment.\n * If `top` the page has to scroll to the top of the page. This mirrors the browser's behavior.\n * If the hash fragment is an id, the page has to scroll to the element with that id.\n * If the hash fragment is a name, the page has to scroll to the first element with that name.\n */\nfunction getHashFragmentDomNode(hashFragment: string) {\n  // If the hash fragment is `top` the page has to scroll to the top of the page.\n  if (hashFragment === 'top') {\n    return document.body\n  }\n\n  // If the hash fragment is an id, the page has to scroll to the element with that id.\n  return (\n    document.getElementById(hashFragment) ??\n    // If the hash fragment is a name, the page has to scroll to the first element with that name.\n    document.getElementsByName(hashFragment)[0]\n  )\n}\ninterface ScrollAndFocusHandlerProps {\n  focusAndScrollRef: FocusAndScrollRef\n  children: React.ReactNode\n  segmentPath: FlightSegmentPath\n}\nclass InnerScrollAndFocusHandler extends React.Component<ScrollAndFocusHandlerProps> {\n  handlePotentialScroll = () => {\n    // Handle scroll and focus, it's only applied once in the first useEffect that triggers that changed.\n    const { focusAndScrollRef, segmentPath } = this.props\n\n    if (focusAndScrollRef.apply) {\n      // segmentPaths is an array of segment paths that should be scrolled to\n      // if the current segment path is not in the array, the scroll is not applied\n      // unless the array is empty, in which case the scroll is always applied\n      if (\n        focusAndScrollRef.segmentPaths.length !== 0 &&\n        !focusAndScrollRef.segmentPaths.some((scrollRefSegmentPath) =>\n          segmentPath.every((segment, index) =>\n            matchSegment(segment, scrollRefSegmentPath[index])\n          )\n        )\n      ) {\n        return\n      }\n\n      let domNode:\n        | ReturnType<typeof getHashFragmentDomNode>\n        | ReturnType<typeof findDOMNode> = null\n      const hashFragment = focusAndScrollRef.hashFragment\n\n      if (hashFragment) {\n        domNode = getHashFragmentDomNode(hashFragment)\n      }\n\n      // `findDOMNode` is tricky because it returns just the first child if the component is a fragment.\n      // This already caused a bug where the first child was a <link/> in head.\n      if (!domNode) {\n        domNode = findDOMNode(this)\n      }\n\n      // If there is no DOM node this layout-router level is skipped. It'll be handled higher-up in the tree.\n      if (!(domNode instanceof Element)) {\n        return\n      }\n\n      // Verify if the element is a HTMLElement and if we want to consider it for scroll behavior.\n      // If the element is skipped, try to select the next sibling and try again.\n      while (!(domNode instanceof HTMLElement) || shouldSkipElement(domNode)) {\n        if (process.env.NODE_ENV !== 'production') {\n          if (domNode.parentElement?.localName === 'head') {\n            // TODO: We enter this state when metadata was rendered as part of the page or via Next.js.\n            // This is always a bug in Next.js and caused by React hoisting metadata.\n            // We need to replace `findDOMNode` in favor of Fragment Refs (when available) so that we can skip over metadata.\n          }\n        }\n\n        // No siblings found that match the criteria are found, so handle scroll higher up in the tree instead.\n        if (domNode.nextElementSibling === null) {\n          return\n        }\n        domNode = domNode.nextElementSibling\n      }\n\n      // State is mutated to ensure that the focus and scroll is applied only once.\n      focusAndScrollRef.apply = false\n      focusAndScrollRef.hashFragment = null\n      focusAndScrollRef.segmentPaths = []\n\n      disableSmoothScrollDuringRouteTransition(\n        () => {\n          // In case of hash scroll, we only need to scroll the element into view\n          if (hashFragment) {\n            ;(domNode as HTMLElement).scrollIntoView()\n\n            return\n          }\n          // Store the current viewport height because reading `clientHeight` causes a reflow,\n          // and it won't change during this function.\n          const htmlElement = document.documentElement\n          const viewportHeight = htmlElement.clientHeight\n\n          // If the element's top edge is already in the viewport, exit early.\n          if (topOfElementInViewport(domNode as HTMLElement, viewportHeight)) {\n            return\n          }\n\n          // Otherwise, try scrolling go the top of the document to be backward compatible with pages\n          // scrollIntoView() called on `<html/>` element scrolls horizontally on chrome and firefox (that shouldn't happen)\n          // We could use it to scroll horizontally following RTL but that also seems to be broken - it will always scroll left\n          // scrollLeft = 0 also seems to ignore RTL and manually checking for RTL is too much hassle so we will scroll just vertically\n          htmlElement.scrollTop = 0\n\n          // Scroll to domNode if domNode is not in viewport when scrolled to top of document\n          if (!topOfElementInViewport(domNode as HTMLElement, viewportHeight)) {\n            // Scroll into view doesn't scroll horizontally by default when not needed\n            ;(domNode as HTMLElement).scrollIntoView()\n          }\n        },\n        {\n          // We will force layout by querying domNode position\n          dontForceLayout: true,\n          onlyHashChange: focusAndScrollRef.onlyHashChange,\n        }\n      )\n\n      // Mutate after scrolling so that it can be read by `disableSmoothScrollDuringRouteTransition`\n      focusAndScrollRef.onlyHashChange = false\n\n      // Set focus on the element\n      domNode.focus()\n    }\n  }\n\n  componentDidMount() {\n    this.handlePotentialScroll()\n  }\n\n  componentDidUpdate() {\n    // Because this property is overwritten in handlePotentialScroll it's fine to always run it when true as it'll be set to false for subsequent renders.\n    if (this.props.focusAndScrollRef.apply) {\n      this.handlePotentialScroll()\n    }\n  }\n\n  render() {\n    return this.props.children\n  }\n}\n\nfunction ScrollAndFocusHandler({\n  segmentPath,\n  children,\n}: {\n  segmentPath: FlightSegmentPath\n  children: React.ReactNode\n}) {\n  const context = useContext(GlobalLayoutRouterContext)\n  if (!context) {\n    throw new Error('invariant global layout router not mounted')\n  }\n\n  return (\n    <InnerScrollAndFocusHandler\n      segmentPath={segmentPath}\n      focusAndScrollRef={context.focusAndScrollRef}\n    >\n      {children}\n    </InnerScrollAndFocusHandler>\n  )\n}\n\n/**\n * InnerLayoutRouter handles rendering the provided segment based on the cache.\n */\nfunction InnerLayoutRouter({\n  tree,\n  segmentPath,\n  debugNameContext,\n  cacheNode: maybeCacheNode,\n  params,\n  url,\n  isActive,\n}: {\n  tree: FlightRouterState\n  segmentPath: FlightSegmentPath\n  debugNameContext: string\n  cacheNode: CacheNode | null\n  params: Params\n  url: string\n  isActive: boolean\n}) {\n  const context = useContext(GlobalLayoutRouterContext)\n  const parentNavPromises = useContext(NavigationPromisesContext)\n\n  if (!context) {\n    throw new Error('invariant global layout router not mounted')\n  }\n\n  const cacheNode =\n    maybeCacheNode !== null\n      ? maybeCacheNode\n      : // This segment is not in the cache. Suspend indefinitely.\n        //\n        // This should only be reachable for inactive/hidden segments, during\n        // prerendering The active segment should always be consistent with the\n        // CacheNode tree. Regardless, if we don't have a matching CacheNode, we\n        // must suspend rather than render nothing, to prevent showing an\n        // inconsistent route.\n\n        (use(unresolvedThenable) as never)\n\n  // `rsc` represents the renderable node for this segment.\n\n  // If this segment has a `prefetchRsc`, it's the statically prefetched data.\n  // We should use that on initial render instead of `rsc`. Then we'll switch\n  // to `rsc` when the dynamic response streams in.\n  //\n  // If no prefetch data is available, then we go straight to rendering `rsc`.\n  const resolvedPrefetchRsc =\n    cacheNode.prefetchRsc !== null ? cacheNode.prefetchRsc : cacheNode.rsc\n\n  // We use `useDeferredValue` to handle switching between the prefetched and\n  // final values. The second argument is returned on initial render, then it\n  // re-renders with the first argument.\n  const rsc: any = useDeferredValue(cacheNode.rsc, resolvedPrefetchRsc)\n\n  // `rsc` is either a React node or a promise for a React node, except we\n  // special case `null` to represent that this segment's data is missing. If\n  // it's a promise, we need to unwrap it so we can determine whether or not the\n  // data is missing.\n  let resolvedRsc: React.ReactNode\n  if (isDeferredRsc(rsc)) {\n    const unwrappedRsc = use(rsc)\n    if (unwrappedRsc === null) {\n      // If the promise was resolved to `null`, it means the data for this\n      // segment was not returned by the server. Suspend indefinitely. When this\n      // happens, the router is responsible for triggering a new state update to\n      // un-suspend this segment.\n      use(unresolvedThenable) as never\n    }\n    resolvedRsc = unwrappedRsc\n  } else {\n    // This is not a deferred RSC promise. Don't need to unwrap it.\n    if (rsc === null) {\n      use(unresolvedThenable) as never\n    }\n    resolvedRsc = rsc\n  }\n\n  // In dev, we create a NavigationPromisesContext containing the instrumented promises that provide\n  // `useSelectedLayoutSegment` and `useSelectedLayoutSegments`.\n  // Promises are cached outside of render to survive suspense retries.\n  let navigationPromises: NavigationPromises | null = null\n  if (process.env.NODE_ENV !== 'production') {\n    const { createNestedLayoutNavigationPromises } =\n      require('./navigation-devtools') as typeof import('./navigation-devtools')\n\n    navigationPromises = createNestedLayoutNavigationPromises(\n      tree,\n      parentNavPromises\n    )\n  }\n\n  let children = resolvedRsc\n\n  if (navigationPromises) {\n    children = (\n      <NavigationPromisesContext.Provider value={navigationPromises}>\n        {resolvedRsc}\n      </NavigationPromisesContext.Provider>\n    )\n  }\n\n  children = (\n    // The layout router context narrows down tree and childNodes at each level.\n    <LayoutRouterContext.Provider\n      value={{\n        parentTree: tree,\n        parentCacheNode: cacheNode,\n        parentSegmentPath: segmentPath,\n        parentParams: params,\n        // This is always set to null as we enter a child segment. It's\n        // populated by LoadingBoundaryProvider the next time we reach a\n        // loading boundary.\n        parentLoadingData: null,\n        debugNameContext: debugNameContext,\n\n        // TODO-APP: overriding of url for parallel routes\n        url: url,\n        isActive: isActive,\n      }}\n    >\n      {children}\n    </LayoutRouterContext.Provider>\n  )\n\n  return children\n}\n\nexport function LoadingBoundaryProvider({\n  loading,\n  children,\n}: {\n  loading: LoadingModuleData\n  children: React.ReactNode\n}) {\n  // Provides the data needed to render a loading.tsx boundary, via context.\n  //\n  // loading.tsx creates a Suspense boundary around each of a layout's child\n  // slots. (Might be bit confusing to think about the data flow, but: if\n  // loading.tsx and layout.tsx are in the same directory, they are assigned\n  // to the same CacheNode.)\n  //\n  // This provider component does not render the Suspense boundary directly;\n  // that's handled by LoadingBoundary.\n  //\n  // TODO: For simplicity, we should combine this provider with LoadingBoundary\n  // and render the Suspense boundary directly. The only real benefit of doing\n  // it separately is so that when there are multiple parallel routes, we only\n  // send the boundary data once, rather than once per child. But that's a\n  // negligible benefit and can be achieved via caching instead.\n  const parentContext = use(LayoutRouterContext)\n  if (parentContext === null) {\n    return children\n  }\n  // All values except for parentLoadingData are the same as the parent context.\n  return (\n    <LayoutRouterContext.Provider\n      value={{\n        parentTree: parentContext.parentTree,\n        parentCacheNode: parentContext.parentCacheNode,\n        parentSegmentPath: parentContext.parentSegmentPath,\n        parentParams: parentContext.parentParams,\n        parentLoadingData: loading,\n        debugNameContext: parentContext.debugNameContext,\n        url: parentContext.url,\n        isActive: parentContext.isActive,\n      }}\n    >\n      {children}\n    </LayoutRouterContext.Provider>\n  )\n}\n\n/**\n * Renders suspense boundary with the provided \"loading\" property as the fallback.\n * If no loading property is provided it renders the children without a suspense boundary.\n */\nfunction LoadingBoundary({\n  name,\n  loading,\n  children,\n}: {\n  name: ActivityProps['name']\n  loading: LoadingModuleData | null\n  children: React.ReactNode\n}): JSX.Element {\n  // TODO: For LoadingBoundary, and the other built-in boundary types, don't\n  // wrap in an extra function component if no user-defined boundary is\n  // provided. In other words, inline this conditional wrapping logic into\n  // the parent component. More efficient and keeps unnecessary junk out of\n  // the component stack.\n  if (loading !== null) {\n    const loadingRsc = loading[0]\n    const loadingStyles = loading[1]\n    const loadingScripts = loading[2]\n    return (\n      <Suspense\n        name={name}\n        fallback={\n          <>\n            {loadingStyles}\n            {loadingScripts}\n            {loadingRsc}\n          </>\n        }\n      >\n        {children}\n      </Suspense>\n    )\n  }\n\n  return <>{children}</>\n}\n\n/**\n * OuterLayoutRouter handles the current segment as well as <Offscreen> rendering of other segments.\n * It can be rendered next to each other with a different `parallelRouterKey`, allowing for Parallel routes.\n */\nexport default function OuterLayoutRouter({\n  parallelRouterKey,\n  error,\n  errorStyles,\n  errorScripts,\n  templateStyles,\n  templateScripts,\n  template,\n  notFound,\n  forbidden,\n  unauthorized,\n  segmentViewBoundaries,\n}: {\n  parallelRouterKey: string\n  error: ErrorComponent | undefined\n  errorStyles: React.ReactNode | undefined\n  errorScripts: React.ReactNode | undefined\n  templateStyles: React.ReactNode | undefined\n  templateScripts: React.ReactNode | undefined\n  template: React.ReactNode\n  notFound: React.ReactNode | undefined\n  forbidden: React.ReactNode | undefined\n  unauthorized: React.ReactNode | undefined\n  segmentViewBoundaries?: React.ReactNode\n}) {\n  const context = useContext(LayoutRouterContext)\n  if (!context) {\n    throw new Error('invariant expected layout router to be mounted')\n  }\n\n  const {\n    parentTree,\n    parentCacheNode,\n    parentSegmentPath,\n    parentParams,\n    parentLoadingData,\n    url,\n    isActive,\n    debugNameContext,\n  } = context\n\n  // Get the CacheNode for this segment by reading it from the parent segment's\n  // child map.\n  const parentTreeSegment = parentTree[0]\n  const segmentPath =\n    parentSegmentPath === null\n      ? // TODO: The root segment value is currently omitted from the segment\n        // path. This has led to a bunch of special cases scattered throughout\n        // the code. We should clean this up.\n        [parallelRouterKey]\n      : parentSegmentPath.concat([parentTreeSegment, parallelRouterKey])\n\n  // The \"state\" key of a segment is the one passed to React — it represents the\n  // identity of the UI tree. Whenever the state key changes, the tree is\n  // recreated and the state is reset. In the App Router model, search params do\n  // not cause state to be lost, so two segments with the same segment path but\n  // different search params should have the same state key.\n  //\n  // The \"cache\" key of a segment, however, *does* include the search params, if\n  // it's possible that the segment accessed the search params on the server.\n  // (This only applies to page segments; layout segments cannot access search\n  // params on the server.)\n  const activeTree = parentTree[1][parallelRouterKey]\n  const maybeParentSlots = parentCacheNode.slots\n  if (activeTree === undefined || maybeParentSlots === null) {\n    // Could not find a matching segment. The client tree is inconsistent with\n    // the server tree. Suspend indefinitely; the router will have already\n    // detected the inconsistency when handling the server response, and\n    // triggered a refresh of the page to recover.\n    use(unresolvedThenable) as never\n  }\n\n  const activeSegment = activeTree[0]\n  const activeCacheNode = maybeParentSlots![parallelRouterKey] ?? null\n  const activeStateKey = createRouterCacheKey(activeSegment, true) // no search params\n\n  // At each level of the route tree, not only do we render the currently\n  // active segment — we also render the last N segments that were active at\n  // this level inside a hidden <Activity> boundary, to preserve their state\n  // if or when the user navigates to them again.\n  //\n  // bfcacheEntry is a linked list of FlightRouterStates.\n  let bfcacheEntry: RouterBFCacheEntry | null = useRouterBFCache(\n    activeTree,\n    activeCacheNode,\n    activeStateKey\n  )\n  let children: Array<React.ReactNode> = []\n  do {\n    const tree = bfcacheEntry.tree\n    const cacheNode = bfcacheEntry.cacheNode\n    const stateKey = bfcacheEntry.stateKey\n    const segment = tree[0]\n\n    /*\n    - Error boundary\n      - Only renders error boundary if error component is provided.\n      - Rendered for each segment to ensure they have their own error state.\n      - When gracefully degrade for bots, skip rendering error boundary.\n    - Loading boundary\n      - Only renders suspense boundary if loading components is provided.\n      - Rendered for each segment to ensure they have their own loading state.\n      - Passed to the router during rendering to ensure it can be immediately rendered when suspending on a Flight fetch.\n  */\n\n    let segmentBoundaryTriggerNode: React.ReactNode = null\n    let segmentViewStateNode: React.ReactNode = null\n    if (process.env.NODE_ENV !== 'production') {\n      const { SegmentBoundaryTriggerNode, SegmentViewStateNode } =\n        require('../../next-devtools/userspace/app/segment-explorer-node') as typeof import('../../next-devtools/userspace/app/segment-explorer-node')\n\n      const pagePrefix = normalizeAppPath(url)\n      segmentViewStateNode = (\n        <SegmentViewStateNode key={pagePrefix} page={pagePrefix} />\n      )\n\n      segmentBoundaryTriggerNode = (\n        <>\n          <SegmentBoundaryTriggerNode />\n        </>\n      )\n    }\n\n    let params = parentParams\n    if (Array.isArray(segment)) {\n      // This segment contains a route param. Accumulate these as we traverse\n      // down the router tree. The result represents the set of params that\n      // the layout/page components are permitted to access below this point.\n      const paramName = segment[0]\n      const paramCacheKey = segment[1]\n      const paramType = segment[2]\n      const paramValue = getParamValueFromCacheKey(paramCacheKey, paramType)\n      if (paramValue !== null) {\n        params = {\n          ...parentParams,\n          [paramName]: paramValue,\n        }\n      }\n    }\n\n    const debugName = getBoundaryDebugNameFromSegment(segment)\n    // `debugNameContext` represents the nearest non-\"virtual\" parent segment.\n    // `getBoundaryDebugNameFromSegment` returns undefined for virtual segments.\n    // So if `debugName` is undefined, the context is passed through unchanged.\n    const childDebugNameContext = debugName ?? debugNameContext\n\n    // In practical terms, clicking this name in the Suspense DevTools\n    // should select the child slots of that layout.\n    //\n    // So the name we apply to the Activity boundary is actually based on\n    // the nearest parent segments.\n    //\n    // We skip over \"virtual\" parents, i.e. ones inserted by Next.js that\n    // don't correspond to application-defined code.\n    const isVirtual = debugName === undefined\n    const debugNameToDisplay = isVirtual ? undefined : debugNameContext\n\n    let child = (\n      <TemplateContext.Provider\n        key={stateKey}\n        value={\n          <ScrollAndFocusHandler segmentPath={segmentPath}>\n            <ErrorBoundary\n              errorComponent={error}\n              errorStyles={errorStyles}\n              errorScripts={errorScripts}\n            >\n              <LoadingBoundary\n                name={debugNameToDisplay}\n                // TODO: The loading module data for a segment is stored on the\n                // parent, then applied to each of that parent segment's\n                // parallel route slots. In the simple case where there's only\n                // one parallel route (the `children` slot), this is no\n                // different from if the loading module data were stored on the\n                // child directly. But I'm not sure this actually makes sense\n                // when there are multiple parallel routes. It's not a huge\n                // issue because you always have the option to define a narrower\n                // loading boundary for a particular slot. But this sort of\n                // smells like an implementation accident to me.\n                loading={parentLoadingData}\n              >\n                <HTTPAccessFallbackBoundary\n                  notFound={notFound}\n                  forbidden={forbidden}\n                  unauthorized={unauthorized}\n                >\n                  <RedirectBoundary>\n                    <InnerLayoutRouter\n                      url={url}\n                      tree={tree}\n                      params={params}\n                      cacheNode={cacheNode}\n                      segmentPath={segmentPath}\n                      debugNameContext={childDebugNameContext}\n                      isActive={isActive && stateKey === activeStateKey}\n                    />\n                    {segmentBoundaryTriggerNode}\n                  </RedirectBoundary>\n                </HTTPAccessFallbackBoundary>\n              </LoadingBoundary>\n            </ErrorBoundary>\n            {segmentViewStateNode}\n          </ScrollAndFocusHandler>\n        }\n      >\n        {templateStyles}\n        {templateScripts}\n        {template}\n      </TemplateContext.Provider>\n    )\n\n    if (process.env.NODE_ENV !== 'production') {\n      const { SegmentStateProvider } =\n        require('../../next-devtools/userspace/app/segment-explorer-node') as typeof import('../../next-devtools/userspace/app/segment-explorer-node')\n\n      child = (\n        <SegmentStateProvider key={stateKey}>\n          {child}\n          {segmentViewBoundaries}\n        </SegmentStateProvider>\n      )\n    }\n\n    if (process.env.__NEXT_CACHE_COMPONENTS) {\n      child = (\n        <Activity\n          name={debugNameToDisplay}\n          key={stateKey}\n          mode={stateKey === activeStateKey ? 'visible' : 'hidden'}\n        >\n          {child}\n        </Activity>\n      )\n    }\n\n    children.push(child)\n\n    bfcacheEntry = bfcacheEntry.next\n  } while (bfcacheEntry !== null)\n\n  return children\n}\n\nfunction getBoundaryDebugNameFromSegment(segment: Segment): string | undefined {\n  if (segment === '/') {\n    // Reached the root\n    return '/'\n  }\n  if (typeof segment === 'string') {\n    if (isVirtualLayout(segment)) {\n      return undefined\n    } else {\n      return segment + '/'\n    }\n  }\n  const paramCacheKey = segment[1]\n  return paramCacheKey + '/'\n}\n\nfunction isVirtualLayout(segment: string): boolean {\n  return (\n    // This is inserted by the loader. We should consider encoding these\n    // in a more special way instead of checking the name, to distinguish them\n    // from app-defined groups.\n    segment === '(slot)'\n  )\n}\n"],"names":["React","Activity","useContext","use","Suspense","useDeferredValue","ReactDOM","LayoutRouterContext","GlobalLayoutRouterContext","TemplateContext","unresolvedThenable","ErrorBoundary","matchSegment","disableSmoothScrollDuringRouteTransition","RedirectBoundary","HTTPAccessFallbackBoundary","createRouterCacheKey","useRouterBFCache","normalizeAppPath","NavigationPromisesContext","getParamValueFromCacheKey","isDeferredRsc","__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE","findDOMNode","instance","window","internal_reactDOMfindDOMNode","rectProperties","shouldSkipElement","element","includes","getComputedStyle","position","rect","getBoundingClientRect","every","item","topOfElementInViewport","viewportHeight","top","getHashFragmentDomNode","hashFragment","document","body","getElementById","getElementsByName","InnerScrollAndFocusHandler","Component","componentDidMount","handlePotentialScroll","componentDidUpdate","props","focusAndScrollRef","apply","render","children","segmentPath","segmentPaths","length","some","scrollRefSegmentPath","segment","index","domNode","Element","HTMLElement","process","env","NODE_ENV","parentElement","localName","nextElementSibling","scrollIntoView","htmlElement","documentElement","clientHeight","scrollTop","dontForceLayout","onlyHashChange","focus","ScrollAndFocusHandler","context","Error","InnerLayoutRouter","tree","debugNameContext","cacheNode","maybeCacheNode","params","url","isActive","parentNavPromises","resolvedPrefetchRsc","prefetchRsc","rsc","resolvedRsc","unwrappedRsc","navigationPromises","createNestedLayoutNavigationPromises","require","Provider","value","parentTree","parentCacheNode","parentSegmentPath","parentParams","parentLoadingData","LoadingBoundaryProvider","loading","parentContext","LoadingBoundary","name","loadingRsc","loadingStyles","loadingScripts","fallback","OuterLayoutRouter","parallelRouterKey","error","errorStyles","errorScripts","templateStyles","templateScripts","template","notFound","forbidden","unauthorized","segmentViewBoundaries","parentTreeSegment","concat","activeTree","maybeParentSlots","slots","undefined","activeSegment","activeCacheNode","activeStateKey","bfcacheEntry","stateKey","segmentBoundaryTriggerNode","segmentViewStateNode","SegmentBoundaryTriggerNode","SegmentViewStateNode","pagePrefix","page","Array","isArray","paramName","paramCacheKey","paramType","paramValue","debugName","getBoundaryDebugNameFromSegment","childDebugNameContext","isVirtual","debugNameToDisplay","child","errorComponent","SegmentStateProvider","__NEXT_CACHE_COMPONENTS","mode","push","next","isVirtualLayout"],"mappings":"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","ignoreList":[0]}