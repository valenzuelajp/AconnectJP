{"version":3,"sources":["../../../../src/client/components/use-action-queue.ts"],"sourcesContent":["import type { Dispatch } from 'react'\nimport React, { use, useMemo, useOptimistic } from 'react'\nimport { isThenable } from '../../shared/lib/is-thenable'\nimport type { AppRouterActionQueue } from './app-router-instance'\nimport type {\n  AppRouterState,\n  ReducerActions,\n  ReducerState,\n} from './router-reducer/router-reducer-types'\n\n// The app router state lives outside of React, so we can import the dispatch\n// method directly wherever we need it, rather than passing it around via props\n// or context.\nlet dispatch: Dispatch<ReducerActions> | null = null\n\nexport function dispatchAppRouterAction(action: ReducerActions) {\n  if (dispatch === null) {\n    throw new Error(\n      'Internal Next.js error: Router action dispatched before initialization.'\n    )\n  }\n  dispatch(action)\n}\n\n// Optimistic state setter for experimental_gesturePush. Only should be used\n// during a gesture transition.\nlet setGestureRouterState: ((state: ReducerState) => void) | null = null\n\nexport function dispatchGestureState(state: ReducerState) {\n  if (setGestureRouterState === null) {\n    throw new Error(\n      'Internal Next.js error: Router action dispatched before initialization.'\n    )\n  }\n  setGestureRouterState(state)\n}\n\nconst __DEV__ = process.env.NODE_ENV !== 'production'\nconst promisesWithDebugInfo: WeakMap<\n  Promise<AppRouterState>,\n  Promise<AppRouterState> & { _debugInfo?: Array<unknown> }\n> = __DEV__ ? new WeakMap() : (null as any)\n\nexport function useActionQueue(\n  actionQueue: AppRouterActionQueue\n): AppRouterState {\n  const [canonicalState, setState] = React.useState<ReducerState>(\n    actionQueue.state\n  )\n\n  // Wrap the canonical state in useOptimistic to support\n  // experimental_gesturePush. During a gesture transition, this returns a fork\n  // of the router state that represents the eventual target if/when the gesture\n  // completes. Otherwise it returns the canonical state.\n  const [state, setGesture] = useOptimistic(canonicalState)\n  setGestureRouterState = setGesture\n\n  // Because of a known issue that requires to decode Flight streams inside the\n  // render phase, we have to be a bit clever and assign the dispatch method to\n  // a module-level variable upon initialization. The useState hook in this\n  // module only exists to synchronize state that lives outside of React.\n  // Ideally, what we'd do instead is pass the state as a prop to root.render;\n  // this is conceptually how we're modeling the app router state, despite the\n  // weird implementation details.\n  if (process.env.NODE_ENV !== 'production') {\n    const { useAppDevRenderingIndicator } =\n      require('../../next-devtools/userspace/use-app-dev-rendering-indicator') as typeof import('../../next-devtools/userspace/use-app-dev-rendering-indicator')\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    const appDevRenderingIndicator = useAppDevRenderingIndicator()\n\n    dispatch = (action: ReducerActions) => {\n      appDevRenderingIndicator(() => {\n        actionQueue.dispatch(action, setState)\n      })\n    }\n  } else {\n    dispatch = (action: ReducerActions) =>\n      actionQueue.dispatch(action, setState)\n  }\n\n  // When navigating to a non-prefetched route, then App Router state will be\n  // blocked until the server responds. We need to transfer the `_debugInfo`\n  // from the underlying Flight response onto the top-level promise that is\n  // passed to React (via `use`) so that the latency is accurately represented\n  // in the React DevTools.\n  const stateWithDebugInfo = useMemo(() => {\n    if (!__DEV__) {\n      return state\n    }\n\n    if (isThenable(state)) {\n      // useMemo can't be used to cache a Promise since the memoized value is thrown\n      // away when we suspend. So we use a WeakMap to cache the Promise with debug info.\n      let promiseWithDebugInfo = promisesWithDebugInfo.get(state)\n      if (promiseWithDebugInfo === undefined) {\n        const debugInfo: Array<unknown> = []\n        promiseWithDebugInfo = Promise.resolve(state).then((asyncState) => {\n          if (asyncState.debugInfo !== null) {\n            debugInfo.push(...asyncState.debugInfo)\n          }\n          return asyncState\n        }) as Promise<AppRouterState> & { _debugInfo?: Array<unknown> }\n        promiseWithDebugInfo._debugInfo = debugInfo\n\n        promisesWithDebugInfo.set(state, promiseWithDebugInfo)\n      }\n\n      return promiseWithDebugInfo\n    }\n    return state\n  }, [state])\n\n  return isThenable(stateWithDebugInfo)\n    ? use(stateWithDebugInfo)\n    : stateWithDebugInfo\n}\n"],"names":["React","use","useMemo","useOptimistic","isThenable","dispatch","dispatchAppRouterAction","action","Error","setGestureRouterState","dispatchGestureState","state","__DEV__","process","env","NODE_ENV","promisesWithDebugInfo","WeakMap","useActionQueue","actionQueue","canonicalState","setState","useState","setGesture","useAppDevRenderingIndicator","require","appDevRenderingIndicator","stateWithDebugInfo","promiseWithDebugInfo","get","undefined","debugInfo","Promise","resolve","then","asyncState","push","_debugInfo","set"],"mappings":"AACA,OAAOA,SAASC,GAAG,EAAEC,OAAO,EAAEC,aAAa,QAAQ,QAAO;AAC1D,SAASC,UAAU,QAAQ,+BAA8B;AAQzD,6EAA6E;AAC7E,+EAA+E;AAC/E,cAAc;AACd,IAAIC,WAA4C;AAEhD,OAAO,SAASC,wBAAwBC,MAAsB;IAC5D,IAAIF,aAAa,MAAM;QACrB,MAAM,qBAEL,CAFK,IAAIG,MACR,4EADI,qBAAA;mBAAA;wBAAA;0BAAA;QAEN;IACF;IACAH,SAASE;AACX;AAEA,4EAA4E;AAC5E,+BAA+B;AAC/B,IAAIE,wBAAgE;AAEpE,OAAO,SAASC,qBAAqBC,KAAmB;IACtD,IAAIF,0BAA0B,MAAM;QAClC,MAAM,qBAEL,CAFK,IAAID,MACR,4EADI,qBAAA;mBAAA;wBAAA;0BAAA;QAEN;IACF;IACAC,sBAAsBE;AACxB;AAEA,MAAMC,UAAUC,QAAQC,GAAG,CAACC,QAAQ,KAAK;AACzC,MAAMC,wBAGFJ,UAAU,IAAIK,YAAa;AAE/B,OAAO,SAASC,eACdC,WAAiC;IAEjC,MAAM,CAACC,gBAAgBC,SAAS,GAAGrB,MAAMsB,QAAQ,CAC/CH,YAAYR,KAAK;IAGnB,uDAAuD;IACvD,6EAA6E;IAC7E,8EAA8E;IAC9E,uDAAuD;IACvD,MAAM,CAACA,OAAOY,WAAW,GAAGpB,cAAciB;IAC1CX,wBAAwBc;IAExB,6EAA6E;IAC7E,6EAA6E;IAC7E,yEAAyE;IACzE,uEAAuE;IACvE,4EAA4E;IAC5E,4EAA4E;IAC5E,gCAAgC;IAChC,IAAIV,QAAQC,GAAG,CAACC,QAAQ,KAAK,cAAc;QACzC,MAAM,EAAES,2BAA2B,EAAE,GACnCC,QAAQ;QACV,sDAAsD;QACtD,MAAMC,2BAA2BF;QAEjCnB,WAAW,CAACE;YACVmB,yBAAyB;gBACvBP,YAAYd,QAAQ,CAACE,QAAQc;YAC/B;QACF;IACF,OAAO;QACLhB,WAAW,CAACE,SACVY,YAAYd,QAAQ,CAACE,QAAQc;IACjC;IAEA,2EAA2E;IAC3E,0EAA0E;IAC1E,yEAAyE;IACzE,4EAA4E;IAC5E,yBAAyB;IACzB,MAAMM,qBAAqBzB,QAAQ;QACjC,IAAI,CAACU,SAAS;YACZ,OAAOD;QACT;QAEA,IAAIP,WAAWO,QAAQ;YACrB,8EAA8E;YAC9E,kFAAkF;YAClF,IAAIiB,uBAAuBZ,sBAAsBa,GAAG,CAAClB;YACrD,IAAIiB,yBAAyBE,WAAW;gBACtC,MAAMC,YAA4B,EAAE;gBACpCH,uBAAuBI,QAAQC,OAAO,CAACtB,OAAOuB,IAAI,CAAC,CAACC;oBAClD,IAAIA,WAAWJ,SAAS,KAAK,MAAM;wBACjCA,UAAUK,IAAI,IAAID,WAAWJ,SAAS;oBACxC;oBACA,OAAOI;gBACT;gBACAP,qBAAqBS,UAAU,GAAGN;gBAElCf,sBAAsBsB,GAAG,CAAC3B,OAAOiB;YACnC;YAEA,OAAOA;QACT;QACA,OAAOjB;IACT,GAAG;QAACA;KAAM;IAEV,OAAOP,WAAWuB,sBACd1B,IAAI0B,sBACJA;AACN","ignoreList":[0]}