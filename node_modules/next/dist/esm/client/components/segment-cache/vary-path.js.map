{"version":3,"sources":["../../../../../src/client/components/segment-cache/vary-path.ts"],"sourcesContent":["import { FetchStrategy } from './types'\nimport type {\n  NormalizedPathname,\n  NormalizedSearch,\n  NormalizedNextUrl,\n} from './cache-key'\nimport type { RouteTree } from './cache'\nimport { Fallback, type FallbackType } from './cache-map'\nimport { HEAD_REQUEST_KEY } from '../../../shared/lib/segment-cache/segment-value-encoding'\n\ntype Opaque<T, K> = T & { __brand: K }\n\n/**\n * A linked-list of all the params (or other param-like) inputs that a cache\n * entry may vary by. This is used by the CacheMap module to reuse cache entries\n * across different param values. If a param has a value of Fallback, it means\n * the cache entry is reusable for all possible values of that param. See\n * cache-map.ts for details.\n *\n * A segment's vary path is a pure function of a segment's position in a\n * particular route tree and the (post-rewrite) URL that is being queried. More\n * concretely, successive queries of the cache for the same segment always use\n * the same vary path.\n *\n * A route's vary path is simpler: it's comprised of the pathname, search\n * string, and Next-URL header.\n */\nexport type VaryPath = {\n  /**\n   * Identifies which param this vary path node corresponds to. Used by\n   * getFulfilledSegmentVaryPath to determine which params to replace with\n   * Fallback based on the varyParams set from the server.\n   *\n   * - For path params: the param name (e.g., 'slug')\n   * - For search params: '?'\n   * - For non-param nodes (request keys, etc.): null\n   */\n  id: string | null\n  value: string | null | FallbackType\n  parent: VaryPath | null\n}\n\n// Because it's so important for vary paths to line up across cache accesses,\n// we use opaque type aliases to ensure these are only created within\n// this module.\n\n// requestKey -> searchParams -> nextUrl\nexport type RouteVaryPath = Opaque<\n  {\n    id: null\n    value: NormalizedPathname\n    parent: {\n      id: '?'\n      value: NormalizedSearch\n      parent: {\n        id: null\n        value: NormalizedNextUrl | null | FallbackType\n        parent: null\n      }\n    }\n  },\n  'RouteVaryPath'\n>\n\n// requestKey -> pathParams\nexport type LayoutVaryPath = Opaque<\n  {\n    id: null\n    value: string\n    parent: PartialSegmentVaryPath | null\n  },\n  'LayoutVaryPath'\n>\n\n// requestKey -> searchParams -> pathParams\nexport type PageVaryPath = Opaque<\n  {\n    id: null\n    value: string\n    parent: {\n      id: '?'\n      value: NormalizedSearch | FallbackType\n      parent: PartialSegmentVaryPath | null\n    }\n  },\n  'PageVaryPath'\n>\n\nexport type SegmentVaryPath = LayoutVaryPath | PageVaryPath\n\n// Intermediate type used when building a vary path during a recursive traversal\n// of the route tree.\nexport type PartialSegmentVaryPath = Opaque<VaryPath, 'PartialSegmentVaryPath'>\n\nexport function getRouteVaryPath(\n  pathname: NormalizedPathname,\n  search: NormalizedSearch,\n  nextUrl: NormalizedNextUrl | null\n): RouteVaryPath {\n  // requestKey -> searchParams -> nextUrl\n  const varyPath: VaryPath = {\n    id: null,\n    value: pathname,\n    parent: {\n      id: '?',\n      value: search,\n      parent: {\n        id: null,\n        value: nextUrl,\n        parent: null,\n      },\n    },\n  }\n  return varyPath as RouteVaryPath\n}\n\nexport function getFulfilledRouteVaryPath(\n  pathname: NormalizedPathname,\n  search: NormalizedSearch,\n  nextUrl: NormalizedNextUrl | null,\n  couldBeIntercepted: boolean\n): RouteVaryPath {\n  // This is called when a route's data is fulfilled. The cache entry will be\n  // re-keyed based on which inputs the response varies by.\n  // requestKey -> searchParams -> nextUrl\n  const varyPath: VaryPath = {\n    id: null,\n    value: pathname,\n    parent: {\n      id: '?',\n      value: search,\n      parent: {\n        id: null,\n        value: couldBeIntercepted ? nextUrl : Fallback,\n        parent: null,\n      },\n    },\n  }\n  return varyPath as RouteVaryPath\n}\n\nexport function appendLayoutVaryPath(\n  parentPath: PartialSegmentVaryPath | null,\n  cacheKey: string,\n  paramName: string\n): PartialSegmentVaryPath {\n  const varyPathPart: VaryPath = {\n    id: paramName,\n    value: cacheKey,\n    parent: parentPath,\n  }\n  return varyPathPart as PartialSegmentVaryPath\n}\n\nexport function finalizeLayoutVaryPath(\n  requestKey: string,\n  varyPath: PartialSegmentVaryPath | null\n): LayoutVaryPath {\n  const layoutVaryPath: VaryPath = {\n    id: null,\n    value: requestKey,\n    parent: varyPath,\n  }\n  return layoutVaryPath as LayoutVaryPath\n}\n\nexport function getPartialLayoutVaryPath(\n  finalizedVaryPath: LayoutVaryPath\n): PartialSegmentVaryPath | null {\n  // This is the inverse of finalizeLayoutVaryPath.\n  return finalizedVaryPath.parent\n}\n\nexport function finalizePageVaryPath(\n  requestKey: string,\n  renderedSearch: NormalizedSearch,\n  varyPath: PartialSegmentVaryPath | null\n): PageVaryPath {\n  // Unlike layouts, a page segment's vary path also includes the search string.\n  // requestKey -> searchParams -> pathParams\n  const pageVaryPath: VaryPath = {\n    id: null,\n    value: requestKey,\n    parent: {\n      id: '?',\n      value: renderedSearch,\n      parent: varyPath,\n    },\n  }\n  return pageVaryPath as PageVaryPath\n}\n\nexport function getPartialPageVaryPath(\n  finalizedVaryPath: PageVaryPath\n): PartialSegmentVaryPath | null {\n  // This is the inverse of finalizePageVaryPath.\n  return finalizedVaryPath.parent.parent\n}\n\nexport function finalizeMetadataVaryPath(\n  pageRequestKey: string,\n  renderedSearch: NormalizedSearch,\n  varyPath: PartialSegmentVaryPath | null\n): PageVaryPath {\n  // The metadata \"segment\" is not a real segment because it doesn't exist in\n  // the normal structure of the route tree, but in terms of caching, it\n  // behaves like a page segment because it varies by all the same params as\n  // a page.\n  //\n  // To keep the protocol for querying the server simple, the request key for\n  // the metadata does not include any path information. It's unnecessary from\n  // the server's perspective, because unlike page segments, there's only one\n  // metadata response per URL, i.e. there's no need to distinguish multiple\n  // parallel pages.\n  //\n  // However, this means the metadata request key is insufficient for\n  // caching the the metadata in the client cache, because on the client we\n  // use the request key to distinguish the metadata entry from all other\n  // page's metadata entries.\n  //\n  // So instead we create a simulated request key based on the page segment.\n  // Conceptually this is equivalent to the request key the server would have\n  // assigned the metadata segment if it treated it as part of the actual\n  // route structure.\n\n  // If there are multiple parallel pages, we use whichever is the first one.\n  // This is fine because the only difference between request keys for\n  // different parallel pages are things like route groups and parallel\n  // route slots. As long as it's always the same one, it doesn't matter.\n  const pageVaryPath: VaryPath = {\n    id: null,\n    // Append the actual metadata request key to the page request key. Note\n    // that we're not using a separate vary path part; it's unnecessary because\n    // these are not conceptually separate inputs.\n    value: pageRequestKey + HEAD_REQUEST_KEY,\n    parent: {\n      id: '?',\n      value: renderedSearch,\n      parent: varyPath,\n    },\n  }\n  return pageVaryPath as PageVaryPath\n}\n\nexport function getSegmentVaryPathForRequest(\n  fetchStrategy: FetchStrategy,\n  tree: RouteTree\n): SegmentVaryPath {\n  // This is used for storing pending requests in the cache. We want to choose\n  // the most generic vary path based on the strategy used to fetch it, i.e.\n  // static/PPR versus runtime prefetching, so that it can be reused as much\n  // as possible.\n  //\n  // We may be able to re-key the response to something even more generic once\n  // we receive it — for example, if the server tells us that the response\n  // doesn't vary on a particular param — but even before we send the request,\n  // we know some params are reusable based on the fetch strategy alone. For\n  // example, a static prefetch will never vary on search params.\n  //\n  // The original vary path with all the params filled in is stored on the\n  // route tree object. We will clone this one to create a new vary path\n  // where certain params are replaced with Fallback.\n  //\n  // This result of this function is not stored anywhere. It's only used to\n  // access the cache a single time.\n  //\n  // TODO: Rather than create a new list object just to access the cache, the\n  // plan is to add the concept of a \"vary mask\". This will represent all the\n  // params that can be treated as Fallback. (Or perhaps the inverse.)\n  const originalVaryPath = tree.varyPath\n\n  // Only page segments (and the special \"metadata\" segment, which is treated\n  // like a page segment for the purposes of caching) may contain search\n  // params. There's no reason to include them in the vary path otherwise.\n  if (tree.isPage) {\n    // Only a runtime prefetch will include search params in the vary path.\n    // Static prefetches never include search params, so they can be reused\n    // across all possible search param values.\n    const doesVaryOnSearchParams =\n      fetchStrategy === FetchStrategy.Full ||\n      fetchStrategy === FetchStrategy.PPRRuntime\n\n    if (!doesVaryOnSearchParams) {\n      // The response from the the server will not vary on search params. Clone\n      // the end of the original vary path to replace the search params\n      // with Fallback.\n      //\n      // requestKey -> searchParams -> pathParams\n      //               ^ This part gets replaced with Fallback\n      const searchParamsVaryPath = (originalVaryPath as PageVaryPath).parent\n      const pathParamsVaryPath = searchParamsVaryPath.parent\n      const patchedVaryPath: VaryPath = {\n        id: null,\n        value: originalVaryPath.value,\n        parent: {\n          id: '?',\n          value: Fallback,\n          parent: pathParamsVaryPath,\n        },\n      }\n      return patchedVaryPath as SegmentVaryPath\n    }\n  }\n\n  // The request does vary on search params. We don't need to modify anything.\n  return originalVaryPath as SegmentVaryPath\n}\n\nexport function clonePageVaryPathWithNewSearchParams(\n  originalVaryPath: PageVaryPath,\n  newSearch: NormalizedSearch\n): PageVaryPath {\n  // requestKey -> searchParams -> pathParams\n  //               ^ This part gets replaced with newSearch\n  const searchParamsVaryPath = originalVaryPath.parent\n  const clonedVaryPath: VaryPath = {\n    id: null,\n    value: originalVaryPath.value,\n    parent: {\n      id: '?',\n      value: newSearch,\n      parent: searchParamsVaryPath.parent,\n    },\n  }\n  return clonedVaryPath as PageVaryPath\n}\n\nexport function getRenderedSearchFromVaryPath(\n  varyPath: PageVaryPath\n): NormalizedSearch | null {\n  const searchParams = varyPath.parent.value\n  return typeof searchParams === 'string'\n    ? (searchParams as NormalizedSearch)\n    : null\n}\n\nexport function getFulfilledSegmentVaryPath(\n  original: VaryPath,\n  varyParams: Set<string>\n): SegmentVaryPath {\n  // Re-keys a segment's vary path based on which params the segment actually\n  // depends on. Params that are NOT in the varyParams set are replaced with\n  // Fallback, allowing the cache entry to be reused across different values of\n  // those params.\n\n  // This is called when a segment is fulfilled with data from the server. The\n  // varyParams set comes from the server and indicates which params were\n  // accessed during rendering.\n  const clone: VaryPath = {\n    id: original.id,\n    // If the id is null, this node is not a param (e.g., it's a request key).\n    // If the id is in the varyParams set, keep the original value.\n    // Otherwise, replace with Fallback to make it reusable.\n    value:\n      original.id === null || varyParams.has(original.id)\n        ? original.value\n        : Fallback,\n    parent:\n      original.parent === null\n        ? null\n        : getFulfilledSegmentVaryPath(original.parent, varyParams),\n  }\n  return clone as SegmentVaryPath\n}\n"],"names":["FetchStrategy","Fallback","HEAD_REQUEST_KEY","getRouteVaryPath","pathname","search","nextUrl","varyPath","id","value","parent","getFulfilledRouteVaryPath","couldBeIntercepted","appendLayoutVaryPath","parentPath","cacheKey","paramName","varyPathPart","finalizeLayoutVaryPath","requestKey","layoutVaryPath","getPartialLayoutVaryPath","finalizedVaryPath","finalizePageVaryPath","renderedSearch","pageVaryPath","getPartialPageVaryPath","finalizeMetadataVaryPath","pageRequestKey","getSegmentVaryPathForRequest","fetchStrategy","tree","originalVaryPath","isPage","doesVaryOnSearchParams","Full","PPRRuntime","searchParamsVaryPath","pathParamsVaryPath","patchedVaryPath","clonePageVaryPathWithNewSearchParams","newSearch","clonedVaryPath","getRenderedSearchFromVaryPath","searchParams","getFulfilledSegmentVaryPath","original","varyParams","clone","has"],"mappings":"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","ignoreList":[0]}