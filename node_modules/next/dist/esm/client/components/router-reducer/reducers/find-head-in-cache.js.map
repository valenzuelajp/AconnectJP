{"version":3,"sources":["../../../../../../src/client/components/router-reducer/reducers/find-head-in-cache.ts"],"sourcesContent":["import type {\n  FlightRouterState,\n  CacheNode,\n} from '../../../../shared/lib/app-router-types'\nimport { DEFAULT_SEGMENT_KEY } from '../../../../shared/lib/segment'\nimport { createRouterCacheKey } from '../create-router-cache-key'\n\nexport function findHeadInCache(\n  cache: CacheNode,\n  parallelRoutes: FlightRouterState[1]\n): [CacheNode, string, string] | null {\n  return findHeadInCacheImpl(cache, parallelRoutes, '', '')\n}\n\nfunction findHeadInCacheImpl(\n  cache: CacheNode,\n  parallelRoutes: FlightRouterState[1],\n  keyPrefix: string,\n  keyPrefixWithoutSearchParams: string\n): [CacheNode, string, string] | null {\n  const isLastItem = Object.keys(parallelRoutes).length === 0\n  if (isLastItem) {\n    // Returns the entire Cache Node of the segment whose head we will render.\n    return [cache, keyPrefix, keyPrefixWithoutSearchParams]\n  }\n\n  // First try the 'children' parallel route if it exists\n  // when starting from the \"root\", this corresponds with the main page component\n  const parallelRoutesKeys = Object.keys(parallelRoutes).filter(\n    (key) => key !== 'children'\n  )\n\n  // if we are at the root, we need to check the children slot first\n  if ('children' in parallelRoutes) {\n    parallelRoutesKeys.unshift('children')\n  }\n\n  const slots = cache.slots\n  if (slots !== null) {\n    for (const key of parallelRoutesKeys) {\n      const [segment, childParallelRoutes] = parallelRoutes[key]\n      // If the parallel is not matched and using the default segment,\n      // skip searching the head from it.\n      if (segment === DEFAULT_SEGMENT_KEY) {\n        continue\n      }\n\n      const childCacheNode = slots[key]\n      if (!childCacheNode) {\n        continue\n      }\n\n      const cacheKey = createRouterCacheKey(segment)\n      const cacheKeyWithoutSearchParams = createRouterCacheKey(segment, true)\n\n      const item = findHeadInCacheImpl(\n        childCacheNode,\n        childParallelRoutes,\n        keyPrefix + '/' + cacheKey,\n        keyPrefix + '/' + cacheKeyWithoutSearchParams\n      )\n\n      if (item) {\n        return item\n      }\n    }\n  }\n\n  return null\n}\n"],"names":["DEFAULT_SEGMENT_KEY","createRouterCacheKey","findHeadInCache","cache","parallelRoutes","findHeadInCacheImpl","keyPrefix","keyPrefixWithoutSearchParams","isLastItem","Object","keys","length","parallelRoutesKeys","filter","key","unshift","slots","segment","childParallelRoutes","childCacheNode","cacheKey","cacheKeyWithoutSearchParams","item"],"mappings":"AAIA,SAASA,mBAAmB,QAAQ,iCAAgC;AACpE,SAASC,oBAAoB,QAAQ,6BAA4B;AAEjE,OAAO,SAASC,gBACdC,KAAgB,EAChBC,cAAoC;IAEpC,OAAOC,oBAAoBF,OAAOC,gBAAgB,IAAI;AACxD;AAEA,SAASC,oBACPF,KAAgB,EAChBC,cAAoC,EACpCE,SAAiB,EACjBC,4BAAoC;IAEpC,MAAMC,aAAaC,OAAOC,IAAI,CAACN,gBAAgBO,MAAM,KAAK;IAC1D,IAAIH,YAAY;QACd,0EAA0E;QAC1E,OAAO;YAACL;YAAOG;YAAWC;SAA6B;IACzD;IAEA,uDAAuD;IACvD,+EAA+E;IAC/E,MAAMK,qBAAqBH,OAAOC,IAAI,CAACN,gBAAgBS,MAAM,CAC3D,CAACC,MAAQA,QAAQ;IAGnB,kEAAkE;IAClE,IAAI,cAAcV,gBAAgB;QAChCQ,mBAAmBG,OAAO,CAAC;IAC7B;IAEA,MAAMC,QAAQb,MAAMa,KAAK;IACzB,IAAIA,UAAU,MAAM;QAClB,KAAK,MAAMF,OAAOF,mBAAoB;YACpC,MAAM,CAACK,SAASC,oBAAoB,GAAGd,cAAc,CAACU,IAAI;YAC1D,gEAAgE;YAChE,mCAAmC;YACnC,IAAIG,YAAYjB,qBAAqB;gBACnC;YACF;YAEA,MAAMmB,iBAAiBH,KAAK,CAACF,IAAI;YACjC,IAAI,CAACK,gBAAgB;gBACnB;YACF;YAEA,MAAMC,WAAWnB,qBAAqBgB;YACtC,MAAMI,8BAA8BpB,qBAAqBgB,SAAS;YAElE,MAAMK,OAAOjB,oBACXc,gBACAD,qBACAZ,YAAY,MAAMc,UAClBd,YAAY,MAAMe;YAGpB,IAAIC,MAAM;gBACR,OAAOA;YACT;QACF;IACF;IAEA,OAAO;AACT","ignoreList":[0]}