{"version":3,"sources":["../../../../../../src/client/components/router-reducer/reducers/server-action-reducer.ts"],"sourcesContent":["import type {\n  ActionFlightResponse,\n  ActionResult,\n} from '../../../../shared/lib/app-router-types'\nimport { callServer } from '../../../app-call-server'\nimport { findSourceMapURL } from '../../../app-find-source-map-url'\nimport {\n  ACTION_HEADER,\n  NEXT_ACTION_NOT_FOUND_HEADER,\n  NEXT_IS_PRERENDER_HEADER,\n  NEXT_HTML_REQUEST_ID_HEADER,\n  NEXT_ROUTER_STATE_TREE_HEADER,\n  NEXT_URL,\n  RSC_CONTENT_TYPE_HEADER,\n  NEXT_REQUEST_ID_HEADER,\n} from '../../app-router-headers'\nimport { UnrecognizedActionError } from '../../unrecognized-action-error'\n\n// TODO: Explicitly import from client.browser\n// eslint-disable-next-line import/no-extraneous-dependencies\nimport {\n  createFromFetch as createFromFetchBrowser,\n  createTemporaryReferenceSet,\n  encodeReply,\n} from 'react-server-dom-webpack/client'\n\nimport type {\n  ReadonlyReducerState,\n  ReducerState,\n  ServerActionAction,\n} from '../router-reducer-types'\nimport { assignLocation } from '../../../assign-location'\nimport { createHrefFromUrl } from '../create-href-from-url'\nimport { hasInterceptionRouteInCurrentTree } from './has-interception-route-in-current-tree'\nimport {\n  normalizeFlightData,\n  prepareFlightRouterStateForRequest,\n  type NormalizedFlightData,\n} from '../../../flight-data-helpers'\nimport { getRedirectError } from '../../redirect'\nimport type { RedirectType } from '../../redirect-error'\nimport { removeBasePath } from '../../../remove-base-path'\nimport { hasBasePath } from '../../../has-base-path'\nimport {\n  extractInfoFromServerReferenceId,\n  omitUnusedArgs,\n} from '../../../../shared/lib/server-reference-info'\nimport { invalidateEntirePrefetchCache } from '../../segment-cache/cache'\nimport { startRevalidationCooldown } from '../../segment-cache/scheduler'\nimport { getDeploymentId } from '../../../../shared/lib/deployment-id'\nimport {\n  completeHardNavigation,\n  convertServerPatchToFullTree,\n  navigateToKnownRoute,\n  navigate,\n} from '../../segment-cache/navigation'\nimport { discoverKnownRoute } from '../../segment-cache/optimistic-routes'\nimport type { NormalizedSearch } from '../../segment-cache/cache-key'\nimport {\n  ActionDidNotRevalidate,\n  ActionDidRevalidateDynamicOnly,\n  ActionDidRevalidateStaticAndDynamic,\n  type ActionRevalidationKind,\n} from '../../../../shared/lib/action-revalidation-kind'\nimport { isExternalURL } from '../../app-router-utils'\nimport { FreshnessPolicy } from '../ppr-navigations'\nimport { invalidateBfCache } from '../../segment-cache/bfcache'\n\nconst createFromFetch =\n  createFromFetchBrowser as (typeof import('react-server-dom-webpack/client.browser'))['createFromFetch']\n\nlet createDebugChannel:\n  | typeof import('../../../dev/debug-channel').createDebugChannel\n  | undefined\n\nif (\n  process.env.NODE_ENV !== 'production' &&\n  process.env.__NEXT_REACT_DEBUG_CHANNEL\n) {\n  createDebugChannel = (\n    require('../../../dev/debug-channel') as typeof import('../../../dev/debug-channel')\n  ).createDebugChannel\n}\n\n// TODO: Refactor to be a discriminated union. Or just get rid of it;\n// fetchServerAction only has one caller, no reason this intermediate type has\n// to exist.\ntype FetchServerActionResult = {\n  redirectLocation: URL | undefined\n  redirectType: RedirectType | undefined\n  revalidationKind: ActionRevalidationKind\n  actionResult: ActionResult | undefined\n  actionFlightData: NormalizedFlightData[] | string | undefined\n  actionFlightDataRenderedSearch: NormalizedSearch | undefined\n  isPrerender: boolean\n  couldBeIntercepted: boolean\n}\n\nasync function fetchServerAction(\n  state: ReadonlyReducerState,\n  nextUrl: ReadonlyReducerState['nextUrl'],\n  { actionId, actionArgs }: ServerActionAction\n): Promise<FetchServerActionResult> {\n  const temporaryReferences = createTemporaryReferenceSet()\n  const info = extractInfoFromServerReferenceId(actionId)\n\n  // TODO: Currently, we're only omitting unused args for the experimental \"use\n  // cache\" functions. Once the server reference info byte feature is stable, we\n  // should apply this to server actions as well.\n  const usedArgs =\n    info.type === 'use-cache' ? omitUnusedArgs(actionArgs, info) : actionArgs\n\n  const body = await encodeReply(usedArgs, { temporaryReferences })\n\n  const headers: Record<string, string> = {\n    Accept: RSC_CONTENT_TYPE_HEADER,\n    [ACTION_HEADER]: actionId,\n    [NEXT_ROUTER_STATE_TREE_HEADER]: prepareFlightRouterStateForRequest(\n      state.tree\n    ),\n  }\n\n  const deploymentId = getDeploymentId()\n  if (deploymentId) {\n    headers['x-deployment-id'] = deploymentId\n  }\n\n  if (nextUrl) {\n    headers[NEXT_URL] = nextUrl\n  }\n\n  if (process.env.NODE_ENV !== 'production') {\n    if (self.__next_r) {\n      headers[NEXT_HTML_REQUEST_ID_HEADER] = self.__next_r\n    }\n\n    // Create a new request ID for the server action request. The server uses\n    // this to tag debug information sent via WebSocket to the client, which\n    // then routes those chunks to the debug channel associated with this ID.\n    headers[NEXT_REQUEST_ID_HEADER] = crypto\n      .getRandomValues(new Uint32Array(1))[0]\n      .toString(16)\n  }\n\n  const res = await fetch(state.canonicalUrl, { method: 'POST', headers, body })\n\n  // Handle server actions that the server didn't recognize.\n  const unrecognizedActionHeader = res.headers.get(NEXT_ACTION_NOT_FOUND_HEADER)\n  if (unrecognizedActionHeader === '1') {\n    throw new UnrecognizedActionError(\n      `Server Action \"${actionId}\" was not found on the server. \\nRead more: https://nextjs.org/docs/messages/failed-to-find-server-action`\n    )\n  }\n\n  const redirectHeader = res.headers.get('x-action-redirect')\n  const [location, _redirectType] = redirectHeader?.split(';') || []\n  let redirectType: RedirectType | undefined\n  switch (_redirectType) {\n    case 'push':\n      redirectType = 'push'\n      break\n    case 'replace':\n      redirectType = 'replace'\n      break\n    default:\n      redirectType = undefined\n  }\n\n  const isPrerender = !!res.headers.get(NEXT_IS_PRERENDER_HEADER)\n\n  let revalidationKind: ActionRevalidationKind = ActionDidNotRevalidate\n  try {\n    const revalidationHeader = res.headers.get('x-action-revalidated')\n    if (revalidationHeader) {\n      const parsedKind = JSON.parse(revalidationHeader)\n      if (\n        parsedKind === ActionDidRevalidateStaticAndDynamic ||\n        parsedKind === ActionDidRevalidateDynamicOnly\n      ) {\n        revalidationKind = parsedKind\n      }\n    }\n  } catch {}\n\n  const redirectLocation = location\n    ? assignLocation(\n        location,\n        new URL(state.canonicalUrl, window.location.href)\n      )\n    : undefined\n\n  const contentType = res.headers.get('content-type')\n  const isRscResponse = !!(\n    contentType && contentType.startsWith(RSC_CONTENT_TYPE_HEADER)\n  )\n\n  // Handle invalid server action responses.\n  // A valid response must have `content-type: text/x-component`, unless it's an external redirect.\n  // (external redirects have an 'x-action-redirect' header, but the body is an empty 'text/plain')\n  if (!isRscResponse && !redirectLocation) {\n    // The server can respond with a text/plain error message, but we'll fallback to something generic\n    // if there isn't one.\n    const message =\n      res.status >= 400 && contentType === 'text/plain'\n        ? await res.text()\n        : 'An unexpected response was received from the server.'\n\n    throw new Error(message)\n  }\n\n  let actionResult: FetchServerActionResult['actionResult']\n  let actionFlightData: FetchServerActionResult['actionFlightData']\n  let actionFlightDataRenderedSearch: FetchServerActionResult['actionFlightDataRenderedSearch']\n  let couldBeIntercepted: boolean = false\n\n  if (isRscResponse) {\n    const response: ActionFlightResponse = await createFromFetch(\n      Promise.resolve(res),\n      {\n        callServer,\n        findSourceMapURL,\n        temporaryReferences,\n        debugChannel: createDebugChannel && createDebugChannel(headers),\n      }\n    )\n\n    // An internal redirect can send an RSC response, but does not have a useful `actionResult`.\n    actionResult = redirectLocation ? undefined : response.a\n    couldBeIntercepted = response.i\n    const maybeFlightData = normalizeFlightData(response.f)\n    if (maybeFlightData !== '') {\n      actionFlightData = maybeFlightData\n      actionFlightDataRenderedSearch = response.q as NormalizedSearch\n    }\n  } else {\n    // An external redirect doesn't contain RSC data.\n    actionResult = undefined\n    actionFlightData = undefined\n    actionFlightDataRenderedSearch = undefined\n  }\n\n  return {\n    actionResult,\n    actionFlightData,\n    actionFlightDataRenderedSearch,\n    redirectLocation,\n    redirectType,\n    revalidationKind,\n    isPrerender,\n    couldBeIntercepted,\n  }\n}\n\n/*\n * This reducer is responsible for calling the server action and processing any side-effects from the server action.\n * It does not mutate the state by itself but rather delegates to other reducers to do the actual mutation.\n */\nexport function serverActionReducer(\n  state: ReadonlyReducerState,\n  action: ServerActionAction\n): ReducerState {\n  const { resolve, reject } = action\n\n  // only pass along the `nextUrl` param (used for interception routes) if the current route was intercepted.\n  // If the route has been intercepted, the action should be as well.\n  // Otherwise the server action might be intercepted with the wrong action id\n  // (ie, one that corresponds with the intercepted route)\n  const nextUrl =\n    // We always send the last next-url, not the current when\n    // performing a dynamic request. This is because we update\n    // the next-url after a navigation, but we want the same\n    // interception route to be matched that used the last\n    // next-url.\n    (state.previousNextUrl || state.nextUrl) &&\n    hasInterceptionRouteInCurrentTree(state.tree)\n      ? state.previousNextUrl || state.nextUrl\n      : null\n\n  return fetchServerAction(state, nextUrl, action).then(\n    async ({\n      revalidationKind,\n      actionResult,\n      actionFlightData: flightData,\n      actionFlightDataRenderedSearch: flightDataRenderedSearch,\n      redirectLocation,\n      redirectType,\n      isPrerender,\n      couldBeIntercepted,\n    }) => {\n      if (revalidationKind !== ActionDidNotRevalidate) {\n        // There was either a revalidation or a refresh, or maybe both.\n\n        // Evict the BFCache, which may contain dynamic data.\n        invalidateBfCache()\n\n        // Store whether this action triggered any revalidation\n        // The action queue will use this information to potentially\n        // trigger a refresh action if the action was discarded\n        // (ie, due to a navigation, before the action completed)\n        action.didRevalidate = true\n\n        // If there was a revalidation, evict the prefetch cache.\n        // TODO: Evict only segments with matching tags and/or paths.\n        // TODO: We should only invalidate the route cache if cookies were\n        // mutated, since route trees may vary based on cookies. For now we\n        // invalidate both caches until we have a way to detect cookie\n        // mutations on the client.\n        if (revalidationKind === ActionDidRevalidateStaticAndDynamic) {\n          invalidateEntirePrefetchCache(nextUrl, state.tree)\n        }\n\n        // Start a cooldown before re-prefetching to allow CDN cache\n        // propagation.\n        startRevalidationCooldown()\n      }\n\n      const navigateType = redirectType || 'push'\n\n      if (redirectLocation !== undefined) {\n        // If the action triggered a redirect, the action promise will be rejected with\n        // a redirect so that it's handled by RedirectBoundary as we won't have a valid\n        // action result to resolve the promise with. This will effectively reset the state of\n        // the component that called the action as the error boundary will remount the tree.\n        // The status code doesn't matter here as the action handler will have already sent\n        // a response with the correct status code.\n\n        if (isExternalURL(redirectLocation)) {\n          // External redirect. Triggers an MPA navigation.\n          const redirectHref = redirectLocation.href\n          const redirectError = createRedirectErrorForAction(\n            redirectHref,\n            navigateType\n          )\n          reject(redirectError)\n          return completeHardNavigation(state, redirectLocation, navigateType)\n        } else {\n          // Internal redirect. Triggers an SPA navigation.\n          const redirectWithBasepath = createHrefFromUrl(\n            redirectLocation,\n            false\n          )\n          const redirectHref = hasBasePath(redirectWithBasepath)\n            ? removeBasePath(redirectWithBasepath)\n            : redirectWithBasepath\n          const redirectError = createRedirectErrorForAction(\n            redirectHref,\n            navigateType\n          )\n          reject(redirectError)\n        }\n      } else {\n        // If there's no redirect, resolve the action with the result.\n        resolve(actionResult)\n      }\n\n      // Check if we can bail out without updating any state.\n      if (\n        // Did the action trigger a redirect?\n        redirectLocation === undefined &&\n        // Did the action revalidate any data?\n        revalidationKind === ActionDidNotRevalidate &&\n        // Did the server render new data?\n        flightData === undefined\n      ) {\n        // The action did not trigger any revalidations or redirects. No\n        // navigation is required.\n        return state\n      }\n\n      if (flightData === undefined && redirectLocation !== undefined) {\n        // The server redirected, but did not send any Flight data. This implies\n        // an external redirect.\n        // TODO: We should refactor the action response type to be more explicit\n        // about the various response types.\n        return completeHardNavigation(state, redirectLocation, navigateType)\n      }\n\n      if (typeof flightData === 'string') {\n        // If the flight data is just a string, something earlier in the\n        // response handling triggered an external redirect.\n        return completeHardNavigation(\n          state,\n          new URL(flightData, location.origin),\n          navigateType\n        )\n      }\n\n      // The action triggered a navigation — either a redirect, a revalidation,\n      // or both.\n\n      // If there was no redirect, then the target URL is the same as the\n      // current URL.\n      const currentUrl = new URL(state.canonicalUrl, location.origin)\n      const currentRenderedSearch = state.renderedSearch\n      const redirectUrl =\n        redirectLocation !== undefined ? redirectLocation : currentUrl\n      const currentFlightRouterState = state.tree\n      const shouldScroll = true\n\n      // If the action triggered a revalidation of the cache, we should also\n      // refresh all the dynamic data.\n      const freshnessPolicy =\n        revalidationKind === ActionDidNotRevalidate\n          ? FreshnessPolicy.Default\n          : FreshnessPolicy.RefreshAll\n\n      // The server may have sent back new data. If so, we will perform a\n      // \"seeded\" navigation that uses the data from the response.\n      // TODO: Currently the server always renders from the root in\n      // response to a Server Action. In the case of a normal redirect\n      // with no revalidation, it should skip over the shared layouts.\n      if (flightData !== undefined && flightDataRenderedSearch !== undefined) {\n        // The server sent back new route data as part of the response. We\n        // will use this to render the new page. If this happens to be only a\n        // subset of the data needed to render the new page, we'll initiate a\n        // new fetch, like we would for a normal navigation.\n        const redirectCanonicalUrl = createHrefFromUrl(redirectUrl)\n        const redirectSeed = convertServerPatchToFullTree(\n          currentFlightRouterState,\n          flightData,\n          flightDataRenderedSearch\n        )\n        const now = Date.now()\n\n        // Learn the route pattern so we can predict it for future navigations.\n        const metadataVaryPath = redirectSeed.metadataVaryPath\n        if (metadataVaryPath !== null) {\n          discoverKnownRoute(\n            now,\n            redirectUrl.pathname,\n            null, // No pending entry\n            redirectSeed.routeTree,\n            metadataVaryPath,\n            couldBeIntercepted,\n            redirectCanonicalUrl,\n            isPrerender,\n            false // hasDynamicRewrite\n          )\n        }\n\n        return navigateToKnownRoute(\n          now,\n          state,\n          redirectUrl,\n          redirectCanonicalUrl,\n          redirectSeed,\n          currentUrl,\n          currentRenderedSearch,\n          state.cache,\n          currentFlightRouterState,\n          freshnessPolicy,\n          nextUrl,\n          shouldScroll,\n          navigateType,\n          null,\n          // Server action redirects don't use route prediction - we already\n          // have the route tree from the server response. If a mismatch occurs\n          // during dynamic data fetch, the retry handler will traverse the\n          // known route tree to mark the entry as having a dynamic rewrite.\n          null\n        )\n      }\n\n      // The server did not send back new data. We'll perform a regular, non-\n      // seeded navigation — effectively the same as <Link> or router.push().\n      return navigate(\n        state,\n        redirectUrl,\n        currentUrl,\n        currentRenderedSearch,\n        state.cache,\n        currentFlightRouterState,\n        nextUrl,\n        freshnessPolicy,\n        shouldScroll,\n        navigateType\n      )\n    },\n    (e: any) => {\n      // When the server action is rejected we don't update the state and instead call the reject handler of the promise.\n      reject(e)\n\n      return state\n    }\n  )\n}\n\nfunction createRedirectErrorForAction(\n  redirectHref: string,\n  resolvedRedirectType: RedirectType\n) {\n  const redirectError = getRedirectError(redirectHref, resolvedRedirectType)\n  // We mark the error as handled because we don't want the redirect to be tried later by\n  // the RedirectBoundary, in case the user goes back and `Activity` triggers the redirect\n  // again, as it's run within an effect.\n  // We don't actually need the RedirectBoundary to do a router.push because we already\n  // have all the necessary RSC data to render the new page within a single roundtrip.\n  ;(redirectError as any).handled = true\n  return redirectError\n}\n"],"names":["callServer","findSourceMapURL","ACTION_HEADER","NEXT_ACTION_NOT_FOUND_HEADER","NEXT_IS_PRERENDER_HEADER","NEXT_HTML_REQUEST_ID_HEADER","NEXT_ROUTER_STATE_TREE_HEADER","NEXT_URL","RSC_CONTENT_TYPE_HEADER","NEXT_REQUEST_ID_HEADER","UnrecognizedActionError","createFromFetch","createFromFetchBrowser","createTemporaryReferenceSet","encodeReply","assignLocation","createHrefFromUrl","hasInterceptionRouteInCurrentTree","normalizeFlightData","prepareFlightRouterStateForRequest","getRedirectError","removeBasePath","hasBasePath","extractInfoFromServerReferenceId","omitUnusedArgs","invalidateEntirePrefetchCache","startRevalidationCooldown","getDeploymentId","completeHardNavigation","convertServerPatchToFullTree","navigateToKnownRoute","navigate","discoverKnownRoute","ActionDidNotRevalidate","ActionDidRevalidateDynamicOnly","ActionDidRevalidateStaticAndDynamic","isExternalURL","FreshnessPolicy","invalidateBfCache","createDebugChannel","process","env","NODE_ENV","__NEXT_REACT_DEBUG_CHANNEL","require","fetchServerAction","state","nextUrl","actionId","actionArgs","temporaryReferences","info","usedArgs","type","body","headers","Accept","tree","deploymentId","self","__next_r","crypto","getRandomValues","Uint32Array","toString","res","fetch","canonicalUrl","method","unrecognizedActionHeader","get","redirectHeader","location","_redirectType","split","redirectType","undefined","isPrerender","revalidationKind","revalidationHeader","parsedKind","JSON","parse","redirectLocation","URL","window","href","contentType","isRscResponse","startsWith","message","status","text","Error","actionResult","actionFlightData","actionFlightDataRenderedSearch","couldBeIntercepted","response","Promise","resolve","debugChannel","a","i","maybeFlightData","f","q","serverActionReducer","action","reject","previousNextUrl","then","flightData","flightDataRenderedSearch","didRevalidate","navigateType","redirectHref","redirectError","createRedirectErrorForAction","redirectWithBasepath","origin","currentUrl","currentRenderedSearch","renderedSearch","redirectUrl","currentFlightRouterState","shouldScroll","freshnessPolicy","Default","RefreshAll","redirectCanonicalUrl","redirectSeed","now","Date","metadataVaryPath","pathname","routeTree","cache","e","resolvedRedirectType","handled"],"mappings":"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","ignoreList":[0]}