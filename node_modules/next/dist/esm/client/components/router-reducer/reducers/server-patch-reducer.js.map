{"version":3,"sources":["../../../../../../src/client/components/router-reducer/reducers/server-patch-reducer.ts"],"sourcesContent":["import { createHrefFromUrl } from '../create-href-from-url'\nimport type {\n  ServerPatchAction,\n  ReducerState,\n  ReadonlyReducerState,\n} from '../router-reducer-types'\nimport {\n  completeHardNavigation,\n  navigateToKnownRoute,\n} from '../../segment-cache/navigation'\nimport { refreshReducer } from './refresh-reducer'\nimport { FreshnessPolicy } from '../ppr-navigations'\n\nexport function serverPatchReducer(\n  state: ReadonlyReducerState,\n  action: ServerPatchAction\n): ReducerState {\n  // A \"retry\" is a navigation that happens due to a route mismatch. It's\n  // similar to a refresh, because we will omit any existing dynamic data on\n  // the page. But we seed the retry navigation with the exact tree that the\n  // server just responded with.\n  const retryMpa = action.mpa\n  const retryUrl = new URL(action.url, location.origin)\n  const retrySeed = action.seed\n  // A retry should not create a new history entry.\n  const navigateType = 'replace'\n  if (retryMpa || retrySeed === null) {\n    // If the server did not send back data during the mismatch, fall back to\n    // an MPA navigation.\n    return completeHardNavigation(state, retryUrl, navigateType)\n  }\n  const currentUrl = new URL(state.canonicalUrl, location.origin)\n  const currentRenderedSearch = state.renderedSearch\n  if (action.previousTree !== state.tree) {\n    // There was another, more recent navigation since the once that\n    // mismatched. We can abort the retry, but we still need to refresh the\n    // page to evict any stale dynamic data.\n    return refreshReducer(state)\n  }\n  // There have been no new navigations since the mismatched one. Refresh,\n  // using the tree we just received from the server.\n  const retryCanonicalUrl = createHrefFromUrl(retryUrl)\n  const retryNextUrl = action.nextUrl\n  const shouldScroll = true\n  const now = Date.now()\n  return navigateToKnownRoute(\n    now,\n    state,\n    retryUrl,\n    retryCanonicalUrl,\n    retrySeed,\n    currentUrl,\n    currentRenderedSearch,\n    state.cache,\n    state.tree,\n    FreshnessPolicy.RefreshAll,\n    retryNextUrl,\n    shouldScroll,\n    navigateType,\n    null,\n    // Server patch (retry) navigations don't use route prediction. This is\n    // typically a retry after a previous mismatch, so the route was already\n    // marked as having a dynamic rewrite when the mismatch was detected.\n    null\n  )\n}\n"],"names":["createHrefFromUrl","completeHardNavigation","navigateToKnownRoute","refreshReducer","FreshnessPolicy","serverPatchReducer","state","action","retryMpa","mpa","retryUrl","URL","url","location","origin","retrySeed","seed","navigateType","currentUrl","canonicalUrl","currentRenderedSearch","renderedSearch","previousTree","tree","retryCanonicalUrl","retryNextUrl","nextUrl","shouldScroll","now","Date","cache","RefreshAll"],"mappings":"AAAA,SAASA,iBAAiB,QAAQ,0BAAyB;AAM3D,SACEC,sBAAsB,EACtBC,oBAAoB,QACf,iCAAgC;AACvC,SAASC,cAAc,QAAQ,oBAAmB;AAClD,SAASC,eAAe,QAAQ,qBAAoB;AAEpD,OAAO,SAASC,mBACdC,KAA2B,EAC3BC,MAAyB;IAEzB,uEAAuE;IACvE,0EAA0E;IAC1E,0EAA0E;IAC1E,8BAA8B;IAC9B,MAAMC,WAAWD,OAAOE,GAAG;IAC3B,MAAMC,WAAW,IAAIC,IAAIJ,OAAOK,GAAG,EAAEC,SAASC,MAAM;IACpD,MAAMC,YAAYR,OAAOS,IAAI;IAC7B,iDAAiD;IACjD,MAAMC,eAAe;IACrB,IAAIT,YAAYO,cAAc,MAAM;QAClC,yEAAyE;QACzE,qBAAqB;QACrB,OAAOd,uBAAuBK,OAAOI,UAAUO;IACjD;IACA,MAAMC,aAAa,IAAIP,IAAIL,MAAMa,YAAY,EAAEN,SAASC,MAAM;IAC9D,MAAMM,wBAAwBd,MAAMe,cAAc;IAClD,IAAId,OAAOe,YAAY,KAAKhB,MAAMiB,IAAI,EAAE;QACtC,gEAAgE;QAChE,uEAAuE;QACvE,wCAAwC;QACxC,OAAOpB,eAAeG;IACxB;IACA,wEAAwE;IACxE,mDAAmD;IACnD,MAAMkB,oBAAoBxB,kBAAkBU;IAC5C,MAAMe,eAAelB,OAAOmB,OAAO;IACnC,MAAMC,eAAe;IACrB,MAAMC,MAAMC,KAAKD,GAAG;IACpB,OAAO1B,qBACL0B,KACAtB,OACAI,UACAc,mBACAT,WACAG,YACAE,uBACAd,MAAMwB,KAAK,EACXxB,MAAMiB,IAAI,EACVnB,gBAAgB2B,UAAU,EAC1BN,cACAE,cACAV,cACA,MACA,uEAAuE;IACvE,wEAAwE;IACxE,qEAAqE;IACrE;AAEJ","ignoreList":[0]}