{"version":3,"sources":["../../../../../../src/client/components/router-reducer/reducers/restore-reducer.ts"],"sourcesContent":["import type {\n  ReadonlyReducerState,\n  ReducerState,\n  RestoreAction,\n} from '../router-reducer-types'\nimport { extractPathFromFlightRouterState } from '../compute-changed-path'\nimport {\n  FreshnessPolicy,\n  spawnDynamicRequests,\n  startPPRNavigation,\n  type NavigationRequestAccumulation,\n} from '../ppr-navigations'\nimport type { FlightRouterState } from '../../../../shared/lib/app-router-types'\nimport {\n  completeHardNavigation,\n  completeTraverseNavigation,\n  convertServerPatchToFullTree,\n} from '../../segment-cache/navigation'\n\nexport function restoreReducer(\n  state: ReadonlyReducerState,\n  action: RestoreAction\n): ReducerState {\n  // This action is used to restore the router state from the history state.\n  // However, it's possible that the history state no longer contains the `FlightRouterState`.\n  // We will copy over the internal state on pushState/replaceState events, but if a history entry\n  // occurred before hydration, or if the user navigated to a hash using a regular anchor link,\n  // the history state will not contain the `FlightRouterState`.\n  // In this case, we'll continue to use the existing tree so the router doesn't get into an invalid state.\n  let treeToRestore: FlightRouterState | undefined\n  let renderedSearch: string | undefined\n  const historyState = action.historyState\n  if (historyState) {\n    treeToRestore = historyState.tree\n    renderedSearch = historyState.renderedSearch\n  } else {\n    treeToRestore = state.tree\n    renderedSearch = state.renderedSearch\n  }\n\n  const currentUrl = new URL(state.canonicalUrl, location.origin)\n  const restoredUrl = action.url\n  const restoredNextUrl =\n    extractPathFromFlightRouterState(treeToRestore) ?? restoredUrl.pathname\n\n  const now = Date.now()\n  const accumulation: NavigationRequestAccumulation = {\n    scrollableSegments: null,\n    separateRefreshUrls: null,\n  }\n  const restoreSeed = convertServerPatchToFullTree(\n    treeToRestore,\n    null,\n    renderedSearch\n  )\n  const task = startPPRNavigation(\n    now,\n    currentUrl,\n    state.renderedSearch,\n    state.cache,\n    state.tree,\n    restoreSeed.routeTree,\n    restoreSeed.metadataVaryPath,\n    FreshnessPolicy.HistoryTraversal,\n    null,\n    null,\n    false,\n    accumulation\n  )\n\n  if (task === null) {\n    return completeHardNavigation(state, restoredUrl, 'replace')\n  }\n  spawnDynamicRequests(\n    task,\n    restoredUrl,\n    restoredNextUrl,\n    FreshnessPolicy.HistoryTraversal,\n    accumulation,\n    // History traversal doesn't use route prediction, so there's no route\n    // cache entry to mark as having a dynamic rewrite on mismatch. If a\n    // mismatch occurs, the retry handler will traverse the known route tree\n    // to find and mark the entry.\n    null\n  )\n  return completeTraverseNavigation(\n    state,\n    restoredUrl,\n    renderedSearch,\n    task.node,\n    task.route,\n    restoredNextUrl\n  )\n}\n"],"names":["extractPathFromFlightRouterState","FreshnessPolicy","spawnDynamicRequests","startPPRNavigation","completeHardNavigation","completeTraverseNavigation","convertServerPatchToFullTree","restoreReducer","state","action","treeToRestore","renderedSearch","historyState","tree","currentUrl","URL","canonicalUrl","location","origin","restoredUrl","url","restoredNextUrl","pathname","now","Date","accumulation","scrollableSegments","separateRefreshUrls","restoreSeed","task","cache","routeTree","metadataVaryPath","HistoryTraversal","node","route"],"mappings":"AAKA,SAASA,gCAAgC,QAAQ,0BAAyB;AAC1E,SACEC,eAAe,EACfC,oBAAoB,EACpBC,kBAAkB,QAEb,qBAAoB;AAE3B,SACEC,sBAAsB,EACtBC,0BAA0B,EAC1BC,4BAA4B,QACvB,iCAAgC;AAEvC,OAAO,SAASC,eACdC,KAA2B,EAC3BC,MAAqB;IAErB,0EAA0E;IAC1E,4FAA4F;IAC5F,gGAAgG;IAChG,6FAA6F;IAC7F,8DAA8D;IAC9D,yGAAyG;IACzG,IAAIC;IACJ,IAAIC;IACJ,MAAMC,eAAeH,OAAOG,YAAY;IACxC,IAAIA,cAAc;QAChBF,gBAAgBE,aAAaC,IAAI;QACjCF,iBAAiBC,aAAaD,cAAc;IAC9C,OAAO;QACLD,gBAAgBF,MAAMK,IAAI;QAC1BF,iBAAiBH,MAAMG,cAAc;IACvC;IAEA,MAAMG,aAAa,IAAIC,IAAIP,MAAMQ,YAAY,EAAEC,SAASC,MAAM;IAC9D,MAAMC,cAAcV,OAAOW,GAAG;IAC9B,MAAMC,kBACJrB,iCAAiCU,kBAAkBS,YAAYG,QAAQ;IAEzE,MAAMC,MAAMC,KAAKD,GAAG;IACpB,MAAME,eAA8C;QAClDC,oBAAoB;QACpBC,qBAAqB;IACvB;IACA,MAAMC,cAActB,6BAClBI,eACA,MACAC;IAEF,MAAMkB,OAAO1B,mBACXoB,KACAT,YACAN,MAAMG,cAAc,EACpBH,MAAMsB,KAAK,EACXtB,MAAMK,IAAI,EACVe,YAAYG,SAAS,EACrBH,YAAYI,gBAAgB,EAC5B/B,gBAAgBgC,gBAAgB,EAChC,MACA,MACA,OACAR;IAGF,IAAII,SAAS,MAAM;QACjB,OAAOzB,uBAAuBI,OAAOW,aAAa;IACpD;IACAjB,qBACE2B,MACAV,aACAE,iBACApB,gBAAgBgC,gBAAgB,EAChCR,cACA,sEAAsE;IACtE,oEAAoE;IACpE,wEAAwE;IACxE,8BAA8B;IAC9B;IAEF,OAAOpB,2BACLG,OACAW,aACAR,gBACAkB,KAAKK,IAAI,EACTL,KAAKM,KAAK,EACVd;AAEJ","ignoreList":[0]}