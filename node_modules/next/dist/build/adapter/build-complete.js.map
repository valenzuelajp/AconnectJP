{"version":3,"sources":["../../../src/build/adapter/build-complete.ts"],"sourcesContent":["import path from 'path'\nimport fs from 'fs/promises'\nimport { pathToFileURL } from 'url'\nimport * as Log from '../output/log'\nimport { isMiddlewareFilename } from '../utils'\nimport { RenderingMode } from '../rendering-mode'\nimport { interopDefault } from '../../lib/interop-default'\nimport type { RouteHas } from '../../lib/load-custom-routes'\nimport { recursiveReadDir } from '../../lib/recursive-readdir'\nimport { isDynamicRoute } from '../../shared/lib/router/utils'\nimport type { Revalidate } from '../../server/lib/cache-control'\nimport type { NextConfigComplete } from '../../server/config-shared'\nimport { normalizeAppPath } from '../../shared/lib/router/utils/app-paths'\nimport { AdapterOutputType, type PHASE_TYPE } from '../../shared/lib/constants'\nimport { normalizePagePath } from '../../shared/lib/page-path/normalize-page-path'\nimport {\n  convertRedirects,\n  convertRewrites,\n  convertHeaders,\n} from 'next/dist/compiled/@vercel/routing-utils'\n\nimport type {\n  MiddlewareManifest,\n  EdgeFunctionDefinition,\n} from '../webpack/plugins/middleware-plugin'\n\nimport type {\n  RoutesManifest,\n  PrerenderManifest,\n  ManifestRewriteRoute,\n  FunctionsConfigManifest,\n  DynamicPrerenderManifestRoute,\n} from '..'\n\nimport {\n  CACHE_ONE_YEAR,\n  HTML_CONTENT_TYPE_HEADER,\n  JSON_CONTENT_TYPE_HEADER,\n  NEXT_RESUME_HEADER,\n} from '../../lib/constants'\n\nimport { normalizeLocalePath } from '../../shared/lib/i18n/normalize-locale-path'\nimport { addPathPrefix } from '../../shared/lib/router/utils/add-path-prefix'\nimport { getRedirectStatus, modifyRouteRegex } from '../../lib/redirect-status'\nimport { getNamedRouteRegex } from '../../shared/lib/router/utils/route-regex'\nimport { escapeStringRegexp } from '../../shared/lib/escape-regexp'\nimport { sortSortableRoutes } from '../../shared/lib/router/utils/sortable-routes'\nimport { generateRoutesManifest } from '../generate-routes-manifest'\n\ninterface SharedRouteFields {\n  /**\n   * id is the unique identifier of the output\n   */\n  id: string\n  /**\n   * filePath is the location on disk of the built entrypoint asset\n   */\n  filePath: string\n  /**\n   * pathname is the URL pathname the asset should be served at\n   */\n  pathname: string\n\n  /**\n   * sourcePage is the original source in the app or pages folder\n   */\n  sourcePage: string\n\n  /**\n   * runtime is which runtime the entrypoint is built for\n   */\n  runtime: 'nodejs' | 'edge'\n  /**\n   * assets are all necessary traced assets that could be\n   * loaded by the output to handle a request e.g. traced\n   * node_modules or necessary manifests for Next.js.\n   * The key is the relative path from the repo root and the value\n   * is the absolute path to the file\n   */\n  assets: Record<string, string>\n\n  /**\n   * wasmAssets are bundled wasm files with mapping of name\n   * to filePath on disk\n   */\n  wasmAssets?: Record<string, string>\n\n  /**\n   * config related to the route\n   */\n  config: {\n    /**\n     * maxDuration is a segment config to signal the max\n     * execution duration a route should be allowed before\n     * it's timed out\n     */\n    maxDuration?: number\n    /**\n     * preferredRegion is a segment config to signal deployment\n     * region preferences to the provider being used\n     */\n    preferredRegion?: string | string[]\n\n    /**\n     * env is the environment variables to expose, this is only\n     * populated for edge runtime currently\n     */\n    env?: Record<string, string>\n  }\n}\n\nexport interface AdapterOutput {\n  /**\n   * `PAGES` represents all the React pages that are under `pages/`.\n   */\n  PAGES: SharedRouteFields & {\n    type: AdapterOutputType.PAGES\n  }\n\n  /**\n   * `PAGES_API` represents all the API routes under `pages/api/`.\n   */\n  PAGES_API: SharedRouteFields & {\n    type: AdapterOutputType.PAGES_API\n  }\n  /**\n   * `APP_PAGE` represents all the React pages that are under `app/` with the\n   * filename of `page.{j,t}s{,x}`.\n   */\n  APP_PAGE: SharedRouteFields & {\n    type: AdapterOutputType.APP_PAGE\n  }\n\n  /**\n   * `APP_ROUTE` represents all the API routes and metadata routes that are under `app/` with the\n   * filename of `route.{j,t}s{,x}`.\n   */\n  APP_ROUTE: SharedRouteFields & {\n    type: AdapterOutputType.APP_ROUTE\n  }\n\n  /**\n   * `PRERENDER` represents an ISR enabled route that might\n   * have a seeded cache entry or fallback generated during build\n   */\n  PRERENDER: {\n    id: string\n    pathname: string\n    type: AdapterOutputType.PRERENDER\n\n    /**\n     * For prerenders the parent output is the originating\n     * page that the prerender is created from\n     */\n    parentOutputId: string\n\n    /**\n     * groupId is the identifier for a group of prerenders that should be\n     * revalidated together\n     */\n    groupId: number\n\n    pprChain?: {\n      headers: Record<string, string>\n    }\n\n    /**\n     * parentFallbackMode signals whether additional routes can be generated\n     * e.g. fallback: false or 'blocking' in getStaticPaths in pages router\n     */\n    parentFallbackMode?: DynamicPrerenderManifestRoute['fallback']\n\n    /**\n     * fallback is initial cache data generated during build for a prerender\n     */\n    fallback?: {\n      /**\n       * path to the fallback file can be HTML/JSON/RSC,\n       */\n      filePath: string | undefined\n      /**\n       * initialStatus is the status code that should be applied\n       * when serving the fallback\n       */\n      initialStatus?: number\n      /**\n       * initialHeaders are the headers that should be sent when\n       * serving the fallback\n       */\n      initialHeaders?: Record<string, string | string[]>\n      /**\n       * initial expiration is how long until the fallback entry\n       * is considered expired and no longer valid to serve\n       */\n      initialExpiration?: number\n      /**\n       * initial revalidate is how long until the fallback is\n       * considered stale and should be revalidated\n       */\n      initialRevalidate?: Revalidate\n\n      /**\n       * postponedState is the PPR state when it postponed and is used for resuming\n       */\n      postponedState: string | undefined\n    }\n\n    /**\n     * config related to the route\n     */\n    config: {\n      /**\n       * allowQuery is the allowed query values to be passed\n       * to an ISR function and what should be considered for the cacheKey\n       * e.g. for /blog/[slug], \"slug\" is the only allowQuery\n       */\n      allowQuery?: string[]\n      /**\n       * allowHeader is the allowed headers to be passed to an\n       * ISR function to prevent accidentally poisoning the cache\n       * from leaking additional information that can impact the render\n       */\n      allowHeader?: string[]\n      /**\n       * bypass for is a list of has conditions the cache\n       * should be bypassed and invoked directly e.g. action header\n       */\n      bypassFor?: RouteHas[]\n      /**\n       * renderingMode signals PPR or not for a prerender\n       */\n      renderingMode?: RenderingMode\n\n      /**\n       * bypassToken is the generated token that signals a prerender cache\n       * should be bypassed\n       */\n      bypassToken?: string\n    }\n  }\n\n  /**\n   * `STATIC_FILE` represents a static file (ie /_next/static) or a purely\n   * static HTML asset e.g. an automatically statically optimized page\n   * that does not use ISR\n   */\n  STATIC_FILE: {\n    id: string\n    filePath: string\n    pathname: string\n    type: AdapterOutputType.STATIC_FILE\n  }\n\n  /**\n   * `MIDDLEWARE` represents the middleware output if present\n   */\n  MIDDLEWARE: SharedRouteFields & {\n    type: AdapterOutputType.MIDDLEWARE\n    /**\n     * config related to the route\n     */\n    config: SharedRouteFields['config'] & {\n      /**\n       * matchers are the configured matchers for middleware\n       */\n      matchers?: Array<{\n        source: string\n        sourceRegex: string\n        has: RouteHas[] | undefined\n        missing: RouteHas[] | undefined\n      }>\n    }\n  }\n}\n\nexport interface AdapterOutputs {\n  pages: Array<AdapterOutput['PAGES']>\n  middleware?: AdapterOutput['MIDDLEWARE']\n  appPages: Array<AdapterOutput['APP_PAGE']>\n  pagesApi: Array<AdapterOutput['PAGES_API']>\n  appRoutes: Array<AdapterOutput['APP_ROUTE']>\n  prerenders: Array<AdapterOutput['PRERENDER']>\n  staticFiles: Array<AdapterOutput['STATIC_FILE']>\n}\n\ntype RewriteItem = {\n  source: string\n  sourceRegex: string\n  destination: string\n  has: RouteHas[] | undefined\n  missing: RouteHas[] | undefined\n}\n\ntype DynamicRouteItem = {\n  source: string\n  sourceRegex: string\n  destination: string\n  has: RouteHas[] | undefined\n  missing: RouteHas[] | undefined\n}\n\ntype Route = {\n  // regex as string can have named or un-named matches\n  source?: string\n  sourceRegex: string\n  // destination can have matches to replace in destination\n  // keyed by $1 for un-named and $name for named\n  destination?: string\n  headers?: Record<string, string>\n  has?: RouteHas[]\n  missing?: RouteHas[]\n  status?: number\n  priority?: boolean\n}\n\nexport interface NextAdapter {\n  name: string\n  /**\n   * modifyConfig is called for any CLI command that loads the next.config\n   * to only apply for specific commands the \"phase\" should be used\n   * @param config\n   * @param ctx\n   * @returns\n   */\n  modifyConfig?: (\n    config: NextConfigComplete,\n    ctx: {\n      phase: PHASE_TYPE\n    }\n  ) => Promise<NextConfigComplete> | NextConfigComplete\n  onBuildComplete?: (ctx: {\n    routing: {\n      beforeMiddleware: Array<Route>\n      beforeFiles: Array<Route>\n      afterFiles: Array<Route>\n      dynamicRoutes: Array<Route>\n      onMatch: Array<Route>\n      fallback: Array<Route>\n      /**\n       * shouldNormalizeNextData indicates whether Next.js data URLs\n       * (e.g., /_next/data/BUILD_ID/page.json) should be normalized\n       * during route resolution. This is true when middleware is present\n       * and there are pages router items to resolve.\n       */\n      shouldNormalizeNextData: boolean\n      rsc: RoutesManifest['rsc']\n    }\n    outputs: AdapterOutputs\n    /**\n     * projectDir is the absolute directory the Next.js application is in\n     */\n    projectDir: string\n    /**\n     * repoRoot is the absolute path of the detected root of the repo\n     */\n    repoRoot: string\n    /**\n     * distDir is the absolute path to the dist directory\n     */\n    distDir: string\n    /**\n     * config is the loaded next.config (has modifyConfig applied)\n     */\n    config: NextConfigComplete\n    /**\n     * nextVersion is the current version of Next.js being used\n     */\n    nextVersion: string\n    /**\n     * buildId is the current unique ID for the build, this can be\n     * influenced by NextConfig.generateBuildId\n     */\n    buildId: string\n  }) => Promise<void> | void\n}\n\nfunction normalizePathnames(\n  config: NextConfigComplete,\n  outputs: AdapterOutputs\n) {\n  // normalize pathname field with basePath\n  if (config.basePath) {\n    for (const output of [\n      ...outputs.pages,\n      ...outputs.pagesApi,\n      ...outputs.appPages,\n      ...outputs.appRoutes,\n      ...outputs.prerenders,\n      ...outputs.staticFiles,\n    ]) {\n      output.pathname =\n        addPathPrefix(output.pathname, config.basePath).replace(/\\/$/, '') ||\n        '/'\n    }\n  }\n}\n\nexport async function handleBuildComplete({\n  dir,\n  config,\n  appType,\n  buildId,\n  configOutDir,\n  distDir,\n  pageKeys,\n  tracingRoot,\n  adapterPath,\n  appPageKeys,\n  staticPages,\n  nextVersion,\n  hasStatic404,\n  hasStatic500,\n  routesManifest,\n  serverPropsPages,\n  hasNodeMiddleware,\n  prerenderManifest,\n  middlewareManifest,\n  requiredServerFiles,\n  hasInstrumentationHook,\n  functionsConfigManifest,\n}: {\n  dir: string\n  appType: 'app' | 'pages' | 'hybrid'\n  distDir: string\n  buildId: string\n  configOutDir: string\n  adapterPath: string\n  tracingRoot: string\n  nextVersion: string\n  hasStatic404: boolean\n  hasStatic500: boolean\n  staticPages: Set<string>\n  hasNodeMiddleware: boolean\n  config: NextConfigComplete\n  pageKeys: readonly string[]\n  serverPropsPages: Set<string>\n  requiredServerFiles: string[]\n  routesManifest: RoutesManifest\n  hasInstrumentationHook: boolean\n  prerenderManifest: PrerenderManifest\n  middlewareManifest: MiddlewareManifest\n  appPageKeys?: readonly string[] | undefined\n  functionsConfigManifest: FunctionsConfigManifest\n}) {\n  const adapterMod = interopDefault(\n    await import(pathToFileURL(require.resolve(adapterPath)).href)\n  ) as NextAdapter\n\n  if (typeof adapterMod.onBuildComplete === 'function') {\n    const outputs: AdapterOutputs = {\n      pages: [],\n      pagesApi: [],\n      appPages: [],\n      appRoutes: [],\n      prerenders: [],\n      staticFiles: [],\n    }\n\n    if (config.output === 'export') {\n      // collect export assets and provide as static files\n      const exportFiles = await recursiveReadDir(configOutDir)\n\n      for (const file of exportFiles) {\n        let pathname = (\n          file.endsWith('.html') ? file.replace(/\\.html$/, '') : file\n        ).replace(/\\\\/g, '/')\n\n        pathname = pathname.startsWith('/') ? pathname : `/${pathname}`\n\n        outputs.staticFiles.push({\n          id: file,\n          pathname,\n          filePath: path.join(configOutDir, file),\n          type: AdapterOutputType.STATIC_FILE,\n        } satisfies AdapterOutput['STATIC_FILE'])\n      }\n    } else {\n      const staticFiles = await recursiveReadDir(path.join(distDir, 'static'))\n\n      for (const file of staticFiles) {\n        const pathname = path.posix.join('/_next/static', file)\n        const filePath = path.join(distDir, 'static', file)\n        outputs.staticFiles.push({\n          type: AdapterOutputType.STATIC_FILE,\n          id: path.join('static', file),\n          pathname,\n          filePath,\n        })\n      }\n\n      const sharedNodeAssets: Record<string, string> = {}\n\n      for (const file of requiredServerFiles) {\n        // add to shared node assets\n        const filePath = path.join(dir, file)\n        const fileOutputPath = path.relative(tracingRoot, filePath)\n        sharedNodeAssets[fileOutputPath] = filePath\n      }\n      // add \"next/setup-node-env\" stub so it can be required via\n      // TODO: should we make this always available without adapters\n      const setupNodeStubPath = path.join(\n        path.dirname(require.resolve('next/package.json')),\n        'setup-node-env.js'\n      )\n      sharedNodeAssets[path.relative(tracingRoot, setupNodeStubPath)] =\n        require.resolve('next/dist/build/adapter/setup-node-env.external')\n\n      if (hasInstrumentationHook) {\n        const assets = await handleTraceFiles(\n          path.join(distDir, 'server', 'instrumentation.js.nft.json')\n        )\n        const fileOutputPath = path.relative(\n          tracingRoot,\n          path.join(distDir, 'server', 'instrumentation.js')\n        )\n        sharedNodeAssets[fileOutputPath] = path.join(\n          distDir,\n          'server',\n          'instrumentation.js'\n        )\n        Object.assign(sharedNodeAssets, assets)\n      }\n\n      async function handleTraceFiles(\n        traceFilePath: string\n      ): Promise<Record<string, string>> {\n        const assets: Record<string, string> = Object.assign(\n          {},\n          sharedNodeAssets\n        )\n        const traceData = JSON.parse(\n          await fs.readFile(traceFilePath, 'utf8')\n        ) as {\n          files: string[]\n        }\n        const traceFileDir = path.dirname(traceFilePath)\n\n        for (const relativeFile of traceData.files) {\n          const tracedFilePath = path.join(traceFileDir, relativeFile)\n          const fileOutputPath = path.relative(tracingRoot, tracedFilePath)\n          assets[fileOutputPath] = tracedFilePath\n        }\n        return assets\n      }\n\n      async function handleEdgeFunction(\n        page: EdgeFunctionDefinition,\n        isMiddleware: boolean = false\n      ) {\n        let type: AdapterOutputType = AdapterOutputType.PAGES\n        const isAppPrefix = page.name.startsWith('app/')\n        const isAppPage = isAppPrefix && page.name.endsWith('/page')\n        const isAppRoute = isAppPrefix && page.name.endsWith('/route')\n        let currentOutputs: Array<\n          | AdapterOutput['PAGES']\n          | AdapterOutput['PAGES_API']\n          | AdapterOutput['APP_PAGE']\n          | AdapterOutput['APP_ROUTE']\n        > = outputs.pages\n\n        if (isMiddleware) {\n          type = AdapterOutputType.MIDDLEWARE\n        } else if (isAppPage) {\n          currentOutputs = outputs.appPages\n          type = AdapterOutputType.APP_PAGE\n        } else if (isAppRoute) {\n          currentOutputs = outputs.appRoutes\n          type = AdapterOutputType.APP_ROUTE\n        } else if (page.page.startsWith('/api')) {\n          currentOutputs = outputs.pagesApi\n          type = AdapterOutputType.PAGES_API\n        }\n\n        const route = page.page.replace(/^(app|pages)\\//, '')\n\n        const output: Omit<AdapterOutput[typeof type], 'type'> & {\n          type: any\n        } = {\n          type,\n          id: page.name,\n          runtime: 'edge',\n          sourcePage: route,\n          pathname: isAppPrefix ? normalizeAppPath(route) : route,\n          filePath: path.join(\n            distDir,\n            page.files.find(\n              (item) =>\n                item.startsWith('server/app') || item.startsWith('server/pages')\n            ) ||\n              // TODO: turbopack build doesn't name the main entry chunk\n              // identifiably so we don't know which to mark here but\n              // technically edge needs all chunks to load always so\n              // should this field even be provided?\n              page.files[0] ||\n              ''\n          ),\n          assets: {},\n          wasmAssets: {},\n          config: {\n            env: page.env,\n          },\n        }\n\n        function handleFile(file: string) {\n          const originalPath = path.join(distDir, file)\n          const fileOutputPath = path.relative(\n            config.distDir,\n            path.join(path.relative(tracingRoot, distDir), file)\n          )\n          if (!output.assets) {\n            output.assets = {}\n          }\n          output.assets[fileOutputPath] = originalPath\n        }\n        for (const file of page.files) {\n          handleFile(file)\n        }\n        for (const item of [...(page.assets || [])]) {\n          if (!output.assets) {\n            output.assets = {}\n          }\n          output.assets[item.name] = path.join(distDir, item.filePath)\n        }\n        for (const item of page.wasm || []) {\n          if (!output.wasmAssets) {\n            output.wasmAssets = {}\n          }\n          output.wasmAssets[item.name] = path.join(distDir, item.filePath)\n        }\n\n        if (type === AdapterOutputType.MIDDLEWARE) {\n          ;(output as AdapterOutput['MIDDLEWARE']).config.matchers =\n            page.matchers.map((item) => {\n              return {\n                source: item.originalSource,\n                sourceRegex: item.regexp,\n                has: item.has,\n                missing: [\n                  ...(item.missing || []),\n                  // always skip middleware for on-demand revalidate\n                  {\n                    type: 'header',\n                    key: 'x-prerender-revalidate',\n                    value: prerenderManifest.preview.previewModeId,\n                  },\n                ],\n              }\n            })\n          output.pathname = '/_middleware'\n          output.id = page.name\n          outputs.middleware = output\n        } else {\n          currentOutputs.push(output)\n        }\n\n        // need to add matching .rsc output\n        if (isAppPage) {\n          const rscPathname = normalizePagePath(output.pathname) + '.rsc'\n          outputs.appPages.push({\n            ...output,\n            pathname: rscPathname,\n            id: page.name + '.rsc',\n          })\n        } else if (serverPropsPages.has(route === '/index' ? '/' : route)) {\n          const nextDataPath = path.posix.join(\n            '/_next/data/',\n            buildId,\n            normalizePagePath(output.pathname) + '.json'\n          )\n          outputs.appPages.push({\n            ...output,\n            pathname: nextDataPath,\n            id: page.name,\n          })\n        }\n      }\n\n      const edgeFunctionHandlers: Promise<any>[] = []\n\n      for (const middleware of Object.values(middlewareManifest.middleware)) {\n        if (isMiddlewareFilename(middleware.name)) {\n          edgeFunctionHandlers.push(handleEdgeFunction(middleware, true))\n        }\n      }\n\n      for (const page of Object.values(middlewareManifest.functions)) {\n        edgeFunctionHandlers.push(handleEdgeFunction(page))\n      }\n      const pagesDistDir = path.join(distDir, 'server', 'pages')\n      const pageOutputMap: Record<\n        string,\n        AdapterOutput['PAGES'] | AdapterOutput['PAGES_API']\n      > = {}\n\n      const rscFallbackPath = path.join(distDir, 'server', 'rsc-fallback.json')\n\n      if (appPageKeys && appPageKeys.length > 0 && pageKeys.length > 0) {\n        await fs.writeFile(rscFallbackPath, '{}')\n      }\n\n      for (const page of pageKeys) {\n        if (page === '/_app' || page === '/_document') {\n          continue\n        }\n\n        if (middlewareManifest.functions.hasOwnProperty(page)) {\n          continue\n        }\n\n        const route = normalizePagePath(page)\n        const pageFile = path.join(pagesDistDir, `${route}.js`)\n\n        // if it's an auto static optimized page it's just\n        // a static file\n        if (staticPages.has(page)) {\n          if (config.i18n) {\n            for (const locale of config.i18n.locales || []) {\n              const localePage =\n                page === '/' ? `/${locale}` : addPathPrefix(page, `/${locale}`)\n\n              const localeOutput = {\n                id: localePage,\n                pathname: localePage,\n                type: AdapterOutputType.STATIC_FILE,\n                filePath: path.join(\n                  pagesDistDir,\n                  `${normalizePagePath(localePage)}.html`\n                ),\n              } satisfies AdapterOutput['STATIC_FILE']\n\n              outputs.staticFiles.push(localeOutput)\n\n              if (appPageKeys && appPageKeys.length > 0) {\n                outputs.staticFiles.push({\n                  id: `${localePage}.rsc`,\n                  pathname: `${localePage}.rsc`,\n                  type: AdapterOutputType.STATIC_FILE,\n                  filePath: rscFallbackPath,\n                })\n              }\n            }\n          } else {\n            const staticOutput = {\n              id: page,\n              pathname: route,\n              type: AdapterOutputType.STATIC_FILE,\n              filePath: pageFile.replace(/\\.js$/, '.html'),\n            } satisfies AdapterOutput['STATIC_FILE']\n\n            outputs.staticFiles.push(staticOutput)\n\n            if (appPageKeys && appPageKeys.length > 0) {\n              outputs.staticFiles.push({\n                id: `${page}.rsc`,\n                pathname: `${route}.rsc`,\n                type: AdapterOutputType.STATIC_FILE,\n                filePath: rscFallbackPath,\n              })\n            }\n          }\n          // if was a static file output don't create page output as well\n          continue\n        }\n\n        const pageTraceFile = `${pageFile}.nft.json`\n        const assets = await handleTraceFiles(pageTraceFile).catch((err) => {\n          if (err.code !== 'ENOENT' || (page !== '/404' && page !== '/500')) {\n            Log.warn(`Failed to locate traced assets for ${pageFile}`, err)\n          }\n          return {} as Record<string, string>\n        })\n        const functionConfig = functionsConfigManifest.functions[route] || {}\n        let sourcePage = route.replace(/^\\//, '')\n\n        sourcePage = sourcePage === 'api' ? 'api/index' : sourcePage\n\n        const output: AdapterOutput['PAGES'] | AdapterOutput['PAGES_API'] = {\n          id: route,\n          type: page.startsWith('/api')\n            ? AdapterOutputType.PAGES_API\n            : AdapterOutputType.PAGES,\n          filePath: pageTraceFile.replace(/\\.nft\\.json$/, ''),\n          pathname: route,\n          sourcePage,\n          assets,\n          runtime: 'nodejs',\n          config: {\n            maxDuration: functionConfig.maxDuration,\n            preferredRegion: functionConfig.regions,\n          },\n        }\n        pageOutputMap[page] = output\n\n        if (output.type === AdapterOutputType.PAGES) {\n          outputs.pages.push(output)\n\n          // if page is get server side props we need to create\n          // the _next/data output as well\n          if (serverPropsPages.has(page)) {\n            const dataPathname = path.posix.join(\n              '/_next/data',\n              buildId,\n              normalizePagePath(page) + '.json'\n            )\n            outputs.pages.push({\n              ...output,\n              pathname: dataPathname,\n              id: dataPathname,\n            })\n\n            if (appPageKeys && appPageKeys.length > 0) {\n              const rscPage = `${page === '/' ? '/index' : page}.rsc`\n              outputs.staticFiles.push({\n                id: rscPage,\n                pathname: rscPage,\n                type: AdapterOutputType.STATIC_FILE,\n                filePath: rscFallbackPath,\n              })\n            }\n          }\n\n          for (const locale of config.i18n?.locales || []) {\n            const localePage =\n              page === '/' ? `/${locale}` : addPathPrefix(page, `/${locale}`)\n\n            outputs.pages.push({\n              ...output,\n              id: localePage,\n              pathname: localePage,\n            })\n\n            if (serverPropsPages.has(page)) {\n              const dataPathname = path.posix.join(\n                '/_next/data',\n                buildId,\n                localePage + '.json'\n              )\n              outputs.pages.push({\n                ...output,\n                pathname: dataPathname,\n                id: dataPathname,\n              })\n              if (appPageKeys && appPageKeys.length > 0) {\n                outputs.staticFiles.push({\n                  id: `${localePage}.rsc`,\n                  pathname: `${localePage}.rsc`,\n                  type: AdapterOutputType.STATIC_FILE,\n                  filePath: rscFallbackPath,\n                })\n              }\n            }\n          }\n        } else {\n          outputs.pagesApi.push(output)\n        }\n      }\n\n      if (hasNodeMiddleware) {\n        const middlewareFile = path.join(distDir, 'server', 'middleware.js')\n        const middlewareTrace = `${middlewareFile}.nft.json`\n        const assets = await handleTraceFiles(middlewareTrace)\n        const functionConfig =\n          functionsConfigManifest.functions['/_middleware'] || {}\n\n        outputs.middleware = {\n          pathname: '/_middleware',\n          id: '/_middleware',\n          sourcePage: 'middleware',\n          assets,\n          type: AdapterOutputType.MIDDLEWARE,\n          runtime: 'nodejs',\n          filePath: middlewareFile,\n          config: {\n            matchers:\n              functionConfig.matchers?.map((item) => {\n                return {\n                  source: item.originalSource,\n                  sourceRegex: item.regexp,\n                  has: item.has,\n                  missing: [\n                    ...(item.missing || []),\n                    // always skip middleware for on-demand revalidate\n                    {\n                      type: 'header',\n                      key: 'x-prerender-revalidate',\n                      value: prerenderManifest.preview.previewModeId,\n                    },\n                  ],\n                }\n              }) || [],\n          },\n        } satisfies AdapterOutput['MIDDLEWARE']\n      }\n      const appOutputMap: Record<\n        string,\n        AdapterOutput['APP_PAGE'] | AdapterOutput['APP_ROUTE']\n      > = {}\n      const appDistDir = path.join(distDir, 'server', 'app')\n\n      if (appPageKeys) {\n        for (const page of appPageKeys) {\n          if (middlewareManifest.functions.hasOwnProperty(page)) {\n            continue\n          }\n          const normalizedPage = normalizeAppPath(page)\n          const pageFile = path.join(appDistDir, `${page}.js`)\n          const pageTraceFile = `${pageFile}.nft.json`\n          const assets = await handleTraceFiles(pageTraceFile).catch((err) => {\n            Log.warn(`Failed to copy traced files for ${pageFile}`, err)\n            return {} as Record<string, string>\n          })\n\n          // If this is a parallel route we just need to merge\n          // the assets as they share the same pathname\n          const existingOutput = appOutputMap[normalizedPage]\n          if (existingOutput) {\n            Object.assign(existingOutput.assets, assets)\n            existingOutput.assets[path.relative(tracingRoot, pageFile)] =\n              pageFile\n\n            continue\n          }\n\n          const functionConfig =\n            functionsConfigManifest.functions[normalizedPage] || {}\n\n          const output: AdapterOutput['APP_PAGE'] | AdapterOutput['APP_ROUTE'] =\n            {\n              pathname: normalizedPage,\n              id: normalizedPage,\n              sourcePage: page,\n              assets,\n              type: page.endsWith('/route')\n                ? AdapterOutputType.APP_ROUTE\n                : AdapterOutputType.APP_PAGE,\n              runtime: 'nodejs',\n              filePath: pageFile,\n              config: {\n                maxDuration: functionConfig.maxDuration,\n                preferredRegion: functionConfig.regions,\n              },\n            }\n          appOutputMap[normalizedPage] = output\n\n          if (output.type === AdapterOutputType.APP_PAGE) {\n            outputs.appPages.push({\n              ...output,\n              pathname: normalizePagePath(output.pathname) + '.rsc',\n              id: normalizePagePath(output.pathname) + '.rsc',\n            })\n            outputs.appPages.push(output)\n          } else {\n            outputs.appRoutes.push(output)\n            outputs.appRoutes.push({\n              ...output,\n              pathname: normalizePagePath(output.pathname) + '.rsc',\n              id: normalizePagePath(output.pathname) + '.rsc',\n            })\n          }\n        }\n      }\n\n      const getParentOutput = (\n        srcRoute: string,\n        childRoute: string,\n        allowMissing?: boolean\n      ) => {\n        const normalizedSrcRoute = normalizeLocalePath(\n          srcRoute,\n          config.i18n?.locales || []\n        ).pathname\n        const parentOutput =\n          pageOutputMap[normalizedSrcRoute] || appOutputMap[normalizedSrcRoute]\n\n        if (!parentOutput && !allowMissing) {\n          console.error({\n            appOutputs: Object.keys(appOutputMap),\n            pageOutputs: Object.keys(pageOutputMap),\n          })\n          throw new Error(\n            `Invariant: failed to find source route ${srcRoute} for prerender ${childRoute}`\n          )\n        }\n        return parentOutput\n      }\n\n      const {\n        prefetchSegmentDirSuffix,\n        prefetchSegmentSuffix,\n        varyHeader,\n        didPostponeHeader,\n        contentTypeHeader: rscContentTypeHeader,\n      } = routesManifest.rsc\n\n      const handleAppMeta = async (\n        route: string,\n        initialOutput: AdapterOutput['PRERENDER'],\n        meta: AppRouteMeta,\n        ctx: {\n          htmlAllowQuery?: string[]\n          dataAllowQuery?: string[]\n        }\n      ) => {\n        if (meta.postponed && initialOutput.fallback) {\n          initialOutput.fallback.postponedState = meta.postponed\n        }\n\n        if (meta?.segmentPaths) {\n          const normalizedRoute = normalizePagePath(route)\n          const segmentsDir = path.join(\n            appDistDir,\n            `${normalizedRoute}${prefetchSegmentDirSuffix}`\n          )\n\n          // If client param parsing is enabled, we follow the same logic as\n          // the HTML allowQuery as it's already going to vary based on if\n          // there's a static shell generated or if there's fallback root\n          // params. If there are fallback root params, and we can serve a\n          // fallback, then we should follow the same logic for the segment\n          // prerenders.\n          //\n          // If client param parsing is not enabled, we have to use the\n          // allowQuery because the segment payloads will contain dynamic\n          // segment values.\n          const segmentAllowQuery = routesManifest.rsc.clientParamParsing\n            ? ctx.htmlAllowQuery\n            : ctx.dataAllowQuery\n\n          for (const segmentPath of meta.segmentPaths) {\n            const outputSegmentPath =\n              path.join(\n                normalizedRoute + prefetchSegmentDirSuffix,\n                segmentPath\n              ) + prefetchSegmentSuffix\n\n            // Only use the fallback value when the allowQuery is defined and\n            // either: (1) it is empty, meaning segments do not vary by params,\n            // or (2) client param parsing is enabled, meaning the segment\n            // payloads are safe to reuse across params.\n            const shouldAttachSegmentFallback =\n              segmentAllowQuery &&\n              (segmentAllowQuery.length === 0 ||\n                routesManifest.rsc.clientParamParsing)\n\n            const fallbackPathname = shouldAttachSegmentFallback\n              ? path.join(segmentsDir, segmentPath + prefetchSegmentSuffix)\n              : undefined\n\n            outputs.prerenders.push({\n              id: outputSegmentPath,\n              pathname: outputSegmentPath,\n              type: AdapterOutputType.PRERENDER,\n              parentOutputId: initialOutput.parentOutputId,\n              groupId: initialOutput.groupId,\n\n              config: {\n                ...initialOutput.config,\n                bypassFor: undefined,\n              },\n\n              fallback: {\n                filePath: fallbackPathname,\n                postponedState: undefined,\n                initialExpiration: initialOutput.fallback?.initialExpiration,\n                initialRevalidate: initialOutput.fallback?.initialRevalidate,\n\n                initialHeaders: {\n                  ...meta.headers,\n                  ...initialOutput.fallback?.initialHeaders,\n                  vary: varyHeader,\n                  'content-type': rscContentTypeHeader,\n                  [didPostponeHeader]: '2',\n                },\n              },\n            } satisfies AdapterOutput['PRERENDER'])\n          }\n        }\n      }\n\n      let prerenderGroupId = 1\n\n      type AppRouteMeta = {\n        segmentPaths?: string[]\n        postponed?: string\n        headers?: Record<string, string>\n        status?: number\n      }\n\n      const getAppRouteMeta = async (\n        route: string,\n        isAppPage: boolean\n      ): Promise<AppRouteMeta> => {\n        const basename = route.endsWith('/') ? `${route}index` : route\n        const meta: AppRouteMeta = isAppPage\n          ? JSON.parse(\n              await fs\n                .readFile(path.join(appDistDir, `${basename}.meta`), 'utf8')\n                .catch(() => '{}')\n            )\n          : {}\n\n        if (meta.headers) {\n          // normalize these for consistency\n          for (const key of Object.keys(meta.headers)) {\n            const keyLower = key.toLowerCase()\n            let value = meta.headers[key]\n\n            // normalize values to strings (e.g. set-cookie can be an array)\n            if (Array.isArray(value)) {\n              value = value.join(', ')\n            } else if (typeof value !== 'string') {\n              value = String(value)\n            }\n\n            if (keyLower !== key) {\n              delete meta.headers[key]\n            }\n            meta.headers[keyLower] = value\n          }\n        }\n\n        return meta\n      }\n\n      const filePathCache = new Map<string, Promise<boolean>>()\n      const cachedFilePathCheck = async (filePath: string) => {\n        if (filePathCache.has(filePath)) {\n          return filePathCache.get(filePath)\n        }\n        const newCheck = fs\n          .access(filePath)\n          .then(() => true)\n          .catch(() => false)\n        filePathCache.set(filePath, newCheck)\n\n        return newCheck\n      }\n\n      for (const route in prerenderManifest.routes) {\n        const {\n          initialExpireSeconds: initialExpiration,\n          initialRevalidateSeconds: initialRevalidate,\n          initialHeaders,\n          initialStatus,\n          dataRoute,\n          prefetchDataRoute,\n          renderingMode,\n          allowHeader,\n          experimentalBypassFor,\n        } = prerenderManifest.routes[route]\n\n        const srcRoute = prerenderManifest.routes[route].srcRoute || route\n        const srcRouteInfo = prerenderManifest.dynamicRoutes[srcRoute]\n\n        const isAppPage =\n          Boolean(appOutputMap[srcRoute]) || srcRoute === '/_not-found'\n\n        // if we already have 404.html favor that instead of\n        // _not-found prerender\n        if (srcRoute === '/_not-found' && hasStatic404) {\n          continue\n        }\n\n        const isNotFoundTrue = prerenderManifest.notFoundRoutes.includes(route)\n\n        let allowQuery: string[] | undefined\n        const routeKeys = routesManifest.dynamicRoutes.find(\n          (item) => item.page === srcRoute\n        )?.routeKeys\n\n        if (!isDynamicRoute(route)) {\n          // for non-dynamic routes we use an empty array since\n          // no query values bust the cache for non-dynamic prerenders\n          // prerendered paths also do not pass allowQuery as they match\n          // during handle: 'filesystem' so should not cache differently\n          // by query values\n          allowQuery = []\n        } else if (routeKeys) {\n          // if we have routeKeys in the routes-manifest we use those\n          // for allowQuery for dynamic routes\n          allowQuery = Object.values(routeKeys)\n        }\n\n        let filePath = path.join(\n          isAppPage ? appDistDir : pagesDistDir,\n          `${normalizePagePath(route)}.${isAppPage && !dataRoute ? 'body' : 'html'}`\n        )\n\n        // we use the static 404 for notFound: true if available\n        // if not we do a blocking invoke on first request\n        if (isNotFoundTrue && hasStatic404) {\n          const locale =\n            config.i18n &&\n            normalizeLocalePath(route, config.i18n?.locales).detectedLocale\n\n          for (const currentFilePath of [\n            path.join(pagesDistDir, locale || '', '404.html'),\n            path.join(pagesDistDir, '404.html'),\n          ]) {\n            if (await cachedFilePathCheck(currentFilePath)) {\n              filePath = currentFilePath\n              break\n            }\n          }\n        }\n\n        const meta = await getAppRouteMeta(route, isAppPage)\n\n        let htmlAllowQuery = allowQuery\n        let dataAllowQuery = allowQuery\n        const dataInitialHeaders: Record<string, string> = {}\n\n        // We additionally vary based on if there's a postponed prerender\n        // because if there isn't, then that means that we generated an\n        // empty shell, and producing an empty RSC shell would be a waste.\n        // If there is a postponed prerender, then the RSC shell would be\n        // non-empty, and it would be valuable to also generate an empty\n        // RSC shell.\n        if (meta.postponed) {\n          htmlAllowQuery = []\n\n          if (routesManifest.rsc.dynamicRSCPrerender) {\n            // If client param parsing is enabled, we follow the same logic as the\n            // HTML allowQuery as it's already going to vary based on if there's a\n            // static shell generated or if there's fallback root params. If there\n            // are fallback root params, and we can serve a fallback, then we\n            // should follow the same logic for the dynamic RSC routes.\n            //\n            // If client param parsing is not enabled, we have to use the\n            // allowQuery because the RSC payloads will contain dynamic segment\n            // values.\n            if (routesManifest.rsc.clientParamParsing) {\n              dataAllowQuery = htmlAllowQuery\n            }\n          }\n        }\n\n        if (renderingMode === RenderingMode.PARTIALLY_STATIC) {\n          // Dynamic RSC requests cannot be cached, so we explicity set it\n          // here to ensure that the response is not cached by the browser.\n          dataInitialHeaders['cache-control'] =\n            'private, no-store, no-cache, max-age=0, must-revalidate'\n        }\n\n        const initialOutput: AdapterOutput['PRERENDER'] = {\n          id: route,\n          type: AdapterOutputType.PRERENDER,\n          pathname: route,\n          parentOutputId:\n            srcRoute === '/_not-found'\n              ? srcRoute\n              : getParentOutput(srcRoute, route).id,\n          groupId: prerenderGroupId,\n\n          pprChain:\n            isAppPage && renderingMode === RenderingMode.PARTIALLY_STATIC\n              ? {\n                  headers: {\n                    [NEXT_RESUME_HEADER]: '1',\n                  },\n                }\n              : undefined,\n\n          parentFallbackMode: srcRouteInfo?.fallback,\n\n          fallback:\n            !isNotFoundTrue || (isNotFoundTrue && hasStatic404)\n              ? {\n                  filePath,\n                  postponedState: undefined,\n                  initialStatus:\n                    initialStatus ??\n                    meta.status ??\n                    (isNotFoundTrue ? 404 : undefined),\n                  initialHeaders: {\n                    ...initialHeaders,\n                    vary: varyHeader,\n                    'content-type': HTML_CONTENT_TYPE_HEADER,\n                    ...meta.headers,\n                  },\n                  initialExpiration,\n                  initialRevalidate:\n                    typeof initialRevalidate === 'undefined'\n                      ? 1\n                      : initialRevalidate,\n                }\n              : undefined,\n          config: {\n            allowQuery,\n            allowHeader,\n            renderingMode,\n            bypassFor:\n              isAppPage && srcRoute !== '/_not-found'\n                ? experimentalBypassFor\n                : undefined,\n            bypassToken: prerenderManifest.preview.previewModeId,\n          },\n        }\n        outputs.prerenders.push(initialOutput)\n\n        if (!isAppPage && appPageKeys && appPageKeys.length > 0) {\n          const rscPage = `${route === '/' ? '/index' : route}.rsc`\n          outputs.staticFiles.push({\n            id: rscPage,\n            pathname: rscPage,\n            type: AdapterOutputType.STATIC_FILE,\n            filePath: rscFallbackPath,\n          })\n        }\n\n        if (dataRoute) {\n          let dataFilePath: string | undefined = path.join(\n            pagesDistDir,\n            `${normalizePagePath(route)}.json`\n          )\n          let postponed = meta.postponed\n\n          const dataRouteToUse =\n            renderingMode === RenderingMode.PARTIALLY_STATIC &&\n            prefetchDataRoute\n              ? prefetchDataRoute\n              : dataRoute\n\n          if (isAppPage) {\n            // When experimental PPR is enabled, we expect that the data\n            // that should be served as a part of the prerender should\n            // be from the prefetch data route. If this isn't enabled\n            // for ppr, the only way to get the data is from the data\n            // route.\n            dataFilePath = path.join(\n              appDistDir,\n              (dataRouteToUse ?? dataRoute)?.replace(/^\\//, '')\n            )\n          }\n\n          if (\n            renderingMode === RenderingMode.PARTIALLY_STATIC &&\n            !(await cachedFilePathCheck(dataFilePath))\n          ) {\n            outputs.prerenders.push({\n              ...initialOutput,\n              id: dataRoute,\n              pathname: dataRoute,\n              fallback: {\n                ...initialOutput.fallback,\n                postponedState: postponed,\n                initialStatus: undefined,\n                initialHeaders: {\n                  ...initialOutput.fallback?.initialHeaders,\n                  ...dataInitialHeaders,\n                  'content-type': isAppPage\n                    ? rscContentTypeHeader\n                    : JSON_CONTENT_TYPE_HEADER,\n                },\n                filePath: undefined,\n              },\n            })\n          } else {\n            outputs.prerenders.push({\n              ...initialOutput,\n              id: dataRoute,\n              pathname: dataRoute,\n              fallback: isNotFoundTrue\n                ? undefined\n                : {\n                    ...initialOutput.fallback,\n                    initialStatus: undefined,\n                    initialHeaders: {\n                      ...initialOutput.fallback?.initialHeaders,\n                      ...dataInitialHeaders,\n                      'content-type': isAppPage\n                        ? rscContentTypeHeader\n                        : JSON_CONTENT_TYPE_HEADER,\n                    },\n                    postponedState: undefined,\n                    filePath: dataFilePath,\n                  },\n            })\n          }\n        }\n\n        if (isAppPage) {\n          await handleAppMeta(route, initialOutput, meta, {\n            htmlAllowQuery,\n            dataAllowQuery,\n          })\n        }\n        prerenderGroupId += 1\n      }\n\n      for (const dynamicRoute in prerenderManifest.dynamicRoutes) {\n        const {\n          fallback,\n          fallbackExpire,\n          fallbackRevalidate,\n          fallbackHeaders,\n          fallbackStatus,\n          fallbackSourceRoute,\n          fallbackRootParams,\n          allowHeader,\n          dataRoute,\n          renderingMode,\n          experimentalBypassFor,\n        } = prerenderManifest.dynamicRoutes[dynamicRoute]\n\n        const srcRoute = fallbackSourceRoute || dynamicRoute\n        const parentOutput = getParentOutput(srcRoute, dynamicRoute)\n        const isAppPage = Boolean(appOutputMap[srcRoute])\n\n        const meta = await getAppRouteMeta(dynamicRoute, isAppPage)\n        const allowQuery = Object.values(\n          routesManifest.dynamicRoutes.find(\n            (item) => item.page === dynamicRoute\n          )?.routeKeys || {}\n        )\n        let htmlAllowQuery = allowQuery\n\n        // We only want to vary on the shell contents if there is a fallback\n        // present and able to be served.\n        if (typeof fallback === 'string') {\n          if (fallbackRootParams && fallbackRootParams.length > 0) {\n            htmlAllowQuery = fallbackRootParams as string[]\n          } // We additionally vary based on if there's a postponed prerender\n          // because if there isn't, then that means that we generated an\n          // empty shell, and producing an empty RSC shell would be a waste.\n          // If there is a postponed prerender, then the RSC shell would be\n          // non-empty, and it would be valuable to also generate an empty\n          // RSC shell.\n          else if (meta.postponed) {\n            htmlAllowQuery = []\n          }\n        }\n\n        const initialOutput: AdapterOutput['PRERENDER'] = {\n          id: dynamicRoute,\n          type: AdapterOutputType.PRERENDER,\n          pathname: dynamicRoute,\n          parentOutputId: parentOutput.id,\n          groupId: prerenderGroupId,\n\n          pprChain:\n            isAppPage && renderingMode === RenderingMode.PARTIALLY_STATIC\n              ? {\n                  headers: {\n                    [NEXT_RESUME_HEADER]: '1',\n                  },\n                }\n              : undefined,\n\n          fallback:\n            typeof fallback === 'string'\n              ? {\n                  filePath: path.join(\n                    isAppPage ? appDistDir : pagesDistDir,\n                    // app router dynamic route fallbacks don't have the\n                    // extension so ensure it's added here\n                    fallback.endsWith('.html') ? fallback : `${fallback}.html`\n                  ),\n                  postponedState: undefined,\n                  initialStatus: fallbackStatus ?? meta.status,\n                  initialHeaders: {\n                    ...fallbackHeaders,\n                    ...(appPageKeys?.length ? { vary: varyHeader } : {}),\n                    'content-type': HTML_CONTENT_TYPE_HEADER,\n                    ...meta.headers,\n                  },\n                  initialExpiration: fallbackExpire,\n                  initialRevalidate: fallbackRevalidate ?? 1,\n                }\n              : undefined,\n          config: {\n            allowQuery: htmlAllowQuery,\n            allowHeader,\n            renderingMode,\n            bypassFor: isAppPage ? experimentalBypassFor : undefined,\n            bypassToken: prerenderManifest.preview.previewModeId,\n          },\n        }\n\n        if (!config.i18n || isAppPage) {\n          outputs.prerenders.push(initialOutput)\n\n          if (\n            !isAppPage &&\n            fallback !== false &&\n            appPageKeys &&\n            appPageKeys.length > 0\n          ) {\n            const rscPage = `${srcRoute === '/' ? '/index' : srcRoute}.rsc`\n            outputs.staticFiles.push({\n              id: rscPage,\n              pathname: rscPage,\n              type: AdapterOutputType.STATIC_FILE,\n              filePath: rscFallbackPath,\n            })\n          }\n\n          let dataAllowQuery = allowQuery\n          const dataInitialHeaders: Record<string, string> = {}\n\n          if (meta.postponed && routesManifest.rsc.dynamicRSCPrerender) {\n            // If client param parsing is enabled, we follow the same logic as the\n            // HTML allowQuery as it's already going to vary based on if there's a\n            // static shell generated or if there's fallback root params. If there\n            // are fallback root params, and we can serve a fallback, then we\n            // should follow the same logic for the dynamic RSC routes.\n            //\n            // If client param parsing is not enabled, we have to use the\n            // allowQuery because the RSC payloads will contain dynamic segment\n            // values.\n            if (routesManifest.rsc.clientParamParsing) {\n              dataAllowQuery = htmlAllowQuery\n            }\n          }\n\n          if (renderingMode === RenderingMode.PARTIALLY_STATIC) {\n            // Dynamic RSC requests cannot be cached, so we explicity set it\n            // here to ensure that the response is not cached by the browser.\n            dataInitialHeaders['cache-control'] =\n              'private, no-store, no-cache, max-age=0, must-revalidate'\n          }\n\n          if (isAppPage) {\n            await handleAppMeta(dynamicRoute, initialOutput, meta, {\n              htmlAllowQuery,\n              dataAllowQuery,\n            })\n          }\n\n          if (renderingMode === RenderingMode.PARTIALLY_STATIC) {\n            outputs.prerenders.push({\n              ...initialOutput,\n              id: `${dynamicRoute}.rsc`,\n              pathname: `${dynamicRoute}.rsc`,\n              fallback: {\n                ...initialOutput.fallback,\n                filePath: undefined,\n                postponedState: meta.postponed,\n                initialStatus: undefined,\n                initialHeaders: {\n                  ...initialOutput.fallback?.initialHeaders,\n                  ...dataInitialHeaders,\n                  'content-type': isAppPage\n                    ? rscContentTypeHeader\n                    : JSON_CONTENT_TYPE_HEADER,\n                },\n              },\n\n              config: {\n                ...initialOutput.config,\n                allowQuery: dataAllowQuery,\n              },\n            })\n          } else if (dataRoute) {\n            outputs.prerenders.push({\n              ...initialOutput,\n              id: dataRoute,\n              pathname: dataRoute,\n              fallback: undefined,\n            })\n          }\n          prerenderGroupId += 1\n        } else {\n          for (const locale of config.i18n.locales) {\n            const currentOutput: AdapterOutput['PRERENDER'] = {\n              ...initialOutput,\n              pathname: path.posix.join(`/${locale}`, initialOutput.pathname),\n              id: path.posix.join(`/${locale}`, initialOutput.id),\n              fallback:\n                typeof fallback === 'string'\n                  ? {\n                      ...initialOutput.fallback,\n                      initialStatus: undefined,\n                      postponedState: undefined,\n                      filePath: path.join(\n                        pagesDistDir,\n                        locale,\n                        // app router dynamic route fallbacks don't have the\n                        // extension so ensure it's added here\n                        fallback.endsWith('.html')\n                          ? fallback\n                          : `${fallback}.html`\n                      ),\n                    }\n                  : undefined,\n              groupId: prerenderGroupId,\n            }\n            outputs.prerenders.push(currentOutput)\n\n            if (\n              !isAppPage &&\n              fallback !== false &&\n              appPageKeys &&\n              appPageKeys.length > 0\n            ) {\n              const rscPage = `${path.posix.join(`/${locale}`, initialOutput.pathname)}.rsc`\n              outputs.staticFiles.push({\n                id: rscPage,\n                pathname: rscPage,\n                type: AdapterOutputType.STATIC_FILE,\n                filePath: rscFallbackPath,\n              })\n            }\n\n            if (dataRoute) {\n              const dataPathname = path.posix.join(\n                `/_next/data`,\n                buildId,\n                locale,\n                dynamicRoute + '.json'\n              )\n              outputs.prerenders.push({\n                ...initialOutput,\n                id: dataPathname,\n                pathname: dataPathname,\n                // data route doesn't have skeleton fallback\n                fallback: undefined,\n                groupId: prerenderGroupId,\n              })\n            }\n            prerenderGroupId += 1\n          }\n        }\n      }\n\n      // ensure 404\n      const staticErrorDocs = [\n        ...(hasStatic404 ? ['/404'] : []),\n        ...(hasStatic500 ? ['/500'] : []),\n      ]\n\n      for (const errorDoc of staticErrorDocs) {\n        const errorDocPath = path.posix.join(\n          '/',\n          config.i18n?.defaultLocale || '',\n          errorDoc\n        )\n\n        if (!prerenderManifest.routes[errorDocPath]) {\n          for (const currentDocPath of [\n            errorDocPath,\n            ...(config.i18n?.locales?.map((locale) =>\n              path.posix.join('/', locale, errorDoc)\n            ) || []),\n          ]) {\n            const currentFilePath = path.join(\n              pagesDistDir,\n              `${currentDocPath}.html`\n            )\n            if (await cachedFilePathCheck(currentFilePath)) {\n              outputs.staticFiles.push({\n                pathname: currentDocPath,\n                id: currentDocPath,\n                type: AdapterOutputType.STATIC_FILE,\n                filePath: currentFilePath,\n              })\n            }\n          }\n        }\n      }\n    }\n\n    normalizePathnames(config, outputs)\n\n    const dynamicRoutes: DynamicRouteItem[] = []\n    const dynamicDataRoutes: DynamicRouteItem[] = []\n    const dynamicSegmentRoutes: DynamicRouteItem[] = []\n\n    const getDestinationQuery = (routeKeys: Record<string, string>) => {\n      const items = Object.entries(routeKeys ?? {})\n      if (items.length === 0) return ''\n\n      return '?' + items.map(([key, value]) => `${value}=$${key}`).join('&')\n    }\n\n    const fallbackFalseHasCondition: RouteHas[] = [\n      {\n        type: 'cookie',\n        key: '__prerender_bypass',\n        value: prerenderManifest.preview.previewModeId,\n      },\n      {\n        type: 'cookie',\n        key: '__next_preview_data',\n      },\n    ]\n\n    for (const route of routesManifest.dynamicRoutes) {\n      const shouldLocalize = config.i18n\n\n      const routeRegex = getNamedRouteRegex(route.page, {\n        prefixRouteKeys: true,\n      })\n\n      const isFallbackFalse =\n        prerenderManifest.dynamicRoutes[route.page]?.fallback === false\n\n      const { hasFallbackRootParams } = route\n\n      const sourceRegex = routeRegex.namedRegex.replace(\n        '^',\n        `^${config.basePath && config.basePath !== '/' ? path.posix.join('/', config.basePath || '') : ''}[/]?${shouldLocalize ? '(?<nextLocale>[^/]{1,})' : ''}`\n      )\n      const destination =\n        path.posix.join(\n          '/',\n          config.basePath,\n          shouldLocalize ? '/$nextLocale' : '',\n          route.page\n        ) + getDestinationQuery(route.routeKeys)\n\n      if (appPageKeys && appPageKeys.length > 0) {\n        // If we have fallback root params (implying we've already\n        // emitted a rewrite for the /_tree request), or if the route\n        // has PPR enabled and client param parsing is enabled, then\n        // we don't need to include any other suffixes.\n        const shouldSkipSuffixes = hasFallbackRootParams\n\n        dynamicRoutes.push({\n          source: route.page + '.rsc',\n          sourceRegex: sourceRegex.replace(\n            new RegExp(escapeStringRegexp('(?:/)?$')),\n            // Now than the upstream issues has been resolved, we can safely\n            // add the suffix back, this resolves a bug related to segment\n            // rewrites not capturing the correct suffix values when\n            // enabled.\n            shouldSkipSuffixes\n              ? '(?<rscSuffix>\\\\.rsc|\\\\.segments/.+\\\\.segment\\\\.rsc)(?:/)?$'\n              : '(?<rscSuffix>\\\\.rsc|\\\\.segments/.+\\\\.segment\\\\.rsc)(?:/)?$'\n          ),\n          destination: destination?.replace(/($|\\?)/, '$rscSuffix$1'),\n          has:\n            isFallbackFalse && !pageKeys.includes(route.page)\n              ? fallbackFalseHasCondition\n              : undefined,\n          missing: undefined,\n        })\n      }\n\n      // needs basePath and locale handling if pages router\n      dynamicRoutes.push({\n        source: route.page,\n        sourceRegex,\n        destination,\n        has: isFallbackFalse ? fallbackFalseHasCondition : undefined,\n        missing: undefined,\n      })\n\n      for (const segmentRoute of route.prefetchSegmentDataRoutes || []) {\n        dynamicSegmentRoutes.push({\n          source: route.page,\n          sourceRegex: segmentRoute.source.replace(\n            '^',\n            `^${config.basePath && config.basePath !== '/' ? path.posix.join('/', config.basePath || '') : ''}[/]?`\n          ),\n          destination: path.posix.join(\n            '/',\n            config.basePath,\n            segmentRoute.destination +\n              getDestinationQuery(segmentRoute.routeKeys)\n          ),\n          has: undefined,\n          missing: undefined,\n        })\n      }\n    }\n\n    const needsMiddlewareResolveRoutes =\n      outputs.middleware && outputs.pages.length > 0\n\n    const dataRoutePages = new Set([\n      ...routesManifest.dataRoutes.map((item) => item.page),\n    ])\n    const sortedDataPages = sortSortableRoutes([\n      ...(needsMiddlewareResolveRoutes\n        ? [...staticPages].map((page) => ({ sourcePage: page, page }))\n        : []),\n      ...routesManifest.dataRoutes.map((item) => ({\n        sourcePage: item.page,\n        page: item.page,\n      })),\n    ])\n\n    for (const { page } of sortedDataPages) {\n      if (needsMiddlewareResolveRoutes || isDynamicRoute(page)) {\n        const shouldLocalize = config.i18n\n        const isFallbackFalse =\n          prerenderManifest.dynamicRoutes[page]?.fallback === false\n\n        const routeRegex = getNamedRouteRegex(page + '.json', {\n          prefixRouteKeys: true,\n          includeSuffix: true,\n        })\n        const isDataRoute = dataRoutePages.has(page)\n\n        const destination = path.posix.join(\n          '/',\n          config.basePath,\n          ...(isDataRoute ? [`_next/data`, buildId] : ''),\n          ...(page === '/'\n            ? [shouldLocalize ? '$nextLocale.json' : 'index.json']\n            : [\n                shouldLocalize ? '$nextLocale' : '',\n                page +\n                  (isDataRoute ? '.json' : '') +\n                  getDestinationQuery(routeRegex.routeKeys || {}),\n              ])\n        )\n\n        dynamicDataRoutes.push({\n          source: page,\n          sourceRegex:\n            shouldLocalize && page === '/'\n              ? '^' +\n                path.posix.join(\n                  '/',\n                  config.basePath,\n                  '_next/data',\n                  escapeStringRegexp(buildId),\n                  '(?<nextLocale>[^/]{1,}).json'\n                )\n              : routeRegex.namedRegex.replace(\n                  '^',\n                  `^${path.posix.join(\n                    '/',\n                    config.basePath,\n                    `_next/data`,\n                    escapeStringRegexp(buildId)\n                  )}[/]?${shouldLocalize ? '(?<nextLocale>[^/]{1,})' : ''}`\n                ),\n          destination,\n          has: isFallbackFalse ? fallbackFalseHasCondition : undefined,\n          missing: undefined,\n        })\n      }\n    }\n\n    const buildRewriteItem = (route: ManifestRewriteRoute): RewriteItem => {\n      const converted = convertRewrites([route], ['nextInternalLocale'])[0]\n      const regex = converted.src || route.regex\n\n      return {\n        source: route.source,\n        sourceRegex: route.internal ? regex : modifyRouteRegex(regex),\n        destination: converted.dest || route.destination,\n        has: route.has,\n        missing: route.missing,\n      } satisfies Route\n    }\n\n    try {\n      Log.info(`Running onBuildComplete from ${adapterMod.name}`)\n\n      const combinedDynamicRoutes = [\n        ...dynamicDataRoutes,\n        ...dynamicSegmentRoutes,\n        ...dynamicRoutes,\n      ] satisfies Route[]\n\n      const rewrites = {\n        beforeFiles: routesManifest.rewrites.beforeFiles.map(buildRewriteItem),\n        afterFiles: routesManifest.rewrites.afterFiles.map(buildRewriteItem),\n        fallback: routesManifest.rewrites.fallback.map(buildRewriteItem),\n      }\n\n      const redirects = routesManifest.redirects.map((route) => {\n        const converted = convertRedirects([route], 307)[0]\n        const regex = converted.src || route.regex\n\n        return {\n          source: route.source,\n          sourceRegex: route.internal ? regex : modifyRouteRegex(regex),\n          headers: 'headers' in converted ? converted.headers || {} : {},\n          status: converted.status || getRedirectStatus(route),\n          has: route.has,\n          missing: route.missing,\n          priority: route.internal || undefined,\n        } satisfies Route\n      })\n\n      const headers = routesManifest.headers.map((route) => {\n        const converted = convertHeaders([route])[0]\n        const regex = converted.src || route.regex\n\n        return {\n          source: route.source,\n          sourceRegex: route.internal ? regex : modifyRouteRegex(regex),\n          headers: 'headers' in converted ? converted.headers || {} : {},\n          has: route.has,\n          missing: route.missing,\n          priority: route.internal || undefined,\n        } satisfies Route\n      })\n\n      await adapterMod.onBuildComplete({\n        routing: {\n          beforeMiddleware: [...headers, ...redirects],\n          beforeFiles: rewrites.beforeFiles,\n          afterFiles: rewrites.afterFiles,\n          dynamicRoutes: combinedDynamicRoutes,\n          onMatch: [\n            {\n              // This ensures we only match known emitted-by-Next.js files and not\n              // user-emitted files which may be missing a hash in their filename.\n              sourceRegex: `${path.posix.join(config.basePath || '/', '_next/static', `/(?:[^/]+/pages|pages|chunks|runtime|css|image|media|${escapeStringRegexp(buildId)})/.+`)}`,\n              // Next.js assets contain a hash or entropy in their filenames, so they\n              // are guaranteed to be unique and cacheable indefinitely.\n              headers: {\n                'cache-control': `public,max-age=${CACHE_ONE_YEAR},immutable`,\n              },\n            },\n          ],\n          fallback: rewrites.fallback,\n          shouldNormalizeNextData: !!needsMiddlewareResolveRoutes,\n          rsc: generateRoutesManifest({\n            appType,\n            pageKeys: {\n              pages: pageKeys as string[],\n              app: appPageKeys as string[],\n            },\n            config,\n            redirects: [],\n            headers: [],\n            rewrites,\n            restrictedRedirectPaths: [],\n            isAppPPREnabled: config.cacheComponents,\n          }).routesManifest.rsc,\n        },\n        outputs,\n\n        config,\n        distDir,\n        buildId,\n        nextVersion,\n        projectDir: dir,\n        repoRoot: tracingRoot,\n      })\n    } catch (err) {\n      Log.error(`Failed to run onBuildComplete from ${adapterMod.name}`)\n      throw err\n    }\n  }\n}\n"],"names":["handleBuildComplete","normalizePathnames","config","outputs","basePath","output","pages","pagesApi","appPages","appRoutes","prerenders","staticFiles","pathname","addPathPrefix","replace","dir","appType","buildId","configOutDir","distDir","pageKeys","tracingRoot","adapterPath","appPageKeys","staticPages","nextVersion","hasStatic404","hasStatic500","routesManifest","serverPropsPages","hasNodeMiddleware","prerenderManifest","middlewareManifest","requiredServerFiles","hasInstrumentationHook","functionsConfigManifest","adapterMod","interopDefault","pathToFileURL","require","resolve","href","onBuildComplete","exportFiles","recursiveReadDir","file","endsWith","startsWith","push","id","filePath","path","join","type","AdapterOutputType","STATIC_FILE","posix","sharedNodeAssets","fileOutputPath","relative","setupNodeStubPath","dirname","assets","handleTraceFiles","Object","assign","traceFilePath","traceData","JSON","parse","fs","readFile","traceFileDir","relativeFile","files","tracedFilePath","handleEdgeFunction","page","isMiddleware","PAGES","isAppPrefix","name","isAppPage","isAppRoute","currentOutputs","MIDDLEWARE","APP_PAGE","APP_ROUTE","PAGES_API","route","runtime","sourcePage","normalizeAppPath","find","item","wasmAssets","env","handleFile","originalPath","wasm","matchers","map","source","originalSource","sourceRegex","regexp","has","missing","key","value","preview","previewModeId","middleware","rscPathname","normalizePagePath","nextDataPath","edgeFunctionHandlers","values","isMiddlewareFilename","functions","pagesDistDir","pageOutputMap","rscFallbackPath","length","writeFile","hasOwnProperty","pageFile","i18n","locale","locales","localePage","localeOutput","staticOutput","pageTraceFile","catch","err","code","Log","warn","functionConfig","maxDuration","preferredRegion","regions","dataPathname","rscPage","middlewareFile","middlewareTrace","appOutputMap","appDistDir","normalizedPage","existingOutput","getParentOutput","srcRoute","childRoute","allowMissing","normalizedSrcRoute","normalizeLocalePath","parentOutput","console","error","appOutputs","keys","pageOutputs","Error","prefetchSegmentDirSuffix","prefetchSegmentSuffix","varyHeader","didPostponeHeader","contentTypeHeader","rscContentTypeHeader","rsc","handleAppMeta","initialOutput","meta","ctx","postponed","fallback","postponedState","segmentPaths","normalizedRoute","segmentsDir","segmentAllowQuery","clientParamParsing","htmlAllowQuery","dataAllowQuery","segmentPath","outputSegmentPath","shouldAttachSegmentFallback","fallbackPathname","undefined","PRERENDER","parentOutputId","groupId","bypassFor","initialExpiration","initialRevalidate","initialHeaders","headers","vary","prerenderGroupId","getAppRouteMeta","basename","keyLower","toLowerCase","Array","isArray","String","filePathCache","Map","cachedFilePathCheck","get","newCheck","access","then","set","routes","initialExpireSeconds","initialRevalidateSeconds","initialStatus","dataRoute","prefetchDataRoute","renderingMode","allowHeader","experimentalBypassFor","srcRouteInfo","dynamicRoutes","Boolean","isNotFoundTrue","notFoundRoutes","includes","allowQuery","routeKeys","isDynamicRoute","detectedLocale","currentFilePath","dataInitialHeaders","dynamicRSCPrerender","RenderingMode","PARTIALLY_STATIC","pprChain","NEXT_RESUME_HEADER","parentFallbackMode","status","HTML_CONTENT_TYPE_HEADER","bypassToken","dataFilePath","dataRouteToUse","JSON_CONTENT_TYPE_HEADER","dynamicRoute","fallbackExpire","fallbackRevalidate","fallbackHeaders","fallbackStatus","fallbackSourceRoute","fallbackRootParams","currentOutput","staticErrorDocs","errorDoc","errorDocPath","defaultLocale","currentDocPath","dynamicDataRoutes","dynamicSegmentRoutes","getDestinationQuery","items","entries","fallbackFalseHasCondition","shouldLocalize","routeRegex","getNamedRouteRegex","prefixRouteKeys","isFallbackFalse","hasFallbackRootParams","namedRegex","destination","shouldSkipSuffixes","RegExp","escapeStringRegexp","segmentRoute","prefetchSegmentDataRoutes","needsMiddlewareResolveRoutes","dataRoutePages","Set","dataRoutes","sortedDataPages","sortSortableRoutes","includeSuffix","isDataRoute","buildRewriteItem","converted","convertRewrites","regex","src","internal","modifyRouteRegex","dest","info","combinedDynamicRoutes","rewrites","beforeFiles","afterFiles","redirects","convertRedirects","getRedirectStatus","priority","convertHeaders","routing","beforeMiddleware","onMatch","CACHE_ONE_YEAR","shouldNormalizeNextData","generateRoutesManifest","app","restrictedRedirectPaths","isAppPPREnabled","cacheComponents","projectDir","repoRoot"],"mappings":"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","ignoreList":[0]}