{"version":3,"sources":["../../../src/export/routes/app-page.ts"],"sourcesContent":["import type { OutgoingHttpHeaders } from 'node:http'\nimport type { ExportRouteResult } from '../types'\nimport type { RenderOpts } from '../../server/app-render/types'\nimport type { NextParsedUrlQuery } from '../../server/request-meta'\nimport type { RouteMetadata } from './types'\n\nimport type {\n  MockedRequest,\n  MockedResponse,\n} from '../../server/lib/mock-request'\nimport { isDynamicUsageError } from '../helpers/is-dynamic-usage-error'\nimport {\n  NEXT_CACHE_TAGS_HEADER,\n  NEXT_META_SUFFIX,\n  RSC_SUFFIX,\n  RSC_SEGMENTS_DIR_SUFFIX,\n  RSC_SEGMENT_SUFFIX,\n} from '../../lib/constants'\nimport { hasNextSupport } from '../../server/ci-info'\nimport { lazyRenderAppPage } from '../../server/route-modules/app-page/module.render'\nimport { isBailoutToCSRError } from '../../shared/lib/lazy-dynamic/bailout-to-csr'\nimport { NodeNextRequest, NodeNextResponse } from '../../server/base-http/node'\nimport { NEXT_IS_PRERENDER_HEADER } from '../../client/components/app-router-headers'\nimport type { FetchMetrics } from '../../server/base-http'\nimport type { WorkStore } from '../../server/app-render/work-async-storage.external'\nimport type { OpaqueFallbackRouteParams } from '../../server/request/fallback-params'\nimport { AfterRunner } from '../../server/after/run-with-after'\nimport type { RequestLifecycleOpts } from '../../server/base-server'\nimport type { AppSharedContext } from '../../server/app-render/app-render'\nimport type { MultiFileWriter } from '../../lib/multi-file-writer'\nimport { stringifyResumeDataCache } from '../../server/resume-data-cache/resume-data-cache'\nimport {\n  UNDERSCORE_GLOBAL_ERROR_ROUTE_ENTRY,\n  UNDERSCORE_NOT_FOUND_ROUTE_ENTRY,\n} from '../../shared/lib/entry-constants'\n\n/**\n * Renders & exports a page associated with the /app directory\n */\nexport async function exportAppPage(\n  req: MockedRequest,\n  res: MockedResponse,\n  page: string,\n  path: string,\n  pathname: string,\n  query: NextParsedUrlQuery,\n  fallbackRouteParams: OpaqueFallbackRouteParams | null,\n  partialRenderOpts: Omit<RenderOpts, keyof RequestLifecycleOpts>,\n  htmlFilepath: string,\n  debugOutput: boolean,\n  isDynamicError: boolean,\n  fileWriter: MultiFileWriter,\n  sharedContext: AppSharedContext\n): Promise<ExportRouteResult> {\n  const afterRunner = new AfterRunner()\n\n  const renderOpts: RenderOpts = {\n    ...partialRenderOpts,\n    waitUntil: afterRunner.context.waitUntil,\n    onClose: afterRunner.context.onClose,\n    onAfterTaskError: afterRunner.context.onTaskError,\n  }\n\n  let isDefaultNotFound = false\n  let isDefaultGlobalError = false\n  // If the page is `/_not-found`, then we should update the page to be `/404`.\n  if (page === UNDERSCORE_NOT_FOUND_ROUTE_ENTRY) {\n    isDefaultNotFound = true\n    pathname = '/404'\n  }\n  // If the page is `/_global-error`, then we should update the page to be `/500`.\n  if (page === UNDERSCORE_GLOBAL_ERROR_ROUTE_ENTRY) {\n    isDefaultGlobalError = true\n    pathname = '/500'\n  }\n\n  try {\n    const result = await lazyRenderAppPage(\n      new NodeNextRequest(req),\n      new NodeNextResponse(res),\n      pathname,\n      query,\n      fallbackRouteParams,\n      renderOpts,\n      undefined,\n      sharedContext\n    )\n\n    const html = result.toUnchunkedString()\n\n    // TODO(after): if we abort a prerender because of an error in an after-callback\n    // we should probably communicate that better (and not log the error twice)\n    await afterRunner.executeAfter()\n\n    const { metadata } = result\n    const {\n      flightData,\n      cacheControl = { revalidate: false, expire: undefined },\n      postponed,\n      fetchTags,\n      fetchMetrics,\n      segmentData,\n      renderResumeDataCache,\n    } = metadata\n\n    // Ensure we don't postpone without having PPR enabled.\n    if (postponed && !renderOpts.experimental.isRoutePPREnabled) {\n      throw new Error('Invariant: page postponed without PPR being enabled')\n    }\n\n    if (cacheControl.revalidate === 0) {\n      if (isDynamicError) {\n        throw new Error(\n          `Page with dynamic = \"error\" encountered dynamic data method on ${path}.`\n        )\n      }\n      const { staticBailoutInfo = {} } = metadata\n\n      if (debugOutput && staticBailoutInfo?.description) {\n        logDynamicUsageWarning({\n          path,\n          description: staticBailoutInfo.description,\n          stack: staticBailoutInfo.stack,\n        })\n      }\n\n      return { cacheControl, fetchMetrics }\n    }\n\n    // If page data isn't available, it means that the page couldn't be rendered\n    // properly so long as we don't have unknown route params. When a route doesn't\n    // have unknown route params, there will not be any flight data.\n    let hasStaticRsc = false\n\n    if (!flightData) {\n      if (\n        !fallbackRouteParams ||\n        fallbackRouteParams.size === 0 ||\n        renderOpts.cacheComponents\n      ) {\n        throw new Error(`Invariant: failed to get page data for ${path}`)\n      }\n    } else {\n      const hasFallbackParams =\n        fallbackRouteParams != null && fallbackRouteParams.size > 0\n      const shouldWriteRsc =\n        !renderOpts.experimental.isRoutePPREnabled ||\n        (!postponed && !hasFallbackParams)\n      hasStaticRsc = shouldWriteRsc\n\n      // With PPR enabled, we normally skip writing .rsc because it may contain\n      // dynamic data. However, for fully static outputs (no postponed state and\n      // no fallback params), we can safely emit the route .rsc to support\n      // static navigations.\n      if (shouldWriteRsc) {\n        fileWriter.append(\n          htmlFilepath.replace(/\\.html$/, RSC_SUFFIX),\n          flightData\n        )\n      }\n    }\n\n    let segmentPaths\n    if (segmentData) {\n      // Emit the per-segment prefetch data. We emit them as separate files\n      // so that the cache handler has the option to treat each as a\n      // separate entry.\n      segmentPaths = []\n      const segmentsDir = htmlFilepath.replace(\n        /\\.html$/,\n        RSC_SEGMENTS_DIR_SUFFIX\n      )\n\n      for (const [segmentPath, buffer] of segmentData) {\n        segmentPaths.push(segmentPath)\n        const segmentDataFilePath =\n          segmentsDir + segmentPath + RSC_SEGMENT_SUFFIX\n        fileWriter.append(segmentDataFilePath, buffer)\n      }\n    }\n\n    const headers: OutgoingHttpHeaders = { ...metadata.headers }\n\n    // If we're writing the file to disk, we know it's a prerender.\n    headers[NEXT_IS_PRERENDER_HEADER] = '1'\n\n    if (fetchTags) {\n      headers[NEXT_CACHE_TAGS_HEADER] = fetchTags\n    }\n\n    // Writing static HTML to a file.\n    fileWriter.append(htmlFilepath, html)\n\n    const isParallelRoute = /\\/@\\w+/.test(page)\n    const isNonSuccessfulStatusCode = res.statusCode > 300\n\n    // When PPR is enabled, we don't always send 200 for routes that have been\n    // pregenerated, so we should grab the status code from the mocked\n    // response.\n    let status: number | undefined = renderOpts.experimental.isRoutePPREnabled\n      ? res.statusCode\n      : undefined\n\n    if (isDefaultNotFound) {\n      // Override the default /_not-found page status code to 404\n      status = 404\n    } else if (isDefaultGlobalError) {\n      // Override the default /_global-error page status code to 500\n      status = 500\n    } else if (isNonSuccessfulStatusCode && !isParallelRoute) {\n      // If it's parallel route the status from mock response is 404\n      status = res.statusCode\n    }\n\n    // Writing the request metadata to a file.\n    const meta: RouteMetadata = {\n      status,\n      headers,\n      postponed,\n      segmentPaths,\n    }\n\n    fileWriter.append(\n      htmlFilepath.replace(/\\.html$/, NEXT_META_SUFFIX),\n      JSON.stringify(meta, null, 2)\n    )\n\n    return {\n      // Filter the metadata if the environment does not have next support.\n      metadata: hasNextSupport\n        ? meta\n        : {\n            segmentPaths: meta.segmentPaths,\n          },\n      hasEmptyStaticShell: Boolean(postponed) && html === '',\n      hasPostponed: Boolean(postponed),\n      hasStaticRsc,\n      cacheControl,\n      fetchMetrics,\n      renderResumeDataCache: renderResumeDataCache\n        ? await stringifyResumeDataCache(\n            renderResumeDataCache,\n            renderOpts.cacheComponents\n          )\n        : undefined,\n    }\n  } catch (err) {\n    if (!isDynamicUsageError(err)) {\n      throw err\n    }\n\n    // We should fail rendering if a client side rendering bailout\n    // occurred at the page level.\n    if (isBailoutToCSRError(err)) {\n      throw err\n    }\n\n    let fetchMetrics: FetchMetrics | undefined\n\n    if (debugOutput) {\n      const store = (renderOpts as any).store as WorkStore\n      const { dynamicUsageDescription, dynamicUsageStack } = store\n      fetchMetrics = store.fetchMetrics\n\n      logDynamicUsageWarning({\n        path,\n        description: dynamicUsageDescription ?? '',\n        stack: dynamicUsageStack,\n      })\n    }\n\n    return { cacheControl: { revalidate: 0, expire: undefined }, fetchMetrics }\n  }\n}\n\nfunction logDynamicUsageWarning({\n  path,\n  description,\n  stack,\n}: {\n  path: string\n  description: string\n  stack?: string\n}) {\n  const errMessage = new Error(\n    `Static generation failed due to dynamic usage on ${path}, reason: ${description}`\n  )\n\n  if (stack) {\n    errMessage.stack = errMessage.message + stack.substring(stack.indexOf('\\n'))\n  }\n\n  console.warn(errMessage)\n}\n"],"names":["exportAppPage","req","res","page","path","pathname","query","fallbackRouteParams","partialRenderOpts","htmlFilepath","debugOutput","isDynamicError","fileWriter","sharedContext","afterRunner","AfterRunner","renderOpts","waitUntil","context","onClose","onAfterTaskError","onTaskError","isDefaultNotFound","isDefaultGlobalError","UNDERSCORE_NOT_FOUND_ROUTE_ENTRY","UNDERSCORE_GLOBAL_ERROR_ROUTE_ENTRY","result","lazyRenderAppPage","NodeNextRequest","NodeNextResponse","undefined","html","toUnchunkedString","executeAfter","metadata","flightData","cacheControl","revalidate","expire","postponed","fetchTags","fetchMetrics","segmentData","renderResumeDataCache","experimental","isRoutePPREnabled","Error","staticBailoutInfo","description","logDynamicUsageWarning","stack","hasStaticRsc","size","cacheComponents","hasFallbackParams","shouldWriteRsc","append","replace","RSC_SUFFIX","segmentPaths","segmentsDir","RSC_SEGMENTS_DIR_SUFFIX","segmentPath","buffer","push","segmentDataFilePath","RSC_SEGMENT_SUFFIX","headers","NEXT_IS_PRERENDER_HEADER","NEXT_CACHE_TAGS_HEADER","isParallelRoute","test","isNonSuccessfulStatusCode","statusCode","status","meta","NEXT_META_SUFFIX","JSON","stringify","hasNextSupport","hasEmptyStaticShell","Boolean","hasPostponed","stringifyResumeDataCache","err","isDynamicUsageError","isBailoutToCSRError","store","dynamicUsageDescription","dynamicUsageStack","errMessage","message","substring","indexOf","console","warn"],"mappings":"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","ignoreList":[0]}