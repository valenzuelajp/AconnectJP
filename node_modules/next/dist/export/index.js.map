{"version":3,"sources":["../../src/export/index.ts"],"sourcesContent":["import type {\n  ExportAppResult,\n  ExportAppOptions,\n  WorkerRenderOptsPartial,\n  ExportPagesResult,\n  ExportPathEntry,\n} from './types'\nimport {\n  createStaticWorker,\n  type PrerenderManifest,\n  type StaticWorker,\n} from '../build'\nimport type { PagesManifest } from '../build/webpack/plugins/pages-manifest-plugin'\n\nimport { bold, yellow } from '../lib/picocolors'\nimport findUp from 'next/dist/compiled/find-up'\nimport { existsSync, promises as fs } from 'fs'\n\nimport '../server/require-hook'\n\nimport { dirname, join, resolve, sep, relative } from 'path'\nimport * as Log from '../build/output/log'\nimport {\n  RSC_SEGMENT_SUFFIX,\n  RSC_SEGMENTS_DIR_SUFFIX,\n  RSC_SUFFIX,\n  SSG_FALLBACK_EXPORT_ERROR,\n} from '../lib/constants'\nimport { recursiveCopy } from '../lib/recursive-copy'\nimport {\n  BUILD_ID_FILE,\n  CLIENT_PUBLIC_FILES_PATH,\n  CLIENT_STATIC_FILES_PATH,\n  EXPORT_DETAIL,\n  EXPORT_MARKER,\n  NEXT_FONT_MANIFEST,\n  MIDDLEWARE_MANIFEST,\n  PAGES_MANIFEST,\n  PHASE_EXPORT,\n  PRERENDER_MANIFEST,\n  SERVER_DIRECTORY,\n  SERVER_REFERENCE_MANIFEST,\n  APP_PATH_ROUTES_MANIFEST,\n  ROUTES_MANIFEST,\n  FUNCTIONS_CONFIG_MANIFEST,\n} from '../shared/lib/constants'\nimport loadConfig from '../server/config'\nimport type { ExportPathMap } from '../server/config-shared'\nimport { parseMaxPostponedStateSize } from '../server/config-shared'\nimport { eventCliSession } from '../telemetry/events'\nimport { hasNextSupport } from '../server/ci-info'\nimport { Telemetry } from '../telemetry/storage'\nimport { normalizePagePath } from '../shared/lib/page-path/normalize-page-path'\nimport { denormalizePagePath } from '../shared/lib/page-path/denormalize-page-path'\nimport { loadEnvConfig } from '@next/env'\nimport { isAPIRoute } from '../lib/is-api-route'\nimport { getPagePath } from '../server/require'\nimport type { Span } from '../trace'\nimport type { MiddlewareManifest } from '../build/webpack/plugins/middleware-plugin'\nimport { isAppRouteRoute } from '../lib/is-app-route-route'\nimport { isAppPageRoute } from '../lib/is-app-page-route'\nimport isError from '../lib/is-error'\nimport { formatManifest } from '../build/manifests/formatter/format-manifest'\nimport { TurborepoAccessTraceResult } from '../build/turborepo-access-trace'\nimport { createProgress } from '../build/progress'\nimport type { DeepReadonly } from '../shared/lib/deep-readonly'\nimport { isInterceptionRouteRewrite } from '../lib/generate-interception-routes-rewrites'\nimport type { ActionManifest } from '../build/webpack/plugins/flight-client-entry-plugin'\nimport { extractInfoFromServerReferenceId } from '../shared/lib/server-reference-info'\nimport { convertSegmentPathToStaticExportFilename } from '../shared/lib/segment-cache/segment-value-encoding'\nimport { getNextBuildDebuggerPortOffset } from '../lib/worker'\nimport { getParams } from './helpers/get-params'\nimport { isDynamicRoute } from '../shared/lib/router/utils/is-dynamic'\nimport { normalizeAppPath } from '../shared/lib/router/utils/app-paths'\nimport type { Params } from '../server/request/params'\n\nexport class ExportError extends Error {\n  code = 'NEXT_EXPORT_ERROR'\n}\n\n/**\n * Picks an RDC seed by matching on the params that are\n * already known, so fallback shells use a seed that has already\n * computed those known params.\n */\nfunction buildRDCCacheByPage(\n  results: ExportPagesResult,\n  finalPhaseExportPaths: ExportPathEntry[]\n): Record<string, string> {\n  const renderResumeDataCachesByPage: Record<string, string> = {}\n  const seedCandidatesByPage = new Map<\n    string,\n    Array<{ path: string; renderResumeDataCache: string }>\n  >()\n\n  for (const { page, path, result } of results) {\n    if (!result) {\n      continue\n    }\n\n    if ('renderResumeDataCache' in result && result.renderResumeDataCache) {\n      // Collect all RDC seeds for this page so we can pick the best match\n      // for each fallback shell later (e.g. locale-specific variants).\n      const candidates = seedCandidatesByPage.get(page) ?? []\n      candidates.push({\n        path,\n        renderResumeDataCache: result.renderResumeDataCache,\n      })\n      seedCandidatesByPage.set(page, candidates)\n      // Remove the RDC string from the result so that it can be garbage\n      // collected, when there are more results for the same page.\n      result.renderResumeDataCache = undefined\n    }\n  }\n\n  const getKnownParamsKey = (\n    normalizedPage: string,\n    path: string,\n    fallbackParamNames: Set<string>\n  ): string | null => {\n    let params: Params\n    try {\n      params = getParams(normalizedPage, path)\n    } catch {\n      return null\n    }\n\n    // Only keep params that are known, then sort\n    // for a stable key so we can match a compatible seed.\n    const entries = Object.entries(params).filter(\n      ([key]) => !fallbackParamNames.has(key)\n    )\n\n    entries.sort(([a], [b]) => (a < b ? -1 : a > b ? 1 : 0))\n    return JSON.stringify(entries)\n  }\n\n  for (const exportPath of finalPhaseExportPaths) {\n    const { page, path, _fallbackRouteParams = [] } = exportPath\n    if (!isDynamicRoute(page)) {\n      continue\n    }\n\n    // Normalize app pages before param matching.\n    const normalizedPage = normalizeAppPath(page)\n    const pageKey = page !== path ? `${page}: ${path}` : path\n    const fallbackParamNames = new Set(\n      _fallbackRouteParams.map((param) => param.paramName)\n    )\n    // Build a key from the known params for this fallback shell so we can\n    // select a seed from a compatible prerendered route.\n    const targetKey = getKnownParamsKey(\n      normalizedPage,\n      path,\n      fallbackParamNames\n    )\n\n    if (!targetKey) {\n      continue\n    }\n\n    const candidates = seedCandidatesByPage.get(page)\n\n    // No suitable candidates, so there's no RDC seed to select\n    if (!candidates || candidates.length === 0) {\n      continue\n    }\n\n    let selected: string | null = null\n    for (const candidate of candidates) {\n      // Pick the seed whose known params match this fallback shell.\n      const candidateKey = getKnownParamsKey(\n        normalizedPage,\n        candidate.path,\n        fallbackParamNames\n      )\n      if (candidateKey === targetKey) {\n        selected = candidate.renderResumeDataCache\n        break\n      }\n    }\n\n    if (selected) {\n      renderResumeDataCachesByPage[pageKey] = selected\n    }\n  }\n\n  return renderResumeDataCachesByPage\n}\n\nasync function exportAppImpl(\n  dir: string,\n  options: Readonly<ExportAppOptions>,\n  span: Span,\n  staticWorker?: StaticWorker\n): Promise<ExportAppResult | null> {\n  dir = resolve(dir)\n\n  // attempt to load global env values so they are available in next.config.js\n  span.traceChild('load-dotenv').traceFn(() => loadEnvConfig(dir, false, Log))\n\n  const { enabledDirectories } = options\n\n  const nextConfig =\n    options.nextConfig ||\n    (await span.traceChild('load-next-config').traceAsyncFn(() =>\n      loadConfig(PHASE_EXPORT, dir, {\n        debugPrerender: options.debugPrerender,\n      })\n    ))\n\n  const distDir = join(dir, nextConfig.distDir)\n  const telemetry = options.buildExport ? null : new Telemetry({ distDir })\n\n  if (telemetry) {\n    telemetry.record(\n      eventCliSession(nextConfig, {\n        webpackVersion: null,\n        cliCommand: 'export',\n        isSrcDir: null,\n        hasNowJson: !!(await findUp('now.json', { cwd: dir })),\n        isCustomServer: null,\n        turboFlag: false,\n        pagesDir: null,\n        appDir: null,\n      })\n    )\n  }\n\n  const subFolders = nextConfig.trailingSlash && !options.buildExport\n\n  if (!options.silent && !options.buildExport) {\n    Log.info(`using build directory: ${distDir}`)\n  }\n\n  const buildIdFile = join(distDir, BUILD_ID_FILE)\n\n  if (!existsSync(buildIdFile)) {\n    throw new ExportError(\n      `Could not find a production build in the '${distDir}' directory. Try building your app with 'next build' before starting the static export. https://nextjs.org/docs/messages/next-export-no-build-id`\n    )\n  }\n\n  const customRoutes = (['rewrites', 'redirects', 'headers'] as const).filter(\n    (config) => typeof nextConfig[config] === 'function'\n  )\n\n  if (!hasNextSupport && !options.buildExport && customRoutes.length > 0) {\n    Log.warn(\n      `rewrites, redirects, and headers are not applied when exporting your application, detected (${customRoutes.join(\n        ', '\n      )}). See more info here: https://nextjs.org/docs/messages/export-no-custom-routes`\n    )\n  }\n\n  const buildId = await fs.readFile(buildIdFile, 'utf8')\n\n  const pagesManifest =\n    !options.pages &&\n    (require(join(distDir, SERVER_DIRECTORY, PAGES_MANIFEST)) as PagesManifest)\n\n  let prerenderManifest: DeepReadonly<PrerenderManifest> | undefined\n  try {\n    prerenderManifest = require(join(distDir, PRERENDER_MANIFEST))\n  } catch {}\n\n  let appRoutePathManifest: Record<string, string> | undefined\n  try {\n    appRoutePathManifest = require(join(distDir, APP_PATH_ROUTES_MANIFEST))\n  } catch (err) {\n    if (\n      isError(err) &&\n      (err.code === 'ENOENT' || err.code === 'MODULE_NOT_FOUND')\n    ) {\n      // the manifest doesn't exist which will happen when using\n      // \"pages\" dir instead of \"app\" dir.\n      appRoutePathManifest = undefined\n    } else {\n      // the manifest is malformed (invalid json)\n      throw err\n    }\n  }\n\n  const excludedPrerenderRoutes = new Set<string>()\n  const pages = options.pages || Object.keys(pagesManifest)\n  const defaultPathMap: ExportPathMap = {}\n\n  let hasApiRoutes = false\n  for (const page of pages) {\n    // _document and _app are not real pages\n    // _error is exported as 404.html later on\n    // API Routes are Node.js functions\n\n    if (isAPIRoute(page)) {\n      hasApiRoutes = true\n      continue\n    }\n\n    if (page === '/_document' || page === '/_app' || page === '/_error') {\n      continue\n    }\n\n    // iSSG pages that are dynamic should not export templated version by\n    // default. In most cases, this would never work. There is no server that\n    // could run `getStaticProps`. If users make their page work lazily, they\n    // can manually add it to the `exportPathMap`.\n    if (prerenderManifest?.dynamicRoutes[page]) {\n      excludedPrerenderRoutes.add(page)\n      continue\n    }\n\n    defaultPathMap[page] = { page }\n  }\n\n  const mapAppRouteToPage = new Map<string, string>()\n  if (!options.buildExport && appRoutePathManifest) {\n    for (const [pageName, routePath] of Object.entries(appRoutePathManifest)) {\n      mapAppRouteToPage.set(routePath, pageName)\n      if (\n        isAppPageRoute(pageName) &&\n        !prerenderManifest?.routes[routePath] &&\n        !prerenderManifest?.dynamicRoutes[routePath]\n      ) {\n        defaultPathMap[routePath] = {\n          page: pageName,\n          _isAppDir: true,\n        }\n      }\n    }\n  }\n\n  // Initialize the output directory\n  const outDir = options.outdir\n\n  if (outDir === join(dir, 'public')) {\n    throw new ExportError(\n      `The 'public' directory is reserved in Next.js and can not be used as the export out directory. https://nextjs.org/docs/messages/can-not-output-to-public`\n    )\n  }\n\n  if (outDir === join(dir, 'static')) {\n    throw new ExportError(\n      `The 'static' directory is reserved in Next.js and can not be used as the export out directory. https://nextjs.org/docs/messages/can-not-output-to-static`\n    )\n  }\n\n  await fs.rm(outDir, { recursive: true, force: true })\n  await fs.mkdir(join(outDir, '_next', buildId), { recursive: true })\n\n  await fs.writeFile(\n    join(distDir, EXPORT_DETAIL),\n    formatManifest({\n      version: 1,\n      outDirectory: outDir,\n      success: false,\n    }),\n    'utf8'\n  )\n\n  // Copy static directory\n  if (!options.buildExport && existsSync(join(dir, 'static'))) {\n    if (!options.silent) {\n      Log.info('Copying \"static\" directory')\n    }\n    await span\n      .traceChild('copy-static-directory')\n      .traceAsyncFn(() =>\n        recursiveCopy(join(dir, 'static'), join(outDir, 'static'))\n      )\n  }\n\n  // Copy .next/static directory\n  if (\n    !options.buildExport &&\n    existsSync(join(distDir, CLIENT_STATIC_FILES_PATH))\n  ) {\n    if (!options.silent) {\n      Log.info('Copying \"static build\" directory')\n    }\n    await span\n      .traceChild('copy-next-static-directory')\n      .traceAsyncFn(() =>\n        recursiveCopy(\n          join(distDir, CLIENT_STATIC_FILES_PATH),\n          join(outDir, '_next', CLIENT_STATIC_FILES_PATH)\n        )\n      )\n  }\n\n  // Get the exportPathMap from the config file\n  if (typeof nextConfig.exportPathMap !== 'function') {\n    nextConfig.exportPathMap = async (defaultMap) => {\n      return defaultMap\n    }\n  }\n\n  const {\n    i18n,\n    images: { loader = 'default', unoptimized },\n  } = nextConfig\n\n  if (i18n && !options.buildExport) {\n    throw new ExportError(\n      `i18n support is not compatible with next export. See here for more info on deploying: https://nextjs.org/docs/messages/export-no-custom-routes`\n    )\n  }\n\n  if (!options.buildExport) {\n    const { isNextImageImported } = await span\n      .traceChild('is-next-image-imported')\n      .traceAsyncFn(() =>\n        fs\n          .readFile(join(distDir, EXPORT_MARKER), 'utf8')\n          .then((text) => JSON.parse(text))\n          .catch(() => ({}))\n      )\n\n    if (\n      isNextImageImported &&\n      loader === 'default' &&\n      !unoptimized &&\n      !hasNextSupport\n    ) {\n      throw new ExportError(\n        `Image Optimization using the default loader is not compatible with export.\n  Possible solutions:\n    - Use \\`next start\\` to run a server, which includes the Image Optimization API.\n    - Configure \\`images.unoptimized = true\\` in \\`next.config.js\\` to disable the Image Optimization API.\n  Read more: https://nextjs.org/docs/messages/export-image-api`\n      )\n    }\n  }\n\n  let serverActionsManifest: ActionManifest | undefined\n  if (enabledDirectories.app) {\n    serverActionsManifest = require(\n      join(distDir, SERVER_DIRECTORY, SERVER_REFERENCE_MANIFEST + '.json')\n    ) as ActionManifest\n\n    if (nextConfig.output === 'export') {\n      const routesManifest = require(join(distDir, ROUTES_MANIFEST))\n\n      // We already prevent rewrites earlier in the process, however Next.js will insert rewrites\n      // for interception routes so we need to check for that here.\n      if (routesManifest?.rewrites?.beforeFiles?.length > 0) {\n        const hasInterceptionRouteRewrite =\n          routesManifest.rewrites.beforeFiles.some(isInterceptionRouteRewrite)\n\n        if (hasInterceptionRouteRewrite) {\n          throw new ExportError(\n            `Intercepting routes are not supported with static export.\\nRead more: https://nextjs.org/docs/app/building-your-application/deploying/static-exports#unsupported-features`\n          )\n        }\n      }\n\n      const actionIds = [\n        ...Object.keys(serverActionsManifest.node),\n        ...Object.keys(serverActionsManifest.edge),\n      ]\n\n      if (\n        actionIds.some(\n          (actionId) =>\n            extractInfoFromServerReferenceId(actionId).type === 'server-action'\n        )\n      ) {\n        throw new ExportError(\n          `Server Actions are not supported with static export.\\nRead more: https://nextjs.org/docs/app/building-your-application/deploying/static-exports#unsupported-features`\n        )\n      }\n    }\n  }\n\n  // Start the rendering process\n  const renderOpts: WorkerRenderOptsPartial = {\n    previewProps: prerenderManifest?.preview,\n    isBuildTimePrerendering: true,\n    assetPrefix: nextConfig.assetPrefix.replace(/\\/$/, ''),\n    distDir,\n    dev: false,\n    basePath: nextConfig.basePath,\n    cacheComponents: nextConfig.cacheComponents ?? false,\n    trailingSlash: nextConfig.trailingSlash,\n    locales: i18n?.locales,\n    locale: i18n?.defaultLocale,\n    defaultLocale: i18n?.defaultLocale,\n    domainLocales: i18n?.domains,\n    disableOptimizedLoading: nextConfig.experimental.disableOptimizedLoading,\n    // Exported pages do not currently support dynamic HTML.\n    supportsDynamicResponse: false,\n    crossOrigin: nextConfig.crossOrigin,\n    optimizeCss: nextConfig.experimental.optimizeCss,\n    nextConfigOutput: nextConfig.output,\n    nextScriptWorkers: nextConfig.experimental.nextScriptWorkers,\n    largePageDataBytes: nextConfig.experimental.largePageDataBytes,\n    serverActions: nextConfig.experimental.serverActions,\n    serverComponents: enabledDirectories.app,\n    cacheLifeProfiles: nextConfig.cacheLife,\n    nextFontManifest: require(\n      join(distDir, 'server', `${NEXT_FONT_MANIFEST}.json`)\n    ),\n    images: nextConfig.images,\n    htmlLimitedBots: nextConfig.htmlLimitedBots.source,\n    experimental: {\n      clientTraceMetadata: nextConfig.experimental.clientTraceMetadata,\n      expireTime: nextConfig.expireTime,\n      staleTimes: nextConfig.experimental.staleTimes,\n      clientParamParsingOrigins:\n        nextConfig.experimental.clientParamParsingOrigins,\n      dynamicOnHover: nextConfig.experimental.dynamicOnHover ?? false,\n      optimisticRouting: nextConfig.experimental.optimisticRouting ?? false,\n      inlineCss: nextConfig.experimental.inlineCss ?? false,\n      authInterrupts: !!nextConfig.experimental.authInterrupts,\n      maxPostponedStateSizeBytes: parseMaxPostponedStateSize(\n        nextConfig.experimental.maxPostponedStateSize\n      ),\n    },\n    reactMaxHeadersLength: nextConfig.reactMaxHeadersLength,\n    hasReadableErrorStacks:\n      nextConfig.experimental.serverSourceMaps === true &&\n      // TODO(NDX-531): Checking (and setting) the minify flags should be\n      // unnecessary once name mapping is fixed.\n      (process.env.TURBOPACK\n        ? nextConfig.experimental.turbopackMinify === false\n        : nextConfig.experimental.serverMinification === false) &&\n      nextConfig.enablePrerenderSourceMaps === true,\n  }\n\n  // We need this for server rendering the Link component.\n  ;(globalThis as any).__NEXT_DATA__ = {\n    nextExport: true,\n  }\n\n  const exportPathMap = await span\n    .traceChild('run-export-path-map')\n    .traceAsyncFn(async () => {\n      const exportMap = await nextConfig.exportPathMap(defaultPathMap, {\n        dev: false,\n        dir,\n        outDir,\n        distDir,\n        buildId,\n      })\n      return exportMap\n    })\n\n  // During static export, remove export 404/500 of pages router\n  // when only app router presents\n  if (!options.buildExport && options.appDirOnly) {\n    delete exportPathMap['/404']\n    delete exportPathMap['/500']\n  }\n\n  // only add missing 404 page when `buildExport` is false\n  if (!options.buildExport && !options.appDirOnly) {\n    // only add missing /404 if not specified in `exportPathMap`\n    if (!exportPathMap['/404']) {\n      exportPathMap['/404'] = { page: '/_error' }\n    }\n\n    /**\n     * exports 404.html for backwards compat\n     * E.g. GitHub Pages, GitLab Pages, Cloudflare Pages, Netlify\n     */\n    if (!exportPathMap['/404.html'] && exportPathMap['/404']) {\n      // alias /404.html to /404 to be compatible with custom 404 / _error page\n      exportPathMap['/404.html'] = exportPathMap['/404']\n    }\n  }\n\n  const allExportPaths: ExportPathEntry[] = []\n  const seenExportPaths = new Set<string>()\n  const fallbackEnabledPages = new Set<string>()\n\n  for (const [path, entry] of Object.entries(exportPathMap)) {\n    // make sure to prevent duplicates\n    const normalizedPath = denormalizePagePath(normalizePagePath(path))\n\n    if (seenExportPaths.has(normalizedPath)) {\n      continue\n    }\n\n    seenExportPaths.add(normalizedPath)\n\n    if (!entry._isAppDir && isAPIRoute(entry.page)) {\n      hasApiRoutes = true\n      continue\n    }\n\n    allExportPaths.push({ ...entry, path: normalizedPath })\n\n    if (prerenderManifest && !options.buildExport) {\n      const prerenderInfo = prerenderManifest.dynamicRoutes[entry.page]\n\n      if (prerenderInfo && prerenderInfo.fallback !== false) {\n        fallbackEnabledPages.add(entry.page)\n      }\n    }\n  }\n\n  if (allExportPaths.length === 0) {\n    if (!prerenderManifest) {\n      return null\n    }\n  }\n\n  if (fallbackEnabledPages.size > 0) {\n    throw new ExportError(\n      `Found pages with \\`fallback\\` enabled:\\n${[...fallbackEnabledPages].join(\n        '\\n'\n      )}\\n${SSG_FALLBACK_EXPORT_ERROR}\\n`\n    )\n  }\n\n  let hasMiddleware = false\n\n  if (!options.buildExport) {\n    try {\n      const middlewareManifest = require(\n        join(distDir, SERVER_DIRECTORY, MIDDLEWARE_MANIFEST)\n      ) as MiddlewareManifest\n\n      const functionsConfigManifest = require(\n        join(distDir, SERVER_DIRECTORY, FUNCTIONS_CONFIG_MANIFEST)\n      )\n\n      hasMiddleware =\n        Object.keys(middlewareManifest.middleware).length > 0 ||\n        Boolean(functionsConfigManifest.functions?.['/_middleware'])\n    } catch {}\n\n    // Warn if the user defines a path for an API page\n    if (hasApiRoutes || hasMiddleware) {\n      if (nextConfig.output === 'export') {\n        Log.warn(\n          yellow(\n            `Statically exporting a Next.js application via \\`next export\\` disables API routes and middleware.`\n          ) +\n            `\\n` +\n            yellow(\n              `This command is meant for static-only hosts, and is` +\n                ' ' +\n                bold(`not necessary to make your application static.`)\n            ) +\n            `\\n` +\n            yellow(\n              `Pages in your application without server-side data dependencies will be automatically statically exported by \\`next build\\`, including pages powered by \\`getStaticProps\\`.`\n            ) +\n            `\\n` +\n            yellow(\n              `Learn more: https://nextjs.org/docs/messages/api-routes-static-export`\n            )\n        )\n      }\n    }\n  }\n\n  const pagesDataDir = options.buildExport\n    ? outDir\n    : join(outDir, '_next/data', buildId)\n\n  const publicDir = join(dir, CLIENT_PUBLIC_FILES_PATH)\n  // Copy public directory\n  if (!options.buildExport && existsSync(publicDir)) {\n    if (!options.silent) {\n      Log.info('Copying \"public\" directory')\n    }\n    await span.traceChild('copy-public-directory').traceAsyncFn(() =>\n      recursiveCopy(publicDir, outDir, {\n        filter(path) {\n          // Exclude paths used by pages\n          return !exportPathMap[path]\n        },\n      })\n    )\n  }\n\n  const exportPagesInBatches = async (\n    worker: StaticWorker,\n    exportPaths: ExportPathEntry[],\n    renderResumeDataCachesByPage?: Record<string, string>\n  ): Promise<ExportPagesResult> => {\n    // Batch filtered pages into smaller batches, and call the export worker on\n    // each batch. We've set a default minimum of 25 pages per batch to ensure\n    // that even setups with only a few static pages can leverage a shared\n    // incremental cache, however this value can be configured.\n    const minPageCountPerBatch =\n      nextConfig.experimental.staticGenerationMinPagesPerWorker ?? 25\n\n    // Calculate the number of workers needed to ensure each batch has at least\n    // minPageCountPerBatch pages.\n    const numWorkers = Math.min(\n      options.numWorkers,\n      Math.ceil(exportPaths.length / minPageCountPerBatch)\n    )\n\n    // Calculate the page count per batch based on the number of workers.\n    const pageCountPerBatch = Math.ceil(exportPaths.length / numWorkers)\n\n    const batches = Array.from({ length: numWorkers }, (_, i) =>\n      exportPaths.slice(i * pageCountPerBatch, (i + 1) * pageCountPerBatch)\n    )\n\n    // Distribute remaining pages.\n    const remainingPages = exportPaths.slice(numWorkers * pageCountPerBatch)\n    remainingPages.forEach((page, index) => {\n      batches[index % batches.length].push(page)\n    })\n\n    return (\n      await Promise.all(\n        batches.map(async (batch) =>\n          worker.exportPages({\n            buildId,\n            deploymentId: nextConfig.deploymentId,\n            exportPaths: batch,\n            parentSpanId: span.getId(),\n            pagesDataDir,\n            renderOpts,\n            options,\n            dir,\n            distDir,\n            outDir,\n            nextConfig,\n            cacheHandler: nextConfig.cacheHandler,\n            cacheMaxMemorySize: nextConfig.cacheMaxMemorySize,\n            fetchCache: true,\n            fetchCacheKeyPrefix: nextConfig.experimental.fetchCacheKeyPrefix,\n            renderResumeDataCachesByPage,\n          })\n        )\n      )\n    ).flat()\n  }\n\n  let initialPhaseExportPaths: ExportPathEntry[] = []\n  const finalPhaseExportPaths: ExportPathEntry[] = []\n\n  if (renderOpts.cacheComponents) {\n    for (const exportPath of allExportPaths) {\n      if (exportPath._allowEmptyStaticShell) {\n        finalPhaseExportPaths.push(exportPath)\n      } else {\n        initialPhaseExportPaths.push(exportPath)\n      }\n    }\n  } else {\n    initialPhaseExportPaths = allExportPaths\n  }\n\n  const totalExportPaths =\n    initialPhaseExportPaths.length + finalPhaseExportPaths.length\n  let worker: StaticWorker | null = null\n  let results: ExportPagesResult = []\n\n  if (totalExportPaths > 0) {\n    const progress = createProgress(\n      totalExportPaths,\n      options.statusMessage ??\n        `Exporting using ${options.numWorkers} worker${options.numWorkers > 1 ? 's' : ''}`\n    )\n\n    if (staticWorker) {\n      // TODO: progress shouldn't rely on \"activity\" event sent from `exportPage`.\n      staticWorker.setOnActivity(progress.run)\n      staticWorker.setOnActivityAbort(progress.clear)\n      worker = staticWorker\n    } else {\n      worker = createStaticWorker(nextConfig, {\n        debuggerPortOffset: getNextBuildDebuggerPortOffset({\n          kind: 'export-page',\n        }),\n        numberOfWorkers: options.numWorkers,\n        progress,\n      })\n    }\n\n    results = await exportPagesInBatches(worker, initialPhaseExportPaths)\n\n    if (finalPhaseExportPaths.length > 0) {\n      const renderResumeDataCachesByPage = buildRDCCacheByPage(\n        results,\n        finalPhaseExportPaths\n      )\n\n      const finalPhaseResults = await exportPagesInBatches(\n        worker,\n        finalPhaseExportPaths,\n        renderResumeDataCachesByPage\n      )\n\n      results.push(...finalPhaseResults)\n    }\n  }\n\n  const collector: ExportAppResult = {\n    byPath: new Map(),\n    byPage: new Map(),\n    ssgNotFoundPaths: new Set(),\n    turborepoAccessTraceResults: new Map(),\n  }\n\n  const failedExportAttemptsByPage: Map<string, boolean> = new Map()\n\n  for (const { result, path, page, pageKey } of results) {\n    if (!result) continue\n    if ('error' in result) {\n      failedExportAttemptsByPage.set(pageKey, true)\n      continue\n    }\n\n    if (result.turborepoAccessTraceResult) {\n      collector.turborepoAccessTraceResults?.set(\n        path,\n        TurborepoAccessTraceResult.fromSerialized(\n          result.turborepoAccessTraceResult\n        )\n      )\n    }\n\n    if (options.buildExport) {\n      // Update path info by path.\n      const info = collector.byPath.get(path) ?? {}\n      if (result.cacheControl) {\n        info.cacheControl = result.cacheControl\n      }\n      if (typeof result.metadata !== 'undefined') {\n        info.metadata = result.metadata\n      }\n\n      if (typeof result.hasEmptyStaticShell !== 'undefined') {\n        info.hasEmptyStaticShell = result.hasEmptyStaticShell\n      }\n\n      if (typeof result.hasPostponed !== 'undefined') {\n        info.hasPostponed = result.hasPostponed\n      }\n\n      if (typeof result.hasStaticRsc !== 'undefined') {\n        info.hasStaticRsc = result.hasStaticRsc\n      }\n\n      if (typeof result.fetchMetrics !== 'undefined') {\n        info.fetchMetrics = result.fetchMetrics\n      }\n\n      collector.byPath.set(path, info)\n\n      // Update not found.\n      if (result.ssgNotFound === true) {\n        collector.ssgNotFoundPaths.add(path)\n      }\n\n      // Update durations.\n      const durations = collector.byPage.get(page) ?? {\n        durationsByPath: new Map<string, number>(),\n      }\n      durations.durationsByPath.set(path, result.duration)\n      collector.byPage.set(page, durations)\n    }\n  }\n\n  // Export mode provide static outputs that are not compatible with PPR mode.\n  if (!options.buildExport && nextConfig.experimental.ppr) {\n    // TODO: add message\n    throw new Error('Invariant: PPR cannot be enabled in export mode')\n  }\n\n  // copy prerendered routes to outDir\n  if (!options.buildExport && prerenderManifest) {\n    await Promise.all(\n      Object.keys(prerenderManifest.routes).map(async (unnormalizedRoute) => {\n        // Special handling: map app /_not-found to 404.html (and 404/index.html when trailingSlash)\n        if (unnormalizedRoute === '/_not-found') {\n          const { srcRoute } = prerenderManifest!.routes[unnormalizedRoute]\n          const appPageName = mapAppRouteToPage.get(srcRoute || '')\n          const pageName = appPageName || srcRoute || unnormalizedRoute\n          const isAppPath = Boolean(appPageName)\n          const route = normalizePagePath(unnormalizedRoute)\n\n          const pagePath = getPagePath(pageName, distDir, undefined, isAppPath)\n          const distPagesDir = join(\n            pagePath,\n            pageName\n              .slice(1)\n              .split('/')\n              .map(() => '..')\n              .join('/')\n          )\n\n          const orig = join(distPagesDir, route)\n          const htmlSrc = `${orig}.html`\n\n          // write 404.html at root\n          const htmlDest404 = join(outDir, '404.html')\n          await fs.mkdir(dirname(htmlDest404), { recursive: true })\n          await fs.copyFile(htmlSrc, htmlDest404)\n\n          // When trailingSlash, also write 404/index.html\n          if (subFolders) {\n            const htmlDest404Index = join(outDir, '404', 'index.html')\n            await fs.mkdir(dirname(htmlDest404Index), { recursive: true })\n            await fs.copyFile(htmlSrc, htmlDest404Index)\n          }\n        }\n        // Skip 500.html in static export\n        if (unnormalizedRoute === '/_global-error') {\n          return\n        }\n        const { srcRoute } = prerenderManifest!.routes[unnormalizedRoute]\n        const appPageName = mapAppRouteToPage.get(srcRoute || '')\n        const pageName = appPageName || srcRoute || unnormalizedRoute\n        const isAppPath = Boolean(appPageName)\n        const isAppRouteHandler = appPageName && isAppRouteRoute(appPageName)\n\n        // returning notFound: true from getStaticProps will not\n        // output html/json files during the build\n        if (prerenderManifest!.notFoundRoutes.includes(unnormalizedRoute)) {\n          return\n        }\n        // TODO: This rewrites /index/foo to /index/index/foo. Investigate and\n        // fix. I presume this was because normalizePagePath was designed for\n        // some other use case and then reused here for static exports without\n        // realizing the implications.\n        const route = normalizePagePath(unnormalizedRoute)\n\n        const pagePath = getPagePath(pageName, distDir, undefined, isAppPath)\n        const distPagesDir = join(\n          pagePath,\n          // strip leading / and then recurse number of nested dirs\n          // to place from base folder\n          pageName\n            .slice(1)\n            .split('/')\n            .map(() => '..')\n            .join('/')\n        )\n\n        const orig = join(distPagesDir, route)\n        const handlerSrc = `${orig}.body`\n        const handlerDest = join(outDir, route)\n\n        if (isAppRouteHandler && existsSync(handlerSrc)) {\n          await fs.mkdir(dirname(handlerDest), { recursive: true })\n          await fs.copyFile(handlerSrc, handlerDest)\n          return\n        }\n\n        const htmlDest = join(\n          outDir,\n          `${route}${\n            subFolders && route !== '/index' ? `${sep}index` : ''\n          }.html`\n        )\n        const jsonDest = isAppPath\n          ? join(\n              outDir,\n              `${route}${\n                subFolders && route !== '/index' ? `${sep}index` : ''\n              }.txt`\n            )\n          : join(pagesDataDir, `${route}.json`)\n\n        await fs.mkdir(dirname(htmlDest), { recursive: true })\n        await fs.mkdir(dirname(jsonDest), { recursive: true })\n\n        const htmlSrc = `${orig}.html`\n        const jsonSrc = `${orig}${isAppPath ? RSC_SUFFIX : '.json'}`\n\n        await fs.copyFile(htmlSrc, htmlDest)\n        await fs.copyFile(jsonSrc, jsonDest)\n\n        const segmentsDir = `${orig}${RSC_SEGMENTS_DIR_SUFFIX}`\n\n        if (isAppPath && existsSync(segmentsDir)) {\n          // Output a data file for each of this page's segments\n          //\n          // These files are requested by the client router's internal\n          // prefetcher, not the user directly. So we don't need to account for\n          // things like trailing slash handling.\n          //\n          // To keep the protocol simple, we can use the non-normalized route\n          // path instead of the normalized one (which, among other things,\n          // rewrites `/` to `/index`).\n          const segmentsDirDest = join(outDir, unnormalizedRoute)\n          const segmentPaths = await collectSegmentPaths(segmentsDir)\n          await Promise.all(\n            segmentPaths.map(async (segmentFileSrc) => {\n              const segmentPath =\n                '/' + segmentFileSrc.slice(0, -RSC_SEGMENT_SUFFIX.length)\n              const segmentFilename =\n                convertSegmentPathToStaticExportFilename(segmentPath)\n              const segmentFileDest = join(segmentsDirDest, segmentFilename)\n              await fs.mkdir(dirname(segmentFileDest), { recursive: true })\n              await fs.copyFile(\n                join(segmentsDir, segmentFileSrc),\n                segmentFileDest\n              )\n            })\n          )\n        }\n      })\n    )\n  }\n\n  if (failedExportAttemptsByPage.size > 0) {\n    const failedPages = Array.from(failedExportAttemptsByPage.keys())\n    throw new ExportError(\n      `Export encountered errors on following paths:\\n\\t${failedPages\n        .sort()\n        .join('\\n\\t')}`\n    )\n  }\n\n  await fs.writeFile(\n    join(distDir, EXPORT_DETAIL),\n    formatManifest({\n      version: 1,\n      outDirectory: outDir,\n      success: true,\n    }),\n    'utf8'\n  )\n\n  if (telemetry) {\n    await telemetry.flush()\n  }\n\n  // Clean up activity listeners for progress.\n  if (staticWorker) {\n    staticWorker.setOnActivity(undefined)\n    staticWorker.setOnActivityAbort(undefined)\n  }\n\n  if (!staticWorker && worker) {\n    await worker.end()\n  }\n\n  return collector\n}\n\nasync function collectSegmentPaths(segmentsDirectory: string) {\n  const results: Array<string> = []\n  await collectSegmentPathsImpl(segmentsDirectory, segmentsDirectory, results)\n  return results\n}\n\nasync function collectSegmentPathsImpl(\n  segmentsDirectory: string,\n  directory: string,\n  results: Array<string>\n) {\n  const segmentFiles = await fs.readdir(directory, {\n    withFileTypes: true,\n  })\n  await Promise.all(\n    segmentFiles.map(async (segmentFile) => {\n      if (segmentFile.isDirectory()) {\n        await collectSegmentPathsImpl(\n          segmentsDirectory,\n          join(directory, segmentFile.name),\n          results\n        )\n        return\n      }\n      if (!segmentFile.name.endsWith(RSC_SEGMENT_SUFFIX)) {\n        return\n      }\n      results.push(\n        relative(segmentsDirectory, join(directory, segmentFile.name))\n      )\n    })\n  )\n}\n\nexport default async function exportApp(\n  dir: string,\n  options: ExportAppOptions,\n  span: Span,\n  staticWorker?: StaticWorker\n): Promise<ExportAppResult | null> {\n  const nextExportSpan = span.traceChild('next-export')\n\n  return nextExportSpan.traceAsyncFn(async () => {\n    return await exportAppImpl(dir, options, nextExportSpan, staticWorker)\n  })\n}\n"],"names":["ExportError","exportApp","Error","code","buildRDCCacheByPage","results","finalPhaseExportPaths","renderResumeDataCachesByPage","seedCandidatesByPage","Map","page","path","result","renderResumeDataCache","candidates","get","push","set","undefined","getKnownParamsKey","normalizedPage","fallbackParamNames","params","getParams","entries","Object","filter","key","has","sort","a","b","JSON","stringify","exportPath","_fallbackRouteParams","isDynamicRoute","normalizeAppPath","pageKey","Set","map","param","paramName","targetKey","length","selected","candidate","candidateKey","exportAppImpl","dir","options","span","staticWorker","resolve","traceChild","traceFn","loadEnvConfig","Log","enabledDirectories","nextConfig","traceAsyncFn","loadConfig","PHASE_EXPORT","debugPrerender","distDir","join","telemetry","buildExport","Telemetry","record","eventCliSession","webpackVersion","cliCommand","isSrcDir","hasNowJson","findUp","cwd","isCustomServer","turboFlag","pagesDir","appDir","subFolders","trailingSlash","silent","info","buildIdFile","BUILD_ID_FILE","existsSync","customRoutes","config","hasNextSupport","warn","buildId","fs","readFile","pagesManifest","pages","require","SERVER_DIRECTORY","PAGES_MANIFEST","prerenderManifest","PRERENDER_MANIFEST","appRoutePathManifest","APP_PATH_ROUTES_MANIFEST","err","isError","excludedPrerenderRoutes","keys","defaultPathMap","hasApiRoutes","isAPIRoute","dynamicRoutes","add","mapAppRouteToPage","pageName","routePath","isAppPageRoute","routes","_isAppDir","outDir","outdir","rm","recursive","force","mkdir","writeFile","EXPORT_DETAIL","formatManifest","version","outDirectory","success","recursiveCopy","CLIENT_STATIC_FILES_PATH","exportPathMap","defaultMap","i18n","images","loader","unoptimized","isNextImageImported","EXPORT_MARKER","then","text","parse","catch","serverActionsManifest","app","SERVER_REFERENCE_MANIFEST","output","routesManifest","ROUTES_MANIFEST","rewrites","beforeFiles","hasInterceptionRouteRewrite","some","isInterceptionRouteRewrite","actionIds","node","edge","actionId","extractInfoFromServerReferenceId","type","renderOpts","previewProps","preview","isBuildTimePrerendering","assetPrefix","replace","dev","basePath","cacheComponents","locales","locale","defaultLocale","domainLocales","domains","disableOptimizedLoading","experimental","supportsDynamicResponse","crossOrigin","optimizeCss","nextConfigOutput","nextScriptWorkers","largePageDataBytes","serverActions","serverComponents","cacheLifeProfiles","cacheLife","nextFontManifest","NEXT_FONT_MANIFEST","htmlLimitedBots","source","clientTraceMetadata","expireTime","staleTimes","clientParamParsingOrigins","dynamicOnHover","optimisticRouting","inlineCss","authInterrupts","maxPostponedStateSizeBytes","parseMaxPostponedStateSize","maxPostponedStateSize","reactMaxHeadersLength","hasReadableErrorStacks","serverSourceMaps","process","env","TURBOPACK","turbopackMinify","serverMinification","enablePrerenderSourceMaps","globalThis","__NEXT_DATA__","nextExport","exportMap","appDirOnly","allExportPaths","seenExportPaths","fallbackEnabledPages","entry","normalizedPath","denormalizePagePath","normalizePagePath","prerenderInfo","fallback","size","SSG_FALLBACK_EXPORT_ERROR","hasMiddleware","functionsConfigManifest","middlewareManifest","MIDDLEWARE_MANIFEST","FUNCTIONS_CONFIG_MANIFEST","middleware","Boolean","functions","yellow","bold","pagesDataDir","publicDir","CLIENT_PUBLIC_FILES_PATH","exportPagesInBatches","worker","exportPaths","minPageCountPerBatch","staticGenerationMinPagesPerWorker","numWorkers","Math","min","ceil","pageCountPerBatch","batches","Array","from","_","i","slice","remainingPages","forEach","index","Promise","all","batch","exportPages","deploymentId","parentSpanId","getId","cacheHandler","cacheMaxMemorySize","fetchCache","fetchCacheKeyPrefix","flat","initialPhaseExportPaths","_allowEmptyStaticShell","totalExportPaths","progress","createProgress","statusMessage","setOnActivity","run","setOnActivityAbort","clear","createStaticWorker","debuggerPortOffset","getNextBuildDebuggerPortOffset","kind","numberOfWorkers","finalPhaseResults","collector","byPath","byPage","ssgNotFoundPaths","turborepoAccessTraceResults","failedExportAttemptsByPage","turborepoAccessTraceResult","TurborepoAccessTraceResult","fromSerialized","cacheControl","metadata","hasEmptyStaticShell","hasPostponed","hasStaticRsc","fetchMetrics","ssgNotFound","durations","durationsByPath","duration","ppr","unnormalizedRoute","srcRoute","appPageName","isAppPath","route","pagePath","getPagePath","distPagesDir","split","orig","htmlSrc","htmlDest404","dirname","copyFile","htmlDest404Index","isAppRouteHandler","isAppRouteRoute","notFoundRoutes","includes","handlerSrc","handlerDest","htmlDest","sep","jsonDest","jsonSrc","RSC_SUFFIX","segmentsDir","RSC_SEGMENTS_DIR_SUFFIX","segmentsDirDest","segmentPaths","collectSegmentPaths","segmentFileSrc","segmentPath","RSC_SEGMENT_SUFFIX","segmentFilename","convertSegmentPathToStaticExportFilename","segmentFileDest","failedPages","flush","end","segmentsDirectory","collectSegmentPathsImpl","directory","segmentFiles","readdir","withFileTypes","segmentFile","isDirectory","name","endsWith","relative","nextExportSpan"],"mappings":"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","ignoreList":[0]}