{"version":3,"sources":["../../../../../src/shared/lib/router/utils/parse-relative-url.ts"],"sourcesContent":["import type { ParsedUrlQuery } from 'querystring'\nimport { getLocationOrigin } from '../../utils'\nimport { searchParamsToUrlQuery } from './querystring'\n\nexport interface ParsedRelativeUrl {\n  auth: string | null\n  hash: string\n  host: string | null\n  hostname: string | null\n  href: string\n  pathname: string\n  port: string | null\n  protocol: string | null\n  query: ParsedUrlQuery\n  search: string\n  slashes: null\n}\n\n/**\n * Parses path-relative urls (e.g. `/hello/world?foo=bar`). If url isn't path-relative\n * (e.g. `./hello`) then at least base must be.\n * Absolute urls are rejected with one exception, in the browser, absolute urls that are on\n * the current origin will be parsed as relative\n */\nexport function parseRelativeUrl(\n  url: string,\n  base?: string,\n  parseQuery?: true\n): ParsedRelativeUrl\nexport function parseRelativeUrl(\n  url: string,\n  base: string | undefined,\n  parseQuery: false\n): Omit<ParsedRelativeUrl, 'query'>\nexport function parseRelativeUrl(\n  url: string,\n  base?: string,\n  parseQuery = true\n): ParsedRelativeUrl | Omit<ParsedRelativeUrl, 'query'> {\n  const globalBase = new URL(\n    typeof window === 'undefined' ? 'http://n' : getLocationOrigin()\n  )\n\n  const resolvedBase = base\n    ? new URL(base, globalBase)\n    : url.startsWith('.')\n      ? new URL(\n          typeof window === 'undefined' ? 'http://n' : window.location.href\n        )\n      : globalBase\n\n  const { pathname, searchParams, search, hash, href, origin } = url.startsWith(\n    '/'\n  )\n    ? // 'http://localhost:3000///' would be received as '///' in Node.js' IncomingMessage\n      // See https://nodejs.org/api/http.html#messageurl\n      // Not using `origin` to support other protocols\n      new URL(`${resolvedBase.protocol}//${resolvedBase.host}${url}`)\n    : new URL(url, resolvedBase)\n\n  if (origin !== globalBase.origin) {\n    throw new Error(`invariant: invalid relative URL, router received ${url}`)\n  }\n\n  return {\n    auth: null,\n    host: null,\n    hostname: null,\n    pathname,\n    port: null,\n    protocol: null,\n    query: parseQuery ? searchParamsToUrlQuery(searchParams) : undefined,\n    search,\n    hash,\n    href: href.slice(origin.length),\n    // We don't know for relative URLs at this point since we set a custom, internal\n    // base that isn't surfaced to users.\n    slashes: null,\n  }\n}\n"],"names":["parseRelativeUrl","url","base","parseQuery","globalBase","URL","window","getLocationOrigin","resolvedBase","startsWith","location","href","pathname","searchParams","search","hash","origin","protocol","host","Error","auth","hostname","port","query","searchParamsToUrlQuery","undefined","slice","length","slashes"],"mappings":";;;;+BAkCgBA;;;eAAAA;;;uBAjCkB;6BACK;AAgChC,SAASA,iBACdC,GAAW,EACXC,IAAa,EACbC,aAAa,IAAI;IAEjB,MAAMC,aAAa,IAAIC,IACrB,OAAOC,WAAW,cAAc,aAAaC,IAAAA,wBAAiB;IAGhE,MAAMC,eAAeN,OACjB,IAAIG,IAAIH,MAAME,cACdH,IAAIQ,UAAU,CAAC,OACb,IAAIJ,IACF,OAAOC,WAAW,cAAc,aAAaA,OAAOI,QAAQ,CAACC,IAAI,IAEnEP;IAEN,MAAM,EAAEQ,QAAQ,EAAEC,YAAY,EAAEC,MAAM,EAAEC,IAAI,EAAEJ,IAAI,EAAEK,MAAM,EAAE,GAAGf,IAAIQ,UAAU,CAC3E,OAGE,kDAAkD;IAClD,gDAAgD;IAChD,IAAIJ,IAAI,GAAGG,aAAaS,QAAQ,CAAC,EAAE,EAAET,aAAaU,IAAI,GAAGjB,KAAK,IAC9D,IAAII,IAAIJ,KAAKO;IAEjB,IAAIQ,WAAWZ,WAAWY,MAAM,EAAE;QAChC,MAAM,qBAAoE,CAApE,IAAIG,MAAM,CAAC,iDAAiD,EAAElB,KAAK,GAAnE,qBAAA;mBAAA;wBAAA;0BAAA;QAAmE;IAC3E;IAEA,OAAO;QACLmB,MAAM;QACNF,MAAM;QACNG,UAAU;QACVT;QACAU,MAAM;QACNL,UAAU;QACVM,OAAOpB,aAAaqB,IAAAA,mCAAsB,EAACX,gBAAgBY;QAC3DX;QACAC;QACAJ,MAAMA,KAAKe,KAAK,CAACV,OAAOW,MAAM;QAC9B,gFAAgF;QAChF,qCAAqC;QACrCC,SAAS;IACX;AACF","ignoreList":[0]}